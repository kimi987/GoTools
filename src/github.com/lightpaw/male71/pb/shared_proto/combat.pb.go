// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/shared_proto/combat.proto
// DO NOT EDIT!

package shared_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type CombatType int32

const (
	CombatType_SINGLE   CombatType = 0
	CombatType_MULTI    CombatType = 1
	CombatType_SINGLE_X CombatType = 2
)

var CombatType_name = map[int32]string{
	0: "SINGLE",
	1: "MULTI",
	2: "SINGLE_X",
}
var CombatType_value = map[string]int32{
	"SINGLE":   0,
	"MULTI":    1,
	"SINGLE_X": 2,
}

func (x CombatType) String() string {
	return proto.EnumName(CombatType_name, int32(x))
}
func (CombatType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCombat, []int{0} }

type Direction int32

const (
	Direction_ORIGIN     Direction = 0
	Direction_UP         Direction = 1
	Direction_LEFT_UP    Direction = 2
	Direction_LEFT       Direction = 3
	Direction_LF_DOWN    Direction = 4
	Direction_DOWN       Direction = 5
	Direction_RIGHT_DOWN Direction = 6
	Direction_RIGHT      Direction = 7
	Direction_RIGHT_UP   Direction = 8
)

var Direction_name = map[int32]string{
	0: "ORIGIN",
	1: "UP",
	2: "LEFT_UP",
	3: "LEFT",
	4: "LF_DOWN",
	5: "DOWN",
	6: "RIGHT_DOWN",
	7: "RIGHT",
	8: "RIGHT_UP",
}
var Direction_value = map[string]int32{
	"ORIGIN":     0,
	"UP":         1,
	"LEFT_UP":    2,
	"LEFT":       3,
	"LF_DOWN":    4,
	"DOWN":       5,
	"RIGHT_DOWN": 6,
	"RIGHT":      7,
	"RIGHT_UP":   8,
}

func (x Direction) String() string {
	return proto.EnumName(Direction_name, int32(x))
}
func (Direction) EnumDescriptor() ([]byte, []int) { return fileDescriptorCombat, []int{1} }

type HurtType int32

const (
	HurtType_InvalidHurtType HurtType = 0
	HurtType_NORMAL          HurtType = 1
	HurtType_CRIT            HurtType = 2
	HurtType_MISS            HurtType = 3
)

var HurtType_name = map[int32]string{
	0: "InvalidHurtType",
	1: "NORMAL",
	2: "CRIT",
	3: "MISS",
}
var HurtType_value = map[string]int32{
	"InvalidHurtType": 0,
	"NORMAL":          1,
	"CRIT":            2,
	"MISS":            3,
}

func (x HurtType) String() string {
	return proto.EnumName(HurtType_name, int32(x))
}
func (HurtType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCombat, []int{2} }

// 战斗分享proto
type CombatShareProto struct {
	Link       string     `protobuf:"bytes,1,opt,name=link,proto3" json:"link,omitempty"`
	SecondLink string     `protobuf:"bytes,4,opt,name=second_link,json=secondLink,proto3" json:"second_link,omitempty"`
	IsAttacker bool       `protobuf:"varint,2,opt,name=is_attacker,json=isAttacker,proto3" json:"is_attacker,omitempty"`
	Type       CombatType `protobuf:"varint,3,opt,name=type,proto3,enum=proto.CombatType" json:"type,omitempty"`
}

func (m *CombatShareProto) Reset()                    { *m = CombatShareProto{} }
func (m *CombatShareProto) String() string            { return proto.CompactTextString(m) }
func (*CombatShareProto) ProtoMessage()               {}
func (*CombatShareProto) Descriptor() ([]byte, []int) { return fileDescriptorCombat, []int{0} }

func (m *CombatShareProto) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *CombatShareProto) GetSecondLink() string {
	if m != nil {
		return m.SecondLink
	}
	return ""
}

func (m *CombatShareProto) GetIsAttacker() bool {
	if m != nil {
		return m.IsAttacker
	}
	return false
}

func (m *CombatShareProto) GetType() CombatType {
	if m != nil {
		return m.Type
	}
	return CombatType_SINGLE
}

type CombatProto struct {
	// 初始数据 进攻方 防守方
	Attacker         *CombatPlayerProto      `protobuf:"bytes,1,opt,name=attacker" json:"attacker,omitempty"`
	AttackerTroopPos []*CombatTroopsPosProto `protobuf:"bytes,7,rep,name=attacker_troop_pos,json=attackerTroopPos" json:"attacker_troop_pos,omitempty"`
	Defenser         *CombatPlayerProto      `protobuf:"bytes,2,opt,name=defenser" json:"defenser,omitempty"`
	DefenserTroopPos []*CombatTroopsPosProto `protobuf:"bytes,8,rep,name=defenser_troop_pos,json=defenserTroopPos" json:"defenser_troop_pos,omitempty"`
	// 地图资源
	MapRes  string `protobuf:"bytes,3,opt,name=map_res,json=mapRes,proto3" json:"map_res,omitempty"`
	MapXLen int32  `protobuf:"varint,4,opt,name=map_x_len,json=mapXLen,proto3" json:"map_x_len,omitempty"`
	MapYLen int32  `protobuf:"varint,5,opt,name=map_y_len,json=mapYLen,proto3" json:"map_y_len,omitempty"`
	// 战斗过程
	Rounds []*CombatRoundProto `protobuf:"bytes,6,rep,name=rounds" json:"rounds,omitempty"`
	// 胜利方 true表示进攻方胜利了
	AttackerWin bool `protobuf:"varint,11,opt,name=attacker_win,json=attackerWin,proto3" json:"attacker_win,omitempty"`
	// 对战双方出战的士兵数量，Key是战斗index，Value是士兵数
	CombatSolider []*Int32Pair `protobuf:"bytes,14,rep,name=combat_solider,json=combatSolider" json:"combat_solider,omitempty"`
	// 存活的士兵，Key是战斗index，Value是士兵数
	AliveSolider []*Int32Pair `protobuf:"bytes,12,rep,name=alive_solider,json=aliveSolider" json:"alive_solider,omitempty"`
	// 击杀的士兵，Key是战斗index，Value是士兵数
	KillSolider []*Int32Pair `protobuf:"bytes,18,rep,name=kill_solider,json=killSolider" json:"kill_solider,omitempty"`
	// 评分，0-险胜 1-小胜 2-大胜 3-完胜
	Score int32 `protobuf:"varint,13,opt,name=score,proto3" json:"score,omitempty"`
	// 战斗在第几条队列上面展开，从1开始
	FightQueue int32 `protobuf:"varint,15,opt,name=fight_queue,json=fightQueue,proto3" json:"fight_queue,omitempty"`
	// 胜利方是否连胜离场
	IsWinnerContinueWinLeave bool `protobuf:"varint,16,opt,name=is_winner_continue_win_leave,json=isWinnerContinueWinLeave,proto3" json:"is_winner_continue_win_leave,omitempty"`
	// 胜利方连胜次数
	WinnerContinueWinTimes int32 `protobuf:"varint,17,opt,name=winner_continue_win_times,json=winnerContinueWinTimes,proto3" json:"winner_continue_win_times,omitempty"`
}

func (m *CombatProto) Reset()                    { *m = CombatProto{} }
func (m *CombatProto) String() string            { return proto.CompactTextString(m) }
func (*CombatProto) ProtoMessage()               {}
func (*CombatProto) Descriptor() ([]byte, []int) { return fileDescriptorCombat, []int{1} }

func (m *CombatProto) GetAttacker() *CombatPlayerProto {
	if m != nil {
		return m.Attacker
	}
	return nil
}

func (m *CombatProto) GetAttackerTroopPos() []*CombatTroopsPosProto {
	if m != nil {
		return m.AttackerTroopPos
	}
	return nil
}

func (m *CombatProto) GetDefenser() *CombatPlayerProto {
	if m != nil {
		return m.Defenser
	}
	return nil
}

func (m *CombatProto) GetDefenserTroopPos() []*CombatTroopsPosProto {
	if m != nil {
		return m.DefenserTroopPos
	}
	return nil
}

func (m *CombatProto) GetMapRes() string {
	if m != nil {
		return m.MapRes
	}
	return ""
}

func (m *CombatProto) GetMapXLen() int32 {
	if m != nil {
		return m.MapXLen
	}
	return 0
}

func (m *CombatProto) GetMapYLen() int32 {
	if m != nil {
		return m.MapYLen
	}
	return 0
}

func (m *CombatProto) GetRounds() []*CombatRoundProto {
	if m != nil {
		return m.Rounds
	}
	return nil
}

func (m *CombatProto) GetAttackerWin() bool {
	if m != nil {
		return m.AttackerWin
	}
	return false
}

func (m *CombatProto) GetCombatSolider() []*Int32Pair {
	if m != nil {
		return m.CombatSolider
	}
	return nil
}

func (m *CombatProto) GetAliveSolider() []*Int32Pair {
	if m != nil {
		return m.AliveSolider
	}
	return nil
}

func (m *CombatProto) GetKillSolider() []*Int32Pair {
	if m != nil {
		return m.KillSolider
	}
	return nil
}

func (m *CombatProto) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *CombatProto) GetFightQueue() int32 {
	if m != nil {
		return m.FightQueue
	}
	return 0
}

func (m *CombatProto) GetIsWinnerContinueWinLeave() bool {
	if m != nil {
		return m.IsWinnerContinueWinLeave
	}
	return false
}

func (m *CombatProto) GetWinnerContinueWinTimes() int32 {
	if m != nil {
		return m.WinnerContinueWinTimes
	}
	return 0
}

type MultiCombatProto struct {
	// 初始数据 进攻方 防守方
	Attacker []*CombatPlayerProto `protobuf:"bytes,1,rep,name=attacker" json:"attacker,omitempty"`
	Defenser []*CombatPlayerProto `protobuf:"bytes,2,rep,name=defenser" json:"defenser,omitempty"`
	// 地图资源
	MapRes               string `protobuf:"bytes,3,opt,name=map_res,json=mapRes,proto3" json:"map_res,omitempty"`
	MapXLen              int32  `protobuf:"varint,4,opt,name=map_x_len,json=mapXLen,proto3" json:"map_x_len,omitempty"`
	MapYLen              int32  `protobuf:"varint,5,opt,name=map_y_len,json=mapYLen,proto3" json:"map_y_len,omitempty"`
	ConcurrentFightCount int32  `protobuf:"varint,6,opt,name=concurrent_fight_count,json=concurrentFightCount,proto3" json:"concurrent_fight_count,omitempty"`
	// 整场战斗最终的胜利方 true表示进攻方胜利了
	AttackerWin bool `protobuf:"varint,11,opt,name=attacker_win,json=attackerWin,proto3" json:"attacker_win,omitempty"`
	// 评分，0-险胜 1-小胜 2-大胜 3-完胜
	Score int32 `protobuf:"varint,13,opt,name=score,proto3" json:"score,omitempty"`
	// 战斗
	Combats            []*CombatProto    `protobuf:"bytes,14,rep,name=combats" json:"combats,omitempty"`
	AttackerDeadCount  int32             `protobuf:"varint,15,opt,name=attacker_dead_count,json=attackerDeadCount,proto3" json:"attacker_dead_count,omitempty"`
	DefenserDeadCount  int32             `protobuf:"varint,16,opt,name=defenser_dead_count,json=defenserDeadCount,proto3" json:"defenser_dead_count,omitempty"`
	AttackerLeaveCount int32             `protobuf:"varint,17,opt,name=attacker_leave_count,json=attackerLeaveCount,proto3" json:"attacker_leave_count,omitempty"`
	DefenserLeaveCount int32             `protobuf:"varint,18,opt,name=defenser_leave_count,json=defenserLeaveCount,proto3" json:"defenser_leave_count,omitempty"`
	WinTimes           []*BytesInt32Pair `protobuf:"bytes,19,rep,name=win_times,json=winTimes" json:"win_times,omitempty"`
}

func (m *MultiCombatProto) Reset()                    { *m = MultiCombatProto{} }
func (m *MultiCombatProto) String() string            { return proto.CompactTextString(m) }
func (*MultiCombatProto) ProtoMessage()               {}
func (*MultiCombatProto) Descriptor() ([]byte, []int) { return fileDescriptorCombat, []int{2} }

func (m *MultiCombatProto) GetAttacker() []*CombatPlayerProto {
	if m != nil {
		return m.Attacker
	}
	return nil
}

func (m *MultiCombatProto) GetDefenser() []*CombatPlayerProto {
	if m != nil {
		return m.Defenser
	}
	return nil
}

func (m *MultiCombatProto) GetMapRes() string {
	if m != nil {
		return m.MapRes
	}
	return ""
}

func (m *MultiCombatProto) GetMapXLen() int32 {
	if m != nil {
		return m.MapXLen
	}
	return 0
}

func (m *MultiCombatProto) GetMapYLen() int32 {
	if m != nil {
		return m.MapYLen
	}
	return 0
}

func (m *MultiCombatProto) GetConcurrentFightCount() int32 {
	if m != nil {
		return m.ConcurrentFightCount
	}
	return 0
}

func (m *MultiCombatProto) GetAttackerWin() bool {
	if m != nil {
		return m.AttackerWin
	}
	return false
}

func (m *MultiCombatProto) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *MultiCombatProto) GetCombats() []*CombatProto {
	if m != nil {
		return m.Combats
	}
	return nil
}

func (m *MultiCombatProto) GetAttackerDeadCount() int32 {
	if m != nil {
		return m.AttackerDeadCount
	}
	return 0
}

func (m *MultiCombatProto) GetDefenserDeadCount() int32 {
	if m != nil {
		return m.DefenserDeadCount
	}
	return 0
}

func (m *MultiCombatProto) GetAttackerLeaveCount() int32 {
	if m != nil {
		return m.AttackerLeaveCount
	}
	return 0
}

func (m *MultiCombatProto) GetDefenserLeaveCount() int32 {
	if m != nil {
		return m.DefenserLeaveCount
	}
	return 0
}

func (m *MultiCombatProto) GetWinTimes() []*BytesInt32Pair {
	if m != nil {
		return m.WinTimes
	}
	return nil
}

type CombatRoundProto struct {
	Round      int32                `protobuf:"varint,1,opt,name=round,proto3" json:"round,omitempty"`
	Actions    []*CombatActionProto `protobuf:"bytes,2,rep,name=actions" json:"actions,omitempty"`
	WallAction *WallActionProto     `protobuf:"bytes,3,opt,name=wall_action,json=wallAction" json:"wall_action,omitempty"`
}

func (m *CombatRoundProto) Reset()                    { *m = CombatRoundProto{} }
func (m *CombatRoundProto) String() string            { return proto.CompactTextString(m) }
func (*CombatRoundProto) ProtoMessage()               {}
func (*CombatRoundProto) Descriptor() ([]byte, []int) { return fileDescriptorCombat, []int{3} }

func (m *CombatRoundProto) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *CombatRoundProto) GetActions() []*CombatActionProto {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *CombatRoundProto) GetWallAction() *WallActionProto {
	if m != nil {
		return m.WallAction
	}
	return nil
}

type CombatActionProto struct {
	Index int32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// 表示移动方向（每次移动一格），没有值表示这个单位不移动
	MoveDirection Direction `protobuf:"varint,3,opt,name=move_direction,json=moveDirection,proto3,enum=proto.Direction" json:"move_direction,omitempty"`
	// 被攻击对象和伤害值，0表示没有对象可以打，但是可能攻击的是城墙
	TargetIndex int32 `protobuf:"varint,4,opt,name=target_index,json=targetIndex,proto3" json:"target_index,omitempty"`
	// 总击杀的士兵数，此处 = 普通技能击杀的士兵数 + 克制技击杀的士兵数 + 后面其他的击杀的士兵数，计算普通技能击杀的士兵数 = 总击杀的士兵数 - 克制技击杀的士兵数 - 后面其他的击杀的士兵数
	Damage int32 `protobuf:"varint,5,opt,name=damage,proto3" json:"damage,omitempty"`
	// 被攻击对象剩余士兵数量
	LeftSoldier int32    `protobuf:"varint,10,opt,name=left_soldier,json=leftSoldier,proto3" json:"left_soldier,omitempty"`
	HurtType    HurtType `protobuf:"varint,6,opt,name=hurt_type,json=hurtType,proto3,enum=proto.HurtType" json:"hurt_type,omitempty"`
	// 造成普通伤害的技能id
	NormalSpell int32 `protobuf:"varint,8,opt,name=normal_spell,json=normalSpell,proto3" json:"normal_spell,omitempty"`
	// 克制技(restraint_spell>0表示触发了克制技)
	// 如果当前释放了克制技，客户端将特效显示该技能的动作/特效，如果找不到该技能的配置，默认释放普通技能的动作/特效
	RestraintSpellDamage int32 `protobuf:"varint,7,opt,name=restraint_spell_damage,json=restraintSpellDamage,proto3" json:"restraint_spell_damage,omitempty"`
	RestraintSpell       int32 `protobuf:"varint,9,opt,name=restraint_spell,json=restraintSpell,proto3" json:"restraint_spell,omitempty"`
	// 伤害城墙的生命值，0表示没有伤害
	HurtWallLife int32 `protobuf:"varint,15,opt,name=hurt_wall_life,json=hurtWallLife,proto3" json:"hurt_wall_life,omitempty"`
	// 城墙剩余血量
	WallLeftLife int32 `protobuf:"varint,17,opt,name=wall_left_life,json=wallLeftLife,proto3" json:"wall_left_life,omitempty"`
	// 伤害城墙的技能，如果hurt_wall_life为0，则不需要读取
	HurtWallSpell int32 `protobuf:"varint,16,opt,name=hurt_wall_spell,json=hurtWallSpell,proto3" json:"hurt_wall_spell,omitempty"`
	// 剩余行动力
	LeftMoveTimes int32 `protobuf:"varint,20,opt,name=left_move_times,json=leftMoveTimes,proto3" json:"left_move_times,omitempty"`
}

func (m *CombatActionProto) Reset()                    { *m = CombatActionProto{} }
func (m *CombatActionProto) String() string            { return proto.CompactTextString(m) }
func (*CombatActionProto) ProtoMessage()               {}
func (*CombatActionProto) Descriptor() ([]byte, []int) { return fileDescriptorCombat, []int{4} }

func (m *CombatActionProto) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *CombatActionProto) GetMoveDirection() Direction {
	if m != nil {
		return m.MoveDirection
	}
	return Direction_ORIGIN
}

func (m *CombatActionProto) GetTargetIndex() int32 {
	if m != nil {
		return m.TargetIndex
	}
	return 0
}

func (m *CombatActionProto) GetDamage() int32 {
	if m != nil {
		return m.Damage
	}
	return 0
}

func (m *CombatActionProto) GetLeftSoldier() int32 {
	if m != nil {
		return m.LeftSoldier
	}
	return 0
}

func (m *CombatActionProto) GetHurtType() HurtType {
	if m != nil {
		return m.HurtType
	}
	return HurtType_InvalidHurtType
}

func (m *CombatActionProto) GetNormalSpell() int32 {
	if m != nil {
		return m.NormalSpell
	}
	return 0
}

func (m *CombatActionProto) GetRestraintSpellDamage() int32 {
	if m != nil {
		return m.RestraintSpellDamage
	}
	return 0
}

func (m *CombatActionProto) GetRestraintSpell() int32 {
	if m != nil {
		return m.RestraintSpell
	}
	return 0
}

func (m *CombatActionProto) GetHurtWallLife() int32 {
	if m != nil {
		return m.HurtWallLife
	}
	return 0
}

func (m *CombatActionProto) GetWallLeftLife() int32 {
	if m != nil {
		return m.WallLeftLife
	}
	return 0
}

func (m *CombatActionProto) GetHurtWallSpell() int32 {
	if m != nil {
		return m.HurtWallSpell
	}
	return 0
}

func (m *CombatActionProto) GetLeftMoveTimes() int32 {
	if m != nil {
		return m.LeftMoveTimes
	}
	return 0
}

type WallActionProto struct {
	// 被攻击对象和伤害值，0表示没有对象可以打
	TargetIndex int32 `protobuf:"varint,4,opt,name=target_index,json=targetIndex,proto3" json:"target_index,omitempty"`
	// 城墙击杀的士兵数
	Damage int32 `protobuf:"varint,5,opt,name=damage,proto3" json:"damage,omitempty"`
	// 被攻击对象剩余士兵数量
	LeftSoldier int32 `protobuf:"varint,6,opt,name=left_soldier,json=leftSoldier,proto3" json:"left_soldier,omitempty"`
}

func (m *WallActionProto) Reset()                    { *m = WallActionProto{} }
func (m *WallActionProto) String() string            { return proto.CompactTextString(m) }
func (*WallActionProto) ProtoMessage()               {}
func (*WallActionProto) Descriptor() ([]byte, []int) { return fileDescriptorCombat, []int{5} }

func (m *WallActionProto) GetTargetIndex() int32 {
	if m != nil {
		return m.TargetIndex
	}
	return 0
}

func (m *WallActionProto) GetDamage() int32 {
	if m != nil {
		return m.Damage
	}
	return 0
}

func (m *WallActionProto) GetLeftSoldier() int32 {
	if m != nil {
		return m.LeftSoldier
	}
	return 0
}

type CombatPlayerProto struct {
	Hero             *HeroBasicProto      `protobuf:"bytes,11,opt,name=hero" json:"hero,omitempty"`
	TotalFightAmount int32                `protobuf:"varint,8,opt,name=total_fight_amount,json=totalFightAmount,proto3" json:"total_fight_amount,omitempty"`
	Troops           []*CombatTroopsProto `protobuf:"bytes,21,rep,name=troops" json:"troops,omitempty"`
	// 城墙，如果城墙属性不为空，表示有城墙
	TotalWallLife int32 `protobuf:"varint,30,opt,name=total_wall_life,json=totalWallLife,proto3" json:"total_wall_life,omitempty"`
	// 城墙的属性，客户端不要读取
	WallStat *SpriteStatProto `protobuf:"bytes,31,opt,name=wall_stat,json=wallStat" json:"wall_stat,omitempty"`
	// 城墙的固定伤害，客户端不要读取
	WallFixDamage int32 `protobuf:"varint,32,opt,name=wall_fix_damage,json=wallFixDamage,proto3" json:"wall_fix_damage,omitempty"`
	// 城墙等级
	WallLevel int32 `protobuf:"varint,33,opt,name=wall_level,json=wallLevel,proto3" json:"wall_level,omitempty"`
}

func (m *CombatPlayerProto) Reset()                    { *m = CombatPlayerProto{} }
func (m *CombatPlayerProto) String() string            { return proto.CompactTextString(m) }
func (*CombatPlayerProto) ProtoMessage()               {}
func (*CombatPlayerProto) Descriptor() ([]byte, []int) { return fileDescriptorCombat, []int{6} }

func (m *CombatPlayerProto) GetHero() *HeroBasicProto {
	if m != nil {
		return m.Hero
	}
	return nil
}

func (m *CombatPlayerProto) GetTotalFightAmount() int32 {
	if m != nil {
		return m.TotalFightAmount
	}
	return 0
}

func (m *CombatPlayerProto) GetTroops() []*CombatTroopsProto {
	if m != nil {
		return m.Troops
	}
	return nil
}

func (m *CombatPlayerProto) GetTotalWallLife() int32 {
	if m != nil {
		return m.TotalWallLife
	}
	return 0
}

func (m *CombatPlayerProto) GetWallStat() *SpriteStatProto {
	if m != nil {
		return m.WallStat
	}
	return nil
}

func (m *CombatPlayerProto) GetWallFixDamage() int32 {
	if m != nil {
		return m.WallFixDamage
	}
	return 0
}

func (m *CombatPlayerProto) GetWallLevel() int32 {
	if m != nil {
		return m.WallLevel
	}
	return 0
}

type CombatTroopsProto struct {
	//    int32 index = 1; // 单位索引号，从1开始（自增，如果两边1v1，那么index就是1和2）
	X          int32 `protobuf:"varint,2,opt,name=x,proto3" json:"x,omitempty"`
	Y          int32 `protobuf:"varint,3,opt,name=y,proto3" json:"y,omitempty"`
	FightIndex int32 `protobuf:"varint,5,opt,name=fight_index,json=fightIndex,proto3" json:"fight_index,omitempty"`
	// 武将信息
	Captain *CaptainInfoProto `protobuf:"bytes,4,opt,name=captain" json:"captain,omitempty"`
}

func (m *CombatTroopsProto) Reset()                    { *m = CombatTroopsProto{} }
func (m *CombatTroopsProto) String() string            { return proto.CompactTextString(m) }
func (*CombatTroopsProto) ProtoMessage()               {}
func (*CombatTroopsProto) Descriptor() ([]byte, []int) { return fileDescriptorCombat, []int{7} }

func (m *CombatTroopsProto) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *CombatTroopsProto) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *CombatTroopsProto) GetFightIndex() int32 {
	if m != nil {
		return m.FightIndex
	}
	return 0
}

func (m *CombatTroopsProto) GetCaptain() *CaptainInfoProto {
	if m != nil {
		return m.Captain
	}
	return nil
}

type CombatTroopsPosProto struct {
	Index int32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	X     int32 `protobuf:"varint,2,opt,name=x,proto3" json:"x,omitempty"`
	Y     int32 `protobuf:"varint,3,opt,name=y,proto3" json:"y,omitempty"`
}

func (m *CombatTroopsPosProto) Reset()                    { *m = CombatTroopsPosProto{} }
func (m *CombatTroopsPosProto) String() string            { return proto.CompactTextString(m) }
func (*CombatTroopsPosProto) ProtoMessage()               {}
func (*CombatTroopsPosProto) Descriptor() ([]byte, []int) { return fileDescriptorCombat, []int{8} }

func (m *CombatTroopsPosProto) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *CombatTroopsPosProto) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *CombatTroopsPosProto) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func init() {
	proto.RegisterType((*CombatShareProto)(nil), "proto.CombatShareProto")
	proto.RegisterType((*CombatProto)(nil), "proto.CombatProto")
	proto.RegisterType((*MultiCombatProto)(nil), "proto.MultiCombatProto")
	proto.RegisterType((*CombatRoundProto)(nil), "proto.CombatRoundProto")
	proto.RegisterType((*CombatActionProto)(nil), "proto.CombatActionProto")
	proto.RegisterType((*WallActionProto)(nil), "proto.WallActionProto")
	proto.RegisterType((*CombatPlayerProto)(nil), "proto.CombatPlayerProto")
	proto.RegisterType((*CombatTroopsProto)(nil), "proto.CombatTroopsProto")
	proto.RegisterType((*CombatTroopsPosProto)(nil), "proto.CombatTroopsPosProto")
	proto.RegisterEnum("proto.CombatType", CombatType_name, CombatType_value)
	proto.RegisterEnum("proto.Direction", Direction_name, Direction_value)
	proto.RegisterEnum("proto.HurtType", HurtType_name, HurtType_value)
}
func (m *CombatShareProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombatShareProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Link) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCombat(dAtA, i, uint64(len(m.Link)))
		i += copy(dAtA[i:], m.Link)
	}
	if m.IsAttacker {
		dAtA[i] = 0x10
		i++
		if m.IsAttacker {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Type))
	}
	if len(m.SecondLink) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCombat(dAtA, i, uint64(len(m.SecondLink)))
		i += copy(dAtA[i:], m.SecondLink)
	}
	return i, nil
}

func (m *CombatProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombatProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Attacker != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Attacker.Size()))
		n1, err := m.Attacker.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Defenser != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Defenser.Size()))
		n2, err := m.Defenser.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.MapRes) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCombat(dAtA, i, uint64(len(m.MapRes)))
		i += copy(dAtA[i:], m.MapRes)
	}
	if m.MapXLen != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.MapXLen))
	}
	if m.MapYLen != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.MapYLen))
	}
	if len(m.Rounds) > 0 {
		for _, msg := range m.Rounds {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCombat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AttackerTroopPos) > 0 {
		for _, msg := range m.AttackerTroopPos {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintCombat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DefenserTroopPos) > 0 {
		for _, msg := range m.DefenserTroopPos {
			dAtA[i] = 0x42
			i++
			i = encodeVarintCombat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AttackerWin {
		dAtA[i] = 0x58
		i++
		if m.AttackerWin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AliveSolider) > 0 {
		for _, msg := range m.AliveSolider {
			dAtA[i] = 0x62
			i++
			i = encodeVarintCombat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Score != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Score))
	}
	if len(m.CombatSolider) > 0 {
		for _, msg := range m.CombatSolider {
			dAtA[i] = 0x72
			i++
			i = encodeVarintCombat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FightQueue != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.FightQueue))
	}
	if m.IsWinnerContinueWinLeave {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.IsWinnerContinueWinLeave {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WinnerContinueWinTimes != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.WinnerContinueWinTimes))
	}
	if len(m.KillSolider) > 0 {
		for _, msg := range m.KillSolider {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCombat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MultiCombatProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiCombatProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Attacker) > 0 {
		for _, msg := range m.Attacker {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCombat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Defenser) > 0 {
		for _, msg := range m.Defenser {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCombat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MapRes) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCombat(dAtA, i, uint64(len(m.MapRes)))
		i += copy(dAtA[i:], m.MapRes)
	}
	if m.MapXLen != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.MapXLen))
	}
	if m.MapYLen != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.MapYLen))
	}
	if m.ConcurrentFightCount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.ConcurrentFightCount))
	}
	if m.AttackerWin {
		dAtA[i] = 0x58
		i++
		if m.AttackerWin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Score != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Score))
	}
	if len(m.Combats) > 0 {
		for _, msg := range m.Combats {
			dAtA[i] = 0x72
			i++
			i = encodeVarintCombat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AttackerDeadCount != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.AttackerDeadCount))
	}
	if m.DefenserDeadCount != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.DefenserDeadCount))
	}
	if m.AttackerLeaveCount != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.AttackerLeaveCount))
	}
	if m.DefenserLeaveCount != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.DefenserLeaveCount))
	}
	if len(m.WinTimes) > 0 {
		for _, msg := range m.WinTimes {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCombat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CombatRoundProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombatRoundProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Round != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Round))
	}
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCombat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.WallAction != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.WallAction.Size()))
		n3, err := m.WallAction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *CombatActionProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombatActionProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Index))
	}
	if m.MoveDirection != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.MoveDirection))
	}
	if m.TargetIndex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.TargetIndex))
	}
	if m.Damage != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Damage))
	}
	if m.HurtType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.HurtType))
	}
	if m.RestraintSpellDamage != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.RestraintSpellDamage))
	}
	if m.NormalSpell != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.NormalSpell))
	}
	if m.RestraintSpell != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.RestraintSpell))
	}
	if m.LeftSoldier != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.LeftSoldier))
	}
	if m.HurtWallLife != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.HurtWallLife))
	}
	if m.HurtWallSpell != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.HurtWallSpell))
	}
	if m.WallLeftLife != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.WallLeftLife))
	}
	if m.LeftMoveTimes != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.LeftMoveTimes))
	}
	return i, nil
}

func (m *WallActionProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WallActionProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TargetIndex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.TargetIndex))
	}
	if m.Damage != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Damage))
	}
	if m.LeftSoldier != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.LeftSoldier))
	}
	return i, nil
}

func (m *CombatPlayerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombatPlayerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalFightAmount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.TotalFightAmount))
	}
	if m.Hero != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Hero.Size()))
		n4, err := m.Hero.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Troops) > 0 {
		for _, msg := range m.Troops {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCombat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TotalWallLife != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.TotalWallLife))
	}
	if m.WallStat != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.WallStat.Size()))
		n5, err := m.WallStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.WallFixDamage != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.WallFixDamage))
	}
	if m.WallLevel != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.WallLevel))
	}
	return i, nil
}

func (m *CombatTroopsProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombatTroopsProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Y))
	}
	if m.Captain != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Captain.Size()))
		n6, err := m.Captain.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.FightIndex != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.FightIndex))
	}
	return i, nil
}

func (m *CombatTroopsPosProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombatTroopsPosProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Index))
	}
	if m.X != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Y))
	}
	return i, nil
}

func encodeFixed64Combat(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Combat(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintCombat(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CombatShareProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovCombat(uint64(l))
	}
	if m.IsAttacker {
		n += 2
	}
	if m.Type != 0 {
		n += 1 + sovCombat(uint64(m.Type))
	}
	l = len(m.SecondLink)
	if l > 0 {
		n += 1 + l + sovCombat(uint64(l))
	}
	return n
}

func (m *CombatProto) Size() (n int) {
	var l int
	_ = l
	if m.Attacker != nil {
		l = m.Attacker.Size()
		n += 1 + l + sovCombat(uint64(l))
	}
	if m.Defenser != nil {
		l = m.Defenser.Size()
		n += 1 + l + sovCombat(uint64(l))
	}
	l = len(m.MapRes)
	if l > 0 {
		n += 1 + l + sovCombat(uint64(l))
	}
	if m.MapXLen != 0 {
		n += 1 + sovCombat(uint64(m.MapXLen))
	}
	if m.MapYLen != 0 {
		n += 1 + sovCombat(uint64(m.MapYLen))
	}
	if len(m.Rounds) > 0 {
		for _, e := range m.Rounds {
			l = e.Size()
			n += 1 + l + sovCombat(uint64(l))
		}
	}
	if len(m.AttackerTroopPos) > 0 {
		for _, e := range m.AttackerTroopPos {
			l = e.Size()
			n += 1 + l + sovCombat(uint64(l))
		}
	}
	if len(m.DefenserTroopPos) > 0 {
		for _, e := range m.DefenserTroopPos {
			l = e.Size()
			n += 1 + l + sovCombat(uint64(l))
		}
	}
	if m.AttackerWin {
		n += 2
	}
	if len(m.AliveSolider) > 0 {
		for _, e := range m.AliveSolider {
			l = e.Size()
			n += 1 + l + sovCombat(uint64(l))
		}
	}
	if m.Score != 0 {
		n += 1 + sovCombat(uint64(m.Score))
	}
	if len(m.CombatSolider) > 0 {
		for _, e := range m.CombatSolider {
			l = e.Size()
			n += 1 + l + sovCombat(uint64(l))
		}
	}
	if m.FightQueue != 0 {
		n += 1 + sovCombat(uint64(m.FightQueue))
	}
	if m.IsWinnerContinueWinLeave {
		n += 3
	}
	if m.WinnerContinueWinTimes != 0 {
		n += 2 + sovCombat(uint64(m.WinnerContinueWinTimes))
	}
	if len(m.KillSolider) > 0 {
		for _, e := range m.KillSolider {
			l = e.Size()
			n += 2 + l + sovCombat(uint64(l))
		}
	}
	return n
}

func (m *MultiCombatProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Attacker) > 0 {
		for _, e := range m.Attacker {
			l = e.Size()
			n += 1 + l + sovCombat(uint64(l))
		}
	}
	if len(m.Defenser) > 0 {
		for _, e := range m.Defenser {
			l = e.Size()
			n += 1 + l + sovCombat(uint64(l))
		}
	}
	l = len(m.MapRes)
	if l > 0 {
		n += 1 + l + sovCombat(uint64(l))
	}
	if m.MapXLen != 0 {
		n += 1 + sovCombat(uint64(m.MapXLen))
	}
	if m.MapYLen != 0 {
		n += 1 + sovCombat(uint64(m.MapYLen))
	}
	if m.ConcurrentFightCount != 0 {
		n += 1 + sovCombat(uint64(m.ConcurrentFightCount))
	}
	if m.AttackerWin {
		n += 2
	}
	if m.Score != 0 {
		n += 1 + sovCombat(uint64(m.Score))
	}
	if len(m.Combats) > 0 {
		for _, e := range m.Combats {
			l = e.Size()
			n += 1 + l + sovCombat(uint64(l))
		}
	}
	if m.AttackerDeadCount != 0 {
		n += 1 + sovCombat(uint64(m.AttackerDeadCount))
	}
	if m.DefenserDeadCount != 0 {
		n += 2 + sovCombat(uint64(m.DefenserDeadCount))
	}
	if m.AttackerLeaveCount != 0 {
		n += 2 + sovCombat(uint64(m.AttackerLeaveCount))
	}
	if m.DefenserLeaveCount != 0 {
		n += 2 + sovCombat(uint64(m.DefenserLeaveCount))
	}
	if len(m.WinTimes) > 0 {
		for _, e := range m.WinTimes {
			l = e.Size()
			n += 2 + l + sovCombat(uint64(l))
		}
	}
	return n
}

func (m *CombatRoundProto) Size() (n int) {
	var l int
	_ = l
	if m.Round != 0 {
		n += 1 + sovCombat(uint64(m.Round))
	}
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovCombat(uint64(l))
		}
	}
	if m.WallAction != nil {
		l = m.WallAction.Size()
		n += 1 + l + sovCombat(uint64(l))
	}
	return n
}

func (m *CombatActionProto) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovCombat(uint64(m.Index))
	}
	if m.MoveDirection != 0 {
		n += 1 + sovCombat(uint64(m.MoveDirection))
	}
	if m.TargetIndex != 0 {
		n += 1 + sovCombat(uint64(m.TargetIndex))
	}
	if m.Damage != 0 {
		n += 1 + sovCombat(uint64(m.Damage))
	}
	if m.HurtType != 0 {
		n += 1 + sovCombat(uint64(m.HurtType))
	}
	if m.RestraintSpellDamage != 0 {
		n += 1 + sovCombat(uint64(m.RestraintSpellDamage))
	}
	if m.NormalSpell != 0 {
		n += 1 + sovCombat(uint64(m.NormalSpell))
	}
	if m.RestraintSpell != 0 {
		n += 1 + sovCombat(uint64(m.RestraintSpell))
	}
	if m.LeftSoldier != 0 {
		n += 1 + sovCombat(uint64(m.LeftSoldier))
	}
	if m.HurtWallLife != 0 {
		n += 1 + sovCombat(uint64(m.HurtWallLife))
	}
	if m.HurtWallSpell != 0 {
		n += 2 + sovCombat(uint64(m.HurtWallSpell))
	}
	if m.WallLeftLife != 0 {
		n += 2 + sovCombat(uint64(m.WallLeftLife))
	}
	if m.LeftMoveTimes != 0 {
		n += 2 + sovCombat(uint64(m.LeftMoveTimes))
	}
	return n
}

func (m *WallActionProto) Size() (n int) {
	var l int
	_ = l
	if m.TargetIndex != 0 {
		n += 1 + sovCombat(uint64(m.TargetIndex))
	}
	if m.Damage != 0 {
		n += 1 + sovCombat(uint64(m.Damage))
	}
	if m.LeftSoldier != 0 {
		n += 1 + sovCombat(uint64(m.LeftSoldier))
	}
	return n
}

func (m *CombatPlayerProto) Size() (n int) {
	var l int
	_ = l
	if m.TotalFightAmount != 0 {
		n += 1 + sovCombat(uint64(m.TotalFightAmount))
	}
	if m.Hero != nil {
		l = m.Hero.Size()
		n += 1 + l + sovCombat(uint64(l))
	}
	if len(m.Troops) > 0 {
		for _, e := range m.Troops {
			l = e.Size()
			n += 2 + l + sovCombat(uint64(l))
		}
	}
	if m.TotalWallLife != 0 {
		n += 2 + sovCombat(uint64(m.TotalWallLife))
	}
	if m.WallStat != nil {
		l = m.WallStat.Size()
		n += 2 + l + sovCombat(uint64(l))
	}
	if m.WallFixDamage != 0 {
		n += 2 + sovCombat(uint64(m.WallFixDamage))
	}
	if m.WallLevel != 0 {
		n += 2 + sovCombat(uint64(m.WallLevel))
	}
	return n
}

func (m *CombatTroopsProto) Size() (n int) {
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovCombat(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovCombat(uint64(m.Y))
	}
	if m.Captain != nil {
		l = m.Captain.Size()
		n += 1 + l + sovCombat(uint64(l))
	}
	if m.FightIndex != 0 {
		n += 1 + sovCombat(uint64(m.FightIndex))
	}
	return n
}

func (m *CombatTroopsPosProto) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovCombat(uint64(m.Index))
	}
	if m.X != 0 {
		n += 1 + sovCombat(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovCombat(uint64(m.Y))
	}
	return n
}

func sovCombat(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCombat(x uint64) (n int) {
	return sovCombat(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CombatShareProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombatShareProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombatShareProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAttacker", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAttacker = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (CombatType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCombat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombatProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombatProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombatProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attacker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attacker == nil {
				m.Attacker = &CombatPlayerProto{}
			}
			if err := m.Attacker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defenser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Defenser == nil {
				m.Defenser = &CombatPlayerProto{}
			}
			if err := m.Defenser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapRes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapRes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapXLen", wireType)
			}
			m.MapXLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapXLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapYLen", wireType)
			}
			m.MapYLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapYLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rounds = append(m.Rounds, &CombatRoundProto{})
			if err := m.Rounds[len(m.Rounds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerTroopPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttackerTroopPos = append(m.AttackerTroopPos, &CombatTroopsPosProto{})
			if err := m.AttackerTroopPos[len(m.AttackerTroopPos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserTroopPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefenserTroopPos = append(m.DefenserTroopPos, &CombatTroopsPosProto{})
			if err := m.DefenserTroopPos[len(m.DefenserTroopPos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerWin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttackerWin = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliveSolider", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliveSolider = append(m.AliveSolider, &Int32Pair{})
			if err := m.AliveSolider[len(m.AliveSolider)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CombatSolider", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CombatSolider = append(m.CombatSolider, &Int32Pair{})
			if err := m.CombatSolider[len(m.CombatSolider)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightQueue", wireType)
			}
			m.FightQueue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightQueue |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWinnerContinueWinLeave", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWinnerContinueWinLeave = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinnerContinueWinTimes", wireType)
			}
			m.WinnerContinueWinTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinnerContinueWinTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillSolider", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KillSolider = append(m.KillSolider, &Int32Pair{})
			if err := m.KillSolider[len(m.KillSolider)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCombat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiCombatProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiCombatProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiCombatProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attacker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attacker = append(m.Attacker, &CombatPlayerProto{})
			if err := m.Attacker[len(m.Attacker)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defenser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Defenser = append(m.Defenser, &CombatPlayerProto{})
			if err := m.Defenser[len(m.Defenser)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapRes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapRes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapXLen", wireType)
			}
			m.MapXLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapXLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapYLen", wireType)
			}
			m.MapYLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapYLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcurrentFightCount", wireType)
			}
			m.ConcurrentFightCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConcurrentFightCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerWin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttackerWin = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Combats = append(m.Combats, &CombatProto{})
			if err := m.Combats[len(m.Combats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerDeadCount", wireType)
			}
			m.AttackerDeadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackerDeadCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserDeadCount", wireType)
			}
			m.DefenserDeadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefenserDeadCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerLeaveCount", wireType)
			}
			m.AttackerLeaveCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackerLeaveCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserLeaveCount", wireType)
			}
			m.DefenserLeaveCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefenserLeaveCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WinTimes = append(m.WinTimes, &BytesInt32Pair{})
			if err := m.WinTimes[len(m.WinTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCombat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombatRoundProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombatRoundProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombatRoundProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &CombatActionProto{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WallAction == nil {
				m.WallAction = &WallActionProto{}
			}
			if err := m.WallAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCombat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombatActionProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombatActionProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombatActionProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveDirection", wireType)
			}
			m.MoveDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveDirection |= (Direction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetIndex", wireType)
			}
			m.TargetIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Damage", wireType)
			}
			m.Damage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Damage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtType", wireType)
			}
			m.HurtType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HurtType |= (HurtType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestraintSpellDamage", wireType)
			}
			m.RestraintSpellDamage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestraintSpellDamage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalSpell", wireType)
			}
			m.NormalSpell = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NormalSpell |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestraintSpell", wireType)
			}
			m.RestraintSpell = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestraintSpell |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftSoldier", wireType)
			}
			m.LeftSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtWallLife", wireType)
			}
			m.HurtWallLife = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HurtWallLife |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtWallSpell", wireType)
			}
			m.HurtWallSpell = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HurtWallSpell |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallLeftLife", wireType)
			}
			m.WallLeftLife = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WallLeftLife |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftMoveTimes", wireType)
			}
			m.LeftMoveTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftMoveTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCombat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WallActionProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WallActionProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WallActionProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetIndex", wireType)
			}
			m.TargetIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Damage", wireType)
			}
			m.Damage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Damage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftSoldier", wireType)
			}
			m.LeftSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCombat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombatPlayerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombatPlayerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombatPlayerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFightAmount", wireType)
			}
			m.TotalFightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalFightAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hero", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hero == nil {
				m.Hero = &HeroBasicProto{}
			}
			if err := m.Hero.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Troops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Troops = append(m.Troops, &CombatTroopsProto{})
			if err := m.Troops[len(m.Troops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalWallLife", wireType)
			}
			m.TotalWallLife = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalWallLife |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WallStat == nil {
				m.WallStat = &SpriteStatProto{}
			}
			if err := m.WallStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallFixDamage", wireType)
			}
			m.WallFixDamage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WallFixDamage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallLevel", wireType)
			}
			m.WallLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WallLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCombat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombatTroopsProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombatTroopsProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombatTroopsProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Captain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Captain == nil {
				m.Captain = &CaptainInfoProto{}
			}
			if err := m.Captain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightIndex", wireType)
			}
			m.FightIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCombat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombatTroopsPosProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombatTroopsPosProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombatTroopsPosProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCombat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCombat(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCombat
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCombat
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCombat(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCombat = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCombat   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/shared_proto/combat.proto", fileDescriptorCombat)
}

var fileDescriptorCombat = []byte{
	// 1390 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0xc1, 0x52, 0x1b, 0x47,
	0x13, 0x66, 0x41, 0x5a, 0x49, 0x2d, 0x21, 0x96, 0x01, 0xe3, 0xfd, 0xfd, 0x27, 0x18, 0xab, 0x9c,
	0x84, 0xb8, 0x5c, 0x60, 0x0b, 0x27, 0x4e, 0x2e, 0x49, 0x61, 0x30, 0x46, 0x55, 0x02, 0x2b, 0x2b,
	0x28, 0x9c, 0x5c, 0xb6, 0x06, 0x69, 0x84, 0xa6, 0x58, 0xed, 0x2a, 0xbb, 0x23, 0x81, 0xce, 0x39,
	0x26, 0x55, 0x39, 0xa5, 0x2a, 0xcf, 0x93, 0x53, 0x8e, 0x79, 0x84, 0x14, 0xc9, 0x83, 0xa4, 0xa6,
	0x7b, 0x77, 0x25, 0x30, 0xb8, 0x48, 0x72, 0xc8, 0x09, 0x4d, 0xf7, 0xd7, 0x5f, 0x77, 0xcf, 0x7c,
	0xd3, 0xb3, 0xc0, 0xa7, 0x27, 0x52, 0x75, 0x07, 0xc7, 0x6b, 0xad, 0xa0, 0xb7, 0xee, 0xc9, 0x93,
	0xae, 0xea, 0xf3, 0xb3, 0xf5, 0x1e, 0xf7, 0xc4, 0xf3, 0xf5, 0xfe, 0xf1, 0x7a, 0xd4, 0xe5, 0xa1,
	0x68, 0xbb, 0xfd, 0x30, 0x50, 0xc1, 0x7a, 0x2b, 0xe8, 0x1d, 0x73, 0xb5, 0x86, 0x0b, 0x96, 0xc5,
	0x3f, 0xf7, 0x9e, 0xdd, 0x3e, 0xfc, 0x98, 0x47, 0x82, 0x82, 0xef, 0x7d, 0x76, 0xfb, 0xa8, 0x9e,
	0xf4, 0xa4, 0xe2, 0xe1, 0xe8, 0xef, 0x47, 0x46, 0x3e, 0xef, 0x47, 0xdd, 0x20, 0x2e, 0xb8, 0xf2,
	0xa3, 0x01, 0xd6, 0x16, 0x76, 0xd0, 0xd4, 0xa8, 0x06, 0x76, 0xc1, 0x20, 0xe3, 0x49, 0xff, 0xd4,
	0x36, 0x56, 0x8c, 0xd5, 0x82, 0x83, 0xbf, 0xd9, 0x7d, 0x28, 0xca, 0xc8, 0xe5, 0x4a, 0xf1, 0xd6,
	0xa9, 0x08, 0xed, 0xe9, 0x15, 0x63, 0x35, 0xef, 0x80, 0x8c, 0x36, 0x63, 0x0b, 0xfb, 0x00, 0x32,
	0x6a, 0xd4, 0x17, 0xf6, 0xcc, 0x8a, 0xb1, 0x5a, 0xae, 0xce, 0x13, 0xff, 0x1a, 0x71, 0x1f, 0x8c,
	0xfa, 0xc2, 0x41, 0xb7, 0xe6, 0x89, 0x44, 0x2b, 0xf0, 0xdb, 0x2e, 0xa6, 0xc8, 0x60, 0x0a, 0x20,
	0x53, 0x5d, 0xfa, 0xa7, 0x95, 0xef, 0x4d, 0x28, 0x52, 0x14, 0x15, 0xf3, 0x0c, 0xf2, 0x69, 0x56,
	0x5d, 0x50, 0xb1, 0x6a, 0x5f, 0xe2, 0x6e, 0x78, 0x7c, 0x24, 0x42, 0xc4, 0x3a, 0x29, 0x52, 0x47,
	0xb5, 0x45, 0x47, 0xf8, 0x51, 0x5c, 0xeb, 0x3b, 0xa3, 0x12, 0x24, 0xbb, 0x0b, 0xb9, 0x1e, 0xef,
	0xbb, 0xa1, 0x88, 0xb0, 0x8d, 0x82, 0x63, 0xf6, 0x78, 0xdf, 0x11, 0x11, 0xbb, 0x07, 0x05, 0xed,
	0x38, 0x77, 0x3d, 0xe1, 0x63, 0xcd, 0x59, 0x47, 0x23, 0xdf, 0xd4, 0x85, 0x9f, 0xf8, 0x46, 0xe8,
	0xcb, 0xa6, 0xbe, 0xaf, 0xb5, 0x6f, 0x1d, 0xcc, 0x30, 0x18, 0xf8, 0xed, 0xc8, 0x36, 0x57, 0x66,
	0x56, 0x8b, 0xd5, 0xbb, 0x97, 0x8a, 0x70, 0xb4, 0x8b, 0x6a, 0x88, 0x61, 0xac, 0x06, 0x2c, 0xe9,
	0xc1, 0x55, 0x61, 0x10, 0xf4, 0xdd, 0x7e, 0x10, 0xd9, 0x39, 0x0c, 0xfe, 0xff, 0xe5, 0x3d, 0xd5,
	0xde, 0xa8, 0x11, 0x44, 0x44, 0x60, 0x25, 0x61, 0x68, 0x6f, 0x04, 0x48, 0x95, 0x34, 0x36, 0x41,
	0x95, 0xbf, 0x05, 0x55, 0x12, 0x96, 0x52, 0x3d, 0x80, 0x52, 0x5a, 0xd5, 0x99, 0xf4, 0xed, 0x22,
	0x9e, 0x7e, 0x31, 0xb1, 0x1d, 0x49, 0x9f, 0x7d, 0x02, 0xb3, 0xdc, 0x93, 0x43, 0xe1, 0x46, 0x81,
	0x27, 0xdb, 0x22, 0xb4, 0x4b, 0x98, 0xc8, 0x8a, 0x13, 0xd5, 0x7c, 0xb5, 0x51, 0x6d, 0x70, 0x19,
	0x3a, 0x25, 0x84, 0x35, 0x09, 0xc5, 0x16, 0x21, 0x1b, 0xb5, 0x82, 0x50, 0xd8, 0xb3, 0xb8, 0x71,
	0xb4, 0x60, 0xcf, 0xa1, 0x4c, 0xd7, 0x2a, 0x65, 0x2b, 0xdf, 0xc0, 0x36, 0x4b, 0xb8, 0x84, 0xee,
	0x3e, 0x14, 0x3b, 0x5a, 0xff, 0xee, 0xb7, 0x03, 0x31, 0x10, 0xf6, 0x1c, 0x92, 0x02, 0x9a, 0xbe,
	0xd2, 0x16, 0xf6, 0x05, 0xbc, 0x27, 0x23, 0xdd, 0x83, 0x2f, 0x42, 0xb7, 0x15, 0xf8, 0x4a, 0xfa,
	0x03, 0xa1, 0xd7, 0xae, 0x27, 0xf8, 0x50, 0xd8, 0x16, 0x76, 0x66, 0xcb, 0xe8, 0x08, 0x21, 0x5b,
	0x31, 0xe2, 0x48, 0xfa, 0x75, 0xed, 0x67, 0x9f, 0xc3, 0xff, 0xae, 0x0b, 0x56, 0xb2, 0x27, 0x22,
	0x7b, 0x1e, 0xd3, 0x2d, 0x9d, 0x5d, 0x0d, 0x3d, 0xd0, 0x5e, 0xb6, 0x01, 0xa5, 0x53, 0xe9, 0x79,
	0x69, 0x4b, 0xec, 0x86, 0x96, 0x8a, 0x1a, 0x15, 0x37, 0x54, 0xf9, 0x33, 0x03, 0xd6, 0xde, 0xc0,
	0x53, 0xf2, 0xe6, 0x2b, 0x31, 0xf3, 0x8f, 0xae, 0xc4, 0xcc, 0x7f, 0x75, 0x25, 0x9e, 0xc1, 0x52,
	0x2b, 0xf0, 0x5b, 0x83, 0x30, 0x14, 0xbe, 0x72, 0xe9, 0xb4, 0x5a, 0xc1, 0xc0, 0x57, 0xb6, 0x89,
	0xc0, 0xc5, 0xb1, 0x77, 0x47, 0x3b, 0xb7, 0xb4, 0xef, 0x36, 0x0a, 0xbc, 0x5e, 0x4a, 0x8f, 0x21,
	0x47, 0x12, 0x89, 0x62, 0x0d, 0xb1, 0xcb, 0x4d, 0x63, 0xbb, 0x09, 0x84, 0xad, 0xc1, 0x42, 0x9a,
	0xa6, 0x2d, 0x78, 0x3b, 0xae, 0x8c, 0x74, 0x34, 0x9f, 0xb8, 0xb6, 0x05, 0x6f, 0x53, 0x59, 0x6b,
	0xb0, 0x90, 0xde, 0xb1, 0x09, 0xbc, 0x45, 0xf8, 0xc4, 0x35, 0xc6, 0x3f, 0x81, 0xc5, 0x94, 0x1f,
	0x05, 0x17, 0x07, 0x90, 0x72, 0xd2, 0xab, 0x8f, 0x5a, 0x4b, 0x23, 0xd2, 0x0c, 0x93, 0x11, 0x8c,
	0x22, 0x12, 0xdf, 0x44, 0x44, 0x15, 0x0a, 0x63, 0x49, 0x2e, 0x60, 0xcf, 0x77, 0xe2, 0x9e, 0x5f,
	0x8c, 0x94, 0x88, 0xc6, 0x4a, 0xcb, 0x9f, 0xc5, 0xda, 0xac, 0xfc, 0x94, 0x3e, 0x03, 0xe3, 0x99,
	0xa4, 0x37, 0x14, 0xa7, 0x12, 0x8e, 0xdd, 0xac, 0x43, 0x0b, 0x56, 0x85, 0x1c, 0x6f, 0x29, 0x19,
	0xf8, 0xd1, 0xb5, 0x2a, 0xda, 0x44, 0x5f, 0xbc, 0xad, 0x31, 0x90, 0x3d, 0x87, 0xe2, 0x19, 0xf7,
	0x3c, 0x97, 0xd6, 0x28, 0xa4, 0x62, 0x75, 0x29, 0x8e, 0x3b, 0xe2, 0x9e, 0x37, 0x19, 0x05, 0x67,
	0xa9, 0xa1, 0xf2, 0x43, 0x06, 0xe6, 0xdf, 0xe2, 0xd5, 0x85, 0x49, 0xbf, 0x2d, 0xce, 0x93, 0xc2,
	0x70, 0xa1, 0x87, 0x46, 0x2f, 0x18, 0x0a, 0xb7, 0x2d, 0x43, 0x31, 0xce, 0x53, 0x4e, 0x6f, 0xd8,
	0x76, 0x62, 0x77, 0x66, 0x35, 0x2e, 0x5d, 0x6a, 0x6d, 0x29, 0x1e, 0x9e, 0x08, 0xe5, 0x12, 0x2b,
	0x89, 0xb9, 0x48, 0xb6, 0x1a, 0x72, 0x2f, 0x81, 0xd9, 0xe6, 0x3d, 0x7e, 0x22, 0x62, 0x35, 0xc7,
	0x2b, 0xf6, 0x18, 0x0a, 0xdd, 0x41, 0xa8, 0x5c, 0x7c, 0xf9, 0x4c, 0x4c, 0x37, 0x17, 0xa7, 0xdb,
	0x1d, 0x84, 0xf4, 0xee, 0xe5, 0xbb, 0xf1, 0x2f, 0x2d, 0xfd, 0x50, 0x44, 0x2a, 0xe4, 0xd2, 0x57,
	0x6e, 0xd4, 0x17, 0x9e, 0xe7, 0xc6, 0xac, 0x39, 0x92, 0x7e, 0xea, 0x6d, 0x6a, 0xe7, 0x36, 0xe5,
	0x78, 0x00, 0x25, 0x3f, 0x08, 0x7b, 0xdc, 0xa3, 0x10, 0x3b, 0x4f, 0xe5, 0x91, 0x0d, 0x81, 0xec,
	0x23, 0x98, 0xbb, 0x42, 0x6c, 0x17, 0x10, 0x55, 0xbe, 0xcc, 0xa8, 0xb9, 0x3c, 0xd1, 0xc1, 0xb1,
	0xda, 0x96, 0x22, 0xb4, 0x81, 0xb8, 0xb4, 0xad, 0x49, 0x26, 0xf6, 0x10, 0xca, 0xd8, 0x12, 0x1e,
	0x98, 0x27, 0x3b, 0xc9, 0x14, 0x2d, 0x69, 0xab, 0x3e, 0xab, 0xba, 0xec, 0x08, 0xf6, 0x21, 0xcc,
	0x8d, 0x51, 0x94, 0x91, 0x44, 0x3f, 0x9b, 0xc0, 0x28, 0xe1, 0x43, 0x28, 0x13, 0x91, 0xce, 0x8a,
	0x6c, 0x24, 0xf5, 0x92, 0xb6, 0xd6, 0x45, 0x47, 0x25, 0x6c, 0x08, 0xc0, 0xf3, 0x23, 0xe1, 0x2e,
	0x12, 0x9b, 0x36, 0xef, 0x05, 0x43, 0x41, 0x32, 0x0d, 0x60, 0xee, 0x8a, 0x5a, 0xfe, 0xcd, 0xe1,
	0x5d, 0xdd, 0x0c, 0xf3, 0xad, 0xcd, 0xa8, 0xfc, 0x32, 0x9d, 0xe8, 0x6f, 0x62, 0x3a, 0xb2, 0xc7,
	0xc0, 0x54, 0xa0, 0xb8, 0x17, 0x4f, 0x2f, 0xde, 0xc3, 0x1b, 0x49, 0xe7, 0x62, 0xa1, 0x07, 0x27,
	0xd7, 0x26, 0xda, 0xd9, 0xc7, 0x90, 0xe9, 0x8a, 0x30, 0xc0, 0x91, 0x35, 0xbe, 0x8a, 0xbb, 0x22,
	0x0c, 0x5e, 0xf0, 0x48, 0xb6, 0x48, 0xf4, 0x08, 0x61, 0x4f, 0xc0, 0xc4, 0x97, 0x3a, 0xb2, 0xef,
	0x5c, 0x73, 0xb5, 0xe2, 0x67, 0x9a, 0xbe, 0x17, 0x08, 0xa7, 0x77, 0x8e, 0x4a, 0x19, 0x1f, 0xd7,
	0x32, 0xed, 0x1c, 0x9a, 0xd3, 0xf3, 0xda, 0x80, 0x02, 0x1d, 0x95, 0xe2, 0xca, 0xbe, 0x7f, 0xe9,
	0xfe, 0x35, 0xfb, 0xa1, 0x54, 0xa2, 0xa9, 0x92, 0x61, 0x98, 0xd7, 0x40, 0xbd, 0xd4, 0xe4, 0x18,
	0xd4, 0x91, 0xe7, 0x89, 0x50, 0x57, 0x88, 0x5c, 0x9b, 0x77, 0xe4, 0x79, 0xac, 0xd0, 0xf7, 0x01,
	0xe2, 0x43, 0x1e, 0x0a, 0xcf, 0x7e, 0x80, 0x90, 0x02, 0x1d, 0xf0, 0x50, 0x78, 0x95, 0xef, 0x8c,
	0x64, 0x13, 0x27, 0x3a, 0x60, 0x25, 0x30, 0xce, 0xf1, 0xd3, 0x2c, 0xeb, 0x18, 0xe7, 0x7a, 0x35,
	0xc2, 0xfb, 0x9a, 0x75, 0x8c, 0x11, 0x7b, 0x0a, 0xb9, 0x16, 0xef, 0x2b, 0x2e, 0xe9, 0x65, 0x99,
	0xf8, 0x6e, 0x22, 0x6b, 0xcd, 0xef, 0x04, 0xc9, 0xe4, 0x26, 0xcb, 0xf8, 0xe5, 0x27, 0x19, 0x64,
	0x27, 0x5e, 0x7e, 0x54, 0x41, 0x65, 0x17, 0x16, 0xaf, 0xfb, 0xda, 0xb9, 0x61, 0x98, 0xbc, 0xa3,
	0xba, 0x47, 0x4f, 0x01, 0xc6, 0x9f, 0xb5, 0x0c, 0xc0, 0x6c, 0xd6, 0xf6, 0x5f, 0xd5, 0x5f, 0x5a,
	0x53, 0xac, 0x00, 0xd9, 0xbd, 0xc3, 0xfa, 0x41, 0xcd, 0x32, 0x58, 0x09, 0xf2, 0x64, 0x76, 0xdf,
	0x58, 0xd3, 0x8f, 0x86, 0x50, 0x18, 0xcf, 0x1b, 0x00, 0xf3, 0xb5, 0x53, 0x7b, 0x55, 0xdb, 0xb7,
	0xa6, 0x98, 0x09, 0xd3, 0x87, 0x0d, 0xcb, 0x60, 0x45, 0xc8, 0xd5, 0x5f, 0xee, 0x1c, 0xb8, 0x87,
	0x0d, 0x6b, 0x9a, 0xe5, 0x21, 0xa3, 0x17, 0xd6, 0x0c, 0x9a, 0x77, 0xdc, 0xed, 0xd7, 0x47, 0xfb,
	0x56, 0x46, 0x9b, 0xf1, 0x57, 0x96, 0x95, 0x01, 0x9c, 0xda, 0xab, 0xdd, 0x03, 0xf2, 0x98, 0x3a,
	0x2f, 0xae, 0xad, 0x9c, 0xce, 0x4b, 0xae, 0xc3, 0x86, 0x95, 0x7f, 0xf4, 0x25, 0xe4, 0x93, 0x39,
	0xc4, 0x16, 0x60, 0xae, 0xe6, 0x0f, 0xb9, 0x27, 0xdb, 0x89, 0xc9, 0x9a, 0xd2, 0xb5, 0xec, 0xbf,
	0x76, 0xf6, 0x36, 0xeb, 0x96, 0xa1, 0xf9, 0xb7, 0x9c, 0xda, 0x01, 0x15, 0xb0, 0x57, 0x6b, 0x36,
	0xad, 0x99, 0x17, 0x2b, 0xbf, 0x5e, 0x2c, 0x1b, 0xbf, 0x5d, 0x2c, 0x1b, 0xbf, 0x5f, 0x2c, 0x1b,
	0x3f, 0xff, 0xb1, 0x3c, 0xb5, 0x6b, 0x7c, 0x53, 0x9a, 0xfc, 0x87, 0xe2, 0xd8, 0xc4, 0x3f, 0x1b,
	0x7f, 0x05, 0x00, 0x00, 0xff, 0xff, 0x9c, 0xc1, 0xf1, 0x29, 0x33, 0x0d, 0x00, 0x00,
}
