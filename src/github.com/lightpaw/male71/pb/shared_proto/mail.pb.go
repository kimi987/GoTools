// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/shared_proto/mail.proto
// DO NOT EDIT!

package shared_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type MailType int32

const (
	MailType_MailNormal              MailType = 0
	MailType_MailReport              MailType = 1
	MailType_MailRobFinished         MailType = 2
	MailType_MailInvestigation       MailType = 3
	MailType_MailBeenInvestigation   MailType = 4
	MailType_MailGuildCall           MailType = 5
	MailType_MailAssemblyReport      MailType = 6
	MailType_MailAssemblyRobFinished MailType = 7
)

var MailType_name = map[int32]string{
	0: "MailNormal",
	1: "MailReport",
	2: "MailRobFinished",
	3: "MailInvestigation",
	4: "MailBeenInvestigation",
	5: "MailGuildCall",
	6: "MailAssemblyReport",
	7: "MailAssemblyRobFinished",
}
var MailType_value = map[string]int32{
	"MailNormal":              0,
	"MailReport":              1,
	"MailRobFinished":         2,
	"MailInvestigation":       3,
	"MailBeenInvestigation":   4,
	"MailGuildCall":           5,
	"MailAssemblyReport":      6,
	"MailAssemblyRobFinished": 7,
}

func (x MailType) String() string {
	return proto.EnumName(MailType_name, int32(x))
}
func (MailType) EnumDescriptor() ([]byte, []int) { return fileDescriptorMail, []int{0} }

type MailProto struct {
	//    string id = 1; // 邮件id
	Id        []byte `protobuf:"bytes,23,opt,name=id,proto3" json:"id,omitempty"`
	Title     string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	SubTitle  string `protobuf:"bytes,4,opt,name=sub_title,json=subTitle,proto3" json:"sub_title,omitempty"`
	Text      string `protobuf:"bytes,3,opt,name=text,proto3" json:"text,omitempty"`
	SendTime  int32  `protobuf:"varint,5,opt,name=send_time,json=sendTime,proto3" json:"send_time,omitempty"`
	Icon      int32  `protobuf:"varint,7,opt,name=icon,proto3" json:"icon,omitempty"`
	Image     string `protobuf:"bytes,15,opt,name=image,proto3" json:"image,omitempty"`
	ImageWord int32  `protobuf:"varint,16,opt,name=image_word,json=imageWord,proto3" json:"image_word,omitempty"`
	// 下面这几个值，系统邮件有效
	SenderName      string            `protobuf:"bytes,12,opt,name=sender_name,json=senderName,proto3" json:"sender_name,omitempty"`
	GuildName       string            `protobuf:"bytes,13,opt,name=guild_name,json=guildName,proto3" json:"guild_name,omitempty"`
	GuildFlagName   string            `protobuf:"bytes,14,opt,name=guild_flag_name,json=guildFlagName,proto3" json:"guild_flag_name,omitempty"`
	Keep            bool              `protobuf:"varint,6,opt,name=keep,proto3" json:"keep,omitempty"`
	Read            bool              `protobuf:"varint,8,opt,name=read,proto3" json:"read,omitempty"`
	HasReport       bool              `protobuf:"varint,9,opt,name=has_report,json=hasReport,proto3" json:"has_report,omitempty"`
	HasPrize        bool              `protobuf:"varint,10,opt,name=has_prize,json=hasPrize,proto3" json:"has_prize,omitempty"`
	Collected       bool              `protobuf:"varint,11,opt,name=collected,proto3" json:"collected,omitempty"`
	ReportTag       int32             `protobuf:"varint,24,opt,name=report_tag,json=reportTag,proto3" json:"report_tag,omitempty"`
	MailType        MailType          `protobuf:"varint,20,opt,name=mail_type,json=mailType,proto3,enum=proto.MailType" json:"mail_type,omitempty"`
	Report          *FightReportProto `protobuf:"bytes,21,opt,name=report" json:"report,omitempty"`
	Prize           *PrizeProto       `protobuf:"bytes,22,opt,name=prize" json:"prize,omitempty"`
	GuildCallHeroId []byte            `protobuf:"bytes,25,opt,name=guild_call_hero_id,json=guildCallHeroId,proto3" json:"guild_call_hero_id,omitempty"`
	GuildCallPosX   int32             `protobuf:"varint,26,opt,name=guild_call_pos_x,json=guildCallPosX,proto3" json:"guild_call_pos_x,omitempty"`
	GuildCallPosY   int32             `protobuf:"varint,27,opt,name=guild_call_pos_y,json=guildCallPosY,proto3" json:"guild_call_pos_y,omitempty"`
}

func (m *MailProto) Reset()                    { *m = MailProto{} }
func (m *MailProto) String() string            { return proto.CompactTextString(m) }
func (*MailProto) ProtoMessage()               {}
func (*MailProto) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{0} }

func (m *MailProto) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *MailProto) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *MailProto) GetSubTitle() string {
	if m != nil {
		return m.SubTitle
	}
	return ""
}

func (m *MailProto) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *MailProto) GetSendTime() int32 {
	if m != nil {
		return m.SendTime
	}
	return 0
}

func (m *MailProto) GetIcon() int32 {
	if m != nil {
		return m.Icon
	}
	return 0
}

func (m *MailProto) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *MailProto) GetImageWord() int32 {
	if m != nil {
		return m.ImageWord
	}
	return 0
}

func (m *MailProto) GetSenderName() string {
	if m != nil {
		return m.SenderName
	}
	return ""
}

func (m *MailProto) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

func (m *MailProto) GetGuildFlagName() string {
	if m != nil {
		return m.GuildFlagName
	}
	return ""
}

func (m *MailProto) GetKeep() bool {
	if m != nil {
		return m.Keep
	}
	return false
}

func (m *MailProto) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *MailProto) GetHasReport() bool {
	if m != nil {
		return m.HasReport
	}
	return false
}

func (m *MailProto) GetHasPrize() bool {
	if m != nil {
		return m.HasPrize
	}
	return false
}

func (m *MailProto) GetCollected() bool {
	if m != nil {
		return m.Collected
	}
	return false
}

func (m *MailProto) GetReportTag() int32 {
	if m != nil {
		return m.ReportTag
	}
	return 0
}

func (m *MailProto) GetMailType() MailType {
	if m != nil {
		return m.MailType
	}
	return MailType_MailNormal
}

func (m *MailProto) GetReport() *FightReportProto {
	if m != nil {
		return m.Report
	}
	return nil
}

func (m *MailProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

func (m *MailProto) GetGuildCallHeroId() []byte {
	if m != nil {
		return m.GuildCallHeroId
	}
	return nil
}

func (m *MailProto) GetGuildCallPosX() int32 {
	if m != nil {
		return m.GuildCallPosX
	}
	return 0
}

func (m *MailProto) GetGuildCallPosY() int32 {
	if m != nil {
		return m.GuildCallPosY
	}
	return 0
}

type FightReportProto struct {
	ShowPrize *PrizeProto `protobuf:"bytes,6,opt,name=show_prize,json=showPrize" json:"show_prize,omitempty"`
	// 战斗发生的位置
	FightX              int32            `protobuf:"varint,8,opt,name=fight_x,json=fightX,proto3" json:"fight_x,omitempty"`
	FightY              int32            `protobuf:"varint,9,opt,name=fight_y,json=fightY,proto3" json:"fight_y,omitempty"`
	FightType           int32            `protobuf:"varint,21,opt,name=fight_type,json=fightType,proto3" json:"fight_type,omitempty"`
	FightTargetId       []byte           `protobuf:"bytes,22,opt,name=fight_target_id,json=fightTargetId,proto3" json:"fight_target_id,omitempty"`
	FightTargetName     string           `protobuf:"bytes,23,opt,name=fight_target_name,json=fightTargetName,proto3" json:"fight_target_name,omitempty"`
	FightTargetFlagName string           `protobuf:"bytes,24,opt,name=fight_target_flag_name,json=fightTargetFlagName,proto3" json:"fight_target_flag_name,omitempty"`
	AttackerWin         bool             `protobuf:"varint,10,opt,name=attacker_win,json=attackerWin,proto3" json:"attacker_win,omitempty"`
	Attacker            *ReportHeroProto `protobuf:"bytes,11,opt,name=attacker" json:"attacker,omitempty"`
	Defenser            *ReportHeroProto `protobuf:"bytes,12,opt,name=defenser" json:"defenser,omitempty"`
	AttackerDesc        string           `protobuf:"bytes,13,opt,name=attacker_desc,json=attackerDesc,proto3" json:"attacker_desc,omitempty"`
	DefenserDesc        string           `protobuf:"bytes,14,opt,name=defenser_desc,json=defenserDesc,proto3" json:"defenser_desc,omitempty"`
	Desc                string           `protobuf:"bytes,15,opt,name=desc,proto3" json:"desc,omitempty"`
	// 战报
	ReplayUrl      string            `protobuf:"bytes,41,opt,name=replay_url,json=replayUrl,proto3" json:"replay_url,omitempty"`
	AttackerSide   bool              `protobuf:"varint,42,opt,name=attacker_side,json=attackerSide,proto3" json:"attacker_side,omitempty"`
	Share          *CombatShareProto `protobuf:"bytes,43,opt,name=share" json:"share,omitempty"`
	Score          int32             `protobuf:"varint,44,opt,name=score,proto3" json:"score,omitempty"`
	RobDuration    int32             `protobuf:"varint,51,opt,name=rob_duration,json=robDuration,proto3" json:"rob_duration,omitempty"`
	DoneDesc       string            `protobuf:"bytes,52,opt,name=done_desc,json=doneDesc,proto3" json:"done_desc,omitempty"`
	DoneDescAmount int32             `protobuf:"varint,53,opt,name=done_desc_amount,json=doneDescAmount,proto3" json:"done_desc_amount,omitempty"`
	// 集结战斗
	FightHero               []*ReportHeroProto    `protobuf:"bytes,60,rep,name=fight_hero,json=fightHero" json:"fight_hero,omitempty"`
	Fight                   []*AssemblyFightProto `protobuf:"bytes,61,rep,name=fight" json:"fight,omitempty"`
	AttackerTroopCount      int32                 `protobuf:"varint,62,opt,name=attacker_troop_count,json=attackerTroopCount,proto3" json:"attacker_troop_count,omitempty"`
	DefenserTroopCount      int32                 `protobuf:"varint,63,opt,name=defenser_troop_count,json=defenserTroopCount,proto3" json:"defenser_troop_count,omitempty"`
	AttackerTroopTotalCount int32                 `protobuf:"varint,64,opt,name=attacker_troop_total_count,json=attackerTroopTotalCount,proto3" json:"attacker_troop_total_count,omitempty"`
	DefenserTroopTotalCount int32                 `protobuf:"varint,65,opt,name=defenser_troop_total_count,json=defenserTroopTotalCount,proto3" json:"defenser_troop_total_count,omitempty"`
	AttackerTroopWinTimes   int32                 `protobuf:"varint,66,opt,name=attacker_troop_win_times,json=attackerTroopWinTimes,proto3" json:"attacker_troop_win_times,omitempty"`
	DefenserTroopWinTimes   int32                 `protobuf:"varint,67,opt,name=defenser_troop_win_times,json=defenserTroopWinTimes,proto3" json:"defenser_troop_win_times,omitempty"`
	MultiLevelMonsterCount  int32                 `protobuf:"varint,68,opt,name=multi_level_monster_count,json=multiLevelMonsterCount,proto3" json:"multi_level_monster_count,omitempty"`
}

func (m *FightReportProto) Reset()                    { *m = FightReportProto{} }
func (m *FightReportProto) String() string            { return proto.CompactTextString(m) }
func (*FightReportProto) ProtoMessage()               {}
func (*FightReportProto) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{1} }

func (m *FightReportProto) GetShowPrize() *PrizeProto {
	if m != nil {
		return m.ShowPrize
	}
	return nil
}

func (m *FightReportProto) GetFightX() int32 {
	if m != nil {
		return m.FightX
	}
	return 0
}

func (m *FightReportProto) GetFightY() int32 {
	if m != nil {
		return m.FightY
	}
	return 0
}

func (m *FightReportProto) GetFightType() int32 {
	if m != nil {
		return m.FightType
	}
	return 0
}

func (m *FightReportProto) GetFightTargetId() []byte {
	if m != nil {
		return m.FightTargetId
	}
	return nil
}

func (m *FightReportProto) GetFightTargetName() string {
	if m != nil {
		return m.FightTargetName
	}
	return ""
}

func (m *FightReportProto) GetFightTargetFlagName() string {
	if m != nil {
		return m.FightTargetFlagName
	}
	return ""
}

func (m *FightReportProto) GetAttackerWin() bool {
	if m != nil {
		return m.AttackerWin
	}
	return false
}

func (m *FightReportProto) GetAttacker() *ReportHeroProto {
	if m != nil {
		return m.Attacker
	}
	return nil
}

func (m *FightReportProto) GetDefenser() *ReportHeroProto {
	if m != nil {
		return m.Defenser
	}
	return nil
}

func (m *FightReportProto) GetAttackerDesc() string {
	if m != nil {
		return m.AttackerDesc
	}
	return ""
}

func (m *FightReportProto) GetDefenserDesc() string {
	if m != nil {
		return m.DefenserDesc
	}
	return ""
}

func (m *FightReportProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *FightReportProto) GetReplayUrl() string {
	if m != nil {
		return m.ReplayUrl
	}
	return ""
}

func (m *FightReportProto) GetAttackerSide() bool {
	if m != nil {
		return m.AttackerSide
	}
	return false
}

func (m *FightReportProto) GetShare() *CombatShareProto {
	if m != nil {
		return m.Share
	}
	return nil
}

func (m *FightReportProto) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *FightReportProto) GetRobDuration() int32 {
	if m != nil {
		return m.RobDuration
	}
	return 0
}

func (m *FightReportProto) GetDoneDesc() string {
	if m != nil {
		return m.DoneDesc
	}
	return ""
}

func (m *FightReportProto) GetDoneDescAmount() int32 {
	if m != nil {
		return m.DoneDescAmount
	}
	return 0
}

func (m *FightReportProto) GetFightHero() []*ReportHeroProto {
	if m != nil {
		return m.FightHero
	}
	return nil
}

func (m *FightReportProto) GetFight() []*AssemblyFightProto {
	if m != nil {
		return m.Fight
	}
	return nil
}

func (m *FightReportProto) GetAttackerTroopCount() int32 {
	if m != nil {
		return m.AttackerTroopCount
	}
	return 0
}

func (m *FightReportProto) GetDefenserTroopCount() int32 {
	if m != nil {
		return m.DefenserTroopCount
	}
	return 0
}

func (m *FightReportProto) GetAttackerTroopTotalCount() int32 {
	if m != nil {
		return m.AttackerTroopTotalCount
	}
	return 0
}

func (m *FightReportProto) GetDefenserTroopTotalCount() int32 {
	if m != nil {
		return m.DefenserTroopTotalCount
	}
	return 0
}

func (m *FightReportProto) GetAttackerTroopWinTimes() int32 {
	if m != nil {
		return m.AttackerTroopWinTimes
	}
	return 0
}

func (m *FightReportProto) GetDefenserTroopWinTimes() int32 {
	if m != nil {
		return m.DefenserTroopWinTimes
	}
	return 0
}

func (m *FightReportProto) GetMultiLevelMonsterCount() int32 {
	if m != nil {
		return m.MultiLevelMonsterCount
	}
	return 0
}

type AssemblyFightProto struct {
	AttackerId           []byte           `protobuf:"bytes,1,opt,name=attacker_id,json=attackerId,proto3" json:"attacker_id,omitempty"`
	DefenserId           []byte           `protobuf:"bytes,2,opt,name=defenser_id,json=defenserId,proto3" json:"defenser_id,omitempty"`
	AttackerFightAmount  int32            `protobuf:"varint,3,opt,name=attacker_fight_amount,json=attackerFightAmount,proto3" json:"attacker_fight_amount,omitempty"`
	DefenserFightAmount  int32            `protobuf:"varint,4,opt,name=defenser_fight_amount,json=defenserFightAmount,proto3" json:"defenser_fight_amount,omitempty"`
	AttackerAliveSoldier int32            `protobuf:"varint,14,opt,name=attacker_alive_soldier,json=attackerAliveSoldier,proto3" json:"attacker_alive_soldier,omitempty"`
	DefenserAliveSoldier int32            `protobuf:"varint,15,opt,name=defenser_alive_soldier,json=defenserAliveSoldier,proto3" json:"defenser_alive_soldier,omitempty"`
	AttackerTotalSoldier int32            `protobuf:"varint,16,opt,name=attacker_total_soldier,json=attackerTotalSoldier,proto3" json:"attacker_total_soldier,omitempty"`
	DefenserTotalSoldier int32            `protobuf:"varint,17,opt,name=defenser_total_soldier,json=defenserTotalSoldier,proto3" json:"defenser_total_soldier,omitempty"`
	AttackerWin          bool             `protobuf:"varint,10,opt,name=attacker_win,json=attackerWin,proto3" json:"attacker_win,omitempty"`
	Attacker             *ReportHeroProto `protobuf:"bytes,11,opt,name=attacker" json:"attacker,omitempty"`
	Defenser             *ReportHeroProto `protobuf:"bytes,12,opt,name=defenser" json:"defenser,omitempty"`
	WinTimes             int32            `protobuf:"varint,13,opt,name=win_times,json=winTimes,proto3" json:"win_times,omitempty"`
	// 战报
	Share     *CombatShareProto `protobuf:"bytes,43,opt,name=share" json:"share,omitempty"`
	ShowPrize *PrizeProto       `protobuf:"bytes,6,opt,name=show_prize,json=showPrize" json:"show_prize,omitempty"`
}

func (m *AssemblyFightProto) Reset()                    { *m = AssemblyFightProto{} }
func (m *AssemblyFightProto) String() string            { return proto.CompactTextString(m) }
func (*AssemblyFightProto) ProtoMessage()               {}
func (*AssemblyFightProto) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{2} }

func (m *AssemblyFightProto) GetAttackerId() []byte {
	if m != nil {
		return m.AttackerId
	}
	return nil
}

func (m *AssemblyFightProto) GetDefenserId() []byte {
	if m != nil {
		return m.DefenserId
	}
	return nil
}

func (m *AssemblyFightProto) GetAttackerFightAmount() int32 {
	if m != nil {
		return m.AttackerFightAmount
	}
	return 0
}

func (m *AssemblyFightProto) GetDefenserFightAmount() int32 {
	if m != nil {
		return m.DefenserFightAmount
	}
	return 0
}

func (m *AssemblyFightProto) GetAttackerAliveSoldier() int32 {
	if m != nil {
		return m.AttackerAliveSoldier
	}
	return 0
}

func (m *AssemblyFightProto) GetDefenserAliveSoldier() int32 {
	if m != nil {
		return m.DefenserAliveSoldier
	}
	return 0
}

func (m *AssemblyFightProto) GetAttackerTotalSoldier() int32 {
	if m != nil {
		return m.AttackerTotalSoldier
	}
	return 0
}

func (m *AssemblyFightProto) GetDefenserTotalSoldier() int32 {
	if m != nil {
		return m.DefenserTotalSoldier
	}
	return 0
}

func (m *AssemblyFightProto) GetAttackerWin() bool {
	if m != nil {
		return m.AttackerWin
	}
	return false
}

func (m *AssemblyFightProto) GetAttacker() *ReportHeroProto {
	if m != nil {
		return m.Attacker
	}
	return nil
}

func (m *AssemblyFightProto) GetDefenser() *ReportHeroProto {
	if m != nil {
		return m.Defenser
	}
	return nil
}

func (m *AssemblyFightProto) GetWinTimes() int32 {
	if m != nil {
		return m.WinTimes
	}
	return 0
}

func (m *AssemblyFightProto) GetShare() *CombatShareProto {
	if m != nil {
		return m.Share
	}
	return nil
}

func (m *AssemblyFightProto) GetShowPrize() *PrizeProto {
	if m != nil {
		return m.ShowPrize
	}
	return nil
}

type ReportHeroProto struct {
	Id                []byte                `protobuf:"bytes,11,opt,name=id,proto3" json:"id,omitempty"`
	Name              string                `protobuf:"bytes,12,opt,name=name,proto3" json:"name,omitempty"`
	Level             int32                 `protobuf:"varint,10,opt,name=level,proto3" json:"level,omitempty"`
	Head              string                `protobuf:"bytes,13,opt,name=head,proto3" json:"head,omitempty"`
	BaseRegion        int32                 `protobuf:"varint,19,opt,name=base_region,json=baseRegion,proto3" json:"base_region,omitempty"`
	GuildFlagName     string                `protobuf:"bytes,20,opt,name=guild_flag_name,json=guildFlagName,proto3" json:"guild_flag_name,omitempty"`
	BaseX             int32                 `protobuf:"varint,14,opt,name=base_x,json=baseX,proto3" json:"base_x,omitempty"`
	BaseY             int32                 `protobuf:"varint,15,opt,name=base_y,json=baseY,proto3" json:"base_y,omitempty"`
	AliveSoldier      int32                 `protobuf:"varint,16,opt,name=alive_soldier,json=aliveSoldier,proto3" json:"alive_soldier,omitempty"`
	TotalSoldier      int32                 `protobuf:"varint,17,opt,name=total_soldier,json=totalSoldier,proto3" json:"total_soldier,omitempty"`
	IsTent            bool                  `protobuf:"varint,18,opt,name=is_tent,json=isTent,proto3" json:"is_tent,omitempty"`
	TotalFightAmount  int32                 `protobuf:"varint,22,opt,name=total_fight_amount,json=totalFightAmount,proto3" json:"total_fight_amount,omitempty"`
	Country           int32                 `protobuf:"varint,24,opt,name=country,proto3" json:"country,omitempty"`
	Captains          []*ReportCaptainProto `protobuf:"bytes,21,rep,name=captains" json:"captains,omitempty"`
	Race              []Race                `protobuf:"varint,23,rep,name=race,enum=proto.Race" json:"race,omitempty"`
	WallLevel         int32                 `protobuf:"varint,31,opt,name=wall_level,json=wallLevel,proto3" json:"wall_level,omitempty"`
	WallCombatSoldier int32                 `protobuf:"varint,32,opt,name=wall_combat_soldier,json=wallCombatSoldier,proto3" json:"wall_combat_soldier,omitempty"`
	WallAliveSoldier  int32                 `protobuf:"varint,33,opt,name=wall_alive_soldier,json=wallAliveSoldier,proto3" json:"wall_alive_soldier,omitempty"`
	WallKillSoldier   int32                 `protobuf:"varint,34,opt,name=wall_kill_soldier,json=wallKillSoldier,proto3" json:"wall_kill_soldier,omitempty"`
	BaseLevel         int32                 `protobuf:"varint,35,opt,name=base_level,json=baseLevel,proto3" json:"base_level,omitempty"`
	Prosperity        int32                 `protobuf:"varint,36,opt,name=prosperity,proto3" json:"prosperity,omitempty"`
	ProsperityCapcity int32                 `protobuf:"varint,37,opt,name=prosperity_capcity,json=prosperityCapcity,proto3" json:"prosperity_capcity,omitempty"`
	IsCopy            bool                  `protobuf:"varint,38,opt,name=is_copy,json=isCopy,proto3" json:"is_copy,omitempty"`
}

func (m *ReportHeroProto) Reset()                    { *m = ReportHeroProto{} }
func (m *ReportHeroProto) String() string            { return proto.CompactTextString(m) }
func (*ReportHeroProto) ProtoMessage()               {}
func (*ReportHeroProto) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{3} }

func (m *ReportHeroProto) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ReportHeroProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ReportHeroProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *ReportHeroProto) GetHead() string {
	if m != nil {
		return m.Head
	}
	return ""
}

func (m *ReportHeroProto) GetBaseRegion() int32 {
	if m != nil {
		return m.BaseRegion
	}
	return 0
}

func (m *ReportHeroProto) GetGuildFlagName() string {
	if m != nil {
		return m.GuildFlagName
	}
	return ""
}

func (m *ReportHeroProto) GetBaseX() int32 {
	if m != nil {
		return m.BaseX
	}
	return 0
}

func (m *ReportHeroProto) GetBaseY() int32 {
	if m != nil {
		return m.BaseY
	}
	return 0
}

func (m *ReportHeroProto) GetAliveSoldier() int32 {
	if m != nil {
		return m.AliveSoldier
	}
	return 0
}

func (m *ReportHeroProto) GetTotalSoldier() int32 {
	if m != nil {
		return m.TotalSoldier
	}
	return 0
}

func (m *ReportHeroProto) GetIsTent() bool {
	if m != nil {
		return m.IsTent
	}
	return false
}

func (m *ReportHeroProto) GetTotalFightAmount() int32 {
	if m != nil {
		return m.TotalFightAmount
	}
	return 0
}

func (m *ReportHeroProto) GetCountry() int32 {
	if m != nil {
		return m.Country
	}
	return 0
}

func (m *ReportHeroProto) GetCaptains() []*ReportCaptainProto {
	if m != nil {
		return m.Captains
	}
	return nil
}

func (m *ReportHeroProto) GetRace() []Race {
	if m != nil {
		return m.Race
	}
	return nil
}

func (m *ReportHeroProto) GetWallLevel() int32 {
	if m != nil {
		return m.WallLevel
	}
	return 0
}

func (m *ReportHeroProto) GetWallCombatSoldier() int32 {
	if m != nil {
		return m.WallCombatSoldier
	}
	return 0
}

func (m *ReportHeroProto) GetWallAliveSoldier() int32 {
	if m != nil {
		return m.WallAliveSoldier
	}
	return 0
}

func (m *ReportHeroProto) GetWallKillSoldier() int32 {
	if m != nil {
		return m.WallKillSoldier
	}
	return 0
}

func (m *ReportHeroProto) GetBaseLevel() int32 {
	if m != nil {
		return m.BaseLevel
	}
	return 0
}

func (m *ReportHeroProto) GetProsperity() int32 {
	if m != nil {
		return m.Prosperity
	}
	return 0
}

func (m *ReportHeroProto) GetProsperityCapcity() int32 {
	if m != nil {
		return m.ProsperityCapcity
	}
	return 0
}

func (m *ReportHeroProto) GetIsCopy() bool {
	if m != nil {
		return m.IsCopy
	}
	return false
}

type ReportCaptainProto struct {
	Index         int32             `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Captain       *CaptainInfoProto `protobuf:"bytes,2,opt,name=captain" json:"captain,omitempty"`
	CombatSoldier int32             `protobuf:"varint,3,opt,name=combat_soldier,json=combatSoldier,proto3" json:"combat_soldier,omitempty"`
	AliveSoldier  int32             `protobuf:"varint,4,opt,name=alive_soldier,json=aliveSoldier,proto3" json:"alive_soldier,omitempty"`
	KillSoldier   int32             `protobuf:"varint,6,opt,name=kill_soldier,json=killSoldier,proto3" json:"kill_soldier,omitempty"`
	FightAmount   int32             `protobuf:"varint,5,opt,name=fight_amount,json=fightAmount,proto3" json:"fight_amount,omitempty"`
}

func (m *ReportCaptainProto) Reset()                    { *m = ReportCaptainProto{} }
func (m *ReportCaptainProto) String() string            { return proto.CompactTextString(m) }
func (*ReportCaptainProto) ProtoMessage()               {}
func (*ReportCaptainProto) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{4} }

func (m *ReportCaptainProto) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *ReportCaptainProto) GetCaptain() *CaptainInfoProto {
	if m != nil {
		return m.Captain
	}
	return nil
}

func (m *ReportCaptainProto) GetCombatSoldier() int32 {
	if m != nil {
		return m.CombatSoldier
	}
	return 0
}

func (m *ReportCaptainProto) GetAliveSoldier() int32 {
	if m != nil {
		return m.AliveSoldier
	}
	return 0
}

func (m *ReportCaptainProto) GetKillSoldier() int32 {
	if m != nil {
		return m.KillSoldier
	}
	return 0
}

func (m *ReportCaptainProto) GetFightAmount() int32 {
	if m != nil {
		return m.FightAmount
	}
	return 0
}

func init() {
	proto.RegisterType((*MailProto)(nil), "proto.MailProto")
	proto.RegisterType((*FightReportProto)(nil), "proto.FightReportProto")
	proto.RegisterType((*AssemblyFightProto)(nil), "proto.AssemblyFightProto")
	proto.RegisterType((*ReportHeroProto)(nil), "proto.ReportHeroProto")
	proto.RegisterType((*ReportCaptainProto)(nil), "proto.ReportCaptainProto")
	proto.RegisterEnum("proto.MailType", MailType_name, MailType_value)
}
func (m *MailProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if len(m.SubTitle) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.SubTitle)))
		i += copy(dAtA[i:], m.SubTitle)
	}
	if m.SendTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.SendTime))
	}
	if m.Keep {
		dAtA[i] = 0x30
		i++
		if m.Keep {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Icon != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Icon))
	}
	if m.Read {
		dAtA[i] = 0x40
		i++
		if m.Read {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HasReport {
		dAtA[i] = 0x48
		i++
		if m.HasReport {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HasPrize {
		dAtA[i] = 0x50
		i++
		if m.HasPrize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Collected {
		dAtA[i] = 0x58
		i++
		if m.Collected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.SenderName) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.SenderName)))
		i += copy(dAtA[i:], m.SenderName)
	}
	if len(m.GuildName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.GuildName)))
		i += copy(dAtA[i:], m.GuildName)
	}
	if len(m.GuildFlagName) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.GuildFlagName)))
		i += copy(dAtA[i:], m.GuildFlagName)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if m.ImageWord != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.ImageWord))
	}
	if m.MailType != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.MailType))
	}
	if m.Report != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Report.Size()))
		n1, err := m.Report.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Prize != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Prize.Size()))
		n2, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.ReportTag != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.ReportTag))
	}
	if len(m.GuildCallHeroId) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.GuildCallHeroId)))
		i += copy(dAtA[i:], m.GuildCallHeroId)
	}
	if m.GuildCallPosX != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.GuildCallPosX))
	}
	if m.GuildCallPosY != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.GuildCallPosY))
	}
	return i, nil
}

func (m *FightReportProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightReportProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShowPrize != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.ShowPrize.Size()))
		n3, err := m.ShowPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.FightX != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.FightX))
	}
	if m.FightY != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.FightY))
	}
	if m.AttackerWin {
		dAtA[i] = 0x50
		i++
		if m.AttackerWin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Attacker != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Attacker.Size()))
		n4, err := m.Attacker.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Defenser != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Defenser.Size()))
		n5, err := m.Defenser.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.AttackerDesc) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.AttackerDesc)))
		i += copy(dAtA[i:], m.AttackerDesc)
	}
	if len(m.DefenserDesc) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.DefenserDesc)))
		i += copy(dAtA[i:], m.DefenserDesc)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.FightType != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.FightType))
	}
	if len(m.FightTargetId) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.FightTargetId)))
		i += copy(dAtA[i:], m.FightTargetId)
	}
	if len(m.FightTargetName) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.FightTargetName)))
		i += copy(dAtA[i:], m.FightTargetName)
	}
	if len(m.FightTargetFlagName) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.FightTargetFlagName)))
		i += copy(dAtA[i:], m.FightTargetFlagName)
	}
	if len(m.ReplayUrl) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.ReplayUrl)))
		i += copy(dAtA[i:], m.ReplayUrl)
	}
	if m.AttackerSide {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		if m.AttackerSide {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Share != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Share.Size()))
		n6, err := m.Share.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Score != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Score))
	}
	if m.RobDuration != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.RobDuration))
	}
	if len(m.DoneDesc) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.DoneDesc)))
		i += copy(dAtA[i:], m.DoneDesc)
	}
	if m.DoneDescAmount != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.DoneDescAmount))
	}
	if len(m.FightHero) > 0 {
		for _, msg := range m.FightHero {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintMail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Fight) > 0 {
		for _, msg := range m.Fight {
			dAtA[i] = 0xea
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintMail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AttackerTroopCount != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.AttackerTroopCount))
	}
	if m.DefenserTroopCount != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.DefenserTroopCount))
	}
	if m.AttackerTroopTotalCount != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.AttackerTroopTotalCount))
	}
	if m.DefenserTroopTotalCount != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.DefenserTroopTotalCount))
	}
	if m.AttackerTroopWinTimes != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.AttackerTroopWinTimes))
	}
	if m.DefenserTroopWinTimes != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.DefenserTroopWinTimes))
	}
	if m.MultiLevelMonsterCount != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.MultiLevelMonsterCount))
	}
	return i, nil
}

func (m *AssemblyFightProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssemblyFightProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AttackerId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.AttackerId)))
		i += copy(dAtA[i:], m.AttackerId)
	}
	if len(m.DefenserId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.DefenserId)))
		i += copy(dAtA[i:], m.DefenserId)
	}
	if m.AttackerFightAmount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.AttackerFightAmount))
	}
	if m.DefenserFightAmount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.DefenserFightAmount))
	}
	if m.ShowPrize != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.ShowPrize.Size()))
		n7, err := m.ShowPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.AttackerWin {
		dAtA[i] = 0x50
		i++
		if m.AttackerWin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Attacker != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Attacker.Size()))
		n8, err := m.Attacker.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Defenser != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Defenser.Size()))
		n9, err := m.Defenser.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.WinTimes != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.WinTimes))
	}
	if m.AttackerAliveSoldier != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.AttackerAliveSoldier))
	}
	if m.DefenserAliveSoldier != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.DefenserAliveSoldier))
	}
	if m.AttackerTotalSoldier != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.AttackerTotalSoldier))
	}
	if m.DefenserTotalSoldier != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.DefenserTotalSoldier))
	}
	if m.Share != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Share.Size()))
		n10, err := m.Share.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *ReportHeroProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportHeroProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Level))
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Head) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Head)))
		i += copy(dAtA[i:], m.Head)
	}
	if m.BaseX != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.BaseX))
	}
	if m.BaseY != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.BaseY))
	}
	if m.AliveSoldier != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.AliveSoldier))
	}
	if m.TotalSoldier != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.TotalSoldier))
	}
	if m.IsTent {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.IsTent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BaseRegion != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.BaseRegion))
	}
	if len(m.GuildFlagName) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.GuildFlagName)))
		i += copy(dAtA[i:], m.GuildFlagName)
	}
	if len(m.Captains) > 0 {
		for _, msg := range m.Captains {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TotalFightAmount != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.TotalFightAmount))
	}
	if len(m.Race) > 0 {
		for _, num := range m.Race {
			dAtA[i] = 0xb8
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMail(dAtA, i, uint64(num))
		}
	}
	if m.Country != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Country))
	}
	if m.WallLevel != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.WallLevel))
	}
	if m.WallCombatSoldier != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.WallCombatSoldier))
	}
	if m.WallAliveSoldier != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.WallAliveSoldier))
	}
	if m.WallKillSoldier != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.WallKillSoldier))
	}
	if m.BaseLevel != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.BaseLevel))
	}
	if m.Prosperity != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Prosperity))
	}
	if m.ProsperityCapcity != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.ProsperityCapcity))
	}
	if m.IsCopy {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		if m.IsCopy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ReportCaptainProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportCaptainProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Index))
	}
	if m.Captain != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Captain.Size()))
		n11, err := m.Captain.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.CombatSoldier != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.CombatSoldier))
	}
	if m.AliveSoldier != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.AliveSoldier))
	}
	if m.FightAmount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.FightAmount))
	}
	if m.KillSoldier != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.KillSoldier))
	}
	return i, nil
}

func encodeFixed64Mail(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Mail(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMail(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MailProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.SubTitle)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.SendTime != 0 {
		n += 1 + sovMail(uint64(m.SendTime))
	}
	if m.Keep {
		n += 2
	}
	if m.Icon != 0 {
		n += 1 + sovMail(uint64(m.Icon))
	}
	if m.Read {
		n += 2
	}
	if m.HasReport {
		n += 2
	}
	if m.HasPrize {
		n += 2
	}
	if m.Collected {
		n += 2
	}
	l = len(m.SenderName)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.GuildFlagName)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.ImageWord != 0 {
		n += 2 + sovMail(uint64(m.ImageWord))
	}
	if m.MailType != 0 {
		n += 2 + sovMail(uint64(m.MailType))
	}
	if m.Report != nil {
		l = m.Report.Size()
		n += 2 + l + sovMail(uint64(l))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 2 + l + sovMail(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 2 + l + sovMail(uint64(l))
	}
	if m.ReportTag != 0 {
		n += 2 + sovMail(uint64(m.ReportTag))
	}
	l = len(m.GuildCallHeroId)
	if l > 0 {
		n += 2 + l + sovMail(uint64(l))
	}
	if m.GuildCallPosX != 0 {
		n += 2 + sovMail(uint64(m.GuildCallPosX))
	}
	if m.GuildCallPosY != 0 {
		n += 2 + sovMail(uint64(m.GuildCallPosY))
	}
	return n
}

func (m *FightReportProto) Size() (n int) {
	var l int
	_ = l
	if m.ShowPrize != nil {
		l = m.ShowPrize.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.FightX != 0 {
		n += 1 + sovMail(uint64(m.FightX))
	}
	if m.FightY != 0 {
		n += 1 + sovMail(uint64(m.FightY))
	}
	if m.AttackerWin {
		n += 2
	}
	if m.Attacker != nil {
		l = m.Attacker.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Defenser != nil {
		l = m.Defenser.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.AttackerDesc)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.DefenserDesc)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.FightType != 0 {
		n += 2 + sovMail(uint64(m.FightType))
	}
	l = len(m.FightTargetId)
	if l > 0 {
		n += 2 + l + sovMail(uint64(l))
	}
	l = len(m.FightTargetName)
	if l > 0 {
		n += 2 + l + sovMail(uint64(l))
	}
	l = len(m.FightTargetFlagName)
	if l > 0 {
		n += 2 + l + sovMail(uint64(l))
	}
	l = len(m.ReplayUrl)
	if l > 0 {
		n += 2 + l + sovMail(uint64(l))
	}
	if m.AttackerSide {
		n += 3
	}
	if m.Share != nil {
		l = m.Share.Size()
		n += 2 + l + sovMail(uint64(l))
	}
	if m.Score != 0 {
		n += 2 + sovMail(uint64(m.Score))
	}
	if m.RobDuration != 0 {
		n += 2 + sovMail(uint64(m.RobDuration))
	}
	l = len(m.DoneDesc)
	if l > 0 {
		n += 2 + l + sovMail(uint64(l))
	}
	if m.DoneDescAmount != 0 {
		n += 2 + sovMail(uint64(m.DoneDescAmount))
	}
	if len(m.FightHero) > 0 {
		for _, e := range m.FightHero {
			l = e.Size()
			n += 2 + l + sovMail(uint64(l))
		}
	}
	if len(m.Fight) > 0 {
		for _, e := range m.Fight {
			l = e.Size()
			n += 2 + l + sovMail(uint64(l))
		}
	}
	if m.AttackerTroopCount != 0 {
		n += 2 + sovMail(uint64(m.AttackerTroopCount))
	}
	if m.DefenserTroopCount != 0 {
		n += 2 + sovMail(uint64(m.DefenserTroopCount))
	}
	if m.AttackerTroopTotalCount != 0 {
		n += 2 + sovMail(uint64(m.AttackerTroopTotalCount))
	}
	if m.DefenserTroopTotalCount != 0 {
		n += 2 + sovMail(uint64(m.DefenserTroopTotalCount))
	}
	if m.AttackerTroopWinTimes != 0 {
		n += 2 + sovMail(uint64(m.AttackerTroopWinTimes))
	}
	if m.DefenserTroopWinTimes != 0 {
		n += 2 + sovMail(uint64(m.DefenserTroopWinTimes))
	}
	if m.MultiLevelMonsterCount != 0 {
		n += 2 + sovMail(uint64(m.MultiLevelMonsterCount))
	}
	return n
}

func (m *AssemblyFightProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.AttackerId)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.DefenserId)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.AttackerFightAmount != 0 {
		n += 1 + sovMail(uint64(m.AttackerFightAmount))
	}
	if m.DefenserFightAmount != 0 {
		n += 1 + sovMail(uint64(m.DefenserFightAmount))
	}
	if m.ShowPrize != nil {
		l = m.ShowPrize.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.AttackerWin {
		n += 2
	}
	if m.Attacker != nil {
		l = m.Attacker.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Defenser != nil {
		l = m.Defenser.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.WinTimes != 0 {
		n += 1 + sovMail(uint64(m.WinTimes))
	}
	if m.AttackerAliveSoldier != 0 {
		n += 1 + sovMail(uint64(m.AttackerAliveSoldier))
	}
	if m.DefenserAliveSoldier != 0 {
		n += 1 + sovMail(uint64(m.DefenserAliveSoldier))
	}
	if m.AttackerTotalSoldier != 0 {
		n += 2 + sovMail(uint64(m.AttackerTotalSoldier))
	}
	if m.DefenserTotalSoldier != 0 {
		n += 2 + sovMail(uint64(m.DefenserTotalSoldier))
	}
	if m.Share != nil {
		l = m.Share.Size()
		n += 2 + l + sovMail(uint64(l))
	}
	return n
}

func (m *ReportHeroProto) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovMail(uint64(m.Level))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.BaseX != 0 {
		n += 1 + sovMail(uint64(m.BaseX))
	}
	if m.BaseY != 0 {
		n += 1 + sovMail(uint64(m.BaseY))
	}
	if m.AliveSoldier != 0 {
		n += 2 + sovMail(uint64(m.AliveSoldier))
	}
	if m.TotalSoldier != 0 {
		n += 2 + sovMail(uint64(m.TotalSoldier))
	}
	if m.IsTent {
		n += 3
	}
	if m.BaseRegion != 0 {
		n += 2 + sovMail(uint64(m.BaseRegion))
	}
	l = len(m.GuildFlagName)
	if l > 0 {
		n += 2 + l + sovMail(uint64(l))
	}
	if len(m.Captains) > 0 {
		for _, e := range m.Captains {
			l = e.Size()
			n += 2 + l + sovMail(uint64(l))
		}
	}
	if m.TotalFightAmount != 0 {
		n += 2 + sovMail(uint64(m.TotalFightAmount))
	}
	if len(m.Race) > 0 {
		for _, e := range m.Race {
			n += 2 + sovMail(uint64(e))
		}
	}
	if m.Country != 0 {
		n += 2 + sovMail(uint64(m.Country))
	}
	if m.WallLevel != 0 {
		n += 2 + sovMail(uint64(m.WallLevel))
	}
	if m.WallCombatSoldier != 0 {
		n += 2 + sovMail(uint64(m.WallCombatSoldier))
	}
	if m.WallAliveSoldier != 0 {
		n += 2 + sovMail(uint64(m.WallAliveSoldier))
	}
	if m.WallKillSoldier != 0 {
		n += 2 + sovMail(uint64(m.WallKillSoldier))
	}
	if m.BaseLevel != 0 {
		n += 2 + sovMail(uint64(m.BaseLevel))
	}
	if m.Prosperity != 0 {
		n += 2 + sovMail(uint64(m.Prosperity))
	}
	if m.ProsperityCapcity != 0 {
		n += 2 + sovMail(uint64(m.ProsperityCapcity))
	}
	if m.IsCopy {
		n += 3
	}
	return n
}

func (m *ReportCaptainProto) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovMail(uint64(m.Index))
	}
	if m.Captain != nil {
		l = m.Captain.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.CombatSoldier != 0 {
		n += 1 + sovMail(uint64(m.CombatSoldier))
	}
	if m.AliveSoldier != 0 {
		n += 1 + sovMail(uint64(m.AliveSoldier))
	}
	if m.FightAmount != 0 {
		n += 1 + sovMail(uint64(m.FightAmount))
	}
	if m.KillSoldier != 0 {
		n += 1 + sovMail(uint64(m.KillSoldier))
	}
	return n
}

func sovMail(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMail(x uint64) (n int) {
	return sovMail(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MailProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendTime", wireType)
			}
			m.SendTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keep", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Keep = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			m.Icon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Icon |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Read", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Read = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasReport", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasReport = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasPrize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasPrize = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Collected = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildFlagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildFlagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageWord", wireType)
			}
			m.ImageWord = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImageWord |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailType", wireType)
			}
			m.MailType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MailType |= (MailType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Report == nil {
				m.Report = &FightReportProto{}
			}
			if err := m.Report.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportTag", wireType)
			}
			m.ReportTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReportTag |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildCallHeroId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildCallHeroId = append(m.GuildCallHeroId[:0], dAtA[iNdEx:postIndex]...)
			if m.GuildCallHeroId == nil {
				m.GuildCallHeroId = []byte{}
			}
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildCallPosX", wireType)
			}
			m.GuildCallPosX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildCallPosX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildCallPosY", wireType)
			}
			m.GuildCallPosY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildCallPosY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightReportProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightReportProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightReportProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowPrize == nil {
				m.ShowPrize = &PrizeProto{}
			}
			if err := m.ShowPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightX", wireType)
			}
			m.FightX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightY", wireType)
			}
			m.FightY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerWin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttackerWin = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attacker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attacker == nil {
				m.Attacker = &ReportHeroProto{}
			}
			if err := m.Attacker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defenser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Defenser == nil {
				m.Defenser = &ReportHeroProto{}
			}
			if err := m.Defenser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttackerDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefenserDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightType", wireType)
			}
			m.FightType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightTargetId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FightTargetId = append(m.FightTargetId[:0], dAtA[iNdEx:postIndex]...)
			if m.FightTargetId == nil {
				m.FightTargetId = []byte{}
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightTargetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FightTargetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightTargetFlagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FightTargetFlagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplayUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplayUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerSide", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttackerSide = bool(v != 0)
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Share == nil {
				m.Share = &CombatShareProto{}
			}
			if err := m.Share.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobDuration", wireType)
			}
			m.RobDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoneDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoneDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoneDescAmount", wireType)
			}
			m.DoneDescAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DoneDescAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightHero", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FightHero = append(m.FightHero, &ReportHeroProto{})
			if err := m.FightHero[len(m.FightHero)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fight = append(m.Fight, &AssemblyFightProto{})
			if err := m.Fight[len(m.Fight)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 62:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerTroopCount", wireType)
			}
			m.AttackerTroopCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackerTroopCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 63:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserTroopCount", wireType)
			}
			m.DefenserTroopCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefenserTroopCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 64:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerTroopTotalCount", wireType)
			}
			m.AttackerTroopTotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackerTroopTotalCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 65:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserTroopTotalCount", wireType)
			}
			m.DefenserTroopTotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefenserTroopTotalCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 66:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerTroopWinTimes", wireType)
			}
			m.AttackerTroopWinTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackerTroopWinTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 67:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserTroopWinTimes", wireType)
			}
			m.DefenserTroopWinTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefenserTroopWinTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 68:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiLevelMonsterCount", wireType)
			}
			m.MultiLevelMonsterCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MultiLevelMonsterCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssemblyFightProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssemblyFightProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssemblyFightProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttackerId = append(m.AttackerId[:0], dAtA[iNdEx:postIndex]...)
			if m.AttackerId == nil {
				m.AttackerId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefenserId = append(m.DefenserId[:0], dAtA[iNdEx:postIndex]...)
			if m.DefenserId == nil {
				m.DefenserId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerFightAmount", wireType)
			}
			m.AttackerFightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackerFightAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserFightAmount", wireType)
			}
			m.DefenserFightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefenserFightAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowPrize == nil {
				m.ShowPrize = &PrizeProto{}
			}
			if err := m.ShowPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerWin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttackerWin = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attacker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attacker == nil {
				m.Attacker = &ReportHeroProto{}
			}
			if err := m.Attacker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defenser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Defenser == nil {
				m.Defenser = &ReportHeroProto{}
			}
			if err := m.Defenser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinTimes", wireType)
			}
			m.WinTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerAliveSoldier", wireType)
			}
			m.AttackerAliveSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackerAliveSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserAliveSoldier", wireType)
			}
			m.DefenserAliveSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefenserAliveSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerTotalSoldier", wireType)
			}
			m.AttackerTotalSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackerTotalSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserTotalSoldier", wireType)
			}
			m.DefenserTotalSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefenserTotalSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Share == nil {
				m.Share = &CombatShareProto{}
			}
			if err := m.Share.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportHeroProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportHeroProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportHeroProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseX", wireType)
			}
			m.BaseX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseY", wireType)
			}
			m.BaseY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliveSoldier", wireType)
			}
			m.AliveSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AliveSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSoldier", wireType)
			}
			m.TotalSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTent = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseRegion", wireType)
			}
			m.BaseRegion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseRegion |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildFlagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildFlagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Captains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Captains = append(m.Captains, &ReportCaptainProto{})
			if err := m.Captains[len(m.Captains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFightAmount", wireType)
			}
			m.TotalFightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalFightAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType == 0 {
				var v Race
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Race(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Race = append(m.Race, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMail
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Race
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Race(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Race = append(m.Race, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Race", wireType)
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			m.Country = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Country |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallLevel", wireType)
			}
			m.WallLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WallLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallCombatSoldier", wireType)
			}
			m.WallCombatSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WallCombatSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallAliveSoldier", wireType)
			}
			m.WallAliveSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WallAliveSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallKillSoldier", wireType)
			}
			m.WallKillSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WallKillSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseLevel", wireType)
			}
			m.BaseLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prosperity", wireType)
			}
			m.Prosperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prosperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProsperityCapcity", wireType)
			}
			m.ProsperityCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProsperityCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCopy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCopy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportCaptainProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportCaptainProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportCaptainProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Captain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Captain == nil {
				m.Captain = &CaptainInfoProto{}
			}
			if err := m.Captain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CombatSoldier", wireType)
			}
			m.CombatSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CombatSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliveSoldier", wireType)
			}
			m.AliveSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AliveSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightAmount", wireType)
			}
			m.FightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillSoldier", wireType)
			}
			m.KillSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMail(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMail
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMail
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMail
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMail
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMail
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMail(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMail = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMail   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/shared_proto/mail.proto", fileDescriptorMail)
}

var fileDescriptorMail = []byte{
	// 1655 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x5f, 0x53, 0xdb, 0x48,
	0x12, 0x8f, 0xc1, 0x32, 0x76, 0xdb, 0xc6, 0x66, 0x00, 0x33, 0xc0, 0x85, 0x18, 0xb8, 0x24, 0x3e,
	0x42, 0x20, 0x47, 0x92, 0xcb, 0x5d, 0xdd, 0x5f, 0x20, 0x95, 0x0b, 0x75, 0x97, 0x54, 0xca, 0xe1,
	0x2a, 0xc9, 0xbd, 0xa8, 0xc6, 0xd2, 0x60, 0x4f, 0x21, 0x4b, 0x2a, 0x49, 0x0e, 0xf8, 0xbe, 0xc3,
	0xbd, 0xef, 0xdb, 0x7e, 0x8e, 0xfd, 0x06, 0xfb, 0xb8, 0x8f, 0xfb, 0xb8, 0x95, 0x7d, 0xde, 0xda,
	0xaf, 0xb0, 0x35, 0xdd, 0x92, 0x2c, 0x19, 0x36, 0xb5, 0xbc, 0xed, 0x93, 0x67, 0xfa, 0xf7, 0xfb,
	0xa9, 0x5b, 0xdd, 0x3d, 0xad, 0x31, 0x3c, 0xe9, 0xab, 0x68, 0x30, 0xea, 0xed, 0x59, 0xde, 0x70,
	0xdf, 0x51, 0xfd, 0x41, 0xe4, 0x8b, 0x8b, 0xfd, 0xa1, 0x70, 0xe4, 0xb3, 0x7d, 0xbf, 0xb7, 0x1f,
	0x0e, 0x44, 0x20, 0x6d, 0xd3, 0x0f, 0xbc, 0xc8, 0xdb, 0x1f, 0x0a, 0xe5, 0xec, 0xe1, 0x92, 0x19,
	0xf8, 0xb3, 0x76, 0x03, 0x71, 0x4f, 0x84, 0x92, 0xc4, 0x6b, 0x7f, 0xf8, 0xe5, 0x2a, 0xcb, 0x1b,
	0xf6, 0x44, 0x14, 0xeb, 0xfe, 0x78, 0x83, 0x50, 0x95, 0xa3, 0x22, 0x11, 0x8c, 0x49, 0xb9, 0xf5,
	0xad, 0x01, 0x95, 0x57, 0x42, 0x39, 0x6f, 0x30, 0xf8, 0x25, 0x30, 0x22, 0x15, 0x39, 0x92, 0xcf,
	0xb4, 0x0b, 0x9d, 0x4a, 0x97, 0x36, 0x8c, 0x41, 0x31, 0x92, 0x97, 0x11, 0x9f, 0x45, 0x23, 0xae,
	0xd9, 0x3a, 0x54, 0xc2, 0x51, 0xcf, 0x24, 0x76, 0x11, 0x81, 0x72, 0x38, 0xea, 0x9d, 0xa2, 0x40,
	0x83, 0xd2, 0xb5, 0xcd, 0x48, 0x0d, 0x25, 0x37, 0xda, 0x85, 0x8e, 0xd1, 0x2d, 0x6b, 0xc3, 0xa9,
	0x1a, 0xe2, 0xd3, 0xce, 0xa5, 0xf4, 0x79, 0xa9, 0x5d, 0xe8, 0x94, 0xbb, 0xb8, 0xd6, 0x36, 0x65,
	0x79, 0x2e, 0x9f, 0x43, 0x2e, 0xae, 0xb5, 0x2d, 0x90, 0xc2, 0xe6, 0x65, 0xe2, 0xe9, 0x35, 0xbb,
	0x0d, 0x30, 0x10, 0xa1, 0x19, 0x48, 0xdf, 0x0b, 0x22, 0x5e, 0x41, 0xa4, 0x32, 0x10, 0x61, 0x17,
	0x0d, 0xda, 0xaf, 0x86, 0xfd, 0x40, 0xfd, 0x4f, 0x72, 0x40, 0xb4, 0x3c, 0x10, 0xe1, 0x1b, 0xbd,
	0x67, 0xbf, 0x81, 0x8a, 0xe5, 0x39, 0x8e, 0xb4, 0x22, 0x69, 0xf3, 0x2a, 0x49, 0x53, 0x03, 0xbb,
	0x03, 0x55, 0x1d, 0xa1, 0x0c, 0x4c, 0x57, 0x0c, 0x25, 0xaf, 0xe1, 0x1b, 0x01, 0x99, 0x5e, 0x8b,
	0xa1, 0xd4, 0xae, 0xfb, 0x23, 0xe5, 0xd8, 0x84, 0xd7, 0x11, 0xaf, 0xa0, 0x05, 0xe1, 0x7b, 0xd0,
	0x20, 0xf8, 0xcc, 0x11, 0x7d, 0xe2, 0xcc, 0x23, 0xa7, 0x8e, 0xe6, 0x17, 0x8e, 0xe8, 0x23, 0x6f,
	0x09, 0x0c, 0x35, 0x14, 0x7d, 0xc9, 0x1b, 0x94, 0x61, 0xdc, 0xe8, 0x87, 0xe3, 0xc2, 0xbc, 0xf0,
	0x02, 0x9b, 0x37, 0x31, 0x0b, 0x15, 0xb4, 0xbc, 0xf3, 0x02, 0x9b, 0xed, 0x42, 0x45, 0x77, 0x98,
	0x19, 0x8d, 0x7d, 0xc9, 0x97, 0xda, 0x85, 0xce, 0xfc, 0x41, 0x83, 0xea, 0xb7, 0xa7, 0x6b, 0x77,
	0x3a, 0xf6, 0x65, 0xb7, 0x3c, 0x8c, 0x57, 0x6c, 0x1f, 0x4a, 0x71, 0x82, 0x96, 0xdb, 0x85, 0x4e,
	0xf5, 0x60, 0x25, 0xa6, 0xbe, 0xd0, 0x8d, 0x41, 0x99, 0xc2, 0x6a, 0x77, 0x63, 0x1a, 0xbb, 0x0f,
	0x06, 0xa5, 0xac, 0x85, 0xfc, 0x85, 0x98, 0x8f, 0x69, 0x23, 0x26, 0xe1, 0x6c, 0x1e, 0x66, 0x94,
	0xcd, 0x57, 0xda, 0x85, 0x4e, 0xad, 0x3b, 0xa3, 0xb0, 0x1c, 0xf4, 0x08, 0x33, 0x12, 0x7d, 0xce,
	0x29, 0x6c, 0xb2, 0x9c, 0x8a, 0x3e, 0x7b, 0x00, 0x8c, 0x72, 0x62, 0x09, 0xc7, 0x31, 0x07, 0x32,
	0xf0, 0x4c, 0x65, 0xf3, 0x55, 0x94, 0x53, 0xb6, 0x8e, 0x85, 0xe3, 0xbc, 0x94, 0x81, 0x77, 0x62,
	0xb3, 0xfb, 0xd0, 0xcc, 0x90, 0x7d, 0x2f, 0x34, 0x2f, 0xf9, 0x1a, 0x3e, 0xb1, 0x9e, 0x52, 0xdf,
	0x78, 0xe1, 0xfb, 0x6b, 0x88, 0x63, 0xbe, 0x7e, 0x95, 0xf8, 0x61, 0xeb, 0x87, 0x0a, 0x34, 0xa7,
	0xdf, 0x99, 0x3d, 0x02, 0x08, 0x07, 0xde, 0x45, 0xdc, 0x23, 0xa5, 0x9f, 0x7b, 0xe1, 0x8a, 0x26,
	0x51, 0xdf, 0xac, 0xc0, 0xdc, 0x99, 0x7e, 0x8a, 0x79, 0x89, 0xad, 0x68, 0x74, 0x4b, 0xb8, 0x7d,
	0x3f, 0x01, 0xc6, 0xd8, 0x89, 0x09, 0xf0, 0x81, 0x6d, 0x42, 0x4d, 0x44, 0x91, 0xb0, 0xce, 0x65,
	0x60, 0x5e, 0x28, 0x37, 0xee, 0xc4, 0x6a, 0x62, 0x7b, 0xa7, 0x5c, 0x76, 0x00, 0xe5, 0x64, 0x8b,
	0xbd, 0x58, 0x3d, 0x68, 0xc5, 0x41, 0x50, 0xb0, 0x3a, 0x29, 0x14, 0x49, 0xca, 0xd3, 0x1a, 0x5b,
	0x9e, 0x49, 0x37, 0x94, 0x01, 0xf6, 0xe7, 0x67, 0x34, 0x09, 0x8f, 0x6d, 0x43, 0x3d, 0x0d, 0xc5,
	0x96, 0xa1, 0x15, 0x37, 0x6e, 0x1a, 0xdf, 0x73, 0x19, 0x5a, 0x9a, 0x94, 0x08, 0x88, 0x44, 0x9d,
	0x5b, 0x4b, 0x8c, 0x48, 0x62, 0x50, 0x44, 0x8c, 0xfa, 0x16, 0xd7, 0xba, 0xfe, 0x94, 0x01, 0x6c,
	0xcc, 0x65, 0xaa, 0x3f, 0x5a, 0xb0, 0x11, 0xef, 0x41, 0x23, 0x86, 0x45, 0xd0, 0x97, 0x91, 0x2e,
	0x7e, 0x0b, 0x8b, 0x5f, 0x27, 0x0e, 0x5a, 0x4f, 0x6c, 0xb6, 0x03, 0x0b, 0x39, 0x1e, 0x9e, 0x9e,
	0x15, 0xf4, 0xd3, 0xc8, 0x30, 0xf1, 0xfc, 0x3c, 0x86, 0x56, 0x8e, 0x3b, 0x39, 0x6e, 0x1c, 0x05,
	0x8b, 0x19, 0x41, 0x7a, 0xe8, 0xa8, 0x4f, 0x1d, 0x31, 0x36, 0x47, 0x81, 0xc3, 0x7f, 0x47, 0x67,
	0x97, 0x2c, 0xff, 0x09, 0x9c, 0x5c, 0x92, 0x42, 0x65, 0x4b, 0xbe, 0x83, 0x05, 0x4b, 0x93, 0xf4,
	0x56, 0xd9, 0x92, 0x3d, 0x04, 0x03, 0xe7, 0x28, 0x7f, 0x90, 0x3b, 0x54, 0xc7, 0x38, 0x86, 0xdf,
	0x6a, 0x24, 0x3e, 0x2a, 0xc8, 0xd2, 0xe7, 0x3c, 0xb4, 0xbc, 0x40, 0xf2, 0x5d, 0xcc, 0x0a, 0x6d,
	0x74, 0x67, 0x04, 0x5e, 0xcf, 0xb4, 0x47, 0x81, 0x88, 0x94, 0xe7, 0xf2, 0xc7, 0x08, 0x56, 0x03,
	0xaf, 0xf7, 0x3c, 0x36, 0xe9, 0x19, 0x66, 0x7b, 0xae, 0xa4, 0x42, 0x3c, 0xa1, 0xc1, 0xaa, 0x0d,
	0x58, 0x84, 0x0e, 0x34, 0x53, 0xd0, 0x14, 0x43, 0x6f, 0xe4, 0x46, 0xfc, 0x29, 0x3e, 0x63, 0x3e,
	0xe1, 0x1c, 0xa2, 0x95, 0x3d, 0x4d, 0x4a, 0xa3, 0x8f, 0x1d, 0xff, 0x4b, 0x7b, 0xf6, 0x33, 0xed,
	0x42, 0x25, 0xd3, 0x7b, 0xb6, 0x0f, 0x06, 0x6e, 0xf8, 0x5f, 0x51, 0xb1, 0x1a, 0x2b, 0x0e, 0xc3,
	0x50, 0x0e, 0x7b, 0xce, 0x18, 0x8f, 0x53, 0xfc, 0x9e, 0xc8, 0x63, 0x8f, 0x60, 0x29, 0xcd, 0x5d,
	0x14, 0x78, 0x9e, 0x6f, 0x5a, 0x18, 0xd5, 0xdf, 0x30, 0x2a, 0x96, 0x60, 0xa7, 0x1a, 0x3a, 0xc6,
	0xc8, 0x1e, 0xc1, 0x52, 0xda, 0x6d, 0x59, 0xc5, 0xdf, 0x49, 0x91, 0x60, 0x19, 0xc5, 0x9f, 0x61,
	0x6d, 0xca, 0x47, 0xe4, 0x45, 0xc2, 0x89, 0x75, 0xff, 0x40, 0xdd, 0x4a, 0xce, 0xd3, 0xa9, 0xc6,
	0x53, 0xf1, 0x94, 0xbb, 0xac, 0xf8, 0x90, 0xc4, 0x39, 0xa7, 0x19, 0xf1, 0x33, 0xe0, 0x53, 0x9e,
	0x2f, 0x94, 0x8b, 0x9f, 0xb5, 0x90, 0x1f, 0xa1, 0x74, 0x39, 0xe7, 0xf7, 0x9d, 0x72, 0xf5, 0x37,
	0x2e, 0xd4, 0xc2, 0x29, 0xaf, 0x13, 0xe1, 0x31, 0x09, 0x73, 0x3e, 0x53, 0xe1, 0x9f, 0x60, 0x75,
	0x38, 0x72, 0x22, 0x65, 0x3a, 0xf2, 0xa3, 0x74, 0xcc, 0xa1, 0xe7, 0x86, 0x91, 0x0c, 0xe2, 0x68,
	0x9f, 0xa3, 0xb2, 0x85, 0x84, 0x7f, 0x6b, 0xfc, 0x15, 0xc1, 0x18, 0xec, 0xd6, 0x97, 0x06, 0xb0,
	0xab, 0x85, 0xd2, 0x5f, 0xb6, 0xf4, 0x1d, 0x94, 0xcd, 0x0b, 0x78, 0x02, 0x21, 0x31, 0x9d, 0xe0,
	0xa7, 0x2f, 0x8d, 0x55, 0xd9, 0xf8, 0xe9, 0xaf, 0x75, 0x21, 0x31, 0x9d, 0xd8, 0xec, 0x00, 0xd2,
	0xb7, 0x34, 0xa9, 0xa9, 0xe2, 0xd6, 0x9b, 0xc5, 0x78, 0x16, 0x13, 0x10, 0x9d, 0xc6, 0xfd, 0x77,
	0x00, 0xe9, 0x0b, 0xe6, 0x35, 0x45, 0xd2, 0x24, 0x60, 0x56, 0x73, 0xf3, 0xd9, 0xfc, 0x2b, 0x9a,
	0xb4, 0xeb, 0x50, 0x99, 0x94, 0xb8, 0x4e, 0x77, 0x9e, 0x8b, 0xa4, 0xaa, 0x4f, 0xa0, 0x95, 0xc6,
	0x29, 0x1c, 0xf5, 0x51, 0x9a, 0xa1, 0xe7, 0xd8, 0x4a, 0x06, 0x38, 0x6a, 0x8d, 0x6e, 0x7a, 0x86,
	0x0e, 0x35, 0xf8, 0x96, 0x30, 0xad, 0x4a, 0x73, 0x98, 0x57, 0x35, 0x48, 0x95, 0xa0, 0xd3, 0xaa,
	0x49, 0xcf, 0x62, 0xab, 0x27, 0xaa, 0x66, 0xde, 0x17, 0xf6, 0xf9, 0x75, 0xbe, 0xf2, 0xaa, 0x85,
	0xbc, 0xaf, 0x9c, 0xea, 0x66, 0x43, 0x71, 0xeb, 0xff, 0x25, 0x68, 0x4c, 0x65, 0x50, 0x0f, 0x4a,
	0x6c, 0x75, 0xac, 0x9d, 0xd1, 0xa5, 0x4d, 0x7c, 0xd3, 0xa8, 0xa6, 0x37, 0x0d, 0x06, 0xc5, 0xcc,
	0xbd, 0x0c, 0xd7, 0xda, 0x36, 0xd0, 0x17, 0x44, 0xfa, 0xa4, 0xe1, 0x9a, 0x2d, 0x43, 0x49, 0x5f,
	0xa7, 0xcd, 0xcb, 0x38, 0xb1, 0x86, 0xde, 0xbd, 0x4f, 0xcd, 0xe3, 0x38, 0x73, 0x68, 0xfe, 0x80,
	0x83, 0x3f, 0x97, 0x57, 0xca, 0x50, 0x4d, 0x64, 0xf3, 0xb9, 0x0d, 0xf5, 0xeb, 0x12, 0x52, 0x8b,
	0xb2, 0x89, 0x58, 0x81, 0x39, 0x15, 0x9a, 0x91, 0x74, 0x23, 0xce, 0xb0, 0x07, 0x4b, 0x2a, 0x3c,
	0x95, 0x6e, 0xa4, 0x0f, 0x17, 0x7a, 0x0e, 0x64, 0x5f, 0x0f, 0xfc, 0x45, 0xd4, 0x82, 0x36, 0x75,
	0xd1, 0x72, 0xdd, 0xc5, 0x71, 0xe9, 0xba, 0x8b, 0xe3, 0x53, 0x28, 0x5b, 0xc2, 0x8f, 0x84, 0x72,
	0x43, 0xbe, 0x9c, 0x1b, 0xce, 0x94, 0xd1, 0x63, 0x02, 0xe3, 0xb6, 0x4c, 0xa8, 0x6c, 0x17, 0x18,
	0x45, 0x9f, 0x3b, 0x84, 0x2d, 0x0c, 0xa3, 0x89, 0x48, 0xf6, 0x04, 0x6e, 0x43, 0x31, 0x10, 0x96,
	0xfe, 0xf8, 0xce, 0x76, 0xe6, 0x0f, 0xaa, 0x89, 0x03, 0x61, 0xc9, 0xa3, 0x99, 0xe6, 0xad, 0x2e,
	0x82, 0x8c, 0xc3, 0x1c, 0x8e, 0xa3, 0x60, 0x1c, 0x5f, 0xf9, 0x92, 0xad, 0xfe, 0xce, 0x5e, 0xe8,
	0x4b, 0x19, 0x15, 0xf4, 0x0e, 0xdd, 0x07, 0xb4, 0x05, 0x87, 0x15, 0xdb, 0x83, 0x45, 0x84, 0xe9,
	0xaf, 0x4b, 0x9a, 0xcf, 0x36, 0xf2, 0x16, 0x34, 0x14, 0x37, 0x4e, 0x9c, 0xd4, 0x5d, 0x60, 0xc8,
	0xcf, 0xd7, 0x68, 0x93, 0x62, 0xd7, 0x48, 0xae, 0xef, 0x77, 0x00, 0x1f, 0x61, 0x9e, 0x2b, 0x67,
	0x52, 0xab, 0x2d, 0x24, 0x37, 0x34, 0xf0, 0x2f, 0xe5, 0xa4, 0xe5, 0xba, 0x0d, 0x58, 0x82, 0x38,
	0xd0, 0x6d, 0x0a, 0x54, 0x5b, 0x28, 0xd0, 0x0d, 0x00, 0x3f, 0xf0, 0x42, 0x5f, 0x06, 0x2a, 0x1a,
	0xf3, 0xdf, 0x52, 0xcd, 0x26, 0x16, 0xf6, 0x10, 0xd8, 0x64, 0x67, 0x5a, 0xc2, 0xb7, 0x34, 0xef,
	0x2e, 0xbd, 0xc7, 0x04, 0x39, 0x26, 0x20, 0x6e, 0x0e, 0xcb, 0xf3, 0xc7, 0xfc, 0x5e, 0xd2, 0x1c,
	0xc7, 0x9e, 0x3f, 0xde, 0xfa, 0xb1, 0x00, 0xec, 0x6a, 0xf5, 0xf0, 0x3f, 0x82, 0x6b, 0xcb, 0x4b,
	0x9c, 0xd5, 0x46, 0x97, 0x36, 0xec, 0xf7, 0x30, 0x17, 0x57, 0x15, 0x47, 0x74, 0xe6, 0xb4, 0x91,
	0xf5, 0xc4, 0x3d, 0x8b, 0x87, 0x52, 0xc2, 0x63, 0x77, 0x61, 0x7e, 0x2a, 0xd7, 0x34, 0xb1, 0xeb,
	0x56, 0x2e, 0xcf, 0x57, 0x8e, 0x41, 0xf1, 0x9a, 0x63, 0xb0, 0x09, 0xb5, 0x5c, 0x0b, 0xd1, 0xdf,
	0xba, 0xea, 0x59, 0xa6, 0x7b, 0x36, 0xa1, 0x96, 0x4b, 0x7e, 0x89, 0x28, 0xe7, 0x93, 0xc4, 0xef,
	0x7c, 0x55, 0x80, 0x72, 0xf2, 0x97, 0x85, 0xcd, 0x03, 0xe8, 0xf5, 0x6b, 0x2f, 0x18, 0x0a, 0xa7,
	0x79, 0x2b, 0xd9, 0x53, 0x46, 0x9a, 0x05, 0xb6, 0x08, 0x0d, 0xdc, 0x7b, 0xbd, 0x17, 0xca, 0x55,
	0xe1, 0x40, 0xda, 0xcd, 0x19, 0xb6, 0x0c, 0x0b, 0xda, 0x78, 0xe2, 0x7e, 0x94, 0x61, 0xa4, 0xfa,
	0x78, 0x69, 0x6a, 0xce, 0xb2, 0x55, 0x58, 0xd6, 0xe6, 0x23, 0x29, 0xdd, 0x3c, 0x54, 0x64, 0x0b,
	0x50, 0xd7, 0xd0, 0x3f, 0x93, 0x3f, 0x07, 0x4d, 0x83, 0xb5, 0x80, 0x69, 0x53, 0xf2, 0xb5, 0x8c,
	0x3d, 0x96, 0xd8, 0x3a, 0xac, 0xe4, 0xec, 0x19, 0xcf, 0x73, 0x47, 0xed, 0xaf, 0x3f, 0x6d, 0x14,
	0xbe, 0xf9, 0xb4, 0x51, 0xf8, 0xee, 0xd3, 0x46, 0xe1, 0x8b, 0xef, 0x37, 0x6e, 0xbd, 0x2c, 0xfc,
	0xb7, 0x96, 0xfd, 0x6f, 0xdd, 0x2b, 0xe1, 0xcf, 0xe3, 0x9f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xe1,
	0xd5, 0xd4, 0xd8, 0x3a, 0x10, 0x00, 0x00,
}
