// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/shared_proto/farm.proto
// DO NOT EDIT!

package shared_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 农场日志类型
type FarmLogType int32

const (
	FarmLogType_Steal   FarmLogType = 0
	FarmLogType_Harvest FarmLogType = 1
)

var FarmLogType_name = map[int32]string{
	0: "Steal",
	1: "Harvest",
}
var FarmLogType_value = map[string]int32{
	"Steal":   0,
	"Harvest": 1,
}

func (x FarmLogType) String() string {
	return proto.EnumName(FarmLogType_name, int32(x))
}
func (FarmLogType) EnumDescriptor() ([]byte, []int) { return fileDescriptorFarm, []int{0} }

// 农场资源配置
type FarmResConfigProto struct {
	Id           int32        `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	RipeDuration int32        `protobuf:"varint,2,opt,name=ripe_duration,json=ripeDuration,proto3" json:"ripe_duration,omitempty"`
	ResType      ResType      `protobuf:"varint,3,opt,name=res_type,json=resType,proto3,enum=proto.ResType" json:"res_type,omitempty"`
	BaseOutput   *AmountProto `protobuf:"bytes,4,opt,name=base_output,json=baseOutput" json:"base_output,omitempty"`
	Icon         string       `protobuf:"bytes,5,opt,name=Icon,proto3" json:"Icon,omitempty"`
}

func (m *FarmResConfigProto) Reset()                    { *m = FarmResConfigProto{} }
func (m *FarmResConfigProto) String() string            { return proto.CompactTextString(m) }
func (*FarmResConfigProto) ProtoMessage()               {}
func (*FarmResConfigProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{0} }

func (m *FarmResConfigProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *FarmResConfigProto) GetRipeDuration() int32 {
	if m != nil {
		return m.RipeDuration
	}
	return 0
}

func (m *FarmResConfigProto) GetResType() ResType {
	if m != nil {
		return m.ResType
	}
	return ResType_InvalidResType
}

func (m *FarmResConfigProto) GetBaseOutput() *AmountProto {
	if m != nil {
		return m.BaseOutput
	}
	return nil
}

func (m *FarmResConfigProto) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

// 农场杂项配置
type FarmMiscConfigProto struct {
	EarlyHarvestPercent      *AmountProto `protobuf:"bytes,1,opt,name=early_harvest_percent,json=earlyHarvestPercent" json:"early_harvest_percent,omitempty"`
	StealGainPercent         *AmountProto `protobuf:"bytes,2,opt,name=steal_gain_percent,json=stealGainPercent" json:"steal_gain_percent,omitempty"`
	CubeStealMaxTime         int32        `protobuf:"varint,3,opt,name=cube_steal_max_time,json=cubeStealMaxTime,proto3" json:"cube_steal_max_time,omitempty"`
	RipeProtectDuration      int32        `protobuf:"varint,4,opt,name=ripe_protect_duration,json=ripeProtectDuration,proto3" json:"ripe_protect_duration,omitempty"`
	StealLogMaxCount         int32        `protobuf:"varint,5,opt,name=steal_log_max_count,json=stealLogMaxCount,proto3" json:"steal_log_max_count,omitempty"`
	DailyStealGoldMaxAmount  int32        `protobuf:"varint,7,opt,name=daily_steal_gold_max_amount,json=dailyStealGoldMaxAmount,proto3" json:"daily_steal_gold_max_amount,omitempty"`
	DailyStealStoneMaxAmount int32        `protobuf:"varint,8,opt,name=daily_steal_stone_max_amount,json=dailyStealStoneMaxAmount,proto3" json:"daily_steal_stone_max_amount,omitempty"`
}

func (m *FarmMiscConfigProto) Reset()                    { *m = FarmMiscConfigProto{} }
func (m *FarmMiscConfigProto) String() string            { return proto.CompactTextString(m) }
func (*FarmMiscConfigProto) ProtoMessage()               {}
func (*FarmMiscConfigProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{1} }

func (m *FarmMiscConfigProto) GetEarlyHarvestPercent() *AmountProto {
	if m != nil {
		return m.EarlyHarvestPercent
	}
	return nil
}

func (m *FarmMiscConfigProto) GetStealGainPercent() *AmountProto {
	if m != nil {
		return m.StealGainPercent
	}
	return nil
}

func (m *FarmMiscConfigProto) GetCubeStealMaxTime() int32 {
	if m != nil {
		return m.CubeStealMaxTime
	}
	return 0
}

func (m *FarmMiscConfigProto) GetRipeProtectDuration() int32 {
	if m != nil {
		return m.RipeProtectDuration
	}
	return 0
}

func (m *FarmMiscConfigProto) GetStealLogMaxCount() int32 {
	if m != nil {
		return m.StealLogMaxCount
	}
	return 0
}

func (m *FarmMiscConfigProto) GetDailyStealGoldMaxAmount() int32 {
	if m != nil {
		return m.DailyStealGoldMaxAmount
	}
	return 0
}

func (m *FarmMiscConfigProto) GetDailyStealStoneMaxAmount() int32 {
	if m != nil {
		return m.DailyStealStoneMaxAmount
	}
	return 0
}

// 每个玩家自己的农场
type HeroFarmProto struct {
	HeroId      []byte           `protobuf:"bytes,1,opt,name=hero_id,json=heroId,proto3" json:"hero_id,omitempty"`
	FarmCube    []*FarmCubeProto `protobuf:"bytes,2,rep,name=farm_cube,json=farmCube" json:"farm_cube,omitempty"`
	GoldEffect  *AmountProto     `protobuf:"bytes,3,opt,name=gold_effect,json=goldEffect" json:"gold_effect,omitempty"`
	StoneEffect *AmountProto     `protobuf:"bytes,4,opt,name=stone_effect,json=stoneEffect" json:"stone_effect,omitempty"`
}

func (m *HeroFarmProto) Reset()                    { *m = HeroFarmProto{} }
func (m *HeroFarmProto) String() string            { return proto.CompactTextString(m) }
func (*HeroFarmProto) ProtoMessage()               {}
func (*HeroFarmProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{2} }

func (m *HeroFarmProto) GetHeroId() []byte {
	if m != nil {
		return m.HeroId
	}
	return nil
}

func (m *HeroFarmProto) GetFarmCube() []*FarmCubeProto {
	if m != nil {
		return m.FarmCube
	}
	return nil
}

func (m *HeroFarmProto) GetGoldEffect() *AmountProto {
	if m != nil {
		return m.GoldEffect
	}
	return nil
}

func (m *HeroFarmProto) GetStoneEffect() *AmountProto {
	if m != nil {
		return m.StoneEffect
	}
	return nil
}

// 每一个农场地块
// 这里改成删掉成熟时间和最大产量，增加开始时间、冲突时间和删除时间。
// 成熟时间可以用当前时间+FarmResConfigProto.RipeDuration
// 最大产量的科技加成需要取在收获时的加成
type FarmCubeProto struct {
	CubeX         int32 `protobuf:"varint,1,opt,name=cube_x,json=cubeX,proto3" json:"cube_x,omitempty"`
	CubeY         int32 `protobuf:"varint,2,opt,name=cube_y,json=cubeY,proto3" json:"cube_y,omitempty"`
	StartTime     int32 `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	ConflictTime  int32 `protobuf:"varint,4,opt,name=conflict_time,json=conflictTime,proto3" json:"conflict_time,omitempty"`
	RemoveTime    int32 `protobuf:"varint,5,opt,name=remove_time,json=removeTime,proto3" json:"remove_time,omitempty"`
	ResConfig     int32 `protobuf:"varint,7,opt,name=res_config,json=resConfig,proto3" json:"res_config,omitempty"`
	StealTimes    int32 `protobuf:"varint,9,opt,name=steal_times,json=stealTimes,proto3" json:"steal_times,omitempty"`
	ShowAnimation bool  `protobuf:"varint,10,opt,name=show_animation,json=showAnimation,proto3" json:"show_animation,omitempty"`
	NpcConflicted bool  `protobuf:"varint,11,opt,name=npc_conflicted,json=npcConflicted,proto3" json:"npc_conflicted,omitempty"`
}

func (m *FarmCubeProto) Reset()                    { *m = FarmCubeProto{} }
func (m *FarmCubeProto) String() string            { return proto.CompactTextString(m) }
func (*FarmCubeProto) ProtoMessage()               {}
func (*FarmCubeProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{3} }

func (m *FarmCubeProto) GetCubeX() int32 {
	if m != nil {
		return m.CubeX
	}
	return 0
}

func (m *FarmCubeProto) GetCubeY() int32 {
	if m != nil {
		return m.CubeY
	}
	return 0
}

func (m *FarmCubeProto) GetStartTime() int32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *FarmCubeProto) GetConflictTime() int32 {
	if m != nil {
		return m.ConflictTime
	}
	return 0
}

func (m *FarmCubeProto) GetRemoveTime() int32 {
	if m != nil {
		return m.RemoveTime
	}
	return 0
}

func (m *FarmCubeProto) GetResConfig() int32 {
	if m != nil {
		return m.ResConfig
	}
	return 0
}

func (m *FarmCubeProto) GetStealTimes() int32 {
	if m != nil {
		return m.StealTimes
	}
	return 0
}

func (m *FarmCubeProto) GetShowAnimation() bool {
	if m != nil {
		return m.ShowAnimation
	}
	return false
}

func (m *FarmCubeProto) GetNpcConflicted() bool {
	if m != nil {
		return m.NpcConflicted
	}
	return false
}

// 一条农场偷菜记录
type FarmStealLogProto struct {
	LogTime        int32       `protobuf:"varint,1,opt,name=log_time,json=logTime,proto3" json:"log_time,omitempty"`
	HeroId         []byte      `protobuf:"bytes,2,opt,name=hero_id,json=heroId,proto3" json:"hero_id,omitempty"`
	ThiefId        []byte      `protobuf:"bytes,8,opt,name=thief_id,json=thiefId,proto3" json:"thief_id,omitempty"`
	ThiefName      string      `protobuf:"bytes,3,opt,name=thief_name,json=thiefName,proto3" json:"thief_name,omitempty"`
	ThiefGuildFlag string      `protobuf:"bytes,4,opt,name=thief_guild_flag,json=thiefGuildFlag,proto3" json:"thief_guild_flag,omitempty"`
	ThiefCountryId int32       `protobuf:"varint,7,opt,name=thief_country_id,json=thiefCountryId,proto3" json:"thief_country_id,omitempty"`
	GoldOutput     int32       `protobuf:"varint,5,opt,name=gold_output,json=goldOutput,proto3" json:"gold_output,omitempty"`
	StoneOutput    int32       `protobuf:"varint,6,opt,name=stone_output,json=stoneOutput,proto3" json:"stone_output,omitempty"`
	Type           FarmLogType `protobuf:"varint,9,opt,name=type,proto3,enum=proto.FarmLogType" json:"type,omitempty"`
}

func (m *FarmStealLogProto) Reset()                    { *m = FarmStealLogProto{} }
func (m *FarmStealLogProto) String() string            { return proto.CompactTextString(m) }
func (*FarmStealLogProto) ProtoMessage()               {}
func (*FarmStealLogProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{4} }

func (m *FarmStealLogProto) GetLogTime() int32 {
	if m != nil {
		return m.LogTime
	}
	return 0
}

func (m *FarmStealLogProto) GetHeroId() []byte {
	if m != nil {
		return m.HeroId
	}
	return nil
}

func (m *FarmStealLogProto) GetThiefId() []byte {
	if m != nil {
		return m.ThiefId
	}
	return nil
}

func (m *FarmStealLogProto) GetThiefName() string {
	if m != nil {
		return m.ThiefName
	}
	return ""
}

func (m *FarmStealLogProto) GetThiefGuildFlag() string {
	if m != nil {
		return m.ThiefGuildFlag
	}
	return ""
}

func (m *FarmStealLogProto) GetThiefCountryId() int32 {
	if m != nil {
		return m.ThiefCountryId
	}
	return 0
}

func (m *FarmStealLogProto) GetGoldOutput() int32 {
	if m != nil {
		return m.GoldOutput
	}
	return 0
}

func (m *FarmStealLogProto) GetStoneOutput() int32 {
	if m != nil {
		return m.StoneOutput
	}
	return 0
}

func (m *FarmStealLogProto) GetType() FarmLogType {
	if m != nil {
		return m.Type
	}
	return FarmLogType_Steal
}

// 偷菜记录列表
type FarmStealLogListProto struct {
	Log []*FarmStealLogProto `protobuf:"bytes,1,rep,name=log" json:"log,omitempty"`
}

func (m *FarmStealLogListProto) Reset()                    { *m = FarmStealLogListProto{} }
func (m *FarmStealLogListProto) String() string            { return proto.CompactTextString(m) }
func (*FarmStealLogListProto) ProtoMessage()               {}
func (*FarmStealLogListProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{5} }

func (m *FarmStealLogListProto) GetLog() []*FarmStealLogProto {
	if m != nil {
		return m.Log
	}
	return nil
}

func init() {
	proto.RegisterType((*FarmResConfigProto)(nil), "proto.FarmResConfigProto")
	proto.RegisterType((*FarmMiscConfigProto)(nil), "proto.FarmMiscConfigProto")
	proto.RegisterType((*HeroFarmProto)(nil), "proto.HeroFarmProto")
	proto.RegisterType((*FarmCubeProto)(nil), "proto.FarmCubeProto")
	proto.RegisterType((*FarmStealLogProto)(nil), "proto.FarmStealLogProto")
	proto.RegisterType((*FarmStealLogListProto)(nil), "proto.FarmStealLogListProto")
	proto.RegisterEnum("proto.FarmLogType", FarmLogType_name, FarmLogType_value)
}
func (m *FarmResConfigProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FarmResConfigProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.Id))
	}
	if m.RipeDuration != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.RipeDuration))
	}
	if m.ResType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.ResType))
	}
	if m.BaseOutput != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.BaseOutput.Size()))
		n1, err := m.BaseOutput.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintFarm(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	return i, nil
}

func (m *FarmMiscConfigProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FarmMiscConfigProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EarlyHarvestPercent != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.EarlyHarvestPercent.Size()))
		n2, err := m.EarlyHarvestPercent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.StealGainPercent != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.StealGainPercent.Size()))
		n3, err := m.StealGainPercent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.CubeStealMaxTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeStealMaxTime))
	}
	if m.RipeProtectDuration != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.RipeProtectDuration))
	}
	if m.StealLogMaxCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.StealLogMaxCount))
	}
	if m.DailyStealGoldMaxAmount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.DailyStealGoldMaxAmount))
	}
	if m.DailyStealStoneMaxAmount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.DailyStealStoneMaxAmount))
	}
	return i, nil
}

func (m *HeroFarmProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroFarmProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HeroId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFarm(dAtA, i, uint64(len(m.HeroId)))
		i += copy(dAtA[i:], m.HeroId)
	}
	if len(m.FarmCube) > 0 {
		for _, msg := range m.FarmCube {
			dAtA[i] = 0x12
			i++
			i = encodeVarintFarm(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.GoldEffect != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.GoldEffect.Size()))
		n4, err := m.GoldEffect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.StoneEffect != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.StoneEffect.Size()))
		n5, err := m.StoneEffect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *FarmCubeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FarmCubeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CubeX != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeX))
	}
	if m.CubeY != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeY))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.StartTime))
	}
	if m.ConflictTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.ConflictTime))
	}
	if m.RemoveTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.RemoveTime))
	}
	if m.ResConfig != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.ResConfig))
	}
	if m.StealTimes != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.StealTimes))
	}
	if m.ShowAnimation {
		dAtA[i] = 0x50
		i++
		if m.ShowAnimation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NpcConflicted {
		dAtA[i] = 0x58
		i++
		if m.NpcConflicted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FarmStealLogProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FarmStealLogProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LogTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.LogTime))
	}
	if len(m.HeroId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFarm(dAtA, i, uint64(len(m.HeroId)))
		i += copy(dAtA[i:], m.HeroId)
	}
	if len(m.ThiefName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFarm(dAtA, i, uint64(len(m.ThiefName)))
		i += copy(dAtA[i:], m.ThiefName)
	}
	if len(m.ThiefGuildFlag) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFarm(dAtA, i, uint64(len(m.ThiefGuildFlag)))
		i += copy(dAtA[i:], m.ThiefGuildFlag)
	}
	if m.GoldOutput != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.GoldOutput))
	}
	if m.StoneOutput != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.StoneOutput))
	}
	if m.ThiefCountryId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.ThiefCountryId))
	}
	if len(m.ThiefId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintFarm(dAtA, i, uint64(len(m.ThiefId)))
		i += copy(dAtA[i:], m.ThiefId)
	}
	if m.Type != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *FarmStealLogListProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FarmStealLogListProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Log) > 0 {
		for _, msg := range m.Log {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFarm(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Farm(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Farm(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintFarm(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *FarmResConfigProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovFarm(uint64(m.Id))
	}
	if m.RipeDuration != 0 {
		n += 1 + sovFarm(uint64(m.RipeDuration))
	}
	if m.ResType != 0 {
		n += 1 + sovFarm(uint64(m.ResType))
	}
	if m.BaseOutput != nil {
		l = m.BaseOutput.Size()
		n += 1 + l + sovFarm(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovFarm(uint64(l))
	}
	return n
}

func (m *FarmMiscConfigProto) Size() (n int) {
	var l int
	_ = l
	if m.EarlyHarvestPercent != nil {
		l = m.EarlyHarvestPercent.Size()
		n += 1 + l + sovFarm(uint64(l))
	}
	if m.StealGainPercent != nil {
		l = m.StealGainPercent.Size()
		n += 1 + l + sovFarm(uint64(l))
	}
	if m.CubeStealMaxTime != 0 {
		n += 1 + sovFarm(uint64(m.CubeStealMaxTime))
	}
	if m.RipeProtectDuration != 0 {
		n += 1 + sovFarm(uint64(m.RipeProtectDuration))
	}
	if m.StealLogMaxCount != 0 {
		n += 1 + sovFarm(uint64(m.StealLogMaxCount))
	}
	if m.DailyStealGoldMaxAmount != 0 {
		n += 1 + sovFarm(uint64(m.DailyStealGoldMaxAmount))
	}
	if m.DailyStealStoneMaxAmount != 0 {
		n += 1 + sovFarm(uint64(m.DailyStealStoneMaxAmount))
	}
	return n
}

func (m *HeroFarmProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.HeroId)
	if l > 0 {
		n += 1 + l + sovFarm(uint64(l))
	}
	if len(m.FarmCube) > 0 {
		for _, e := range m.FarmCube {
			l = e.Size()
			n += 1 + l + sovFarm(uint64(l))
		}
	}
	if m.GoldEffect != nil {
		l = m.GoldEffect.Size()
		n += 1 + l + sovFarm(uint64(l))
	}
	if m.StoneEffect != nil {
		l = m.StoneEffect.Size()
		n += 1 + l + sovFarm(uint64(l))
	}
	return n
}

func (m *FarmCubeProto) Size() (n int) {
	var l int
	_ = l
	if m.CubeX != 0 {
		n += 1 + sovFarm(uint64(m.CubeX))
	}
	if m.CubeY != 0 {
		n += 1 + sovFarm(uint64(m.CubeY))
	}
	if m.StartTime != 0 {
		n += 1 + sovFarm(uint64(m.StartTime))
	}
	if m.ConflictTime != 0 {
		n += 1 + sovFarm(uint64(m.ConflictTime))
	}
	if m.RemoveTime != 0 {
		n += 1 + sovFarm(uint64(m.RemoveTime))
	}
	if m.ResConfig != 0 {
		n += 1 + sovFarm(uint64(m.ResConfig))
	}
	if m.StealTimes != 0 {
		n += 1 + sovFarm(uint64(m.StealTimes))
	}
	if m.ShowAnimation {
		n += 2
	}
	if m.NpcConflicted {
		n += 2
	}
	return n
}

func (m *FarmStealLogProto) Size() (n int) {
	var l int
	_ = l
	if m.LogTime != 0 {
		n += 1 + sovFarm(uint64(m.LogTime))
	}
	l = len(m.HeroId)
	if l > 0 {
		n += 1 + l + sovFarm(uint64(l))
	}
	l = len(m.ThiefName)
	if l > 0 {
		n += 1 + l + sovFarm(uint64(l))
	}
	l = len(m.ThiefGuildFlag)
	if l > 0 {
		n += 1 + l + sovFarm(uint64(l))
	}
	if m.GoldOutput != 0 {
		n += 1 + sovFarm(uint64(m.GoldOutput))
	}
	if m.StoneOutput != 0 {
		n += 1 + sovFarm(uint64(m.StoneOutput))
	}
	if m.ThiefCountryId != 0 {
		n += 1 + sovFarm(uint64(m.ThiefCountryId))
	}
	l = len(m.ThiefId)
	if l > 0 {
		n += 1 + l + sovFarm(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovFarm(uint64(m.Type))
	}
	return n
}

func (m *FarmStealLogListProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Log) > 0 {
		for _, e := range m.Log {
			l = e.Size()
			n += 1 + l + sovFarm(uint64(l))
		}
	}
	return n
}

func sovFarm(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFarm(x uint64) (n int) {
	return sovFarm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FarmResConfigProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FarmResConfigProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FarmResConfigProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RipeDuration", wireType)
			}
			m.RipeDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RipeDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResType", wireType)
			}
			m.ResType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResType |= (ResType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseOutput == nil {
				m.BaseOutput = &AmountProto{}
			}
			if err := m.BaseOutput.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FarmMiscConfigProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FarmMiscConfigProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FarmMiscConfigProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarlyHarvestPercent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EarlyHarvestPercent == nil {
				m.EarlyHarvestPercent = &AmountProto{}
			}
			if err := m.EarlyHarvestPercent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StealGainPercent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StealGainPercent == nil {
				m.StealGainPercent = &AmountProto{}
			}
			if err := m.StealGainPercent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeStealMaxTime", wireType)
			}
			m.CubeStealMaxTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeStealMaxTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RipeProtectDuration", wireType)
			}
			m.RipeProtectDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RipeProtectDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StealLogMaxCount", wireType)
			}
			m.StealLogMaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StealLogMaxCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyStealGoldMaxAmount", wireType)
			}
			m.DailyStealGoldMaxAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailyStealGoldMaxAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyStealStoneMaxAmount", wireType)
			}
			m.DailyStealStoneMaxAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailyStealStoneMaxAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroFarmProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroFarmProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroFarmProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeroId = append(m.HeroId[:0], dAtA[iNdEx:postIndex]...)
			if m.HeroId == nil {
				m.HeroId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FarmCube", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FarmCube = append(m.FarmCube, &FarmCubeProto{})
			if err := m.FarmCube[len(m.FarmCube)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldEffect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GoldEffect == nil {
				m.GoldEffect = &AmountProto{}
			}
			if err := m.GoldEffect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoneEffect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StoneEffect == nil {
				m.StoneEffect = &AmountProto{}
			}
			if err := m.StoneEffect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FarmCubeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FarmCubeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FarmCubeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeX", wireType)
			}
			m.CubeX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeY", wireType)
			}
			m.CubeY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConflictTime", wireType)
			}
			m.ConflictTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConflictTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveTime", wireType)
			}
			m.RemoveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoveTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResConfig", wireType)
			}
			m.ResConfig = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResConfig |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StealTimes", wireType)
			}
			m.StealTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StealTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowAnimation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShowAnimation = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NpcConflicted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NpcConflicted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FarmStealLogProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FarmStealLogProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FarmStealLogProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogTime", wireType)
			}
			m.LogTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeroId = append(m.HeroId[:0], dAtA[iNdEx:postIndex]...)
			if m.HeroId == nil {
				m.HeroId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThiefName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThiefName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThiefGuildFlag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThiefGuildFlag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldOutput", wireType)
			}
			m.GoldOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoldOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoneOutput", wireType)
			}
			m.StoneOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoneOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThiefCountryId", wireType)
			}
			m.ThiefCountryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThiefCountryId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThiefId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThiefId = append(m.ThiefId[:0], dAtA[iNdEx:postIndex]...)
			if m.ThiefId == nil {
				m.ThiefId = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (FarmLogType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FarmStealLogListProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FarmStealLogListProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FarmStealLogListProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Log = append(m.Log, &FarmStealLogProto{})
			if err := m.Log[len(m.Log)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFarm(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFarm
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFarm(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFarm = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFarm   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/shared_proto/farm.proto", fileDescriptorFarm)
}

var fileDescriptorFarm = []byte{
	// 880 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xdd, 0x8e, 0xe3, 0x34,
	0x18, 0xdd, 0x74, 0xa6, 0xd3, 0xe6, 0x4b, 0x5b, 0x15, 0x97, 0xd1, 0x86, 0x9f, 0x19, 0x4a, 0x57,
	0x8b, 0xca, 0x4a, 0x3b, 0x15, 0xb3, 0x20, 0x6e, 0x10, 0x62, 0x29, 0xcc, 0x8f, 0x34, 0x85, 0x51,
	0x66, 0x2f, 0x80, 0x9b, 0xc8, 0x4d, 0x9c, 0xd4, 0x52, 0x12, 0x47, 0x8e, 0xb3, 0xdb, 0xbe, 0x09,
	0x6f, 0x01, 0x2f, 0xc0, 0x05, 0x57, 0x70, 0xc9, 0x23, 0xa0, 0xe1, 0x45, 0x90, 0x3f, 0xbb, 0x9d,
	0x8c, 0xc4, 0x5c, 0x70, 0xd5, 0xf8, 0xf8, 0x1c, 0xfb, 0xf3, 0xf1, 0xf9, 0x5c, 0xf8, 0x34, 0xe5,
	0x6a, 0x55, 0x2f, 0x4f, 0x22, 0x91, 0xcf, 0x32, 0x9e, 0xae, 0x54, 0x49, 0xdf, 0xcc, 0x72, 0x9a,
	0xb1, 0xcf, 0x67, 0xe5, 0x72, 0x56, 0xad, 0xa8, 0x64, 0x71, 0x58, 0x4a, 0xa1, 0xc4, 0x2c, 0xa1,
	0x32, 0x3f, 0xc1, 0x4f, 0xd2, 0xc6, 0x9f, 0x77, 0xff, 0x87, 0x78, 0x49, 0x2b, 0x66, 0xc4, 0x93,
	0xdf, 0x1c, 0x20, 0x67, 0x54, 0xe6, 0x01, 0xab, 0xe6, 0xa2, 0x48, 0x78, 0x7a, 0x8d, 0x6b, 0x0e,
	0xa0, 0xc5, 0x63, 0xdf, 0x19, 0x3b, 0xd3, 0x76, 0xd0, 0xe2, 0x31, 0x79, 0x02, 0x7d, 0xc9, 0x4b,
	0x16, 0xc6, 0xb5, 0xa4, 0x8a, 0x8b, 0xc2, 0x6f, 0xe1, 0x54, 0x4f, 0x83, 0xdf, 0x58, 0x8c, 0x7c,
	0x0c, 0x5d, 0xc9, 0xaa, 0x50, 0x6d, 0x4a, 0xe6, 0xef, 0x8d, 0x9d, 0xe9, 0xe0, 0x74, 0x60, 0x76,
	0x39, 0x09, 0x58, 0xf5, 0x6a, 0x53, 0xb2, 0xa0, 0x23, 0xcd, 0x07, 0x79, 0x01, 0x9e, 0x2e, 0x22,
	0x14, 0xb5, 0x2a, 0x6b, 0xe5, 0xef, 0x8f, 0x9d, 0xa9, 0x77, 0x4a, 0x2c, 0xfb, 0x65, 0x2e, 0xea,
	0x42, 0x61, 0x21, 0x01, 0x68, 0xda, 0xf7, 0xc8, 0x22, 0x04, 0xf6, 0x2f, 0x23, 0x51, 0xf8, 0xed,
	0xb1, 0x33, 0x75, 0x03, 0xfc, 0x9e, 0xfc, 0xb2, 0x07, 0x23, 0x5d, 0xff, 0x82, 0x57, 0x51, 0xf3,
	0x00, 0x67, 0x70, 0xc8, 0xa8, 0xcc, 0x36, 0xe1, 0x8a, 0xca, 0xd7, 0xac, 0x52, 0x61, 0xc9, 0x64,
	0xc4, 0x0a, 0x85, 0x67, 0xfa, 0xef, 0xad, 0x46, 0x28, 0xb8, 0x30, 0xfc, 0x6b, 0x43, 0x27, 0x5f,
	0x01, 0xa9, 0x14, 0xa3, 0x59, 0x98, 0x52, 0x5e, 0xec, 0x16, 0x69, 0x3d, 0xb8, 0xc8, 0x10, 0xd9,
	0xe7, 0x94, 0x17, 0xdb, 0x15, 0x9e, 0xc3, 0x28, 0xaa, 0x97, 0x2c, 0x34, 0xcb, 0xe4, 0x74, 0x1d,
	0x2a, 0x9e, 0x1b, 0x83, 0xda, 0xc1, 0x50, 0x4f, 0xdd, 0xe8, 0x99, 0x05, 0x5d, 0xbf, 0xe2, 0x39,
	0x23, 0xa7, 0x70, 0x88, 0x4e, 0xeb, 0xa5, 0x59, 0xa4, 0xee, 0x1c, 0xdf, 0x47, 0xc1, 0x48, 0x4f,
	0x5e, 0x9b, 0xb9, 0x9d, 0xf1, 0xcf, 0x61, 0x64, 0x56, 0xcf, 0x44, 0x8a, 0x3b, 0x44, 0xba, 0x20,
	0xf4, 0xa9, 0x6d, 0x2b, 0xba, 0x12, 0xe9, 0x82, 0xae, 0xe7, 0x1a, 0x27, 0x5f, 0xc0, 0x7b, 0x31,
	0xe5, 0xd9, 0xc6, 0x96, 0x94, 0x8a, 0x2c, 0x46, 0x15, 0xc5, 0x73, 0xf8, 0x1d, 0x94, 0x3d, 0x46,
	0x0a, 0x96, 0x76, 0x2e, 0xb2, 0x78, 0x41, 0xd7, 0xe6, 0x98, 0xe4, 0x4b, 0x78, 0xbf, 0xa9, 0xae,
	0x94, 0x28, 0x58, 0x53, 0xde, 0x45, 0xb9, 0x7f, 0x27, 0xbf, 0xd1, 0x8c, 0x9d, 0x7e, 0xf2, 0x87,
	0x03, 0xfd, 0x0b, 0x26, 0x85, 0xbe, 0x35, 0x73, 0x57, 0x8f, 0xa1, 0xb3, 0x62, 0x52, 0x84, 0x36,
	0x71, 0xbd, 0xe0, 0x40, 0x0f, 0x2f, 0x63, 0xf2, 0x09, 0xb8, 0x3a, 0xe7, 0xa1, 0x36, 0xc9, 0x6f,
	0x8d, 0xf7, 0xa6, 0xde, 0xe9, 0xdb, 0xd6, 0x73, 0xad, 0x9e, 0xd7, 0x4b, 0x66, 0x5c, 0xef, 0x26,
	0x76, 0xa8, 0x83, 0x85, 0xe7, 0x61, 0x49, 0xc2, 0x22, 0x85, 0x2e, 0x3f, 0x10, 0x2c, 0x4d, 0xfb,
	0x16, 0x59, 0xe4, 0x33, 0xe8, 0x99, 0x63, 0x58, 0xd5, 0xc3, 0x71, 0xf4, 0x90, 0x67, 0x64, 0x93,
	0x5f, 0x5b, 0xd0, 0xbf, 0x57, 0x07, 0x39, 0x84, 0x03, 0xbc, 0xeb, 0xb5, 0x6d, 0x9d, 0xb6, 0x1e,
	0xfd, 0xb0, 0x83, 0x37, 0xb6, 0x6d, 0x10, 0xfe, 0x91, 0x1c, 0x01, 0x54, 0x8a, 0x4a, 0xd5, 0x0c,
	0x84, 0x8b, 0x08, 0x26, 0xe1, 0x09, 0xf4, 0x23, 0x51, 0x24, 0x19, 0x8f, 0x2c, 0xc3, 0x24, 0xa0,
	0xb7, 0x05, 0x91, 0xf4, 0x01, 0x78, 0x92, 0xe5, 0xe2, 0x35, 0x33, 0x14, 0x73, 0xe5, 0x60, 0x20,
	0x24, 0x1c, 0x01, 0xe8, 0xa6, 0x8c, 0xb0, 0x37, 0xec, 0xdd, 0xba, 0x72, 0xdb, 0xed, 0x5a, 0x6f,
	0xee, 0x51, 0xcb, 0x2b, 0xdf, 0x35, 0x7a, 0x84, 0xb4, 0xbc, 0x22, 0x4f, 0x61, 0x50, 0xad, 0xc4,
	0x9b, 0x90, 0x16, 0x3c, 0x37, 0x41, 0x84, 0xb1, 0x33, 0xed, 0x06, 0x7d, 0x8d, 0xbe, 0xdc, 0x82,
	0x9a, 0x56, 0x94, 0x51, 0xb8, 0xad, 0x8d, 0xc5, 0xbe, 0x67, 0x68, 0x45, 0x89, 0x7d, 0x69, 0xc0,
	0xc9, 0xef, 0x2d, 0x78, 0x4b, 0x5b, 0x76, 0x63, 0x33, 0x69, 0x6c, 0x7b, 0x07, 0xba, 0x3a, 0xb9,
	0x78, 0x02, 0x63, 0x5c, 0x27, 0x13, 0x29, 0x96, 0xdf, 0xc8, 0x46, 0xeb, 0x5e, 0x36, 0x8e, 0x00,
	0xd4, 0x8a, 0xb3, 0x24, 0x2c, 0xa8, 0x35, 0xcf, 0x0d, 0x5c, 0x44, 0xbe, 0xa3, 0x39, 0x23, 0x53,
	0x18, 0x9a, 0xe9, 0xb4, 0xe6, 0x59, 0x1c, 0x26, 0x19, 0x4d, 0xd1, 0x3f, 0x37, 0x18, 0x20, 0x7e,
	0xae, 0xe1, 0xb3, 0x8c, 0xa2, 0x03, 0x98, 0x18, 0xfb, 0x14, 0x59, 0x07, 0x35, 0x64, 0x9f, 0x9d,
	0x0f, 0xb7, 0xe9, 0xb0, 0x8c, 0x03, 0x64, 0x98, 0x24, 0x58, 0xca, 0x6e, 0x37, 0x6c, 0x3c, 0xb9,
	0xd1, 0xe5, 0x1a, 0xab, 0xcd, 0x6e, 0x73, 0x03, 0x5f, 0xc6, 0xfa, 0xa8, 0x86, 0xc9, 0x63, 0xec,
	0x94, 0x5e, 0xd0, 0xc1, 0xf1, 0x65, 0x4c, 0x3e, 0x82, 0x7d, 0x7c, 0x3a, 0x5d, 0x7c, 0x3a, 0x49,
	0x23, 0xe8, 0x57, 0x22, 0xc5, 0xe7, 0x13, 0xe7, 0x27, 0x73, 0x38, 0x6c, 0x5a, 0x78, 0xc5, 0x2b,
	0x13, 0x4e, 0xf2, 0x0c, 0xf6, 0x32, 0x91, 0xfa, 0x0e, 0x36, 0x8a, 0xdf, 0xd0, 0xdf, 0x73, 0x3b,
	0xd0, 0xa4, 0x67, 0x4f, 0xc1, 0x6b, 0xac, 0x4c, 0x5c, 0x68, 0x23, 0x69, 0xf8, 0x88, 0x78, 0xd0,
	0xb1, 0x6f, 0xe0, 0xd0, 0xf9, 0x7a, 0xfc, 0xe7, 0xed, 0xb1, 0xf3, 0xd7, 0xed, 0xb1, 0xf3, 0xf7,
	0xed, 0xb1, 0xf3, 0xf3, 0x3f, 0xc7, 0x8f, 0x2e, 0x9c, 0x9f, 0x7a, 0xcd, 0xff, 0x92, 0xe5, 0x01,
	0xfe, 0xbc, 0xf8, 0x37, 0x00, 0x00, 0xff, 0xff, 0xc4, 0x32, 0xe5, 0x34, 0xbc, 0x06, 0x00, 0x00,
}
