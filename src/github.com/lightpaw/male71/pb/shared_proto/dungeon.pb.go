// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/shared_proto/dungeon.proto
// DO NOT EDIT!

package shared_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type DifficultType int32

const (
	DifficultType_Invalid  DifficultType = 0
	DifficultType_ORDINARY DifficultType = 1
	DifficultType_ELITE    DifficultType = 2
)

var DifficultType_name = map[int32]string{
	0: "Invalid",
	1: "ORDINARY",
	2: "ELITE",
}
var DifficultType_value = map[string]int32{
	"Invalid":  0,
	"ORDINARY": 1,
	"ELITE":    2,
}

func (x DifficultType) String() string {
	return proto.EnumName(DifficultType_name, int32(x))
}
func (DifficultType) EnumDescriptor() ([]byte, []int) { return fileDescriptorDungeon, []int{0} }

type DungeonChapterProto struct {
	Id int32 `protobuf:"varint,10,opt,name=id,proto3" json:"id,omitempty"`
	// int32 sequence = 1; // 章节序列
	ChapterName  string              `protobuf:"bytes,2,opt,name=chapter_name,json=chapterName,proto3" json:"chapter_name,omitempty"`
	ChapterDesc  string              `protobuf:"bytes,3,opt,name=chapter_desc,json=chapterDesc,proto3" json:"chapter_desc,omitempty"`
	CaptainSoul  int32               `protobuf:"varint,5,opt,name=captain_soul,json=captainSoul,proto3" json:"captain_soul,omitempty"`
	Type         DifficultType       `protobuf:"varint,12,opt,name=type,proto3,enum=proto.DifficultType" json:"type,omitempty"`
	BgImg        string              `protobuf:"bytes,13,opt,name=bg_img,json=bgImg,proto3" json:"bg_img,omitempty"`
	DungeonDatas []*DungeonDataProto `protobuf:"bytes,14,rep,name=dungeon_datas,json=dungeonDatas" json:"dungeon_datas,omitempty"`
	PassPrize    *PrizeProto         `protobuf:"bytes,15,opt,name=pass_prize,json=passPrize" json:"pass_prize,omitempty"`
	StarPrize    []*PrizeProto       `protobuf:"bytes,16,rep,name=star_prize,json=starPrize" json:"star_prize,omitempty"`
	Star         []int32             `protobuf:"varint,17,rep,name=star" json:"star,omitempty"`
}

func (m *DungeonChapterProto) Reset()                    { *m = DungeonChapterProto{} }
func (m *DungeonChapterProto) String() string            { return proto.CompactTextString(m) }
func (*DungeonChapterProto) ProtoMessage()               {}
func (*DungeonChapterProto) Descriptor() ([]byte, []int) { return fileDescriptorDungeon, []int{0} }

func (m *DungeonChapterProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DungeonChapterProto) GetChapterName() string {
	if m != nil {
		return m.ChapterName
	}
	return ""
}

func (m *DungeonChapterProto) GetChapterDesc() string {
	if m != nil {
		return m.ChapterDesc
	}
	return ""
}

func (m *DungeonChapterProto) GetCaptainSoul() int32 {
	if m != nil {
		return m.CaptainSoul
	}
	return 0
}

func (m *DungeonChapterProto) GetType() DifficultType {
	if m != nil {
		return m.Type
	}
	return DifficultType_Invalid
}

func (m *DungeonChapterProto) GetBgImg() string {
	if m != nil {
		return m.BgImg
	}
	return ""
}

func (m *DungeonChapterProto) GetDungeonDatas() []*DungeonDataProto {
	if m != nil {
		return m.DungeonDatas
	}
	return nil
}

func (m *DungeonChapterProto) GetPassPrize() *PrizeProto {
	if m != nil {
		return m.PassPrize
	}
	return nil
}

func (m *DungeonChapterProto) GetStarPrize() []*PrizeProto {
	if m != nil {
		return m.StarPrize
	}
	return nil
}

func (m *DungeonChapterProto) GetStar() []int32 {
	if m != nil {
		return m.Star
	}
	return nil
}

type DungeonDataProto struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// int32 sequence = 10; // 副本序列
	Name                string                     `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Desc                string                     `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	UnlockHeroLevel     int32                      `protobuf:"varint,4,opt,name=unlock_hero_level,json=unlockHeroLevel,proto3" json:"unlock_hero_level,omitempty"`
	UnlockPassDungeon   []int32                    `protobuf:"varint,5,rep,name=unlock_pass_dungeon,json=unlockPassDungeon" json:"unlock_pass_dungeon,omitempty"`
	UnlockPuzzleIndex   int32                      `protobuf:"varint,6,opt,name=unlock_puzzle_index,json=unlockPuzzleIndex,proto3" json:"unlock_puzzle_index,omitempty"`
	UnlockBayeStage     int32                      `protobuf:"varint,9,opt,name=unlock_baye_stage,json=unlockBayeStage,proto3" json:"unlock_baye_stage,omitempty"`
	StoryId             int32                      `protobuf:"varint,7,opt,name=story_id,json=storyId,proto3" json:"story_id,omitempty"`
	DialogId            int32                      `protobuf:"varint,8,opt,name=dialog_id,json=dialogId,proto3" json:"dialog_id,omitempty"`
	PreBattleDialogId   int32                      `protobuf:"varint,22,opt,name=pre_battle_dialog_id,json=preBattleDialogId,proto3" json:"pre_battle_dialog_id,omitempty"`
	AfterBattleDialogId int32                      `protobuf:"varint,23,opt,name=after_battle_dialog_id,json=afterBattleDialogId,proto3" json:"after_battle_dialog_id,omitempty"`
	BallonToolTip       string                     `protobuf:"bytes,20,opt,name=ballon_tool_tip,json=ballonToolTip,proto3" json:"ballon_tool_tip,omitempty"`
	NpcName             string                     `protobuf:"bytes,21,opt,name=npc_name,json=npcName,proto3" json:"npc_name,omitempty"`
	NpcIcon             string                     `protobuf:"bytes,24,opt,name=npc_icon,json=npcIcon,proto3" json:"npc_icon,omitempty"`
	CombatSceneRes      string                     `protobuf:"bytes,25,opt,name=combat_scene_res,json=combatSceneRes,proto3" json:"combat_scene_res,omitempty"`
	FirstPassPrize      *PrizeProto                `protobuf:"bytes,14,opt,name=first_pass_prize,json=firstPassPrize" json:"first_pass_prize,omitempty"`
	PassPrize           *PrizeProto                `protobuf:"bytes,13,opt,name=pass_prize,json=passPrize" json:"pass_prize,omitempty"`
	ShowPrize           *PrizeProto                `protobuf:"bytes,11,opt,name=show_prize,json=showPrize" json:"show_prize,omitempty"`
	Monster             *MonsterMasterDataProto    `protobuf:"bytes,12,opt,name=monster" json:"monster,omitempty"`
	ChapterId           int32                      `protobuf:"varint,31,opt,name=chapter_id,json=chapterId,proto3" json:"chapter_id,omitempty"`
	Type                DifficultType              `protobuf:"varint,32,opt,name=type,proto3,enum=proto.DifficultType" json:"type,omitempty"`
	Star                int32                      `protobuf:"varint,15,opt,name=star,proto3" json:"star,omitempty"`
	StarCondition       []int32                    `protobuf:"varint,16,rep,name=star_condition,json=starCondition" json:"star_condition,omitempty"`
	StarConditionValue  []int32                    `protobuf:"varint,17,rep,name=star_condition_value,json=starConditionValue" json:"star_condition_value,omitempty"`
	PassLimit           int32                      `protobuf:"varint,18,opt,name=pass_limit,json=passLimit,proto3" json:"pass_limit,omitempty"`
	Sp                  int32                      `protobuf:"varint,19,opt,name=sp,proto3" json:"sp,omitempty"`
	Prev                int32                      `protobuf:"varint,33,opt,name=prev,proto3" json:"prev,omitempty"`
	Next                int32                      `protobuf:"varint,34,opt,name=next,proto3" json:"next,omitempty"`
	YuanJunData         []*MonsterCaptainDataProto `protobuf:"bytes,35,rep,name=yuan_jun_data,json=yuanJunData" json:"yuan_jun_data,omitempty"`
	// 剧情槽位和剧情id
	PlotIdx []int32 `protobuf:"varint,36,rep,name=plot_idx,json=plotIdx" json:"plot_idx,omitempty"`
	PlotId  []int32 `protobuf:"varint,37,rep,name=plot_id,json=plotId" json:"plot_id,omitempty"`
	// 引导布阵
	GuideTroop *DungeonGuideTroopDataProto `protobuf:"bytes,38,opt,name=guide_troop,json=guideTroop" json:"guide_troop,omitempty"`
}

func (m *DungeonDataProto) Reset()                    { *m = DungeonDataProto{} }
func (m *DungeonDataProto) String() string            { return proto.CompactTextString(m) }
func (*DungeonDataProto) ProtoMessage()               {}
func (*DungeonDataProto) Descriptor() ([]byte, []int) { return fileDescriptorDungeon, []int{1} }

func (m *DungeonDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DungeonDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DungeonDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *DungeonDataProto) GetUnlockHeroLevel() int32 {
	if m != nil {
		return m.UnlockHeroLevel
	}
	return 0
}

func (m *DungeonDataProto) GetUnlockPassDungeon() []int32 {
	if m != nil {
		return m.UnlockPassDungeon
	}
	return nil
}

func (m *DungeonDataProto) GetUnlockPuzzleIndex() int32 {
	if m != nil {
		return m.UnlockPuzzleIndex
	}
	return 0
}

func (m *DungeonDataProto) GetUnlockBayeStage() int32 {
	if m != nil {
		return m.UnlockBayeStage
	}
	return 0
}

func (m *DungeonDataProto) GetStoryId() int32 {
	if m != nil {
		return m.StoryId
	}
	return 0
}

func (m *DungeonDataProto) GetDialogId() int32 {
	if m != nil {
		return m.DialogId
	}
	return 0
}

func (m *DungeonDataProto) GetPreBattleDialogId() int32 {
	if m != nil {
		return m.PreBattleDialogId
	}
	return 0
}

func (m *DungeonDataProto) GetAfterBattleDialogId() int32 {
	if m != nil {
		return m.AfterBattleDialogId
	}
	return 0
}

func (m *DungeonDataProto) GetBallonToolTip() string {
	if m != nil {
		return m.BallonToolTip
	}
	return ""
}

func (m *DungeonDataProto) GetNpcName() string {
	if m != nil {
		return m.NpcName
	}
	return ""
}

func (m *DungeonDataProto) GetNpcIcon() string {
	if m != nil {
		return m.NpcIcon
	}
	return ""
}

func (m *DungeonDataProto) GetCombatSceneRes() string {
	if m != nil {
		return m.CombatSceneRes
	}
	return ""
}

func (m *DungeonDataProto) GetFirstPassPrize() *PrizeProto {
	if m != nil {
		return m.FirstPassPrize
	}
	return nil
}

func (m *DungeonDataProto) GetPassPrize() *PrizeProto {
	if m != nil {
		return m.PassPrize
	}
	return nil
}

func (m *DungeonDataProto) GetShowPrize() *PrizeProto {
	if m != nil {
		return m.ShowPrize
	}
	return nil
}

func (m *DungeonDataProto) GetMonster() *MonsterMasterDataProto {
	if m != nil {
		return m.Monster
	}
	return nil
}

func (m *DungeonDataProto) GetChapterId() int32 {
	if m != nil {
		return m.ChapterId
	}
	return 0
}

func (m *DungeonDataProto) GetType() DifficultType {
	if m != nil {
		return m.Type
	}
	return DifficultType_Invalid
}

func (m *DungeonDataProto) GetStar() int32 {
	if m != nil {
		return m.Star
	}
	return 0
}

func (m *DungeonDataProto) GetStarCondition() []int32 {
	if m != nil {
		return m.StarCondition
	}
	return nil
}

func (m *DungeonDataProto) GetStarConditionValue() []int32 {
	if m != nil {
		return m.StarConditionValue
	}
	return nil
}

func (m *DungeonDataProto) GetPassLimit() int32 {
	if m != nil {
		return m.PassLimit
	}
	return 0
}

func (m *DungeonDataProto) GetSp() int32 {
	if m != nil {
		return m.Sp
	}
	return 0
}

func (m *DungeonDataProto) GetPrev() int32 {
	if m != nil {
		return m.Prev
	}
	return 0
}

func (m *DungeonDataProto) GetNext() int32 {
	if m != nil {
		return m.Next
	}
	return 0
}

func (m *DungeonDataProto) GetYuanJunData() []*MonsterCaptainDataProto {
	if m != nil {
		return m.YuanJunData
	}
	return nil
}

func (m *DungeonDataProto) GetPlotIdx() []int32 {
	if m != nil {
		return m.PlotIdx
	}
	return nil
}

func (m *DungeonDataProto) GetPlotId() []int32 {
	if m != nil {
		return m.PlotId
	}
	return nil
}

func (m *DungeonDataProto) GetGuideTroop() *DungeonGuideTroopDataProto {
	if m != nil {
		return m.GuideTroop
	}
	return nil
}

type DungeonMiscProto struct {
	MaxAutoTimes        int32 `protobuf:"varint,1,opt,name=max_auto_times,json=maxAutoTimes,proto3" json:"max_auto_times,omitempty"`
	RecoverAutoDuration int32 `protobuf:"varint,2,opt,name=recover_auto_duration,json=recoverAutoDuration,proto3" json:"recover_auto_duration,omitempty"`
	AutoPerTimes        int32 `protobuf:"varint,3,opt,name=auto_per_times,json=autoPerTimes,proto3" json:"auto_per_times,omitempty"`
}

func (m *DungeonMiscProto) Reset()                    { *m = DungeonMiscProto{} }
func (m *DungeonMiscProto) String() string            { return proto.CompactTextString(m) }
func (*DungeonMiscProto) ProtoMessage()               {}
func (*DungeonMiscProto) Descriptor() ([]byte, []int) { return fileDescriptorDungeon, []int{2} }

func (m *DungeonMiscProto) GetMaxAutoTimes() int32 {
	if m != nil {
		return m.MaxAutoTimes
	}
	return 0
}

func (m *DungeonMiscProto) GetRecoverAutoDuration() int32 {
	if m != nil {
		return m.RecoverAutoDuration
	}
	return 0
}

func (m *DungeonMiscProto) GetAutoPerTimes() int32 {
	if m != nil {
		return m.AutoPerTimes
	}
	return 0
}

type DungeonGuideTroopDataProto struct {
	NotFirst bool    `protobuf:"varint,1,opt,name=not_first,json=notFirst,proto3" json:"not_first,omitempty"`
	Captain  []int32 `protobuf:"varint,2,rep,name=captain" json:"captain,omitempty"`
	SrcPos   []int32 `protobuf:"varint,3,rep,name=src_pos,json=srcPos" json:"src_pos,omitempty"`
	SrcPosX  []int32 `protobuf:"varint,5,rep,name=src_pos_x,json=srcPosX" json:"src_pos_x,omitempty"`
	DstPos   []int32 `protobuf:"varint,4,rep,name=dst_pos,json=dstPos" json:"dst_pos,omitempty"`
	DstPosX  []int32 `protobuf:"varint,6,rep,name=dst_pos_x,json=dstPosX" json:"dst_pos_x,omitempty"`
}

func (m *DungeonGuideTroopDataProto) Reset()         { *m = DungeonGuideTroopDataProto{} }
func (m *DungeonGuideTroopDataProto) String() string { return proto.CompactTextString(m) }
func (*DungeonGuideTroopDataProto) ProtoMessage()    {}
func (*DungeonGuideTroopDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorDungeon, []int{3}
}

func (m *DungeonGuideTroopDataProto) GetNotFirst() bool {
	if m != nil {
		return m.NotFirst
	}
	return false
}

func (m *DungeonGuideTroopDataProto) GetCaptain() []int32 {
	if m != nil {
		return m.Captain
	}
	return nil
}

func (m *DungeonGuideTroopDataProto) GetSrcPos() []int32 {
	if m != nil {
		return m.SrcPos
	}
	return nil
}

func (m *DungeonGuideTroopDataProto) GetSrcPosX() []int32 {
	if m != nil {
		return m.SrcPosX
	}
	return nil
}

func (m *DungeonGuideTroopDataProto) GetDstPos() []int32 {
	if m != nil {
		return m.DstPos
	}
	return nil
}

func (m *DungeonGuideTroopDataProto) GetDstPosX() []int32 {
	if m != nil {
		return m.DstPosX
	}
	return nil
}

type DungeonChapterStar struct {
	Chapter int32 `protobuf:"varint,1,opt,name=chapter,proto3" json:"chapter,omitempty"`
	Star    int32 `protobuf:"varint,2,opt,name=star,proto3" json:"star,omitempty"`
}

func (m *DungeonChapterStar) Reset()                    { *m = DungeonChapterStar{} }
func (m *DungeonChapterStar) String() string            { return proto.CompactTextString(m) }
func (*DungeonChapterStar) ProtoMessage()               {}
func (*DungeonChapterStar) Descriptor() ([]byte, []int) { return fileDescriptorDungeon, []int{4} }

func (m *DungeonChapterStar) GetChapter() int32 {
	if m != nil {
		return m.Chapter
	}
	return 0
}

func (m *DungeonChapterStar) GetStar() int32 {
	if m != nil {
		return m.Star
	}
	return 0
}

type DungeonStar struct {
	Dungeon     int32  `protobuf:"varint,1,opt,name=dungeon,proto3" json:"dungeon,omitempty"`
	EnabledStar []bool `protobuf:"varint,2,rep,name=enabled_star,json=enabledStar" json:"enabled_star,omitempty"`
}

func (m *DungeonStar) Reset()                    { *m = DungeonStar{} }
func (m *DungeonStar) String() string            { return proto.CompactTextString(m) }
func (*DungeonStar) ProtoMessage()               {}
func (*DungeonStar) Descriptor() ([]byte, []int) { return fileDescriptorDungeon, []int{5} }

func (m *DungeonStar) GetDungeon() int32 {
	if m != nil {
		return m.Dungeon
	}
	return 0
}

func (m *DungeonStar) GetEnabledStar() []bool {
	if m != nil {
		return m.EnabledStar
	}
	return nil
}

type DungeonPassLimit struct {
	Dungeon int32 `protobuf:"varint,1,opt,name=dungeon,proto3" json:"dungeon,omitempty"`
	Times   int32 `protobuf:"varint,2,opt,name=times,proto3" json:"times,omitempty"`
}

func (m *DungeonPassLimit) Reset()                    { *m = DungeonPassLimit{} }
func (m *DungeonPassLimit) String() string            { return proto.CompactTextString(m) }
func (*DungeonPassLimit) ProtoMessage()               {}
func (*DungeonPassLimit) Descriptor() ([]byte, []int) { return fileDescriptorDungeon, []int{6} }

func (m *DungeonPassLimit) GetDungeon() int32 {
	if m != nil {
		return m.Dungeon
	}
	return 0
}

func (m *DungeonPassLimit) GetTimes() int32 {
	if m != nil {
		return m.Times
	}
	return 0
}

type CollectedChapterStarPrizes struct {
	Chapter     int32   `protobuf:"varint,1,opt,name=chapter,proto3" json:"chapter,omitempty"`
	PrizeIndexs []int32 `protobuf:"varint,2,rep,name=prize_indexs,json=prizeIndexs" json:"prize_indexs,omitempty"`
}

func (m *CollectedChapterStarPrizes) Reset()         { *m = CollectedChapterStarPrizes{} }
func (m *CollectedChapterStarPrizes) String() string { return proto.CompactTextString(m) }
func (*CollectedChapterStarPrizes) ProtoMessage()    {}
func (*CollectedChapterStarPrizes) Descriptor() ([]byte, []int) {
	return fileDescriptorDungeon, []int{7}
}

func (m *CollectedChapterStarPrizes) GetChapter() int32 {
	if m != nil {
		return m.Chapter
	}
	return 0
}

func (m *CollectedChapterStarPrizes) GetPrizeIndexs() []int32 {
	if m != nil {
		return m.PrizeIndexs
	}
	return nil
}

// 玩家副本
type HeroDungeonProto struct {
	// 保存章节已经领过的奖励
	ChapterStarPrizes []*CollectedChapterStarPrizes `protobuf:"bytes,16,rep,name=chapter_star_prizes,json=chapterStarPrizes" json:"chapter_star_prizes,omitempty"`
	// 保存章节的总星数
	ChapterStars []*DungeonChapterStar `protobuf:"bytes,14,rep,name=chapter_stars,json=chapterStars" json:"chapter_stars,omitempty"`
	// 保存通过星数的副本以及对应星数
	DungeonStars []*DungeonStar `protobuf:"bytes,12,rep,name=dungeon_stars,json=dungeonStars" json:"dungeon_stars,omitempty"`
	// 保存每日通过次数限制的副本的次数
	DungeonLimits []*DungeonPassLimit `protobuf:"bytes,13,rep,name=dungeon_limits,json=dungeonLimits" json:"dungeon_limits,omitempty"`
	// 通关了的副本
	PassDungeons []int32 `protobuf:"varint,1,rep,name=pass_dungeons,json=passDungeons" json:"pass_dungeons,omitempty"`
	// 领取了的通关副本奖励，该值是：DungeonDataProto.id 副本id
	CollectedPassDungeonPrizes []int32 `protobuf:"varint,5,rep,name=collected_pass_dungeon_prizes,json=collectedPassDungeonPrizes" json:"collected_pass_dungeon_prizes,omitempty"`
	// 领取了的章节奖励，该值是：DungeonChapterDifficultProto.id
	CollectedChapterPrizes []int32 `protobuf:"varint,2,rep,name=collected_chapter_prizes,json=collectedChapterPrizes" json:"collected_chapter_prizes,omitempty"`
	// 扫荡恢复开始时间
	// 计算扫荡次数
	// 当前时间: ctime
	// 恢复开始时间 auto_recover_start_time
	// 次数 = (ctime - auto_recover_start_time) / DungeonMiscProto.recover_auto_duration
	// 下次恢复间隔:
	// if 次数 >= DungeonMiscProto.max_auto_times {
	//      次数满了
	// } else {
	//      (次数+1) * DungeonMiscProto.recover_auto_duration - ctime
	// }
	AutoRecoverStartTime  int32                 `protobuf:"varint,3,opt,name=auto_recover_start_time,json=autoRecoverStartTime,proto3" json:"auto_recover_start_time,omitempty"`
	CollectAutoTimesIndex int32                 `protobuf:"varint,4,opt,name=collect_auto_times_index,json=collectAutoTimesIndex,proto3" json:"collect_auto_times_index,omitempty"`
	VipBoughtTimes        []*HeroVipBoughtTimes `protobuf:"bytes,8,rep,name=vip_bought_times,json=vipBoughtTimes" json:"vip_bought_times,omitempty"`
}

func (m *HeroDungeonProto) Reset()                    { *m = HeroDungeonProto{} }
func (m *HeroDungeonProto) String() string            { return proto.CompactTextString(m) }
func (*HeroDungeonProto) ProtoMessage()               {}
func (*HeroDungeonProto) Descriptor() ([]byte, []int) { return fileDescriptorDungeon, []int{8} }

func (m *HeroDungeonProto) GetChapterStarPrizes() []*CollectedChapterStarPrizes {
	if m != nil {
		return m.ChapterStarPrizes
	}
	return nil
}

func (m *HeroDungeonProto) GetChapterStars() []*DungeonChapterStar {
	if m != nil {
		return m.ChapterStars
	}
	return nil
}

func (m *HeroDungeonProto) GetDungeonStars() []*DungeonStar {
	if m != nil {
		return m.DungeonStars
	}
	return nil
}

func (m *HeroDungeonProto) GetDungeonLimits() []*DungeonPassLimit {
	if m != nil {
		return m.DungeonLimits
	}
	return nil
}

func (m *HeroDungeonProto) GetPassDungeons() []int32 {
	if m != nil {
		return m.PassDungeons
	}
	return nil
}

func (m *HeroDungeonProto) GetCollectedPassDungeonPrizes() []int32 {
	if m != nil {
		return m.CollectedPassDungeonPrizes
	}
	return nil
}

func (m *HeroDungeonProto) GetCollectedChapterPrizes() []int32 {
	if m != nil {
		return m.CollectedChapterPrizes
	}
	return nil
}

func (m *HeroDungeonProto) GetAutoRecoverStartTime() int32 {
	if m != nil {
		return m.AutoRecoverStartTime
	}
	return 0
}

func (m *HeroDungeonProto) GetCollectAutoTimesIndex() int32 {
	if m != nil {
		return m.CollectAutoTimesIndex
	}
	return 0
}

func (m *HeroDungeonProto) GetVipBoughtTimes() []*HeroVipBoughtTimes {
	if m != nil {
		return m.VipBoughtTimes
	}
	return nil
}

type HeroVipBoughtTimes struct {
	DungeonId   int32 `protobuf:"varint,1,opt,name=dungeon_id,json=dungeonId,proto3" json:"dungeon_id,omitempty"`
	BoughtTimes int32 `protobuf:"varint,3,opt,name=bought_times,json=boughtTimes,proto3" json:"bought_times,omitempty"`
}

func (m *HeroVipBoughtTimes) Reset()                    { *m = HeroVipBoughtTimes{} }
func (m *HeroVipBoughtTimes) String() string            { return proto.CompactTextString(m) }
func (*HeroVipBoughtTimes) ProtoMessage()               {}
func (*HeroVipBoughtTimes) Descriptor() ([]byte, []int) { return fileDescriptorDungeon, []int{9} }

func (m *HeroVipBoughtTimes) GetDungeonId() int32 {
	if m != nil {
		return m.DungeonId
	}
	return 0
}

func (m *HeroVipBoughtTimes) GetBoughtTimes() int32 {
	if m != nil {
		return m.BoughtTimes
	}
	return 0
}

func init() {
	proto.RegisterType((*DungeonChapterProto)(nil), "proto.DungeonChapterProto")
	proto.RegisterType((*DungeonDataProto)(nil), "proto.DungeonDataProto")
	proto.RegisterType((*DungeonMiscProto)(nil), "proto.DungeonMiscProto")
	proto.RegisterType((*DungeonGuideTroopDataProto)(nil), "proto.DungeonGuideTroopDataProto")
	proto.RegisterType((*DungeonChapterStar)(nil), "proto.DungeonChapterStar")
	proto.RegisterType((*DungeonStar)(nil), "proto.DungeonStar")
	proto.RegisterType((*DungeonPassLimit)(nil), "proto.DungeonPassLimit")
	proto.RegisterType((*CollectedChapterStarPrizes)(nil), "proto.CollectedChapterStarPrizes")
	proto.RegisterType((*HeroDungeonProto)(nil), "proto.HeroDungeonProto")
	proto.RegisterType((*HeroVipBoughtTimes)(nil), "proto.HeroVipBoughtTimes")
	proto.RegisterEnum("proto.DifficultType", DifficultType_name, DifficultType_value)
}
func (m *DungeonChapterProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DungeonChapterProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChapterName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(len(m.ChapterName)))
		i += copy(dAtA[i:], m.ChapterName)
	}
	if len(m.ChapterDesc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(len(m.ChapterDesc)))
		i += copy(dAtA[i:], m.ChapterDesc)
	}
	if m.CaptainSoul != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.CaptainSoul))
	}
	if m.Id != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.Type))
	}
	if len(m.BgImg) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(len(m.BgImg)))
		i += copy(dAtA[i:], m.BgImg)
	}
	if len(m.DungeonDatas) > 0 {
		for _, msg := range m.DungeonDatas {
			dAtA[i] = 0x72
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PassPrize != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.PassPrize.Size()))
		n1, err := m.PassPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.StarPrize) > 0 {
		for _, msg := range m.StarPrize {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Star) > 0 {
		for _, num := range m.Star {
			dAtA[i] = 0x88
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *DungeonDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DungeonDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.UnlockHeroLevel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.UnlockHeroLevel))
	}
	if len(m.UnlockPassDungeon) > 0 {
		for _, num := range m.UnlockPassDungeon {
			dAtA[i] = 0x28
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(num))
		}
	}
	if m.UnlockPuzzleIndex != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.UnlockPuzzleIndex))
	}
	if m.StoryId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.StoryId))
	}
	if m.DialogId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.DialogId))
	}
	if m.UnlockBayeStage != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.UnlockBayeStage))
	}
	if m.ShowPrize != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.ShowPrize.Size()))
		n2, err := m.ShowPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Monster != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.Monster.Size()))
		n3, err := m.Monster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.PassPrize != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.PassPrize.Size()))
		n4, err := m.PassPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.FirstPassPrize != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.FirstPassPrize.Size()))
		n5, err := m.FirstPassPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Star != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.Star))
	}
	if len(m.StarCondition) > 0 {
		for _, num := range m.StarCondition {
			dAtA[i] = 0x80
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(num))
		}
	}
	if len(m.StarConditionValue) > 0 {
		for _, num := range m.StarConditionValue {
			dAtA[i] = 0x88
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(num))
		}
	}
	if m.PassLimit != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.PassLimit))
	}
	if m.Sp != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.Sp))
	}
	if len(m.BallonToolTip) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(len(m.BallonToolTip)))
		i += copy(dAtA[i:], m.BallonToolTip)
	}
	if len(m.NpcName) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(len(m.NpcName)))
		i += copy(dAtA[i:], m.NpcName)
	}
	if m.PreBattleDialogId != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.PreBattleDialogId))
	}
	if m.AfterBattleDialogId != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.AfterBattleDialogId))
	}
	if len(m.NpcIcon) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(len(m.NpcIcon)))
		i += copy(dAtA[i:], m.NpcIcon)
	}
	if len(m.CombatSceneRes) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(len(m.CombatSceneRes)))
		i += copy(dAtA[i:], m.CombatSceneRes)
	}
	if m.ChapterId != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.ChapterId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.Type))
	}
	if m.Prev != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.Prev))
	}
	if m.Next != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.Next))
	}
	if len(m.YuanJunData) > 0 {
		for _, msg := range m.YuanJunData {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PlotIdx) > 0 {
		for _, num := range m.PlotIdx {
			dAtA[i] = 0xa0
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(num))
		}
	}
	if len(m.PlotId) > 0 {
		for _, num := range m.PlotId {
			dAtA[i] = 0xa8
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(num))
		}
	}
	if m.GuideTroop != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.GuideTroop.Size()))
		n6, err := m.GuideTroop.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *DungeonMiscProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DungeonMiscProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxAutoTimes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.MaxAutoTimes))
	}
	if m.RecoverAutoDuration != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.RecoverAutoDuration))
	}
	if m.AutoPerTimes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.AutoPerTimes))
	}
	return i, nil
}

func (m *DungeonGuideTroopDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DungeonGuideTroopDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NotFirst {
		dAtA[i] = 0x8
		i++
		if m.NotFirst {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Captain) > 0 {
		for _, num := range m.Captain {
			dAtA[i] = 0x10
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(num))
		}
	}
	if len(m.SrcPos) > 0 {
		for _, num := range m.SrcPos {
			dAtA[i] = 0x18
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(num))
		}
	}
	if len(m.DstPos) > 0 {
		for _, num := range m.DstPos {
			dAtA[i] = 0x20
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(num))
		}
	}
	if len(m.SrcPosX) > 0 {
		for _, num := range m.SrcPosX {
			dAtA[i] = 0x28
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(num))
		}
	}
	if len(m.DstPosX) > 0 {
		for _, num := range m.DstPosX {
			dAtA[i] = 0x30
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *DungeonChapterStar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DungeonChapterStar) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chapter != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.Chapter))
	}
	if m.Star != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.Star))
	}
	return i, nil
}

func (m *DungeonStar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DungeonStar) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dungeon != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.Dungeon))
	}
	if len(m.EnabledStar) > 0 {
		for _, b := range m.EnabledStar {
			dAtA[i] = 0x10
			i++
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	return i, nil
}

func (m *DungeonPassLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DungeonPassLimit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dungeon != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.Dungeon))
	}
	if m.Times != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.Times))
	}
	return i, nil
}

func (m *CollectedChapterStarPrizes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectedChapterStarPrizes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chapter != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.Chapter))
	}
	if len(m.PrizeIndexs) > 0 {
		for _, num := range m.PrizeIndexs {
			dAtA[i] = 0x10
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *HeroDungeonProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroDungeonProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PassDungeons) > 0 {
		for _, num := range m.PassDungeons {
			dAtA[i] = 0x8
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(num))
		}
	}
	if len(m.CollectedChapterPrizes) > 0 {
		for _, num := range m.CollectedChapterPrizes {
			dAtA[i] = 0x10
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(num))
		}
	}
	if m.AutoRecoverStartTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.AutoRecoverStartTime))
	}
	if m.CollectAutoTimesIndex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.CollectAutoTimesIndex))
	}
	if len(m.CollectedPassDungeonPrizes) > 0 {
		for _, num := range m.CollectedPassDungeonPrizes {
			dAtA[i] = 0x28
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(num))
		}
	}
	if len(m.VipBoughtTimes) > 0 {
		for _, msg := range m.VipBoughtTimes {
			dAtA[i] = 0x42
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DungeonStars) > 0 {
		for _, msg := range m.DungeonStars {
			dAtA[i] = 0x62
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DungeonLimits) > 0 {
		for _, msg := range m.DungeonLimits {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ChapterStars) > 0 {
		for _, msg := range m.ChapterStars {
			dAtA[i] = 0x72
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ChapterStarPrizes) > 0 {
		for _, msg := range m.ChapterStarPrizes {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDungeon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HeroVipBoughtTimes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroVipBoughtTimes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DungeonId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.DungeonId))
	}
	if m.BoughtTimes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDungeon(dAtA, i, uint64(m.BoughtTimes))
	}
	return i, nil
}

func encodeFixed64Dungeon(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Dungeon(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintDungeon(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DungeonChapterProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChapterName)
	if l > 0 {
		n += 1 + l + sovDungeon(uint64(l))
	}
	l = len(m.ChapterDesc)
	if l > 0 {
		n += 1 + l + sovDungeon(uint64(l))
	}
	if m.CaptainSoul != 0 {
		n += 1 + sovDungeon(uint64(m.CaptainSoul))
	}
	if m.Id != 0 {
		n += 1 + sovDungeon(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovDungeon(uint64(m.Type))
	}
	l = len(m.BgImg)
	if l > 0 {
		n += 1 + l + sovDungeon(uint64(l))
	}
	if len(m.DungeonDatas) > 0 {
		for _, e := range m.DungeonDatas {
			l = e.Size()
			n += 1 + l + sovDungeon(uint64(l))
		}
	}
	if m.PassPrize != nil {
		l = m.PassPrize.Size()
		n += 1 + l + sovDungeon(uint64(l))
	}
	if len(m.StarPrize) > 0 {
		for _, e := range m.StarPrize {
			l = e.Size()
			n += 2 + l + sovDungeon(uint64(l))
		}
	}
	if len(m.Star) > 0 {
		for _, e := range m.Star {
			n += 2 + sovDungeon(uint64(e))
		}
	}
	return n
}

func (m *DungeonDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDungeon(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDungeon(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovDungeon(uint64(l))
	}
	if m.UnlockHeroLevel != 0 {
		n += 1 + sovDungeon(uint64(m.UnlockHeroLevel))
	}
	if len(m.UnlockPassDungeon) > 0 {
		for _, e := range m.UnlockPassDungeon {
			n += 1 + sovDungeon(uint64(e))
		}
	}
	if m.UnlockPuzzleIndex != 0 {
		n += 1 + sovDungeon(uint64(m.UnlockPuzzleIndex))
	}
	if m.StoryId != 0 {
		n += 1 + sovDungeon(uint64(m.StoryId))
	}
	if m.DialogId != 0 {
		n += 1 + sovDungeon(uint64(m.DialogId))
	}
	if m.UnlockBayeStage != 0 {
		n += 1 + sovDungeon(uint64(m.UnlockBayeStage))
	}
	if m.ShowPrize != nil {
		l = m.ShowPrize.Size()
		n += 1 + l + sovDungeon(uint64(l))
	}
	if m.Monster != nil {
		l = m.Monster.Size()
		n += 1 + l + sovDungeon(uint64(l))
	}
	if m.PassPrize != nil {
		l = m.PassPrize.Size()
		n += 1 + l + sovDungeon(uint64(l))
	}
	if m.FirstPassPrize != nil {
		l = m.FirstPassPrize.Size()
		n += 1 + l + sovDungeon(uint64(l))
	}
	if m.Star != 0 {
		n += 1 + sovDungeon(uint64(m.Star))
	}
	if len(m.StarCondition) > 0 {
		for _, e := range m.StarCondition {
			n += 2 + sovDungeon(uint64(e))
		}
	}
	if len(m.StarConditionValue) > 0 {
		for _, e := range m.StarConditionValue {
			n += 2 + sovDungeon(uint64(e))
		}
	}
	if m.PassLimit != 0 {
		n += 2 + sovDungeon(uint64(m.PassLimit))
	}
	if m.Sp != 0 {
		n += 2 + sovDungeon(uint64(m.Sp))
	}
	l = len(m.BallonToolTip)
	if l > 0 {
		n += 2 + l + sovDungeon(uint64(l))
	}
	l = len(m.NpcName)
	if l > 0 {
		n += 2 + l + sovDungeon(uint64(l))
	}
	if m.PreBattleDialogId != 0 {
		n += 2 + sovDungeon(uint64(m.PreBattleDialogId))
	}
	if m.AfterBattleDialogId != 0 {
		n += 2 + sovDungeon(uint64(m.AfterBattleDialogId))
	}
	l = len(m.NpcIcon)
	if l > 0 {
		n += 2 + l + sovDungeon(uint64(l))
	}
	l = len(m.CombatSceneRes)
	if l > 0 {
		n += 2 + l + sovDungeon(uint64(l))
	}
	if m.ChapterId != 0 {
		n += 2 + sovDungeon(uint64(m.ChapterId))
	}
	if m.Type != 0 {
		n += 2 + sovDungeon(uint64(m.Type))
	}
	if m.Prev != 0 {
		n += 2 + sovDungeon(uint64(m.Prev))
	}
	if m.Next != 0 {
		n += 2 + sovDungeon(uint64(m.Next))
	}
	if len(m.YuanJunData) > 0 {
		for _, e := range m.YuanJunData {
			l = e.Size()
			n += 2 + l + sovDungeon(uint64(l))
		}
	}
	if len(m.PlotIdx) > 0 {
		for _, e := range m.PlotIdx {
			n += 2 + sovDungeon(uint64(e))
		}
	}
	if len(m.PlotId) > 0 {
		for _, e := range m.PlotId {
			n += 2 + sovDungeon(uint64(e))
		}
	}
	if m.GuideTroop != nil {
		l = m.GuideTroop.Size()
		n += 2 + l + sovDungeon(uint64(l))
	}
	return n
}

func (m *DungeonMiscProto) Size() (n int) {
	var l int
	_ = l
	if m.MaxAutoTimes != 0 {
		n += 1 + sovDungeon(uint64(m.MaxAutoTimes))
	}
	if m.RecoverAutoDuration != 0 {
		n += 1 + sovDungeon(uint64(m.RecoverAutoDuration))
	}
	if m.AutoPerTimes != 0 {
		n += 1 + sovDungeon(uint64(m.AutoPerTimes))
	}
	return n
}

func (m *DungeonGuideTroopDataProto) Size() (n int) {
	var l int
	_ = l
	if m.NotFirst {
		n += 2
	}
	if len(m.Captain) > 0 {
		for _, e := range m.Captain {
			n += 1 + sovDungeon(uint64(e))
		}
	}
	if len(m.SrcPos) > 0 {
		for _, e := range m.SrcPos {
			n += 1 + sovDungeon(uint64(e))
		}
	}
	if len(m.DstPos) > 0 {
		for _, e := range m.DstPos {
			n += 1 + sovDungeon(uint64(e))
		}
	}
	if len(m.SrcPosX) > 0 {
		for _, e := range m.SrcPosX {
			n += 1 + sovDungeon(uint64(e))
		}
	}
	if len(m.DstPosX) > 0 {
		for _, e := range m.DstPosX {
			n += 1 + sovDungeon(uint64(e))
		}
	}
	return n
}

func (m *DungeonChapterStar) Size() (n int) {
	var l int
	_ = l
	if m.Chapter != 0 {
		n += 1 + sovDungeon(uint64(m.Chapter))
	}
	if m.Star != 0 {
		n += 1 + sovDungeon(uint64(m.Star))
	}
	return n
}

func (m *DungeonStar) Size() (n int) {
	var l int
	_ = l
	if m.Dungeon != 0 {
		n += 1 + sovDungeon(uint64(m.Dungeon))
	}
	if len(m.EnabledStar) > 0 {
		n += 2 * len(m.EnabledStar)
	}
	return n
}

func (m *DungeonPassLimit) Size() (n int) {
	var l int
	_ = l
	if m.Dungeon != 0 {
		n += 1 + sovDungeon(uint64(m.Dungeon))
	}
	if m.Times != 0 {
		n += 1 + sovDungeon(uint64(m.Times))
	}
	return n
}

func (m *CollectedChapterStarPrizes) Size() (n int) {
	var l int
	_ = l
	if m.Chapter != 0 {
		n += 1 + sovDungeon(uint64(m.Chapter))
	}
	if len(m.PrizeIndexs) > 0 {
		for _, e := range m.PrizeIndexs {
			n += 1 + sovDungeon(uint64(e))
		}
	}
	return n
}

func (m *HeroDungeonProto) Size() (n int) {
	var l int
	_ = l
	if len(m.PassDungeons) > 0 {
		for _, e := range m.PassDungeons {
			n += 1 + sovDungeon(uint64(e))
		}
	}
	if len(m.CollectedChapterPrizes) > 0 {
		for _, e := range m.CollectedChapterPrizes {
			n += 1 + sovDungeon(uint64(e))
		}
	}
	if m.AutoRecoverStartTime != 0 {
		n += 1 + sovDungeon(uint64(m.AutoRecoverStartTime))
	}
	if m.CollectAutoTimesIndex != 0 {
		n += 1 + sovDungeon(uint64(m.CollectAutoTimesIndex))
	}
	if len(m.CollectedPassDungeonPrizes) > 0 {
		for _, e := range m.CollectedPassDungeonPrizes {
			n += 1 + sovDungeon(uint64(e))
		}
	}
	if len(m.VipBoughtTimes) > 0 {
		for _, e := range m.VipBoughtTimes {
			l = e.Size()
			n += 1 + l + sovDungeon(uint64(l))
		}
	}
	if len(m.DungeonStars) > 0 {
		for _, e := range m.DungeonStars {
			l = e.Size()
			n += 1 + l + sovDungeon(uint64(l))
		}
	}
	if len(m.DungeonLimits) > 0 {
		for _, e := range m.DungeonLimits {
			l = e.Size()
			n += 1 + l + sovDungeon(uint64(l))
		}
	}
	if len(m.ChapterStars) > 0 {
		for _, e := range m.ChapterStars {
			l = e.Size()
			n += 1 + l + sovDungeon(uint64(l))
		}
	}
	if len(m.ChapterStarPrizes) > 0 {
		for _, e := range m.ChapterStarPrizes {
			l = e.Size()
			n += 2 + l + sovDungeon(uint64(l))
		}
	}
	return n
}

func (m *HeroVipBoughtTimes) Size() (n int) {
	var l int
	_ = l
	if m.DungeonId != 0 {
		n += 1 + sovDungeon(uint64(m.DungeonId))
	}
	if m.BoughtTimes != 0 {
		n += 1 + sovDungeon(uint64(m.BoughtTimes))
	}
	return n
}

func sovDungeon(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDungeon(x uint64) (n int) {
	return sovDungeon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DungeonChapterProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDungeon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DungeonChapterProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DungeonChapterProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChapterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapterDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChapterDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainSoul", wireType)
			}
			m.CaptainSoul = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainSoul |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (DifficultType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgImg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgImg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DungeonDatas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DungeonDatas = append(m.DungeonDatas, &DungeonDataProto{})
			if err := m.DungeonDatas[len(m.DungeonDatas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PassPrize == nil {
				m.PassPrize = &PrizeProto{}
			}
			if err := m.PassPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StarPrize = append(m.StarPrize, &PrizeProto{})
			if err := m.StarPrize[len(m.StarPrize)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Star = append(m.Star, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDungeon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDungeon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Star = append(m.Star, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDungeon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDungeon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DungeonDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDungeon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DungeonDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DungeonDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockHeroLevel", wireType)
			}
			m.UnlockHeroLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnlockHeroLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnlockPassDungeon = append(m.UnlockPassDungeon, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDungeon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDungeon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnlockPassDungeon = append(m.UnlockPassDungeon, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockPassDungeon", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockPuzzleIndex", wireType)
			}
			m.UnlockPuzzleIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnlockPuzzleIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoryId", wireType)
			}
			m.StoryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoryId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DialogId", wireType)
			}
			m.DialogId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DialogId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockBayeStage", wireType)
			}
			m.UnlockBayeStage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnlockBayeStage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowPrize == nil {
				m.ShowPrize = &PrizeProto{}
			}
			if err := m.ShowPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Monster == nil {
				m.Monster = &MonsterMasterDataProto{}
			}
			if err := m.Monster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PassPrize == nil {
				m.PassPrize = &PrizeProto{}
			}
			if err := m.PassPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstPassPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FirstPassPrize == nil {
				m.FirstPassPrize = &PrizeProto{}
			}
			if err := m.FirstPassPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StarCondition = append(m.StarCondition, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDungeon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDungeon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StarCondition = append(m.StarCondition, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StarCondition", wireType)
			}
		case 17:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StarConditionValue = append(m.StarConditionValue, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDungeon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDungeon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StarConditionValue = append(m.StarConditionValue, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StarConditionValue", wireType)
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassLimit", wireType)
			}
			m.PassLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PassLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sp", wireType)
			}
			m.Sp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BallonToolTip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BallonToolTip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NpcName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NpcName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreBattleDialogId", wireType)
			}
			m.PreBattleDialogId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreBattleDialogId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterBattleDialogId", wireType)
			}
			m.AfterBattleDialogId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AfterBattleDialogId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NpcIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NpcIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CombatSceneRes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CombatSceneRes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapterId", wireType)
			}
			m.ChapterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChapterId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (DifficultType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prev", wireType)
			}
			m.Prev = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prev |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			m.Next = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Next |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YuanJunData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.YuanJunData = append(m.YuanJunData, &MonsterCaptainDataProto{})
			if err := m.YuanJunData[len(m.YuanJunData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PlotIdx = append(m.PlotIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDungeon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDungeon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PlotIdx = append(m.PlotIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PlotIdx", wireType)
			}
		case 37:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PlotId = append(m.PlotId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDungeon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDungeon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PlotId = append(m.PlotId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PlotId", wireType)
			}
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuideTroop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GuideTroop == nil {
				m.GuideTroop = &DungeonGuideTroopDataProto{}
			}
			if err := m.GuideTroop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDungeon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDungeon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DungeonMiscProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDungeon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DungeonMiscProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DungeonMiscProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAutoTimes", wireType)
			}
			m.MaxAutoTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAutoTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverAutoDuration", wireType)
			}
			m.RecoverAutoDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecoverAutoDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoPerTimes", wireType)
			}
			m.AutoPerTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoPerTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDungeon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDungeon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DungeonGuideTroopDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDungeon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DungeonGuideTroopDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DungeonGuideTroopDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotFirst", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotFirst = bool(v != 0)
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Captain = append(m.Captain, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDungeon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDungeon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Captain = append(m.Captain, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Captain", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SrcPos = append(m.SrcPos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDungeon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDungeon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SrcPos = append(m.SrcPos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPos", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DstPos = append(m.DstPos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDungeon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDungeon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DstPos = append(m.DstPos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPos", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SrcPosX = append(m.SrcPosX, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDungeon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDungeon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SrcPosX = append(m.SrcPosX, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPosX", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DstPosX = append(m.DstPosX, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDungeon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDungeon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DstPosX = append(m.DstPosX, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPosX", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDungeon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDungeon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DungeonChapterStar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDungeon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DungeonChapterStar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DungeonChapterStar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chapter", wireType)
			}
			m.Chapter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chapter |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDungeon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDungeon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DungeonStar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDungeon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DungeonStar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DungeonStar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dungeon", wireType)
			}
			m.Dungeon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dungeon |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EnabledStar = append(m.EnabledStar, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDungeon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDungeon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EnabledStar = append(m.EnabledStar, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EnabledStar", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDungeon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDungeon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DungeonPassLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDungeon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DungeonPassLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DungeonPassLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dungeon", wireType)
			}
			m.Dungeon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dungeon |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Times", wireType)
			}
			m.Times = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Times |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDungeon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDungeon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectedChapterStarPrizes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDungeon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectedChapterStarPrizes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectedChapterStarPrizes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chapter", wireType)
			}
			m.Chapter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chapter |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrizeIndexs = append(m.PrizeIndexs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDungeon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDungeon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrizeIndexs = append(m.PrizeIndexs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrizeIndexs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDungeon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDungeon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroDungeonProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDungeon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroDungeonProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroDungeonProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PassDungeons = append(m.PassDungeons, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDungeon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDungeon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PassDungeons = append(m.PassDungeons, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PassDungeons", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CollectedChapterPrizes = append(m.CollectedChapterPrizes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDungeon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDungeon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CollectedChapterPrizes = append(m.CollectedChapterPrizes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedChapterPrizes", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRecoverStartTime", wireType)
			}
			m.AutoRecoverStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoRecoverStartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectAutoTimesIndex", wireType)
			}
			m.CollectAutoTimesIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectAutoTimesIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CollectedPassDungeonPrizes = append(m.CollectedPassDungeonPrizes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDungeon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDungeon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CollectedPassDungeonPrizes = append(m.CollectedPassDungeonPrizes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedPassDungeonPrizes", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipBoughtTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VipBoughtTimes = append(m.VipBoughtTimes, &HeroVipBoughtTimes{})
			if err := m.VipBoughtTimes[len(m.VipBoughtTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DungeonStars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DungeonStars = append(m.DungeonStars, &DungeonStar{})
			if err := m.DungeonStars[len(m.DungeonStars)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DungeonLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DungeonLimits = append(m.DungeonLimits, &DungeonPassLimit{})
			if err := m.DungeonLimits[len(m.DungeonLimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapterStars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChapterStars = append(m.ChapterStars, &DungeonChapterStar{})
			if err := m.ChapterStars[len(m.ChapterStars)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapterStarPrizes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDungeon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChapterStarPrizes = append(m.ChapterStarPrizes, &CollectedChapterStarPrizes{})
			if err := m.ChapterStarPrizes[len(m.ChapterStarPrizes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDungeon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDungeon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroVipBoughtTimes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDungeon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroVipBoughtTimes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroVipBoughtTimes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DungeonId", wireType)
			}
			m.DungeonId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DungeonId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoughtTimes", wireType)
			}
			m.BoughtTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BoughtTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDungeon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDungeon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDungeon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDungeon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDungeon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDungeon
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDungeon
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDungeon(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDungeon = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDungeon   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/shared_proto/dungeon.proto", fileDescriptorDungeon)
}

var fileDescriptorDungeon = []byte{
	// 1451 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x57, 0x4d, 0x6f, 0x1b, 0x37,
	0x13, 0x8e, 0x64, 0xcb, 0x92, 0xa8, 0x0f, 0xcb, 0xf4, 0x47, 0x18, 0xe7, 0xb5, 0x5f, 0x45, 0x6f,
	0x92, 0x57, 0xcd, 0xc1, 0x2e, 0x9c, 0x04, 0x3e, 0x34, 0x28, 0x10, 0xd9, 0x69, 0xa3, 0x22, 0x49,
	0x5d, 0xd9, 0x08, 0xd2, 0x02, 0x05, 0x41, 0xed, 0xd2, 0x32, 0xdb, 0xd5, 0x72, 0xb1, 0xe4, 0x3a,
	0x72, 0x6e, 0x3d, 0xf6, 0xda, 0x53, 0x7f, 0x52, 0x8f, 0xed, 0x2f, 0x68, 0x91, 0xfe, 0x91, 0x82,
	0x43, 0xee, 0x87, 0x9c, 0xb8, 0x4d, 0x2f, 0xd6, 0x72, 0x66, 0x1e, 0x72, 0x86, 0xf3, 0xf0, 0x21,
	0x8d, 0xf6, 0x27, 0x42, 0x9f, 0x25, 0xe3, 0x1d, 0x4f, 0x4e, 0x77, 0x03, 0x31, 0x39, 0xd3, 0x11,
	0x7b, 0xbd, 0x3b, 0x65, 0x01, 0xdf, 0xdf, 0x8d, 0xc6, 0xbb, 0xea, 0x8c, 0xc5, 0xdc, 0xa7, 0x51,
	0x2c, 0xb5, 0xdc, 0xf5, 0x93, 0x70, 0xc2, 0x65, 0xb8, 0x03, 0x23, 0x5c, 0x81, 0x9f, 0xcd, 0x07,
	0x1f, 0x8e, 0x1f, 0x33, 0xc5, 0x2d, 0x78, 0xf3, 0x5f, 0xac, 0x3a, 0x95, 0xa1, 0xd2, 0x3c, 0xb6,
	0xc0, 0xde, 0x8f, 0x0b, 0x68, 0xf5, 0xd0, 0xe6, 0x71, 0x70, 0xc6, 0x22, 0xcd, 0xe3, 0x23, 0xc8,
	0xe6, 0x16, 0x6a, 0x7a, 0x76, 0x4c, 0x43, 0x36, 0xe5, 0xa4, 0xdc, 0x2d, 0xf5, 0xeb, 0xa3, 0x86,
	0xb3, 0xbd, 0x60, 0x53, 0x5e, 0x0c, 0xf1, 0xb9, 0xf2, 0xc8, 0xc2, 0x5c, 0xc8, 0x21, 0x57, 0x1e,
	0x84, 0xb0, 0x48, 0x33, 0x11, 0x52, 0x25, 0x93, 0x80, 0x54, 0xba, 0xa5, 0x7e, 0x65, 0xd4, 0x70,
	0xb6, 0x63, 0x99, 0x04, 0xb8, 0x8d, 0xca, 0xc2, 0x27, 0x08, 0x1c, 0x65, 0xe1, 0xe3, 0x3e, 0x5a,
	0xd4, 0x17, 0x11, 0x27, 0xcd, 0x6e, 0xa9, 0xdf, 0xde, 0x5b, 0xb3, 0x69, 0xee, 0x1c, 0x8a, 0xd3,
	0x53, 0xe1, 0x25, 0x81, 0x3e, 0xb9, 0x88, 0xf8, 0x08, 0x22, 0xf0, 0x3a, 0x5a, 0x1a, 0x4f, 0xa8,
	0x98, 0x4e, 0x48, 0x0b, 0x56, 0xae, 0x8c, 0x27, 0xc3, 0xe9, 0x04, 0x3f, 0x42, 0x2d, 0xb7, 0xb1,
	0xd4, 0x67, 0x9a, 0x29, 0xd2, 0xee, 0x2e, 0xf4, 0x1b, 0x7b, 0xd7, 0xd3, 0x99, 0xac, 0xef, 0x90,
	0x69, 0x06, 0x95, 0x8e, 0x9a, 0x7e, 0x6e, 0x51, 0xf8, 0x63, 0x84, 0x22, 0xa6, 0x14, 0x8d, 0x62,
	0xf1, 0x86, 0x93, 0xe5, 0x6e, 0xa9, 0xdf, 0xd8, 0x5b, 0x71, 0xd0, 0x23, 0x63, 0xb3, 0xa0, 0xba,
	0x09, 0x82, 0xb1, 0x41, 0x28, 0xcd, 0x62, 0x87, 0xe8, 0xc0, 0x62, 0xef, 0x43, 0x98, 0x20, 0x8b,
	0xd8, 0x40, 0x8b, 0x66, 0x40, 0x56, 0xba, 0x0b, 0xfd, 0xca, 0xa0, 0xdc, 0xb9, 0x36, 0x82, 0x71,
	0xef, 0xf7, 0x3a, 0xea, 0x5c, 0x4e, 0xcf, 0xed, 0x4f, 0x29, 0xdb, 0x1f, 0x8c, 0x16, 0x0b, 0x0d,
	0x81, 0x6f, 0x63, 0x2b, 0x74, 0x00, 0xbe, 0xf1, 0x3d, 0xb4, 0x92, 0x84, 0x81, 0xf4, 0xbe, 0xa7,
	0x67, 0x3c, 0x96, 0x34, 0xe0, 0xe7, 0x3c, 0x20, 0x8b, 0x30, 0xcd, 0xb2, 0x75, 0x3c, 0xe5, 0xb1,
	0x7c, 0x66, 0xcc, 0x78, 0x0f, 0xad, 0xba, 0x58, 0xa8, 0xdd, 0x6d, 0x08, 0xa9, 0x64, 0xf9, 0xb9,
	0xa9, 0x8e, 0x98, 0x52, 0x2e, 0x41, 0xbc, 0x93, 0x63, 0x92, 0x37, 0x6f, 0x02, 0x4e, 0x45, 0xe8,
	0xf3, 0x19, 0x59, 0x82, 0x15, 0xd2, 0x78, 0xf0, 0x0c, 0x8d, 0x03, 0xdf, 0x40, 0x35, 0xa5, 0x65,
	0x7c, 0x41, 0x85, 0x4f, 0xaa, 0x10, 0x54, 0x85, 0xf1, 0xd0, 0xc7, 0x37, 0x51, 0xdd, 0x17, 0x2c,
	0x90, 0x13, 0xe3, 0xab, 0x81, 0xaf, 0x66, 0x0d, 0x43, 0xbf, 0x50, 0xc7, 0x98, 0x5d, 0x70, 0xaa,
	0x34, 0x9b, 0x70, 0x52, 0x2f, 0xd6, 0x31, 0x60, 0x17, 0xfc, 0xd8, 0x98, 0xa1, 0x15, 0x67, 0xf2,
	0xb5, 0x6b, 0x45, 0xe3, 0xca, 0xe6, 0x99, 0x20, 0xdb, 0x8a, 0x7d, 0x54, 0x75, 0xe7, 0x01, 0x08,
	0xd7, 0xd8, 0xdb, 0x72, 0xe1, 0xcf, 0xad, 0xf5, 0x39, 0x33, 0x7f, 0x73, 0xb2, 0xa4, 0xd1, 0x97,
	0x78, 0xd2, 0xfa, 0x00, 0x9e, 0x7c, 0x82, 0x3a, 0xa7, 0x22, 0x56, 0x9a, 0x16, 0x70, 0xed, 0xab,
	0x70, 0x6d, 0x08, 0x3d, 0xca, 0xc0, 0xd8, 0x51, 0x66, 0x19, 0x0a, 0x87, 0x6f, 0xfc, 0x11, 0x6a,
	0x03, 0xf1, 0x3c, 0x19, 0xfa, 0x42, 0x0b, 0x19, 0x02, 0xf9, 0x6c, 0xc3, 0x5a, 0xc6, 0x73, 0x90,
	0x3a, 0xf0, 0x03, 0xb4, 0x36, 0x1f, 0x4a, 0xcf, 0x59, 0x90, 0xf0, 0x02, 0x03, 0xf1, 0x1c, 0xe0,
	0xa5, 0xf1, 0xe2, 0x2d, 0x57, 0x63, 0x20, 0xa6, 0x42, 0x13, 0x0c, 0x4b, 0x43, 0x41, 0xcf, 0x8c,
	0xc1, 0x30, 0x53, 0x45, 0x64, 0xd5, 0x32, 0x53, 0x45, 0xf8, 0x2e, 0x5a, 0x1e, 0xb3, 0x20, 0x90,
	0x21, 0xd5, 0x52, 0x06, 0x54, 0x8b, 0x88, 0xac, 0x01, 0x21, 0x5b, 0xd6, 0x7c, 0x22, 0x65, 0x70,
	0x22, 0x22, 0xc3, 0x84, 0x30, 0xf2, 0xac, 0xac, 0xac, 0x43, 0x40, 0x35, 0x8c, 0x3c, 0x90, 0x94,
	0x5d, 0xb4, 0x16, 0xc5, 0x9c, 0x8e, 0x99, 0xd6, 0x01, 0xa7, 0x39, 0x29, 0x36, 0x2c, 0xab, 0xa2,
	0x98, 0x0f, 0xc0, 0x75, 0x98, 0xb2, 0xe3, 0x3e, 0xda, 0x60, 0xa7, 0x46, 0x81, 0xde, 0x81, 0x5c,
	0x07, 0xc8, 0x2a, 0x78, 0x2f, 0x81, 0x5c, 0x02, 0xc2, 0x93, 0x21, 0x21, 0x59, 0x02, 0x43, 0x4f,
	0x86, 0xb8, 0x8f, 0x3a, 0x9e, 0x9c, 0x8e, 0x99, 0xa6, 0xca, 0xe3, 0x21, 0xa7, 0x31, 0x57, 0xe4,
	0x06, 0x84, 0xb4, 0xad, 0xfd, 0xd8, 0x98, 0x47, 0x5c, 0x99, 0xcd, 0x49, 0xd5, 0x4f, 0xf8, 0xe4,
	0xbf, 0x76, 0x73, 0x9c, 0x65, 0x98, 0xcb, 0x58, 0xf7, 0x1f, 0x65, 0x0c, 0xa3, 0xc5, 0x28, 0xe6,
	0xe7, 0xe4, 0x96, 0x6d, 0xad, 0xf9, 0x86, 0x43, 0xce, 0x67, 0x9a, 0xf4, 0xac, 0xcd, 0x7c, 0xe3,
	0x01, 0x6a, 0x5d, 0x24, 0x2c, 0xa4, 0xdf, 0x25, 0x56, 0xd8, 0xc8, 0xff, 0x40, 0x6a, 0xb6, 0xe7,
	0x09, 0x7b, 0x60, 0xa5, 0x35, 0x67, 0x6c, 0xc3, 0x80, 0xbe, 0x48, 0xc0, 0x82, 0xb7, 0x50, 0x2d,
	0x0a, 0xa4, 0xa6, 0xc2, 0x9f, 0x91, 0xdb, 0x59, 0xef, 0xab, 0xc6, 0x36, 0xf4, 0x67, 0xf8, 0x26,
	0xaa, 0x3a, 0x37, 0xb9, 0x93, 0x79, 0x97, 0xac, 0x17, 0x0f, 0x50, 0x63, 0x92, 0x08, 0x9f, 0x53,
	0x1d, 0x4b, 0x19, 0x91, 0xbb, 0x40, 0xdd, 0x5b, 0xf3, 0xaa, 0xfa, 0xb9, 0x09, 0x38, 0x31, 0xfe,
	0x3c, 0x01, 0x34, 0xc9, 0x8c, 0xbd, 0x9f, 0x4a, 0x99, 0xc2, 0x3d, 0x17, 0xca, 0xb3, 0x0a, 0x77,
	0x1b, 0xb5, 0xa7, 0x6c, 0x46, 0x59, 0xa2, 0x25, 0xd5, 0x62, 0xca, 0x95, 0x53, 0xbb, 0xe6, 0x94,
	0xcd, 0x1e, 0x27, 0x5a, 0x9e, 0x18, 0x1b, 0xde, 0x43, 0xeb, 0x31, 0xf7, 0xe4, 0x39, 0x8f, 0x6d,
	0xa4, 0x9f, 0xc4, 0x0c, 0x48, 0x5f, 0xb6, 0x8d, 0x76, 0x4e, 0x03, 0x38, 0x74, 0x2e, 0x33, 0x33,
	0xc4, 0x46, 0x3c, 0x76, 0x33, 0x2f, 0xd8, 0x99, 0x8d, 0xf5, 0x88, 0xc7, 0x30, 0x73, 0xef, 0xb7,
	0x12, 0xda, 0xbc, 0x3a, 0x7f, 0xa3, 0x4e, 0xa1, 0xd4, 0x14, 0x0e, 0x24, 0x64, 0x56, 0x1b, 0xd5,
	0x42, 0xa9, 0x3f, 0x33, 0x63, 0xfc, 0x1f, 0x54, 0x75, 0x97, 0x19, 0x29, 0xe7, 0xfb, 0xe9, 0x4c,
	0x66, 0x3f, 0x55, 0xec, 0xd1, 0x48, 0x9a, 0x85, 0xb3, 0xfd, 0x54, 0xb1, 0x77, 0x24, 0x95, 0x71,
	0xfa, 0x46, 0x0d, 0xa4, 0x22, 0x8b, 0xb9, 0xd3, 0x57, 0xda, 0x38, 0xb7, 0x51, 0xdd, 0x21, 0xe9,
	0xac, 0xa0, 0xc3, 0x55, 0x8b, 0x7d, 0x65, 0xfc, 0x0e, 0x4c, 0x8d, 0xe6, 0x66, 0x7e, 0x0b, 0x7f,
	0xd5, 0x1b, 0x20, 0x3c, 0x7f, 0xab, 0x1f, 0x1b, 0xc5, 0x20, 0xa8, 0xea, 0x18, 0xea, 0xb6, 0x38,
	0x1d, 0x66, 0xfa, 0x52, 0xce, 0xf5, 0xa5, 0xf7, 0x02, 0x35, 0xdc, 0x1c, 0x29, 0x38, 0xbd, 0x18,
	0x1c, 0xd8, 0x0d, 0xf1, 0x1d, 0xd4, 0xe4, 0x21, 0x1b, 0x07, 0xdc, 0xa7, 0x6e, 0x92, 0x85, 0x7e,
	0x0d, 0xf2, 0x69, 0x38, 0xbb, 0x99, 0xa0, 0x37, 0xc8, 0x7a, 0x7f, 0x94, 0x69, 0xc8, 0xd5, 0x93,
	0xae, 0xa1, 0x8a, 0x6d, 0x99, 0x4d, 0xc9, 0x0e, 0x7a, 0xdf, 0xa2, 0xcd, 0x03, 0x19, 0x04, 0xdc,
	0xd3, 0xdc, 0x2f, 0x54, 0x06, 0x22, 0xa9, 0xfe, 0xa6, 0xbe, 0x3b, 0xa8, 0x09, 0x8a, 0x6b, 0x6f,
	0x29, 0x55, 0x68, 0x56, 0x03, 0xec, 0x70, 0x47, 0xa9, 0xde, 0x0f, 0x15, 0xd4, 0x31, 0xd7, 0x62,
	0x9a, 0x27, 0x10, 0xe0, 0xff, 0xa8, 0x55, 0xbc, 0x16, 0x0d, 0x3d, 0x53, 0x70, 0x33, 0xca, 0x6f,
	0x44, 0x85, 0x1f, 0x21, 0xe2, 0xa5, 0xc9, 0xd1, 0x54, 0x1c, 0x60, 0xfa, 0xe2, 0x82, 0x1b, 0xde,
	0xa5, 0x02, 0x5c, 0xf2, 0x0f, 0xd1, 0x75, 0x20, 0x6b, 0xca, 0x72, 0xb3, 0x95, 0x1a, 0x68, 0xeb,
	0x58, 0xbb, 0x66, 0xdc, 0x23, 0xeb, 0x35, 0x45, 0x6b, 0x43, 0x5f, 0xbc, 0x9f, 0x2d, 0x5a, 0x38,
	0x41, 0xee, 0x32, 0xb6, 0xd7, 0xfd, 0xba, 0xf3, 0x67, 0x67, 0xc9, 0x5e, 0xc8, 0x4f, 0xd0, 0x56,
	0x9e, 0x6d, 0xb1, 0xc0, 0x34, 0xe5, 0x9c, 0x76, 0x9b, 0x59, 0x60, 0xe1, 0x05, 0xe0, 0xd2, 0x3e,
	0x40, 0x9d, 0x73, 0x11, 0xd1, 0xb1, 0x4c, 0x26, 0x67, 0xda, 0x9d, 0xb2, 0x1a, 0x28, 0xd3, 0x0d,
	0xa7, 0x0d, 0x66, 0x43, 0x5f, 0x8a, 0x68, 0x00, 0x11, 0x90, 0xc0, 0xa8, 0x7d, 0x3e, 0x37, 0xc6,
	0xfb, 0xf9, 0x9b, 0xcd, 0x94, 0xad, 0x48, 0x13, 0x66, 0xc0, 0xf3, 0xea, 0x62, 0x8a, 0xce, 0x9e,
	0x6b, 0x66, 0xa0, 0xf0, 0xa7, 0xa8, 0x9d, 0x02, 0xe1, 0x96, 0x52, 0xa4, 0xf5, 0xbe, 0xd7, 0x5e,
	0x46, 0xb8, 0x51, 0xba, 0x0e, 0x8c, 0x0c, 0xbe, 0x95, 0x36, 0xca, 0x2e, 0xdc, 0x9e, 0x4b, 0xfd,
	0xdd, 0x33, 0x34, 0x4a, 0xdf, 0xbc, 0x76, 0xfd, 0xaf, 0xd0, 0x6a, 0x11, 0x9f, 0x6e, 0x9d, 0x7d,
	0x05, 0xa6, 0xe2, 0x78, 0x35, 0x63, 0x47, 0x2b, 0xde, 0x65, 0x53, 0xef, 0x25, 0xc2, 0xef, 0xee,
	0x98, 0xb9, 0x6e, 0xd2, 0x42, 0xb3, 0xe7, 0x60, 0xdd, 0x59, 0x86, 0xbe, 0x79, 0x68, 0xcf, 0x75,
	0xc0, 0x32, 0xa6, 0x31, 0xce, 0x67, 0xb8, 0xf7, 0x10, 0xb5, 0xe6, 0xae, 0x1f, 0xdc, 0x40, 0xd5,
	0x61, 0x78, 0xce, 0x02, 0xe1, 0x77, 0xae, 0xe1, 0x26, 0xaa, 0x7d, 0x39, 0x3a, 0x1c, 0xbe, 0x78,
	0x3c, 0xfa, 0xba, 0x53, 0xc2, 0x75, 0x54, 0x79, 0xf2, 0x6c, 0x78, 0xf2, 0xa4, 0x53, 0x1e, 0x74,
	0x7f, 0x79, 0xbb, 0x5d, 0xfa, 0xf5, 0xed, 0x76, 0xe9, 0x8f, 0xb7, 0xdb, 0xa5, 0x9f, 0xff, 0xdc,
	0xbe, 0xf6, 0xb4, 0xf4, 0x4d, 0xb3, 0xf8, 0x0f, 0xc5, 0x78, 0x09, 0x7e, 0xee, 0xff, 0x15, 0x00,
	0x00, 0xff, 0xff, 0xcf, 0xe6, 0xe3, 0xf2, 0xfa, 0x0c, 0x00, 0x00,
}
