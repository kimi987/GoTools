// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/shared_proto/spell.proto
// DO NOT EDIT!

package shared_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type SpellTargetType int32

const (
	SpellTargetType_InvalidSpellTarget SpellTargetType = 0
	SpellTargetType_STEnemy            SpellTargetType = 1
	SpellTargetType_STFriend           SpellTargetType = 2
	SpellTargetType_STSelf             SpellTargetType = 3
)

var SpellTargetType_name = map[int32]string{
	0: "InvalidSpellTarget",
	1: "STEnemy",
	2: "STFriend",
	3: "STSelf",
}
var SpellTargetType_value = map[string]int32{
	"InvalidSpellTarget": 0,
	"STEnemy":            1,
	"STFriend":           2,
	"STSelf":             3,
}

func (x SpellTargetType) String() string {
	return proto.EnumName(SpellTargetType_name, int32(x))
}
func (SpellTargetType) EnumDescriptor() ([]byte, []int) { return fileDescriptorSpell, []int{0} }

type SpellTargetSubType int32

const (
	SpellTargetSubType_SSTNone           SpellTargetSubType = 0
	SpellTargetSubType_SSTRandom         SpellTargetSubType = 1
	SpellTargetSubType_STTMaxLifePercent SpellTargetSubType = 2
	SpellTargetSubType_STTMinLifePercent SpellTargetSubType = 3
	SpellTargetSubType_SSTMaxRage        SpellTargetSubType = 4
	SpellTargetSubType_SSTMinRage        SpellTargetSubType = 5
)

var SpellTargetSubType_name = map[int32]string{
	0: "SSTNone",
	1: "SSTRandom",
	2: "STTMaxLifePercent",
	3: "STTMinLifePercent",
	4: "SSTMaxRage",
	5: "SSTMinRage",
}
var SpellTargetSubType_value = map[string]int32{
	"SSTNone":           0,
	"SSTRandom":         1,
	"STTMaxLifePercent": 2,
	"STTMinLifePercent": 3,
	"SSTMaxRage":        4,
	"SSTMinRage":        5,
}

func (x SpellTargetSubType) String() string {
	return proto.EnumName(SpellTargetSubType_name, int32(x))
}
func (SpellTargetSubType) EnumDescriptor() ([]byte, []int) { return fileDescriptorSpell, []int{1} }

type StateStackType int32

const (
	StateStackType_SSNone    StateStackType = 0
	StateStackType_SSReplace StateStackType = 1
	StateStackType_SSStack   StateStackType = 2
)

var StateStackType_name = map[int32]string{
	0: "SSNone",
	1: "SSReplace",
	2: "SSStack",
}
var StateStackType_value = map[string]int32{
	"SSNone":    0,
	"SSReplace": 1,
	"SSStack":   2,
}

func (x StateStackType) String() string {
	return proto.EnumName(StateStackType_name, int32(x))
}
func (StateStackType) EnumDescriptor() ([]byte, []int) { return fileDescriptorSpell, []int{2} }

type SpellTriggerType int32

const (
	SpellTriggerType_STNone           SpellTriggerType = 0
	SpellTriggerType_STBeginRelease   SpellTriggerType = 1
	SpellTriggerType_STFirstHit       SpellTriggerType = 2
	SpellTriggerType_STHitN           SpellTriggerType = 3
	SpellTriggerType_STBeenHit        SpellTriggerType = 4
	SpellTriggerType_STShieldBroken   SpellTriggerType = 5
	SpellTriggerType_STFirstHitTarget SpellTriggerType = 6
)

var SpellTriggerType_name = map[int32]string{
	0: "STNone",
	1: "STBeginRelease",
	2: "STFirstHit",
	3: "STHitN",
	4: "STBeenHit",
	5: "STShieldBroken",
	6: "STFirstHitTarget",
}
var SpellTriggerType_value = map[string]int32{
	"STNone":           0,
	"STBeginRelease":   1,
	"STFirstHit":       2,
	"STHitN":           3,
	"STBeenHit":        4,
	"STShieldBroken":   5,
	"STFirstHitTarget": 6,
}

func (x SpellTriggerType) String() string {
	return proto.EnumName(SpellTriggerType_name, int32(x))
}
func (SpellTriggerType) EnumDescriptor() ([]byte, []int) { return fileDescriptorSpell, []int{3} }

type SpellProto struct {
	Id     int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name   string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	IconId string `protobuf:"bytes,5,opt,name=icon_id,json=iconId,proto3" json:"icon_id,omitempty"`
	Desc   string `protobuf:"bytes,4,opt,name=desc,proto3" json:"desc,omitempty"`
}

func (m *SpellProto) Reset()                    { *m = SpellProto{} }
func (m *SpellProto) String() string            { return proto.CompactTextString(m) }
func (*SpellProto) ProtoMessage()               {}
func (*SpellProto) Descriptor() ([]byte, []int) { return fileDescriptorSpell, []int{0} }

func (m *SpellProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SpellProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SpellProto) GetIconId() string {
	if m != nil {
		return m.IconId
	}
	return ""
}

func (m *SpellProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

type SpellIdProto struct {
	Id           int32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Spell        int32   `protobuf:"varint,2,opt,name=spell,proto3" json:"spell,omitempty"`
	PassiveSpell []int32 `protobuf:"varint,3,rep,name=passive_spell,json=passiveSpell" json:"passive_spell,omitempty"`
}

func (m *SpellIdProto) Reset()                    { *m = SpellIdProto{} }
func (m *SpellIdProto) String() string            { return proto.CompactTextString(m) }
func (*SpellIdProto) ProtoMessage()               {}
func (*SpellIdProto) Descriptor() ([]byte, []int) { return fileDescriptorSpell, []int{1} }

func (m *SpellIdProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SpellIdProto) GetSpell() int32 {
	if m != nil {
		return m.Spell
	}
	return 0
}

func (m *SpellIdProto) GetPassiveSpell() []int32 {
	if m != nil {
		return m.PassiveSpell
	}
	return nil
}

func init() {
	proto.RegisterType((*SpellProto)(nil), "proto.SpellProto")
	proto.RegisterType((*SpellIdProto)(nil), "proto.SpellIdProto")
	proto.RegisterEnum("proto.SpellTargetType", SpellTargetType_name, SpellTargetType_value)
	proto.RegisterEnum("proto.SpellTargetSubType", SpellTargetSubType_name, SpellTargetSubType_value)
	proto.RegisterEnum("proto.StateStackType", StateStackType_name, StateStackType_value)
	proto.RegisterEnum("proto.SpellTriggerType", SpellTriggerType_name, SpellTriggerType_value)
}
func (m *SpellProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpellProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSpell(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSpell(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSpell(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.IconId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSpell(dAtA, i, uint64(len(m.IconId)))
		i += copy(dAtA[i:], m.IconId)
	}
	return i, nil
}

func (m *SpellIdProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpellIdProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSpell(dAtA, i, uint64(m.Id))
	}
	if m.Spell != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSpell(dAtA, i, uint64(m.Spell))
	}
	if len(m.PassiveSpell) > 0 {
		for _, num := range m.PassiveSpell {
			dAtA[i] = 0x18
			i++
			i = encodeVarintSpell(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func encodeFixed64Spell(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Spell(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintSpell(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SpellProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSpell(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSpell(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovSpell(uint64(l))
	}
	l = len(m.IconId)
	if l > 0 {
		n += 1 + l + sovSpell(uint64(l))
	}
	return n
}

func (m *SpellIdProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSpell(uint64(m.Id))
	}
	if m.Spell != 0 {
		n += 1 + sovSpell(uint64(m.Spell))
	}
	if len(m.PassiveSpell) > 0 {
		for _, e := range m.PassiveSpell {
			n += 1 + sovSpell(uint64(e))
		}
	}
	return n
}

func sovSpell(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSpell(x uint64) (n int) {
	return sovSpell(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SpellProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpell
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpellProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpellProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpell
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpell
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpell
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpell
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpell
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpell
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpell
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpell(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpell
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpellIdProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpell
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpellIdProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpellIdProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpell
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spell", wireType)
			}
			m.Spell = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpell
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Spell |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpell
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PassiveSpell = append(m.PassiveSpell, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpell
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSpell
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpell
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PassiveSpell = append(m.PassiveSpell, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PassiveSpell", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpell(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpell
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSpell(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSpell
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpell
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpell
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSpell
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSpell
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSpell(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSpell = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSpell   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/shared_proto/spell.proto", fileDescriptorSpell)
}

var fileDescriptorSpell = []byte{
	// 477 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x52, 0xcf, 0x6e, 0xd3, 0x30,
	0x18, 0xaf, 0xd3, 0xa6, 0x63, 0x1f, 0x5d, 0x31, 0xd6, 0x80, 0x8a, 0x43, 0x55, 0xed, 0xc2, 0xd4,
	0xc3, 0x7a, 0x00, 0x04, 0xe7, 0x48, 0x4c, 0xad, 0x04, 0x53, 0x15, 0xfb, 0x84, 0x34, 0x55, 0x4e,
	0xfc, 0x2d, 0xb5, 0x96, 0x38, 0x51, 0xe2, 0x0d, 0x76, 0xe1, 0xca, 0x2b, 0xf0, 0x48, 0x1c, 0x79,
	0x04, 0x54, 0x5e, 0x04, 0xd9, 0x59, 0x21, 0x07, 0x0e, 0x9c, 0xfc, 0x7d, 0xbf, 0x9f, 0x7f, 0x7f,
	0x62, 0x05, 0x5e, 0x67, 0xda, 0x6e, 0x6f, 0x92, 0xb3, 0xb4, 0x2c, 0x16, 0xb9, 0xce, 0xb6, 0xb6,
	0x92, 0x9f, 0x16, 0x85, 0xcc, 0xf1, 0xcd, 0xa2, 0x4a, 0x16, 0xcd, 0x56, 0xd6, 0xa8, 0x36, 0x55,
	0x5d, 0xda, 0x72, 0xd1, 0x54, 0x98, 0xe7, 0x67, 0x7e, 0x66, 0xa1, 0x3f, 0x9e, 0xbf, 0xfa, 0x7f,
	0x75, 0x22, 0x1b, 0x6c, 0xc5, 0x27, 0x97, 0x00, 0xdc, 0x79, 0xad, 0xbd, 0xd5, 0x18, 0x02, 0xad,
	0x26, 0x64, 0x46, 0x4e, 0xc3, 0x38, 0xd0, 0x8a, 0x31, 0x18, 0x18, 0x59, 0xe0, 0x24, 0x98, 0x91,
	0xd3, 0xc3, 0xd8, 0xcf, 0x0e, 0x53, 0xd8, 0xa4, 0x93, 0x41, 0x8b, 0xb9, 0x99, 0x3d, 0x83, 0x03,
	0x9d, 0x96, 0x66, 0xa3, 0xd5, 0x24, 0xf4, 0xf0, 0xd0, 0xad, 0x2b, 0x75, 0x72, 0x09, 0x23, 0x6f,
	0xbf, 0x52, 0xff, 0x0e, 0x38, 0x86, 0xd0, 0x7f, 0x8a, 0x4f, 0x08, 0xe3, 0x76, 0x61, 0x2f, 0xe0,
	0xa8, 0x92, 0x4d, 0xa3, 0x6f, 0x71, 0xd3, 0xb2, 0xfd, 0x59, 0xff, 0x34, 0x8c, 0x02, 0xda, 0x8b,
	0x47, 0xf7, 0x84, 0x77, 0x9d, 0xaf, 0xe1, 0x91, 0x1f, 0x84, 0xac, 0x33, 0xb4, 0xe2, 0xae, 0x42,
	0xf6, 0x14, 0xd8, 0xca, 0xdc, 0xca, 0x5c, 0xab, 0x0e, 0x43, 0x7b, 0xec, 0x21, 0x1c, 0x70, 0xf1,
	0xce, 0x60, 0x71, 0x47, 0x09, 0x1b, 0xc1, 0x03, 0x2e, 0xce, 0x6b, 0x8d, 0x46, 0xd1, 0x80, 0x01,
	0x0c, 0xb9, 0xe0, 0x98, 0x5f, 0xd1, 0xfe, 0xfc, 0x0b, 0xb0, 0x8e, 0x8e, 0xdf, 0x24, 0xde, 0xd4,
	0x89, 0xb9, 0xb8, 0x28, 0x0d, 0xd2, 0x1e, 0x3b, 0x82, 0x43, 0xce, 0x45, 0x2c, 0x8d, 0x2a, 0x0b,
	0x4a, 0xd8, 0x13, 0x78, 0xcc, 0x85, 0xf8, 0x20, 0x3f, 0xbf, 0xd7, 0x57, 0xb8, 0xc6, 0x3a, 0x45,
	0x63, 0x69, 0xb0, 0x87, 0xb5, 0xe9, 0xc2, 0x7d, 0x36, 0x06, 0xe0, 0xdc, 0xdd, 0x8e, 0x65, 0x86,
	0x74, 0xb0, 0xdf, 0xb5, 0xf1, 0x7b, 0x38, 0x7f, 0x0b, 0x63, 0x6e, 0xa5, 0x45, 0x6e, 0x65, 0x7a,
	0xed, 0xb3, 0x5d, 0x3b, 0xde, 0x8d, 0x8e, 0xb1, 0xca, 0x65, 0x8a, 0x94, 0xb4, 0xb5, 0xfc, 0x4d,
	0x1a, 0xcc, 0xbf, 0x12, 0xa0, 0x6d, 0xf5, 0x5a, 0x67, 0x19, 0xd6, 0x7f, 0xc4, 0xfb, 0xde, 0x0c,
	0xc6, 0x5c, 0x44, 0x98, 0x69, 0x13, 0x63, 0x8e, 0xb2, 0x71, 0x0e, 0x2e, 0x5e, 0x9c, 0xeb, 0xba,
	0xb1, 0x4b, 0x6d, 0xf7, 0x4f, 0xb1, 0xd4, 0xf6, 0x82, 0xf6, 0x7d, 0x98, 0x88, 0x10, 0x8d, 0xa3,
	0x06, 0xad, 0x9c, 0x6f, 0x35, 0xe6, 0x2a, 0xaa, 0xcb, 0x6b, 0x34, 0x34, 0x64, 0xc7, 0x40, 0xff,
	0xca, 0xef, 0x9f, 0x7a, 0x18, 0xcd, 0xbe, 0xef, 0xa6, 0xe4, 0xc7, 0x6e, 0x4a, 0x7e, 0xee, 0xa6,
	0xe4, 0xdb, 0xaf, 0x69, 0x6f, 0x49, 0x3e, 0x8e, 0xba, 0x3f, 0x60, 0x32, 0xf4, 0xc7, 0xcb, 0xdf,
	0x01, 0x00, 0x00, 0xff, 0xff, 0xb7, 0x2b, 0x76, 0x26, 0xf2, 0x02, 0x00, 0x00,
}
