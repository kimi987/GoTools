// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/shared_proto/hero.proto
// DO NOT EDIT!

package shared_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type HeroBoolType int32

const (
	HeroBoolType_BOOL_JIUGUAN_REFRESH          HeroBoolType = 0
	HeroBoolType_BOOL_JIUGUAN_CONSULT          HeroBoolType = 1
	HeroBoolType_BOOL_COLLECT_TRAIN_EXP        HeroBoolType = 2
	HeroBoolType_BOOL_FORGE_EQUIPMENT          HeroBoolType = 3
	HeroBoolType_BOOL_WEAR_EQUIPMENT           HeroBoolType = 4
	HeroBoolType_BOOL_WEAR_CAPTAIN_SOUL        HeroBoolType = 5
	HeroBoolType_BOOL_REFINED_CAPTAIN          HeroBoolType = 6
	HeroBoolType_BOOL_INVASE_HOME_NPC          HeroBoolType = 7
	HeroBoolType_BOOL_INVASE_ML_NPC            HeroBoolType = 8
	HeroBoolType_BOOL_WORKSHOP_COLLECT         HeroBoolType = 9
	HeroBoolType_BOOL_LEARN_TECH               HeroBoolType = 10
	HeroBoolType_BOOL_COLLECT_FARM             HeroBoolType = 11
	HeroBoolType_BOOL_RECOVER_SOLDIER          HeroBoolType = 12
	HeroBoolType_BOOL_UPGRADE_SOLDIER          HeroBoolType = 13
	HeroBoolType_BOOL_WORKER_CDR               HeroBoolType = 14
	HeroBoolType_BOOL_TECH_CDR                 HeroBoolType = 15
	HeroBoolType_BOOL_VIEW_FARM                HeroBoolType = 16
	HeroBoolType_BOOL_COMPELTED_FIRST_ZHENGWU  HeroBoolType = 17
	HeroBoolType_BOOL_FREE_FISH                HeroBoolType = 18
	HeroBoolType_BOOL_YUANBAO_FISH             HeroBoolType = 19
	HeroBoolType_BOOL_UPGRADE_BASE             HeroBoolType = 20
	HeroBoolType_BOOL_BAYE_PRIZE               HeroBoolType = 21
	HeroBoolType_BOOL_USE_TU_FEI_GOODS         HeroBoolType = 22
	HeroBoolType_BOOL_USE_GEM                  HeroBoolType = 23
	HeroBoolType_BOOL_GET_CAPTAIN_SOUL         HeroBoolType = 24
	HeroBoolType_BOOL_SEEK_CATPAIN             HeroBoolType = 25
	HeroBoolType_BOOL_UPGRADE_CAPTAIN_SOUL     HeroBoolType = 26
	HeroBoolType_BOOL_CAPTAIN_UPGRADE_OFFICIAL HeroBoolType = 27
	HeroBoolType_BOOL_AUTO_DUNGEON             HeroBoolType = 28
	HeroBoolType_BOOL_XUAN_YUAN                HeroBoolType = 29
	HeroBoolType_BOOL_CLOSE_FIGHT_GUIDE        HeroBoolType = 30
	HeroBoolType_BOOL_SET_DEFENSER             HeroBoolType = 31
	HeroBoolType_BOOL_JOIN_NPC_GUILD           HeroBoolType = 32
	HeroBoolType_BOOL_TOWER_FAIL               HeroBoolType = 33
	HeroBoolType_BOOL_PROTECT_REMOVED          HeroBoolType = 34
	HeroBoolType_BOOL_BEEN_ROB                 HeroBoolType = 35
	HeroBoolType_BOOL_WATER                    HeroBoolType = 36
	HeroBoolType_BOOL_PLANT_FARM               HeroBoolType = 37
	HeroBoolType_BOOL_NPC_BAOWU                HeroBoolType = 38
	HeroBoolType_BOOL_UNLOCK_BAOWU             HeroBoolType = 39
	HeroBoolType_BOOL_BUY_LEVEL_FUND           HeroBoolType = 40
	HeroBoolType_BOOL_CAPTAIN_BORN             HeroBoolType = 41
	HeroBoolType_BOOL_CAPTAIN_UP_STAR          HeroBoolType = 42
	HeroBoolType_BOOL_INVASE_BAOZ              HeroBoolType = 43
	HeroBoolType_BOOL_VIEW_MAP                 HeroBoolType = 44
)

var HeroBoolType_name = map[int32]string{
	0:  "BOOL_JIUGUAN_REFRESH",
	1:  "BOOL_JIUGUAN_CONSULT",
	2:  "BOOL_COLLECT_TRAIN_EXP",
	3:  "BOOL_FORGE_EQUIPMENT",
	4:  "BOOL_WEAR_EQUIPMENT",
	5:  "BOOL_WEAR_CAPTAIN_SOUL",
	6:  "BOOL_REFINED_CAPTAIN",
	7:  "BOOL_INVASE_HOME_NPC",
	8:  "BOOL_INVASE_ML_NPC",
	9:  "BOOL_WORKSHOP_COLLECT",
	10: "BOOL_LEARN_TECH",
	11: "BOOL_COLLECT_FARM",
	12: "BOOL_RECOVER_SOLDIER",
	13: "BOOL_UPGRADE_SOLDIER",
	14: "BOOL_WORKER_CDR",
	15: "BOOL_TECH_CDR",
	16: "BOOL_VIEW_FARM",
	17: "BOOL_COMPELTED_FIRST_ZHENGWU",
	18: "BOOL_FREE_FISH",
	19: "BOOL_YUANBAO_FISH",
	20: "BOOL_UPGRADE_BASE",
	21: "BOOL_BAYE_PRIZE",
	22: "BOOL_USE_TU_FEI_GOODS",
	23: "BOOL_USE_GEM",
	24: "BOOL_GET_CAPTAIN_SOUL",
	25: "BOOL_SEEK_CATPAIN",
	26: "BOOL_UPGRADE_CAPTAIN_SOUL",
	27: "BOOL_CAPTAIN_UPGRADE_OFFICIAL",
	28: "BOOL_AUTO_DUNGEON",
	29: "BOOL_XUAN_YUAN",
	30: "BOOL_CLOSE_FIGHT_GUIDE",
	31: "BOOL_SET_DEFENSER",
	32: "BOOL_JOIN_NPC_GUILD",
	33: "BOOL_TOWER_FAIL",
	34: "BOOL_PROTECT_REMOVED",
	35: "BOOL_BEEN_ROB",
	36: "BOOL_WATER",
	37: "BOOL_PLANT_FARM",
	38: "BOOL_NPC_BAOWU",
	39: "BOOL_UNLOCK_BAOWU",
	40: "BOOL_BUY_LEVEL_FUND",
	41: "BOOL_CAPTAIN_BORN",
	42: "BOOL_CAPTAIN_UP_STAR",
	43: "BOOL_INVASE_BAOZ",
	44: "BOOL_VIEW_MAP",
}
var HeroBoolType_value = map[string]int32{
	"BOOL_JIUGUAN_REFRESH":          0,
	"BOOL_JIUGUAN_CONSULT":          1,
	"BOOL_COLLECT_TRAIN_EXP":        2,
	"BOOL_FORGE_EQUIPMENT":          3,
	"BOOL_WEAR_EQUIPMENT":           4,
	"BOOL_WEAR_CAPTAIN_SOUL":        5,
	"BOOL_REFINED_CAPTAIN":          6,
	"BOOL_INVASE_HOME_NPC":          7,
	"BOOL_INVASE_ML_NPC":            8,
	"BOOL_WORKSHOP_COLLECT":         9,
	"BOOL_LEARN_TECH":               10,
	"BOOL_COLLECT_FARM":             11,
	"BOOL_RECOVER_SOLDIER":          12,
	"BOOL_UPGRADE_SOLDIER":          13,
	"BOOL_WORKER_CDR":               14,
	"BOOL_TECH_CDR":                 15,
	"BOOL_VIEW_FARM":                16,
	"BOOL_COMPELTED_FIRST_ZHENGWU":  17,
	"BOOL_FREE_FISH":                18,
	"BOOL_YUANBAO_FISH":             19,
	"BOOL_UPGRADE_BASE":             20,
	"BOOL_BAYE_PRIZE":               21,
	"BOOL_USE_TU_FEI_GOODS":         22,
	"BOOL_USE_GEM":                  23,
	"BOOL_GET_CAPTAIN_SOUL":         24,
	"BOOL_SEEK_CATPAIN":             25,
	"BOOL_UPGRADE_CAPTAIN_SOUL":     26,
	"BOOL_CAPTAIN_UPGRADE_OFFICIAL": 27,
	"BOOL_AUTO_DUNGEON":             28,
	"BOOL_XUAN_YUAN":                29,
	"BOOL_CLOSE_FIGHT_GUIDE":        30,
	"BOOL_SET_DEFENSER":             31,
	"BOOL_JOIN_NPC_GUILD":           32,
	"BOOL_TOWER_FAIL":               33,
	"BOOL_PROTECT_REMOVED":          34,
	"BOOL_BEEN_ROB":                 35,
	"BOOL_WATER":                    36,
	"BOOL_PLANT_FARM":               37,
	"BOOL_NPC_BAOWU":                38,
	"BOOL_UNLOCK_BAOWU":             39,
	"BOOL_BUY_LEVEL_FUND":           40,
	"BOOL_CAPTAIN_BORN":             41,
	"BOOL_CAPTAIN_UP_STAR":          42,
	"BOOL_INVASE_BAOZ":              43,
	"BOOL_VIEW_MAP":                 44,
}

func (x HeroBoolType) String() string {
	return proto.EnumName(HeroBoolType_name, int32(x))
}
func (HeroBoolType) EnumDescriptor() ([]byte, []int) { return fileDescriptorHero, []int{0} }

type HeroProto struct {
	Ctime int32  `protobuf:"varint,101,opt,name=ctime,proto3" json:"ctime,omitempty"`
	Id    []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name  string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// 联盟数据
	GuildId             int32           `protobuf:"varint,6,opt,name=guild_id,json=guildId,proto3" json:"guild_id,omitempty"`
	GuildName           string          `protobuf:"bytes,5,opt,name=guild_name,json=guildName,proto3" json:"guild_name,omitempty"`
	GuildFlagName       string          `protobuf:"bytes,7,opt,name=guild_flag_name,json=guildFlagName,proto3" json:"guild_flag_name,omitempty"`
	CountryId           int32           `protobuf:"varint,8,opt,name=country_id,json=countryId,proto3" json:"country_id,omitempty"`
	Guild               *HeroGuildProto `protobuf:"bytes,31,opt,name=guild" json:"guild,omitempty"`
	ContributionCoin    int32           `protobuf:"varint,32,opt,name=contribution_coin,json=contributionCoin,proto3" json:"contribution_coin,omitempty"`
	GuildDonateTimes    []int32         `protobuf:"varint,33,rep,name=guild_donate_times,json=guildDonateTimes" json:"guild_donate_times,omitempty"`
	JoinGuildIds        []int32         `protobuf:"varint,34,rep,name=join_guild_ids,json=joinGuildIds" json:"join_guild_ids,omitempty"`
	BeenInvateGuildIds  []int32         `protobuf:"varint,35,rep,name=been_invate_guild_ids,json=beenInvateGuildIds" json:"been_invate_guild_ids,omitempty"`
	NextNotifyGuildTime int32           `protobuf:"varint,39,opt,name=next_notify_guild_time,json=nextNotifyGuildTime,proto3" json:"next_notify_guild_time,omitempty"`
	// bool has_first_join_guild_prize = 39; // 有首次加入联盟奖励可以领取
	CollectedFirstJoinGuildPrize bool                        `protobuf:"varint,40,opt,name=collected_first_join_guild_prize,json=collectedFirstJoinGuildPrize,proto3" json:"collected_first_join_guild_prize,omitempty"`
	CollectedDailyGuildRankPrize bool                        `protobuf:"varint,44,opt,name=collected_daily_guild_rank_prize,json=collectedDailyGuildRankPrize,proto3" json:"collected_daily_guild_rank_prize,omitempty"`
	JoinGuildTime                int32                       `protobuf:"varint,68,opt,name=join_guild_time,json=joinGuildTime,proto3" json:"join_guild_time,omitempty"`
	WorkshopOutputStartTime      int32                       `protobuf:"varint,77,opt,name=workshop_output_start_time,json=workshopOutputStartTime,proto3" json:"workshop_output_start_time,omitempty"`
	CollectedGuildTaskStages     []*Int32PairInt32ArrayProto `protobuf:"bytes,130,rep,name=collected_guild_task_stages,json=collectedGuildTaskStages" json:"collected_guild_task_stages,omitempty"`
	Head                         int32                       `protobuf:"varint,20,opt,name=head,proto3" json:"head,omitempty"`
	Head2                        string                      `protobuf:"bytes,22,opt,name=head2,proto3" json:"head2,omitempty"`
	Body                         int32                       `protobuf:"varint,21,opt,name=body,proto3" json:"body,omitempty"`
	Level                        int32                       `protobuf:"varint,12,opt,name=level,proto3" json:"level,omitempty"`
	Exp                          int32                       `protobuf:"varint,13,opt,name=exp,proto3" json:"exp,omitempty"`
	Male                         bool                        `protobuf:"varint,14,opt,name=male,proto3" json:"male,omitempty"`
	Location                     int32                       `protobuf:"varint,76,opt,name=location,proto3" json:"location,omitempty"`
	HasOldName                   bool                        `protobuf:"varint,15,opt,name=has_old_name,json=hasOldName,proto3" json:"has_old_name,omitempty"`
	NextChangeNameTime           int32                       `protobuf:"varint,16,opt,name=next_change_name_time,json=nextChangeNameTime,proto3" json:"next_change_name_time,omitempty"`
	ChangeHeroNameTimes          int32                       `protobuf:"varint,18,opt,name=change_hero_name_times,json=changeHeroNameTimes,proto3" json:"change_hero_name_times,omitempty"`
	GiveFirstChangeHeroNamePrize bool                        `protobuf:"varint,19,opt,name=give_first_change_hero_name_prize,json=giveFirstChangeHeroNamePrize,proto3" json:"give_first_change_hero_name_prize,omitempty"`
	FightAmount                  int32                       `protobuf:"varint,17,opt,name=fight_amount,json=fightAmount,proto3" json:"fight_amount,omitempty"`
	// 野外相关
	Region *HeroRegionProto `protobuf:"bytes,29,opt,name=region" json:"region,omitempty"`
	// 主界面军情
	SelfMilitaryInfo []*MilitaryInfoProto `protobuf:"bytes,28,rep,name=self_military_info,json=selfMilitaryInfo" json:"self_military_info,omitempty"`
	Domestic         *HeroDomesticProto   `protobuf:"bytes,3,opt,name=domestic" json:"domestic,omitempty"`
	Military         *HeroMilitaryProto   `protobuf:"bytes,4,opt,name=military" json:"military,omitempty"`
	// 元宝
	Yuanbao int32 `protobuf:"varint,41,opt,name=yuanbao,proto3" json:"yuanbao,omitempty"`
	// 点券
	Dianquan      int32                 `protobuf:"varint,126,opt,name=dianquan,proto3" json:"dianquan,omitempty"`
	Yinliang      int32                 `protobuf:"varint,106,opt,name=yinliang,proto3" json:"yinliang,omitempty"`
	Sp            int32                 `protobuf:"varint,107,opt,name=sp,proto3" json:"sp,omitempty"`
	BuySpTimes    int32                 `protobuf:"varint,108,opt,name=buy_sp_times,json=buySpTimes,proto3" json:"buy_sp_times,omitempty"`
	CreateTime    int32                 `protobuf:"varint,42,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	AccumLoginDay int32                 `protobuf:"varint,43,opt,name=accum_login_day,json=accumLoginDay,proto3" json:"accum_login_day,omitempty"`
	Charge        *ChargeProto          `protobuf:"bytes,50,opt,name=charge" json:"charge,omitempty"`
	Depot         *HeroDepotProto       `protobuf:"bytes,51,opt,name=depot" json:"depot,omitempty"`
	Tower         *HeroTowerProto       `protobuf:"bytes,52,opt,name=tower" json:"tower,omitempty"`
	Task          *HeroTaskProto        `protobuf:"bytes,53,opt,name=task" json:"task,omitempty"`
	CaptainSoul   *HeroCaptainSoulProto `protobuf:"bytes,54,opt,name=captain_soul,json=captainSoul" json:"captain_soul,omitempty"`
	// 开启了的装备合成
	OpenCombineEquip *HeroOpenCombineEquipProto `protobuf:"bytes,55,opt,name=open_combine_equip,json=openCombineEquip" json:"open_combine_equip,omitempty"`
	// 商店数据
	Shop *HeroShopProto `protobuf:"bytes,56,opt,name=shop" json:"shop,omitempty"`
	// 重楼密室
	SecretTower *HeroSecretTowerProto `protobuf:"bytes,57,opt,name=secret_tower,json=secretTower" json:"secret_tower,omitempty"`
	// 副本
	Dungeon *HeroDungeonProto `protobuf:"bytes,59,opt,name=dungeon" json:"dungeon,omitempty"`
	// 标签
	Tag *HeroTagProto `protobuf:"bytes,61,opt,name=tag" json:"tag,omitempty"`
	// 君主策略
	Strategy *HeroStrategyProto `protobuf:"bytes,62,opt,name=strategy" json:"strategy,omitempty"`
	// 客户端数据
	ClientDatas *HeroClientDatasProto `protobuf:"bytes,63,opt,name=client_datas,json=clientDatas" json:"client_datas,omitempty"`
	// 钓鱼
	Fishing *HeroFishingProto `protobuf:"bytes,64,opt,name=fishing" json:"fishing,omitempty"`
	// 功能开启
	FuncOpen *HeroFunctionProto `protobuf:"bytes,65,opt,name=func_open,json=funcOpen" json:"func_open,omitempty"`
	// 贵族
	GuiZu *HeroGuiZuProto `protobuf:"bytes,66,opt,name=gui_zu,json=guiZu" json:"gui_zu,omitempty"`
	// 摇钱树
	TreasuryTree *HeroTreasuryTreeProto `protobuf:"bytes,67,opt,name=treasury_tree,json=treasuryTree" json:"treasury_tree,omitempty"`
	// 政务
	ZhengWu *HeroZhengWuProto `protobuf:"bytes,69,opt,name=zheng_wu,json=zhengWu" json:"zheng_wu,omitempty"`
	// 过关斩将
	ZhanJiang *HeroZhanJiangProto `protobuf:"bytes,70,opt,name=zhan_jiang,json=zhanJiang" json:"zhan_jiang,omitempty"`
	// 答题
	Question *HeroQuestionProto `protobuf:"bytes,71,opt,name=question" json:"question,omitempty"`
	// 关系
	Relation *HeroRelationProto `protobuf:"bytes,72,opt,name=relation" json:"relation,omitempty"`
	// 随机事件
	RandomEvent *HeroRandomEventProto `protobuf:"bytes,78,opt,name=random_event,json=randomEvent" json:"random_event,omitempty"`
	// 问卷调查
	Survey *HeroSurveyProto `protobuf:"bytes,73,opt,name=survey" json:"survey,omitempty"`
	// 设置
	Settings *HeroSettingsProto `protobuf:"bytes,74,opt,name=settings" json:"settings,omitempty"`
	// 合璧
	Hebi *HeroHebiProto `protobuf:"bytes,75,opt,name=hebi" json:"hebi,omitempty"`
	// bool值
	Bools int32 `protobuf:"varint,102,opt,name=bools,proto3" json:"bools,omitempty"`
	// arrayIndex = int(type / 32)
	// boolIndex = (type % 32)
	BoolsArray []uint32 `protobuf:"varint,104,rep,name=bools_array,json=boolsArray" json:"bools_array,omitempty"`
	// 代码生成的proto
	HeroGen *HeroGenProto `protobuf:"bytes,103,opt,name=hero_gen,json=heroGen" json:"hero_gen,omitempty"`
	// buff
	Buff *HeroBuffProto `protobuf:"bytes,109,opt,name=buff" json:"buff,omitempty"`
	Vip  *HeroVipProto  `protobuf:"bytes,110,opt,name=vip" json:"vip,omitempty"`
	// 名城营建
	McBuild *HeroMcBuildProto `protobuf:"bytes,111,opt,name=mc_build,json=mcBuild" json:"mc_build,omitempty"`
	// 红包
	RedPacket *HeroRedPacketProto `protobuf:"bytes,112,opt,name=red_packet,json=redPacket" json:"red_packet,omitempty"`
	// 教学
	Teach *HeroTeachProto `protobuf:"bytes,116,opt,name=teach" json:"teach,omitempty"`
	// 国家的一部分数据
	CountryOfficial *HeroCountryMiscProto `protobuf:"bytes,117,opt,name=country_official,json=countryOfficial" json:"country_official,omitempty"`
	// 营销
	Promotion *HeroPromotionProto `protobuf:"bytes,105,opt,name=promotion" json:"promotion,omitempty"`
	// 服务器配置
	ServerInfo *HeroServerInfoProto `protobuf:"bytes,127,opt,name=server_info,json=serverInfo" json:"server_info,omitempty"`
}

func (m *HeroProto) Reset()                    { *m = HeroProto{} }
func (m *HeroProto) String() string            { return proto.CompactTextString(m) }
func (*HeroProto) ProtoMessage()               {}
func (*HeroProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{0} }

func (m *HeroProto) GetCtime() int32 {
	if m != nil {
		return m.Ctime
	}
	return 0
}

func (m *HeroProto) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *HeroProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeroProto) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *HeroProto) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

func (m *HeroProto) GetGuildFlagName() string {
	if m != nil {
		return m.GuildFlagName
	}
	return ""
}

func (m *HeroProto) GetCountryId() int32 {
	if m != nil {
		return m.CountryId
	}
	return 0
}

func (m *HeroProto) GetGuild() *HeroGuildProto {
	if m != nil {
		return m.Guild
	}
	return nil
}

func (m *HeroProto) GetContributionCoin() int32 {
	if m != nil {
		return m.ContributionCoin
	}
	return 0
}

func (m *HeroProto) GetGuildDonateTimes() []int32 {
	if m != nil {
		return m.GuildDonateTimes
	}
	return nil
}

func (m *HeroProto) GetJoinGuildIds() []int32 {
	if m != nil {
		return m.JoinGuildIds
	}
	return nil
}

func (m *HeroProto) GetBeenInvateGuildIds() []int32 {
	if m != nil {
		return m.BeenInvateGuildIds
	}
	return nil
}

func (m *HeroProto) GetNextNotifyGuildTime() int32 {
	if m != nil {
		return m.NextNotifyGuildTime
	}
	return 0
}

func (m *HeroProto) GetCollectedFirstJoinGuildPrize() bool {
	if m != nil {
		return m.CollectedFirstJoinGuildPrize
	}
	return false
}

func (m *HeroProto) GetCollectedDailyGuildRankPrize() bool {
	if m != nil {
		return m.CollectedDailyGuildRankPrize
	}
	return false
}

func (m *HeroProto) GetJoinGuildTime() int32 {
	if m != nil {
		return m.JoinGuildTime
	}
	return 0
}

func (m *HeroProto) GetWorkshopOutputStartTime() int32 {
	if m != nil {
		return m.WorkshopOutputStartTime
	}
	return 0
}

func (m *HeroProto) GetCollectedGuildTaskStages() []*Int32PairInt32ArrayProto {
	if m != nil {
		return m.CollectedGuildTaskStages
	}
	return nil
}

func (m *HeroProto) GetHead() int32 {
	if m != nil {
		return m.Head
	}
	return 0
}

func (m *HeroProto) GetHead2() string {
	if m != nil {
		return m.Head2
	}
	return ""
}

func (m *HeroProto) GetBody() int32 {
	if m != nil {
		return m.Body
	}
	return 0
}

func (m *HeroProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *HeroProto) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *HeroProto) GetMale() bool {
	if m != nil {
		return m.Male
	}
	return false
}

func (m *HeroProto) GetLocation() int32 {
	if m != nil {
		return m.Location
	}
	return 0
}

func (m *HeroProto) GetHasOldName() bool {
	if m != nil {
		return m.HasOldName
	}
	return false
}

func (m *HeroProto) GetNextChangeNameTime() int32 {
	if m != nil {
		return m.NextChangeNameTime
	}
	return 0
}

func (m *HeroProto) GetChangeHeroNameTimes() int32 {
	if m != nil {
		return m.ChangeHeroNameTimes
	}
	return 0
}

func (m *HeroProto) GetGiveFirstChangeHeroNamePrize() bool {
	if m != nil {
		return m.GiveFirstChangeHeroNamePrize
	}
	return false
}

func (m *HeroProto) GetFightAmount() int32 {
	if m != nil {
		return m.FightAmount
	}
	return 0
}

func (m *HeroProto) GetRegion() *HeroRegionProto {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *HeroProto) GetSelfMilitaryInfo() []*MilitaryInfoProto {
	if m != nil {
		return m.SelfMilitaryInfo
	}
	return nil
}

func (m *HeroProto) GetDomestic() *HeroDomesticProto {
	if m != nil {
		return m.Domestic
	}
	return nil
}

func (m *HeroProto) GetMilitary() *HeroMilitaryProto {
	if m != nil {
		return m.Military
	}
	return nil
}

func (m *HeroProto) GetYuanbao() int32 {
	if m != nil {
		return m.Yuanbao
	}
	return 0
}

func (m *HeroProto) GetDianquan() int32 {
	if m != nil {
		return m.Dianquan
	}
	return 0
}

func (m *HeroProto) GetYinliang() int32 {
	if m != nil {
		return m.Yinliang
	}
	return 0
}

func (m *HeroProto) GetSp() int32 {
	if m != nil {
		return m.Sp
	}
	return 0
}

func (m *HeroProto) GetBuySpTimes() int32 {
	if m != nil {
		return m.BuySpTimes
	}
	return 0
}

func (m *HeroProto) GetCreateTime() int32 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *HeroProto) GetAccumLoginDay() int32 {
	if m != nil {
		return m.AccumLoginDay
	}
	return 0
}

func (m *HeroProto) GetCharge() *ChargeProto {
	if m != nil {
		return m.Charge
	}
	return nil
}

func (m *HeroProto) GetDepot() *HeroDepotProto {
	if m != nil {
		return m.Depot
	}
	return nil
}

func (m *HeroProto) GetTower() *HeroTowerProto {
	if m != nil {
		return m.Tower
	}
	return nil
}

func (m *HeroProto) GetTask() *HeroTaskProto {
	if m != nil {
		return m.Task
	}
	return nil
}

func (m *HeroProto) GetCaptainSoul() *HeroCaptainSoulProto {
	if m != nil {
		return m.CaptainSoul
	}
	return nil
}

func (m *HeroProto) GetOpenCombineEquip() *HeroOpenCombineEquipProto {
	if m != nil {
		return m.OpenCombineEquip
	}
	return nil
}

func (m *HeroProto) GetShop() *HeroShopProto {
	if m != nil {
		return m.Shop
	}
	return nil
}

func (m *HeroProto) GetSecretTower() *HeroSecretTowerProto {
	if m != nil {
		return m.SecretTower
	}
	return nil
}

func (m *HeroProto) GetDungeon() *HeroDungeonProto {
	if m != nil {
		return m.Dungeon
	}
	return nil
}

func (m *HeroProto) GetTag() *HeroTagProto {
	if m != nil {
		return m.Tag
	}
	return nil
}

func (m *HeroProto) GetStrategy() *HeroStrategyProto {
	if m != nil {
		return m.Strategy
	}
	return nil
}

func (m *HeroProto) GetClientDatas() *HeroClientDatasProto {
	if m != nil {
		return m.ClientDatas
	}
	return nil
}

func (m *HeroProto) GetFishing() *HeroFishingProto {
	if m != nil {
		return m.Fishing
	}
	return nil
}

func (m *HeroProto) GetFuncOpen() *HeroFunctionProto {
	if m != nil {
		return m.FuncOpen
	}
	return nil
}

func (m *HeroProto) GetGuiZu() *HeroGuiZuProto {
	if m != nil {
		return m.GuiZu
	}
	return nil
}

func (m *HeroProto) GetTreasuryTree() *HeroTreasuryTreeProto {
	if m != nil {
		return m.TreasuryTree
	}
	return nil
}

func (m *HeroProto) GetZhengWu() *HeroZhengWuProto {
	if m != nil {
		return m.ZhengWu
	}
	return nil
}

func (m *HeroProto) GetZhanJiang() *HeroZhanJiangProto {
	if m != nil {
		return m.ZhanJiang
	}
	return nil
}

func (m *HeroProto) GetQuestion() *HeroQuestionProto {
	if m != nil {
		return m.Question
	}
	return nil
}

func (m *HeroProto) GetRelation() *HeroRelationProto {
	if m != nil {
		return m.Relation
	}
	return nil
}

func (m *HeroProto) GetRandomEvent() *HeroRandomEventProto {
	if m != nil {
		return m.RandomEvent
	}
	return nil
}

func (m *HeroProto) GetSurvey() *HeroSurveyProto {
	if m != nil {
		return m.Survey
	}
	return nil
}

func (m *HeroProto) GetSettings() *HeroSettingsProto {
	if m != nil {
		return m.Settings
	}
	return nil
}

func (m *HeroProto) GetHebi() *HeroHebiProto {
	if m != nil {
		return m.Hebi
	}
	return nil
}

func (m *HeroProto) GetBools() int32 {
	if m != nil {
		return m.Bools
	}
	return 0
}

func (m *HeroProto) GetBoolsArray() []uint32 {
	if m != nil {
		return m.BoolsArray
	}
	return nil
}

func (m *HeroProto) GetHeroGen() *HeroGenProto {
	if m != nil {
		return m.HeroGen
	}
	return nil
}

func (m *HeroProto) GetBuff() *HeroBuffProto {
	if m != nil {
		return m.Buff
	}
	return nil
}

func (m *HeroProto) GetVip() *HeroVipProto {
	if m != nil {
		return m.Vip
	}
	return nil
}

func (m *HeroProto) GetMcBuild() *HeroMcBuildProto {
	if m != nil {
		return m.McBuild
	}
	return nil
}

func (m *HeroProto) GetRedPacket() *HeroRedPacketProto {
	if m != nil {
		return m.RedPacket
	}
	return nil
}

func (m *HeroProto) GetTeach() *HeroTeachProto {
	if m != nil {
		return m.Teach
	}
	return nil
}

func (m *HeroProto) GetCountryOfficial() *HeroCountryMiscProto {
	if m != nil {
		return m.CountryOfficial
	}
	return nil
}

func (m *HeroProto) GetPromotion() *HeroPromotionProto {
	if m != nil {
		return m.Promotion
	}
	return nil
}

func (m *HeroProto) GetServerInfo() *HeroServerInfoProto {
	if m != nil {
		return m.ServerInfo
	}
	return nil
}

type HeroGuildProto struct {
	// 联盟数据
	Id       int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name     string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	FlagName string `protobuf:"bytes,3,opt,name=flagName,proto3" json:"flagName,omitempty"`
	Country  int32  `protobuf:"varint,4,opt,name=country,proto3" json:"country,omitempty"`
	Level    int32  `protobuf:"varint,5,opt,name=level,proto3" json:"level,omitempty"`
	Leader   []byte `protobuf:"bytes,6,opt,name=leader,proto3" json:"leader,omitempty"`
}

func (m *HeroGuildProto) Reset()                    { *m = HeroGuildProto{} }
func (m *HeroGuildProto) String() string            { return proto.CompactTextString(m) }
func (*HeroGuildProto) ProtoMessage()               {}
func (*HeroGuildProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{1} }

func (m *HeroGuildProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *HeroGuildProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeroGuildProto) GetFlagName() string {
	if m != nil {
		return m.FlagName
	}
	return ""
}

func (m *HeroGuildProto) GetCountry() int32 {
	if m != nil {
		return m.Country
	}
	return 0
}

func (m *HeroGuildProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *HeroGuildProto) GetLeader() []byte {
	if m != nil {
		return m.Leader
	}
	return nil
}

type HeroRelationProto struct {
	Friend           [][]byte                    `protobuf:"bytes,1,rep,name=friend" json:"friend,omitempty"`
	FriendCreateTime []int32                     `protobuf:"varint,5,rep,name=friend_create_time,json=friendCreateTime" json:"friend_create_time,omitempty"`
	Black            [][]byte                    `protobuf:"bytes,2,rep,name=black" json:"black,omitempty"`
	BlackCreateTime  []int32                     `protobuf:"varint,6,rep,name=black_create_time,json=blackCreateTime" json:"black_create_time,omitempty"`
	Enemy            []*HeroEnemyProto           `protobuf:"bytes,3,rep,name=enemy" json:"enemy,omitempty"`
	Important        []*HeroImportantFriendProto `protobuf:"bytes,4,rep,name=important" json:"important,omitempty"`
}

func (m *HeroRelationProto) Reset()                    { *m = HeroRelationProto{} }
func (m *HeroRelationProto) String() string            { return proto.CompactTextString(m) }
func (*HeroRelationProto) ProtoMessage()               {}
func (*HeroRelationProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{2} }

func (m *HeroRelationProto) GetFriend() [][]byte {
	if m != nil {
		return m.Friend
	}
	return nil
}

func (m *HeroRelationProto) GetFriendCreateTime() []int32 {
	if m != nil {
		return m.FriendCreateTime
	}
	return nil
}

func (m *HeroRelationProto) GetBlack() [][]byte {
	if m != nil {
		return m.Black
	}
	return nil
}

func (m *HeroRelationProto) GetBlackCreateTime() []int32 {
	if m != nil {
		return m.BlackCreateTime
	}
	return nil
}

func (m *HeroRelationProto) GetEnemy() []*HeroEnemyProto {
	if m != nil {
		return m.Enemy
	}
	return nil
}

func (m *HeroRelationProto) GetImportant() []*HeroImportantFriendProto {
	if m != nil {
		return m.Important
	}
	return nil
}

type HeroRandomEventProto struct {
	Events    []*EventPositionProto `protobuf:"bytes,1,rep,name=events" json:"events,omitempty"`
	Handbooks []int32               `protobuf:"varint,2,rep,name=handbooks" json:"handbooks,omitempty"`
}

func (m *HeroRandomEventProto) Reset()                    { *m = HeroRandomEventProto{} }
func (m *HeroRandomEventProto) String() string            { return proto.CompactTextString(m) }
func (*HeroRandomEventProto) ProtoMessage()               {}
func (*HeroRandomEventProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{3} }

func (m *HeroRandomEventProto) GetEvents() []*EventPositionProto {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *HeroRandomEventProto) GetHandbooks() []int32 {
	if m != nil {
		return m.Handbooks
	}
	return nil
}

type HeroEnemyProto struct {
	EnemyId []byte `protobuf:"bytes,1,opt,name=enemy_id,json=enemyId,proto3" json:"enemy_id,omitempty"`
	AddTime int32  `protobuf:"varint,2,opt,name=add_time,json=addTime,proto3" json:"add_time,omitempty"`
}

func (m *HeroEnemyProto) Reset()                    { *m = HeroEnemyProto{} }
func (m *HeroEnemyProto) String() string            { return proto.CompactTextString(m) }
func (*HeroEnemyProto) ProtoMessage()               {}
func (*HeroEnemyProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{4} }

func (m *HeroEnemyProto) GetEnemyId() []byte {
	if m != nil {
		return m.EnemyId
	}
	return nil
}

func (m *HeroEnemyProto) GetAddTime() int32 {
	if m != nil {
		return m.AddTime
	}
	return 0
}

type HeroImportantFriendProto struct {
	FriendId []byte `protobuf:"bytes,1,opt,name=friend_id,json=friendId,proto3" json:"friend_id,omitempty"`
	SetTime  int32  `protobuf:"varint,2,opt,name=set_time,json=setTime,proto3" json:"set_time,omitempty"`
}

func (m *HeroImportantFriendProto) Reset()                    { *m = HeroImportantFriendProto{} }
func (m *HeroImportantFriendProto) String() string            { return proto.CompactTextString(m) }
func (*HeroImportantFriendProto) ProtoMessage()               {}
func (*HeroImportantFriendProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{5} }

func (m *HeroImportantFriendProto) GetFriendId() []byte {
	if m != nil {
		return m.FriendId
	}
	return nil
}

func (m *HeroImportantFriendProto) GetSetTime() int32 {
	if m != nil {
		return m.SetTime
	}
	return 0
}

type HeroServerInfoProto struct {
	//    int32 pid = 1; // 哪个平台的（暂时先不管这个值）
	Sid       int32 `protobuf:"varint,2,opt,name=sid,proto3" json:"sid,omitempty"`
	StartTime int32 `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// {{local}}/1.txt
	// {{cos}}/1.txt
	// http://192.168.1.5/1.txt
	LocalUrl string `protobuf:"bytes,4,opt,name=local_url,json=localUrl,proto3" json:"local_url,omitempty"`
	CosUrl   string `protobuf:"bytes,5,opt,name=cos_url,json=cosUrl,proto3" json:"cos_url,omitempty"`
}

func (m *HeroServerInfoProto) Reset()                    { *m = HeroServerInfoProto{} }
func (m *HeroServerInfoProto) String() string            { return proto.CompactTextString(m) }
func (*HeroServerInfoProto) ProtoMessage()               {}
func (*HeroServerInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{6} }

func (m *HeroServerInfoProto) GetSid() int32 {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *HeroServerInfoProto) GetStartTime() int32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *HeroServerInfoProto) GetLocalUrl() string {
	if m != nil {
		return m.LocalUrl
	}
	return ""
}

func (m *HeroServerInfoProto) GetCosUrl() string {
	if m != nil {
		return m.CosUrl
	}
	return ""
}

type OtherHeroProto struct {
	Id            []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name          string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	GuildId       int32  `protobuf:"varint,6,opt,name=guild_id,json=guildId,proto3" json:"guild_id,omitempty"`
	GuildName     string `protobuf:"bytes,5,opt,name=guild_name,json=guildName,proto3" json:"guild_name,omitempty"`
	GuildFlagName string `protobuf:"bytes,7,opt,name=guild_flag_name,json=guildFlagName,proto3" json:"guild_flag_name,omitempty"`
	CountryId     int32  `protobuf:"varint,8,opt,name=country_id,json=countryId,proto3" json:"country_id,omitempty"`
	Head          string `protobuf:"bytes,19,opt,name=head,proto3" json:"head,omitempty"`
	Body          int32  `protobuf:"varint,27,opt,name=body,proto3" json:"body,omitempty"`
	Level         int32  `protobuf:"varint,12,opt,name=level,proto3" json:"level,omitempty"`
	Male          bool   `protobuf:"varint,14,opt,name=male,proto3" json:"male,omitempty"`
	Location      int32  `protobuf:"varint,76,opt,name=location,proto3" json:"location,omitempty"`
	HasOldName    bool   `protobuf:"varint,15,opt,name=has_old_name,json=hasOldName,proto3" json:"has_old_name,omitempty"`
	FightAmount   int32  `protobuf:"varint,17,opt,name=fight_amount,json=fightAmount,proto3" json:"fight_amount,omitempty"`
	MaxTowerFloor int32  `protobuf:"varint,18,opt,name=max_tower_floor,json=maxTowerFloor,proto3" json:"max_tower_floor,omitempty"`
	// 主城
	Home *HeroBaseProto `protobuf:"bytes,20,opt,name=home" json:"home,omitempty"`
	// 行营
	Tent *HeroBaseProto `protobuf:"bytes,26,opt,name=tent" json:"tent,omitempty"`
	// 是否有白旗
	HasWhiteFlag  bool   `protobuf:"varint,25,opt,name=has_white_flag,json=hasWhiteFlag,proto3" json:"has_white_flag,omitempty"`
	WhiteFlagName string `protobuf:"bytes,28,opt,name=white_flag_name,json=whiteFlagName,proto3" json:"white_flag_name,omitempty"`
	// 内政
	Domestic *HeroDomesticOtherProto `protobuf:"bytes,21,opt,name=domestic" json:"domestic,omitempty"`
	// 军衔等级
	JunXianLevel int32 `protobuf:"varint,22,opt,name=jun_xian_level,json=junXianLevel,proto3" json:"jun_xian_level,omitempty"`
	// 历史最高军衔等级
	HistoryMaxJunXianLevel int32 `protobuf:"varint,24,opt,name=history_max_jun_xian_level,json=historyMaxJunXianLevel,proto3" json:"history_max_jun_xian_level,omitempty"`
	MaxBaseLevel           int32 `protobuf:"varint,23,opt,name=max_base_level,json=maxBaseLevel,proto3" json:"max_base_level,omitempty"`
	// 标签
	Tag *HeroTagProto `protobuf:"bytes,59,opt,name=tag" json:"tag,omitempty"`
	// 将魂
	CaptainSoul        *HeroCaptainSoulOtherProto `protobuf:"bytes,60,opt,name=captain_soul,json=captainSoul" json:"captain_soul,omitempty"`
	SelectShowAchieves *SelectShowAchievesProto   `protobuf:"bytes,61,opt,name=select_show_achieves,json=selectShowAchieves" json:"select_show_achieves,omitempty"`
}

func (m *OtherHeroProto) Reset()                    { *m = OtherHeroProto{} }
func (m *OtherHeroProto) String() string            { return proto.CompactTextString(m) }
func (*OtherHeroProto) ProtoMessage()               {}
func (*OtherHeroProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{7} }

func (m *OtherHeroProto) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *OtherHeroProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OtherHeroProto) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *OtherHeroProto) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

func (m *OtherHeroProto) GetGuildFlagName() string {
	if m != nil {
		return m.GuildFlagName
	}
	return ""
}

func (m *OtherHeroProto) GetCountryId() int32 {
	if m != nil {
		return m.CountryId
	}
	return 0
}

func (m *OtherHeroProto) GetHead() string {
	if m != nil {
		return m.Head
	}
	return ""
}

func (m *OtherHeroProto) GetBody() int32 {
	if m != nil {
		return m.Body
	}
	return 0
}

func (m *OtherHeroProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *OtherHeroProto) GetMale() bool {
	if m != nil {
		return m.Male
	}
	return false
}

func (m *OtherHeroProto) GetLocation() int32 {
	if m != nil {
		return m.Location
	}
	return 0
}

func (m *OtherHeroProto) GetHasOldName() bool {
	if m != nil {
		return m.HasOldName
	}
	return false
}

func (m *OtherHeroProto) GetFightAmount() int32 {
	if m != nil {
		return m.FightAmount
	}
	return 0
}

func (m *OtherHeroProto) GetMaxTowerFloor() int32 {
	if m != nil {
		return m.MaxTowerFloor
	}
	return 0
}

func (m *OtherHeroProto) GetHome() *HeroBaseProto {
	if m != nil {
		return m.Home
	}
	return nil
}

func (m *OtherHeroProto) GetTent() *HeroBaseProto {
	if m != nil {
		return m.Tent
	}
	return nil
}

func (m *OtherHeroProto) GetHasWhiteFlag() bool {
	if m != nil {
		return m.HasWhiteFlag
	}
	return false
}

func (m *OtherHeroProto) GetWhiteFlagName() string {
	if m != nil {
		return m.WhiteFlagName
	}
	return ""
}

func (m *OtherHeroProto) GetDomestic() *HeroDomesticOtherProto {
	if m != nil {
		return m.Domestic
	}
	return nil
}

func (m *OtherHeroProto) GetJunXianLevel() int32 {
	if m != nil {
		return m.JunXianLevel
	}
	return 0
}

func (m *OtherHeroProto) GetHistoryMaxJunXianLevel() int32 {
	if m != nil {
		return m.HistoryMaxJunXianLevel
	}
	return 0
}

func (m *OtherHeroProto) GetMaxBaseLevel() int32 {
	if m != nil {
		return m.MaxBaseLevel
	}
	return 0
}

func (m *OtherHeroProto) GetTag() *HeroTagProto {
	if m != nil {
		return m.Tag
	}
	return nil
}

func (m *OtherHeroProto) GetCaptainSoul() *HeroCaptainSoulOtherProto {
	if m != nil {
		return m.CaptainSoul
	}
	return nil
}

func (m *OtherHeroProto) GetSelectShowAchieves() *SelectShowAchievesProto {
	if m != nil {
		return m.SelectShowAchieves
	}
	return nil
}

type HeroRegionProto struct {
	// 主城
	Home                                *HeroBaseProto `protobuf:"bytes,1,opt,name=home" json:"home,omitempty"`
	WhiteFlagGuildId                    int32          `protobuf:"varint,31,opt,name=white_flag_guild_id,json=whiteFlagGuildId,proto3" json:"white_flag_guild_id,omitempty"`
	WhiteFlagGuildFlagName              string         `protobuf:"bytes,32,opt,name=white_flag_guild_flag_name,json=whiteFlagGuildFlagName,proto3" json:"white_flag_guild_flag_name,omitempty"`
	WhiteFlagDisappearTime              int32          `protobuf:"varint,33,opt,name=white_flag_disappear_time,json=whiteFlagDisappearTime,proto3" json:"white_flag_disappear_time,omitempty"`
	MianStartTime                       int32          `protobuf:"varint,38,opt,name=mian_start_time,json=mianStartTime,proto3" json:"mian_start_time,omitempty"`
	MianDisappearTime                   int32          `protobuf:"varint,34,opt,name=mian_disappear_time,json=mianDisappearTime,proto3" json:"mian_disappear_time,omitempty"`
	NextUseMianGoodsTime                int32          `protobuf:"varint,37,opt,name=next_use_mian_goods_time,json=nextUseMianGoodsTime,proto3" json:"next_use_mian_goods_time,omitempty"`
	MaxBaseLevel                        int32          `protobuf:"varint,35,opt,name=max_base_level,json=maxBaseLevel,proto3" json:"max_base_level,omitempty"`
	MoveBaseRestoreProsperityBufEndTime int32          `protobuf:"varint,36,opt,name=move_base_restore_prosperity_buf_end_time,json=moveBaseRestoreProsperityBufEndTime,proto3" json:"move_base_restore_prosperity_buf_end_time,omitempty"`
	HomeDefenseTroopIndex               int32          `protobuf:"varint,11,opt,name=home_defense_troop_index,json=homeDefenseTroopIndex,proto3" json:"home_defense_troop_index,omitempty"`
	HomeTroopDefeatedMailProto          *MailProto     `protobuf:"bytes,13,opt,name=home_troop_defeated_mail_proto,json=homeTroopDefeatedMailProto" json:"home_troop_defeated_mail_proto,omitempty"`
	// 驻守镜像
	CopyDefenserCaptainId     []int32             `protobuf:"varint,41,rep,name=copy_defenser_captain_id,json=copyDefenserCaptainId" json:"copy_defenser_captain_id,omitempty"`
	CopyDefenserCaptainXindex []int32             `protobuf:"varint,46,rep,name=copy_defenser_captain_xindex,json=copyDefenserCaptainXindex" json:"copy_defenser_captain_xindex,omitempty"`
	CopyDefenserSoldier       int32               `protobuf:"varint,42,opt,name=copy_defenser_soldier,json=copyDefenserSoldier,proto3" json:"copy_defenser_soldier,omitempty"`
	CopyDefenserTotalSoldier  int32               `protobuf:"varint,43,opt,name=copy_defenser_total_soldier,json=copyDefenserTotalSoldier,proto3" json:"copy_defenser_total_soldier,omitempty"`
	CopyDefenserEndTime       int32               `protobuf:"varint,44,opt,name=copy_defenser_end_time,json=copyDefenserEndTime,proto3" json:"copy_defenser_end_time,omitempty"`
	CopyDefenserTroopIndex    int32               `protobuf:"varint,45,opt,name=copy_defenser_troop_index,json=copyDefenserTroopIndex,proto3" json:"copy_defenser_troop_index,omitempty"`
	FavoritePoses             *FavoritePosesProto `protobuf:"bytes,55,opt,name=favorite_poses,json=favoritePoses" json:"favorite_poses,omitempty"`
	// 侦查
	NextInvestigateTime            int32                                `protobuf:"varint,68,opt,name=next_investigate_time,json=nextInvestigateTime,proto3" json:"next_investigate_time,omitempty"`
	MultiLevelNpc                  []*HeroMultiLevelNpcProto            `protobuf:"bytes,69,rep,name=multi_level_npc,json=multiLevelNpc" json:"multi_level_npc,omitempty"`
	MultiLevelNpcPassLevel         int32                                `protobuf:"varint,70,opt,name=multi_level_npc_pass_level,json=multiLevelNpcPassLevel,proto3" json:"multi_level_npc_pass_level,omitempty"`
	MultiLevelNpcStartRecoveryTime *RecoverableTimesWithExtraTimesProto `protobuf:"bytes,26,opt,name=multi_level_npc_start_recovery_time,json=multiLevelNpcStartRecoveryTime" json:"multi_level_npc_start_recovery_time,omitempty"`
	InvaseHeroStartRecoveryTime    *RecoverableTimesWithExtraTimesProto `protobuf:"bytes,27,opt,name=invase_hero_start_recovery_time,json=invaseHeroStartRecoveryTime" json:"invase_hero_start_recovery_time,omitempty"`
	JunTuanNpcStartTime            *RecoverableTimesWithExtraTimesProto `protobuf:"bytes,28,opt,name=jun_tuan_npc_start_time,json=junTuanNpcStartTime" json:"jun_tuan_npc_start_time,omitempty"`
}

func (m *HeroRegionProto) Reset()                    { *m = HeroRegionProto{} }
func (m *HeroRegionProto) String() string            { return proto.CompactTextString(m) }
func (*HeroRegionProto) ProtoMessage()               {}
func (*HeroRegionProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{8} }

func (m *HeroRegionProto) GetHome() *HeroBaseProto {
	if m != nil {
		return m.Home
	}
	return nil
}

func (m *HeroRegionProto) GetWhiteFlagGuildId() int32 {
	if m != nil {
		return m.WhiteFlagGuildId
	}
	return 0
}

func (m *HeroRegionProto) GetWhiteFlagGuildFlagName() string {
	if m != nil {
		return m.WhiteFlagGuildFlagName
	}
	return ""
}

func (m *HeroRegionProto) GetWhiteFlagDisappearTime() int32 {
	if m != nil {
		return m.WhiteFlagDisappearTime
	}
	return 0
}

func (m *HeroRegionProto) GetMianStartTime() int32 {
	if m != nil {
		return m.MianStartTime
	}
	return 0
}

func (m *HeroRegionProto) GetMianDisappearTime() int32 {
	if m != nil {
		return m.MianDisappearTime
	}
	return 0
}

func (m *HeroRegionProto) GetNextUseMianGoodsTime() int32 {
	if m != nil {
		return m.NextUseMianGoodsTime
	}
	return 0
}

func (m *HeroRegionProto) GetMaxBaseLevel() int32 {
	if m != nil {
		return m.MaxBaseLevel
	}
	return 0
}

func (m *HeroRegionProto) GetMoveBaseRestoreProsperityBufEndTime() int32 {
	if m != nil {
		return m.MoveBaseRestoreProsperityBufEndTime
	}
	return 0
}

func (m *HeroRegionProto) GetHomeDefenseTroopIndex() int32 {
	if m != nil {
		return m.HomeDefenseTroopIndex
	}
	return 0
}

func (m *HeroRegionProto) GetHomeTroopDefeatedMailProto() *MailProto {
	if m != nil {
		return m.HomeTroopDefeatedMailProto
	}
	return nil
}

func (m *HeroRegionProto) GetCopyDefenserCaptainId() []int32 {
	if m != nil {
		return m.CopyDefenserCaptainId
	}
	return nil
}

func (m *HeroRegionProto) GetCopyDefenserCaptainXindex() []int32 {
	if m != nil {
		return m.CopyDefenserCaptainXindex
	}
	return nil
}

func (m *HeroRegionProto) GetCopyDefenserSoldier() int32 {
	if m != nil {
		return m.CopyDefenserSoldier
	}
	return 0
}

func (m *HeroRegionProto) GetCopyDefenserTotalSoldier() int32 {
	if m != nil {
		return m.CopyDefenserTotalSoldier
	}
	return 0
}

func (m *HeroRegionProto) GetCopyDefenserEndTime() int32 {
	if m != nil {
		return m.CopyDefenserEndTime
	}
	return 0
}

func (m *HeroRegionProto) GetCopyDefenserTroopIndex() int32 {
	if m != nil {
		return m.CopyDefenserTroopIndex
	}
	return 0
}

func (m *HeroRegionProto) GetFavoritePoses() *FavoritePosesProto {
	if m != nil {
		return m.FavoritePoses
	}
	return nil
}

func (m *HeroRegionProto) GetNextInvestigateTime() int32 {
	if m != nil {
		return m.NextInvestigateTime
	}
	return 0
}

func (m *HeroRegionProto) GetMultiLevelNpc() []*HeroMultiLevelNpcProto {
	if m != nil {
		return m.MultiLevelNpc
	}
	return nil
}

func (m *HeroRegionProto) GetMultiLevelNpcPassLevel() int32 {
	if m != nil {
		return m.MultiLevelNpcPassLevel
	}
	return 0
}

func (m *HeroRegionProto) GetMultiLevelNpcStartRecoveryTime() *RecoverableTimesWithExtraTimesProto {
	if m != nil {
		return m.MultiLevelNpcStartRecoveryTime
	}
	return nil
}

func (m *HeroRegionProto) GetInvaseHeroStartRecoveryTime() *RecoverableTimesWithExtraTimesProto {
	if m != nil {
		return m.InvaseHeroStartRecoveryTime
	}
	return nil
}

func (m *HeroRegionProto) GetJunTuanNpcStartTime() *RecoverableTimesWithExtraTimesProto {
	if m != nil {
		return m.JunTuanNpcStartTime
	}
	return nil
}

type HeroMultiLevelNpcProto struct {
	Type      MultiLevelNpcType `protobuf:"varint,1,opt,name=type,proto3,enum=proto.MultiLevelNpcType" json:"type,omitempty"`
	PassLevel int32             `protobuf:"varint,2,opt,name=pass_level,json=passLevel,proto3" json:"pass_level,omitempty"`
	Hate      int32             `protobuf:"varint,3,opt,name=hate,proto3" json:"hate,omitempty"`
}

func (m *HeroMultiLevelNpcProto) Reset()                    { *m = HeroMultiLevelNpcProto{} }
func (m *HeroMultiLevelNpcProto) String() string            { return proto.CompactTextString(m) }
func (*HeroMultiLevelNpcProto) ProtoMessage()               {}
func (*HeroMultiLevelNpcProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{9} }

func (m *HeroMultiLevelNpcProto) GetType() MultiLevelNpcType {
	if m != nil {
		return m.Type
	}
	return MultiLevelNpcType_InvalidMultiLevelNpcType
}

func (m *HeroMultiLevelNpcProto) GetPassLevel() int32 {
	if m != nil {
		return m.PassLevel
	}
	return 0
}

func (m *HeroMultiLevelNpcProto) GetHate() int32 {
	if m != nil {
		return m.Hate
	}
	return 0
}

type FavoritePosesProto struct {
	Poses []*FavoritePosProto `protobuf:"bytes,1,rep,name=poses" json:"poses,omitempty"`
}

func (m *FavoritePosesProto) Reset()                    { *m = FavoritePosesProto{} }
func (m *FavoritePosesProto) String() string            { return proto.CompactTextString(m) }
func (*FavoritePosesProto) ProtoMessage()               {}
func (*FavoritePosesProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{10} }

func (m *FavoritePosesProto) GetPoses() []*FavoritePosProto {
	if m != nil {
		return m.Poses
	}
	return nil
}

type FavoritePosProto struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	X  int32 `protobuf:"varint,2,opt,name=x,proto3" json:"x,omitempty"`
	Y  int32 `protobuf:"varint,3,opt,name=y,proto3" json:"y,omitempty"`
}

func (m *FavoritePosProto) Reset()                    { *m = FavoritePosProto{} }
func (m *FavoritePosProto) String() string            { return proto.CompactTextString(m) }
func (*FavoritePosProto) ProtoMessage()               {}
func (*FavoritePosProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{11} }

func (m *FavoritePosProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *FavoritePosProto) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *FavoritePosProto) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

type FavoritePosListProto struct {
	Detail []*FavoritePosDetailProto `protobuf:"bytes,1,rep,name=detail" json:"detail,omitempty"`
}

func (m *FavoritePosListProto) Reset()                    { *m = FavoritePosListProto{} }
func (m *FavoritePosListProto) String() string            { return proto.CompactTextString(m) }
func (*FavoritePosListProto) ProtoMessage()               {}
func (*FavoritePosListProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{12} }

func (m *FavoritePosListProto) GetDetail() []*FavoritePosDetailProto {
	if m != nil {
		return m.Detail
	}
	return nil
}

type FavoritePosDetailProto struct {
	Pos      *FavoritePosProto `protobuf:"bytes,1,opt,name=pos" json:"pos,omitempty"`
	HaveHero bool              `protobuf:"varint,4,opt,name=have_hero,json=haveHero,proto3" json:"have_hero,omitempty"`
	Hero     *HeroBasicProto   `protobuf:"bytes,5,opt,name=hero" json:"hero,omitempty"`
	IsHome   bool              `protobuf:"varint,6,opt,name=is_home,json=isHome,proto3" json:"is_home,omitempty"`
}

func (m *FavoritePosDetailProto) Reset()                    { *m = FavoritePosDetailProto{} }
func (m *FavoritePosDetailProto) String() string            { return proto.CompactTextString(m) }
func (*FavoritePosDetailProto) ProtoMessage()               {}
func (*FavoritePosDetailProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{13} }

func (m *FavoritePosDetailProto) GetPos() *FavoritePosProto {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *FavoritePosDetailProto) GetHaveHero() bool {
	if m != nil {
		return m.HaveHero
	}
	return false
}

func (m *FavoritePosDetailProto) GetHero() *HeroBasicProto {
	if m != nil {
		return m.Hero
	}
	return nil
}

func (m *FavoritePosDetailProto) GetIsHome() bool {
	if m != nil {
		return m.IsHome
	}
	return false
}

type HeroBaseProto struct {
	BaseRegion int32 `protobuf:"varint,1,opt,name=base_region,json=baseRegion,proto3" json:"base_region,omitempty"`
	BaseLevel  int32 `protobuf:"varint,2,opt,name=base_level,json=baseLevel,proto3" json:"base_level,omitempty"`
	BaseX      int32 `protobuf:"varint,3,opt,name=base_x,json=baseX,proto3" json:"base_x,omitempty"`
	BaseY      int32 `protobuf:"varint,4,opt,name=base_y,json=baseY,proto3" json:"base_y,omitempty"`
	Prosperity int32 `protobuf:"varint,5,opt,name=prosperity,proto3" json:"prosperity,omitempty"`
}

func (m *HeroBaseProto) Reset()                    { *m = HeroBaseProto{} }
func (m *HeroBaseProto) String() string            { return proto.CompactTextString(m) }
func (*HeroBaseProto) ProtoMessage()               {}
func (*HeroBaseProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{14} }

func (m *HeroBaseProto) GetBaseRegion() int32 {
	if m != nil {
		return m.BaseRegion
	}
	return 0
}

func (m *HeroBaseProto) GetBaseLevel() int32 {
	if m != nil {
		return m.BaseLevel
	}
	return 0
}

func (m *HeroBaseProto) GetBaseX() int32 {
	if m != nil {
		return m.BaseX
	}
	return 0
}

func (m *HeroBaseProto) GetBaseY() int32 {
	if m != nil {
		return m.BaseY
	}
	return 0
}

func (m *HeroBaseProto) GetProsperity() int32 {
	if m != nil {
		return m.Prosperity
	}
	return 0
}

type StratagemProto struct {
	Id              int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	DailyUsedTimes  int32 `protobuf:"varint,2,opt,name=daily_used_times,json=dailyUsedTimes,proto3" json:"daily_used_times,omitempty"`
	NextUseableTime int32 `protobuf:"varint,4,opt,name=next_useable_time,json=nextUseableTime,proto3" json:"next_useable_time,omitempty"`
}

func (m *StratagemProto) Reset()                    { *m = StratagemProto{} }
func (m *StratagemProto) String() string            { return proto.CompactTextString(m) }
func (*StratagemProto) ProtoMessage()               {}
func (*StratagemProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{15} }

func (m *StratagemProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StratagemProto) GetDailyUsedTimes() int32 {
	if m != nil {
		return m.DailyUsedTimes
	}
	return 0
}

func (m *StratagemProto) GetNextUseableTime() int32 {
	if m != nil {
		return m.NextUseableTime
	}
	return 0
}

type TrappedStratagemProto struct {
	Id      int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	EndTime int32 `protobuf:"varint,3,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (m *TrappedStratagemProto) Reset()                    { *m = TrappedStratagemProto{} }
func (m *TrappedStratagemProto) String() string            { return proto.CompactTextString(m) }
func (*TrappedStratagemProto) ProtoMessage()               {}
func (*TrappedStratagemProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{16} }

func (m *TrappedStratagemProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrappedStratagemProto) GetEndTime() int32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type StratagemTargetTimesProto struct {
	Id    []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Times int32  `protobuf:"varint,2,opt,name=times,proto3" json:"times,omitempty"`
}

func (m *StratagemTargetTimesProto) Reset()                    { *m = StratagemTargetTimesProto{} }
func (m *StratagemTargetTimesProto) String() string            { return proto.CompactTextString(m) }
func (*StratagemTargetTimesProto) ProtoMessage()               {}
func (*StratagemTargetTimesProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{17} }

func (m *StratagemTargetTimesProto) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *StratagemTargetTimesProto) GetTimes() int32 {
	if m != nil {
		return m.Times
	}
	return 0
}

type HeroStrategyProto struct {
	Stratagems        []*StratagemProto            `protobuf:"bytes,1,rep,name=stratagems" json:"stratagems,omitempty"`
	TrappedStratagems []*TrappedStratagemProto     `protobuf:"bytes,2,rep,name=trapped_stratagems,json=trappedStratagems" json:"trapped_stratagems,omitempty"`
	TodayTargetTimes  []*StratagemTargetTimesProto `protobuf:"bytes,3,rep,name=today_target_times,json=todayTargetTimes" json:"today_target_times,omitempty"`
}

func (m *HeroStrategyProto) Reset()                    { *m = HeroStrategyProto{} }
func (m *HeroStrategyProto) String() string            { return proto.CompactTextString(m) }
func (*HeroStrategyProto) ProtoMessage()               {}
func (*HeroStrategyProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{18} }

func (m *HeroStrategyProto) GetStratagems() []*StratagemProto {
	if m != nil {
		return m.Stratagems
	}
	return nil
}

func (m *HeroStrategyProto) GetTrappedStratagems() []*TrappedStratagemProto {
	if m != nil {
		return m.TrappedStratagems
	}
	return nil
}

func (m *HeroStrategyProto) GetTodayTargetTimes() []*StratagemTargetTimesProto {
	if m != nil {
		return m.TodayTargetTimes
	}
	return nil
}

type HeroClientDatasProto struct {
	// 数据，比如 30客户端设置为true了，里面的数组就会包括30，表示已经设置值了
	IntValue   []int32 `protobuf:"varint,1,rep,name=int_value,json=intValue" json:"int_value,omitempty"`
	ClientKeys []int32 `protobuf:"varint,2,rep,name=client_keys,json=clientKeys" json:"client_keys,omitempty"`
}

func (m *HeroClientDatasProto) Reset()                    { *m = HeroClientDatasProto{} }
func (m *HeroClientDatasProto) String() string            { return proto.CompactTextString(m) }
func (*HeroClientDatasProto) ProtoMessage()               {}
func (*HeroClientDatasProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{19} }

func (m *HeroClientDatasProto) GetIntValue() []int32 {
	if m != nil {
		return m.IntValue
	}
	return nil
}

func (m *HeroClientDatasProto) GetClientKeys() []int32 {
	if m != nil {
		return m.ClientKeys
	}
	return nil
}

func init() {
	proto.RegisterType((*HeroProto)(nil), "proto.HeroProto")
	proto.RegisterType((*HeroGuildProto)(nil), "proto.HeroGuildProto")
	proto.RegisterType((*HeroRelationProto)(nil), "proto.HeroRelationProto")
	proto.RegisterType((*HeroRandomEventProto)(nil), "proto.HeroRandomEventProto")
	proto.RegisterType((*HeroEnemyProto)(nil), "proto.HeroEnemyProto")
	proto.RegisterType((*HeroImportantFriendProto)(nil), "proto.HeroImportantFriendProto")
	proto.RegisterType((*HeroServerInfoProto)(nil), "proto.HeroServerInfoProto")
	proto.RegisterType((*OtherHeroProto)(nil), "proto.OtherHeroProto")
	proto.RegisterType((*HeroRegionProto)(nil), "proto.HeroRegionProto")
	proto.RegisterType((*HeroMultiLevelNpcProto)(nil), "proto.HeroMultiLevelNpcProto")
	proto.RegisterType((*FavoritePosesProto)(nil), "proto.FavoritePosesProto")
	proto.RegisterType((*FavoritePosProto)(nil), "proto.FavoritePosProto")
	proto.RegisterType((*FavoritePosListProto)(nil), "proto.FavoritePosListProto")
	proto.RegisterType((*FavoritePosDetailProto)(nil), "proto.FavoritePosDetailProto")
	proto.RegisterType((*HeroBaseProto)(nil), "proto.HeroBaseProto")
	proto.RegisterType((*StratagemProto)(nil), "proto.StratagemProto")
	proto.RegisterType((*TrappedStratagemProto)(nil), "proto.TrappedStratagemProto")
	proto.RegisterType((*StratagemTargetTimesProto)(nil), "proto.StratagemTargetTimesProto")
	proto.RegisterType((*HeroStrategyProto)(nil), "proto.HeroStrategyProto")
	proto.RegisterType((*HeroClientDatasProto)(nil), "proto.HeroClientDatasProto")
	proto.RegisterEnum("proto.HeroBoolType", HeroBoolType_name, HeroBoolType_value)
}
func (m *HeroProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Domestic != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Domestic.Size()))
		n1, err := m.Domestic.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Military != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Military.Size()))
		n2, err := m.Military.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.GuildName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.GuildName)))
		i += copy(dAtA[i:], m.GuildName)
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.GuildId))
	}
	if len(m.GuildFlagName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.GuildFlagName)))
		i += copy(dAtA[i:], m.GuildFlagName)
	}
	if m.CountryId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CountryId))
	}
	if m.Level != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Level))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Exp))
	}
	if m.Male {
		dAtA[i] = 0x70
		i++
		if m.Male {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HasOldName {
		dAtA[i] = 0x78
		i++
		if m.HasOldName {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NextChangeNameTime != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.NextChangeNameTime))
	}
	if m.FightAmount != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.FightAmount))
	}
	if m.ChangeHeroNameTimes != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ChangeHeroNameTimes))
	}
	if m.GiveFirstChangeHeroNamePrize {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.GiveFirstChangeHeroNamePrize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Head != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Head))
	}
	if m.Body != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Body))
	}
	if len(m.Head2) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.Head2)))
		i += copy(dAtA[i:], m.Head2)
	}
	if len(m.SelfMilitaryInfo) > 0 {
		for _, msg := range m.SelfMilitaryInfo {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Region != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Region.Size()))
		n3, err := m.Region.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Guild != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Guild.Size()))
		n4, err := m.Guild.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.ContributionCoin != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ContributionCoin))
	}
	if len(m.GuildDonateTimes) > 0 {
		for _, num := range m.GuildDonateTimes {
			dAtA[i] = 0x88
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintHero(dAtA, i, uint64(num))
		}
	}
	if len(m.JoinGuildIds) > 0 {
		for _, num := range m.JoinGuildIds {
			dAtA[i] = 0x90
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintHero(dAtA, i, uint64(num))
		}
	}
	if len(m.BeenInvateGuildIds) > 0 {
		for _, num := range m.BeenInvateGuildIds {
			dAtA[i] = 0x98
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintHero(dAtA, i, uint64(num))
		}
	}
	if m.NextNotifyGuildTime != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.NextNotifyGuildTime))
	}
	if m.CollectedFirstJoinGuildPrize {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		if m.CollectedFirstJoinGuildPrize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Yuanbao != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Yuanbao))
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CreateTime))
	}
	if m.AccumLoginDay != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.AccumLoginDay))
	}
	if m.CollectedDailyGuildRankPrize {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		if m.CollectedDailyGuildRankPrize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Charge != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Charge.Size()))
		n5, err := m.Charge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Depot != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Depot.Size()))
		n6, err := m.Depot.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Tower != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Tower.Size()))
		n7, err := m.Tower.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Task != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Task.Size()))
		n8, err := m.Task.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.CaptainSoul != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CaptainSoul.Size()))
		n9, err := m.CaptainSoul.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.OpenCombineEquip != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.OpenCombineEquip.Size()))
		n10, err := m.OpenCombineEquip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Shop != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Shop.Size()))
		n11, err := m.Shop.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.SecretTower != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.SecretTower.Size()))
		n12, err := m.SecretTower.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Dungeon != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Dungeon.Size()))
		n13, err := m.Dungeon.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Tag != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Tag.Size()))
		n14, err := m.Tag.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Strategy != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Strategy.Size()))
		n15, err := m.Strategy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.ClientDatas != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ClientDatas.Size()))
		n16, err := m.ClientDatas.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Fishing != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Fishing.Size()))
		n17, err := m.Fishing.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.FuncOpen != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.FuncOpen.Size()))
		n18, err := m.FuncOpen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.GuiZu != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.GuiZu.Size()))
		n19, err := m.GuiZu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.TreasuryTree != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.TreasuryTree.Size()))
		n20, err := m.TreasuryTree.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.JoinGuildTime != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.JoinGuildTime))
	}
	if m.ZhengWu != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ZhengWu.Size()))
		n21, err := m.ZhengWu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.ZhanJiang != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ZhanJiang.Size()))
		n22, err := m.ZhanJiang.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Question != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Question.Size()))
		n23, err := m.Question.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Relation != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Relation.Size()))
		n24, err := m.Relation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Survey != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Survey.Size()))
		n25, err := m.Survey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Settings != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Settings.Size()))
		n26, err := m.Settings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Hebi != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Hebi.Size()))
		n27, err := m.Hebi.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Location != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Location))
	}
	if m.WorkshopOutputStartTime != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.WorkshopOutputStartTime))
	}
	if m.RandomEvent != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.RandomEvent.Size()))
		n28, err := m.RandomEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.Ctime != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Ctime))
	}
	if m.Bools != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Bools))
	}
	if m.HeroGen != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.HeroGen.Size()))
		n29, err := m.HeroGen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if len(m.BoolsArray) > 0 {
		for _, num := range m.BoolsArray {
			dAtA[i] = 0xc0
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintHero(dAtA, i, uint64(num))
		}
	}
	if m.Promotion != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Promotion.Size()))
		n30, err := m.Promotion.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.Yinliang != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Yinliang))
	}
	if m.Sp != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Sp))
	}
	if m.BuySpTimes != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.BuySpTimes))
	}
	if m.Buff != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Buff.Size()))
		n31, err := m.Buff.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.Vip != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Vip.Size()))
		n32, err := m.Vip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.McBuild != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.McBuild.Size()))
		n33, err := m.McBuild.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.RedPacket != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.RedPacket.Size()))
		n34, err := m.RedPacket.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.Teach != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Teach.Size()))
		n35, err := m.Teach.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.CountryOfficial != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CountryOfficial.Size()))
		n36, err := m.CountryOfficial.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.Dianquan != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Dianquan))
	}
	if m.ServerInfo != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ServerInfo.Size()))
		n37, err := m.ServerInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if len(m.CollectedGuildTaskStages) > 0 {
		for _, msg := range m.CollectedGuildTaskStages {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x8
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HeroGuildProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroGuildProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.FlagName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.FlagName)))
		i += copy(dAtA[i:], m.FlagName)
	}
	if m.Country != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Country))
	}
	if m.Level != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Level))
	}
	if len(m.Leader) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.Leader)))
		i += copy(dAtA[i:], m.Leader)
	}
	return i, nil
}

func (m *HeroRelationProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroRelationProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Friend) > 0 {
		for _, b := range m.Friend {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHero(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Black) > 0 {
		for _, b := range m.Black {
			dAtA[i] = 0x12
			i++
			i = encodeVarintHero(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Enemy) > 0 {
		for _, msg := range m.Enemy {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Important) > 0 {
		for _, msg := range m.Important {
			dAtA[i] = 0x22
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.FriendCreateTime) > 0 {
		for _, num := range m.FriendCreateTime {
			dAtA[i] = 0x28
			i++
			i = encodeVarintHero(dAtA, i, uint64(num))
		}
	}
	if len(m.BlackCreateTime) > 0 {
		for _, num := range m.BlackCreateTime {
			dAtA[i] = 0x30
			i++
			i = encodeVarintHero(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *HeroRandomEventProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroRandomEventProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Handbooks) > 0 {
		for _, num := range m.Handbooks {
			dAtA[i] = 0x10
			i++
			i = encodeVarintHero(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *HeroEnemyProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroEnemyProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EnemyId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.EnemyId)))
		i += copy(dAtA[i:], m.EnemyId)
	}
	if m.AddTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.AddTime))
	}
	return i, nil
}

func (m *HeroImportantFriendProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroImportantFriendProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FriendId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.FriendId)))
		i += copy(dAtA[i:], m.FriendId)
	}
	if m.SetTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.SetTime))
	}
	return i, nil
}

func (m *HeroServerInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroServerInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Sid))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.StartTime))
	}
	if len(m.LocalUrl) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.LocalUrl)))
		i += copy(dAtA[i:], m.LocalUrl)
	}
	if len(m.CosUrl) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.CosUrl)))
		i += copy(dAtA[i:], m.CosUrl)
	}
	return i, nil
}

func (m *OtherHeroProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OtherHeroProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.GuildName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.GuildName)))
		i += copy(dAtA[i:], m.GuildName)
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.GuildId))
	}
	if len(m.GuildFlagName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.GuildFlagName)))
		i += copy(dAtA[i:], m.GuildFlagName)
	}
	if m.CountryId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CountryId))
	}
	if m.Level != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Level))
	}
	if m.Male {
		dAtA[i] = 0x70
		i++
		if m.Male {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HasOldName {
		dAtA[i] = 0x78
		i++
		if m.HasOldName {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FightAmount != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.FightAmount))
	}
	if m.MaxTowerFloor != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MaxTowerFloor))
	}
	if len(m.Head) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.Head)))
		i += copy(dAtA[i:], m.Head)
	}
	if m.Home != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Home.Size()))
		n38, err := m.Home.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.Domestic != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Domestic.Size()))
		n39, err := m.Domestic.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.JunXianLevel != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.JunXianLevel))
	}
	if m.MaxBaseLevel != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MaxBaseLevel))
	}
	if m.HistoryMaxJunXianLevel != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.HistoryMaxJunXianLevel))
	}
	if m.HasWhiteFlag {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		if m.HasWhiteFlag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Tent != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Tent.Size()))
		n40, err := m.Tent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.Body != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Body))
	}
	if len(m.WhiteFlagName) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.WhiteFlagName)))
		i += copy(dAtA[i:], m.WhiteFlagName)
	}
	if m.Tag != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Tag.Size()))
		n41, err := m.Tag.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.CaptainSoul != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CaptainSoul.Size()))
		n42, err := m.CaptainSoul.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.SelectShowAchieves != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.SelectShowAchieves.Size()))
		n43, err := m.SelectShowAchieves.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.Location != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Location))
	}
	return i, nil
}

func (m *HeroRegionProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroRegionProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Home != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Home.Size()))
		n44, err := m.Home.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.HomeDefenseTroopIndex != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.HomeDefenseTroopIndex))
	}
	if m.HomeTroopDefeatedMailProto != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.HomeTroopDefeatedMailProto.Size()))
		n45, err := m.HomeTroopDefeatedMailProto.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.MultiLevelNpcStartRecoveryTime != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MultiLevelNpcStartRecoveryTime.Size()))
		n46, err := m.MultiLevelNpcStartRecoveryTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.InvaseHeroStartRecoveryTime != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.InvaseHeroStartRecoveryTime.Size()))
		n47, err := m.InvaseHeroStartRecoveryTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if m.JunTuanNpcStartTime != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.JunTuanNpcStartTime.Size()))
		n48, err := m.JunTuanNpcStartTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.WhiteFlagGuildId != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.WhiteFlagGuildId))
	}
	if len(m.WhiteFlagGuildFlagName) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.WhiteFlagGuildFlagName)))
		i += copy(dAtA[i:], m.WhiteFlagGuildFlagName)
	}
	if m.WhiteFlagDisappearTime != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.WhiteFlagDisappearTime))
	}
	if m.MianDisappearTime != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MianDisappearTime))
	}
	if m.MaxBaseLevel != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MaxBaseLevel))
	}
	if m.MoveBaseRestoreProsperityBufEndTime != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MoveBaseRestoreProsperityBufEndTime))
	}
	if m.NextUseMianGoodsTime != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.NextUseMianGoodsTime))
	}
	if m.MianStartTime != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MianStartTime))
	}
	if len(m.CopyDefenserCaptainId) > 0 {
		for _, num := range m.CopyDefenserCaptainId {
			dAtA[i] = 0xc8
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintHero(dAtA, i, uint64(num))
		}
	}
	if m.CopyDefenserSoldier != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CopyDefenserSoldier))
	}
	if m.CopyDefenserTotalSoldier != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CopyDefenserTotalSoldier))
	}
	if m.CopyDefenserEndTime != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CopyDefenserEndTime))
	}
	if m.CopyDefenserTroopIndex != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CopyDefenserTroopIndex))
	}
	if len(m.CopyDefenserCaptainXindex) > 0 {
		for _, num := range m.CopyDefenserCaptainXindex {
			dAtA[i] = 0xf0
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintHero(dAtA, i, uint64(num))
		}
	}
	if m.FavoritePoses != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.FavoritePoses.Size()))
		n49, err := m.FavoritePoses.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.NextInvestigateTime != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.NextInvestigateTime))
	}
	if len(m.MultiLevelNpc) > 0 {
		for _, msg := range m.MultiLevelNpc {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x4
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MultiLevelNpcPassLevel != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MultiLevelNpcPassLevel))
	}
	return i, nil
}

func (m *HeroMultiLevelNpcProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroMultiLevelNpcProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Type))
	}
	if m.PassLevel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.PassLevel))
	}
	if m.Hate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Hate))
	}
	return i, nil
}

func (m *FavoritePosesProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FavoritePosesProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Poses) > 0 {
		for _, msg := range m.Poses {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FavoritePosProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FavoritePosProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Id))
	}
	if m.X != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Y))
	}
	return i, nil
}

func (m *FavoritePosListProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FavoritePosListProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Detail) > 0 {
		for _, msg := range m.Detail {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FavoritePosDetailProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FavoritePosDetailProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pos != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Pos.Size()))
		n50, err := m.Pos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.HaveHero {
		dAtA[i] = 0x20
		i++
		if m.HaveHero {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Hero != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Hero.Size()))
		n51, err := m.Hero.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.IsHome {
		dAtA[i] = 0x30
		i++
		if m.IsHome {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *HeroBaseProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroBaseProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BaseRegion != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.BaseRegion))
	}
	if m.BaseLevel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.BaseLevel))
	}
	if m.BaseX != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.BaseX))
	}
	if m.BaseY != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.BaseY))
	}
	if m.Prosperity != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Prosperity))
	}
	return i, nil
}

func (m *StratagemProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StratagemProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Id))
	}
	if m.DailyUsedTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.DailyUsedTimes))
	}
	if m.NextUseableTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.NextUseableTime))
	}
	return i, nil
}

func (m *TrappedStratagemProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrappedStratagemProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Id))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *StratagemTargetTimesProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StratagemTargetTimesProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Times != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Times))
	}
	return i, nil
}

func (m *HeroStrategyProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroStrategyProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stratagems) > 0 {
		for _, msg := range m.Stratagems {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TrappedStratagems) > 0 {
		for _, msg := range m.TrappedStratagems {
			dAtA[i] = 0x12
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TodayTargetTimes) > 0 {
		for _, msg := range m.TodayTargetTimes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HeroClientDatasProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroClientDatasProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IntValue) > 0 {
		for _, num := range m.IntValue {
			dAtA[i] = 0x8
			i++
			i = encodeVarintHero(dAtA, i, uint64(num))
		}
	}
	if len(m.ClientKeys) > 0 {
		for _, num := range m.ClientKeys {
			dAtA[i] = 0x10
			i++
			i = encodeVarintHero(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func encodeFixed64Hero(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Hero(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintHero(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HeroProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovHero(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovHero(uint64(l))
	}
	if m.Domestic != nil {
		l = m.Domestic.Size()
		n += 1 + l + sovHero(uint64(l))
	}
	if m.Military != nil {
		l = m.Military.Size()
		n += 1 + l + sovHero(uint64(l))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 1 + l + sovHero(uint64(l))
	}
	if m.GuildId != 0 {
		n += 1 + sovHero(uint64(m.GuildId))
	}
	l = len(m.GuildFlagName)
	if l > 0 {
		n += 1 + l + sovHero(uint64(l))
	}
	if m.CountryId != 0 {
		n += 1 + sovHero(uint64(m.CountryId))
	}
	if m.Level != 0 {
		n += 1 + sovHero(uint64(m.Level))
	}
	if m.Exp != 0 {
		n += 1 + sovHero(uint64(m.Exp))
	}
	if m.Male {
		n += 2
	}
	if m.HasOldName {
		n += 2
	}
	if m.NextChangeNameTime != 0 {
		n += 2 + sovHero(uint64(m.NextChangeNameTime))
	}
	if m.FightAmount != 0 {
		n += 2 + sovHero(uint64(m.FightAmount))
	}
	if m.ChangeHeroNameTimes != 0 {
		n += 2 + sovHero(uint64(m.ChangeHeroNameTimes))
	}
	if m.GiveFirstChangeHeroNamePrize {
		n += 3
	}
	if m.Head != 0 {
		n += 2 + sovHero(uint64(m.Head))
	}
	if m.Body != 0 {
		n += 2 + sovHero(uint64(m.Body))
	}
	l = len(m.Head2)
	if l > 0 {
		n += 2 + l + sovHero(uint64(l))
	}
	if len(m.SelfMilitaryInfo) > 0 {
		for _, e := range m.SelfMilitaryInfo {
			l = e.Size()
			n += 2 + l + sovHero(uint64(l))
		}
	}
	if m.Region != nil {
		l = m.Region.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Guild != nil {
		l = m.Guild.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.ContributionCoin != 0 {
		n += 2 + sovHero(uint64(m.ContributionCoin))
	}
	if len(m.GuildDonateTimes) > 0 {
		for _, e := range m.GuildDonateTimes {
			n += 2 + sovHero(uint64(e))
		}
	}
	if len(m.JoinGuildIds) > 0 {
		for _, e := range m.JoinGuildIds {
			n += 2 + sovHero(uint64(e))
		}
	}
	if len(m.BeenInvateGuildIds) > 0 {
		for _, e := range m.BeenInvateGuildIds {
			n += 2 + sovHero(uint64(e))
		}
	}
	if m.NextNotifyGuildTime != 0 {
		n += 2 + sovHero(uint64(m.NextNotifyGuildTime))
	}
	if m.CollectedFirstJoinGuildPrize {
		n += 3
	}
	if m.Yuanbao != 0 {
		n += 2 + sovHero(uint64(m.Yuanbao))
	}
	if m.CreateTime != 0 {
		n += 2 + sovHero(uint64(m.CreateTime))
	}
	if m.AccumLoginDay != 0 {
		n += 2 + sovHero(uint64(m.AccumLoginDay))
	}
	if m.CollectedDailyGuildRankPrize {
		n += 3
	}
	if m.Charge != nil {
		l = m.Charge.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Depot != nil {
		l = m.Depot.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Tower != nil {
		l = m.Tower.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Task != nil {
		l = m.Task.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.CaptainSoul != nil {
		l = m.CaptainSoul.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.OpenCombineEquip != nil {
		l = m.OpenCombineEquip.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Shop != nil {
		l = m.Shop.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.SecretTower != nil {
		l = m.SecretTower.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Dungeon != nil {
		l = m.Dungeon.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Tag != nil {
		l = m.Tag.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Strategy != nil {
		l = m.Strategy.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.ClientDatas != nil {
		l = m.ClientDatas.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Fishing != nil {
		l = m.Fishing.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.FuncOpen != nil {
		l = m.FuncOpen.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.GuiZu != nil {
		l = m.GuiZu.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.TreasuryTree != nil {
		l = m.TreasuryTree.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.JoinGuildTime != 0 {
		n += 2 + sovHero(uint64(m.JoinGuildTime))
	}
	if m.ZhengWu != nil {
		l = m.ZhengWu.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.ZhanJiang != nil {
		l = m.ZhanJiang.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Question != nil {
		l = m.Question.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Relation != nil {
		l = m.Relation.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Survey != nil {
		l = m.Survey.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Settings != nil {
		l = m.Settings.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Hebi != nil {
		l = m.Hebi.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Location != 0 {
		n += 2 + sovHero(uint64(m.Location))
	}
	if m.WorkshopOutputStartTime != 0 {
		n += 2 + sovHero(uint64(m.WorkshopOutputStartTime))
	}
	if m.RandomEvent != nil {
		l = m.RandomEvent.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Ctime != 0 {
		n += 2 + sovHero(uint64(m.Ctime))
	}
	if m.Bools != 0 {
		n += 2 + sovHero(uint64(m.Bools))
	}
	if m.HeroGen != nil {
		l = m.HeroGen.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if len(m.BoolsArray) > 0 {
		for _, e := range m.BoolsArray {
			n += 2 + sovHero(uint64(e))
		}
	}
	if m.Promotion != nil {
		l = m.Promotion.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Yinliang != 0 {
		n += 2 + sovHero(uint64(m.Yinliang))
	}
	if m.Sp != 0 {
		n += 2 + sovHero(uint64(m.Sp))
	}
	if m.BuySpTimes != 0 {
		n += 2 + sovHero(uint64(m.BuySpTimes))
	}
	if m.Buff != nil {
		l = m.Buff.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Vip != nil {
		l = m.Vip.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.McBuild != nil {
		l = m.McBuild.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.RedPacket != nil {
		l = m.RedPacket.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Teach != nil {
		l = m.Teach.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.CountryOfficial != nil {
		l = m.CountryOfficial.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Dianquan != 0 {
		n += 2 + sovHero(uint64(m.Dianquan))
	}
	if m.ServerInfo != nil {
		l = m.ServerInfo.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if len(m.CollectedGuildTaskStages) > 0 {
		for _, e := range m.CollectedGuildTaskStages {
			l = e.Size()
			n += 2 + l + sovHero(uint64(l))
		}
	}
	return n
}

func (m *HeroGuildProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovHero(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovHero(uint64(l))
	}
	l = len(m.FlagName)
	if l > 0 {
		n += 1 + l + sovHero(uint64(l))
	}
	if m.Country != 0 {
		n += 1 + sovHero(uint64(m.Country))
	}
	if m.Level != 0 {
		n += 1 + sovHero(uint64(m.Level))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovHero(uint64(l))
	}
	return n
}

func (m *HeroRelationProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Friend) > 0 {
		for _, b := range m.Friend {
			l = len(b)
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if len(m.Black) > 0 {
		for _, b := range m.Black {
			l = len(b)
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if len(m.Enemy) > 0 {
		for _, e := range m.Enemy {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if len(m.Important) > 0 {
		for _, e := range m.Important {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if len(m.FriendCreateTime) > 0 {
		for _, e := range m.FriendCreateTime {
			n += 1 + sovHero(uint64(e))
		}
	}
	if len(m.BlackCreateTime) > 0 {
		for _, e := range m.BlackCreateTime {
			n += 1 + sovHero(uint64(e))
		}
	}
	return n
}

func (m *HeroRandomEventProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if len(m.Handbooks) > 0 {
		for _, e := range m.Handbooks {
			n += 1 + sovHero(uint64(e))
		}
	}
	return n
}

func (m *HeroEnemyProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.EnemyId)
	if l > 0 {
		n += 1 + l + sovHero(uint64(l))
	}
	if m.AddTime != 0 {
		n += 1 + sovHero(uint64(m.AddTime))
	}
	return n
}

func (m *HeroImportantFriendProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.FriendId)
	if l > 0 {
		n += 1 + l + sovHero(uint64(l))
	}
	if m.SetTime != 0 {
		n += 1 + sovHero(uint64(m.SetTime))
	}
	return n
}

func (m *HeroServerInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.Sid != 0 {
		n += 1 + sovHero(uint64(m.Sid))
	}
	if m.StartTime != 0 {
		n += 1 + sovHero(uint64(m.StartTime))
	}
	l = len(m.LocalUrl)
	if l > 0 {
		n += 1 + l + sovHero(uint64(l))
	}
	l = len(m.CosUrl)
	if l > 0 {
		n += 1 + l + sovHero(uint64(l))
	}
	return n
}

func (m *OtherHeroProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovHero(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovHero(uint64(l))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 1 + l + sovHero(uint64(l))
	}
	if m.GuildId != 0 {
		n += 1 + sovHero(uint64(m.GuildId))
	}
	l = len(m.GuildFlagName)
	if l > 0 {
		n += 1 + l + sovHero(uint64(l))
	}
	if m.CountryId != 0 {
		n += 1 + sovHero(uint64(m.CountryId))
	}
	if m.Level != 0 {
		n += 1 + sovHero(uint64(m.Level))
	}
	if m.Male {
		n += 2
	}
	if m.HasOldName {
		n += 2
	}
	if m.FightAmount != 0 {
		n += 2 + sovHero(uint64(m.FightAmount))
	}
	if m.MaxTowerFloor != 0 {
		n += 2 + sovHero(uint64(m.MaxTowerFloor))
	}
	l = len(m.Head)
	if l > 0 {
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Home != nil {
		l = m.Home.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Domestic != nil {
		l = m.Domestic.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.JunXianLevel != 0 {
		n += 2 + sovHero(uint64(m.JunXianLevel))
	}
	if m.MaxBaseLevel != 0 {
		n += 2 + sovHero(uint64(m.MaxBaseLevel))
	}
	if m.HistoryMaxJunXianLevel != 0 {
		n += 2 + sovHero(uint64(m.HistoryMaxJunXianLevel))
	}
	if m.HasWhiteFlag {
		n += 3
	}
	if m.Tent != nil {
		l = m.Tent.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Body != 0 {
		n += 2 + sovHero(uint64(m.Body))
	}
	l = len(m.WhiteFlagName)
	if l > 0 {
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Tag != nil {
		l = m.Tag.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.CaptainSoul != nil {
		l = m.CaptainSoul.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.SelectShowAchieves != nil {
		l = m.SelectShowAchieves.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Location != 0 {
		n += 2 + sovHero(uint64(m.Location))
	}
	return n
}

func (m *HeroRegionProto) Size() (n int) {
	var l int
	_ = l
	if m.Home != nil {
		l = m.Home.Size()
		n += 1 + l + sovHero(uint64(l))
	}
	if m.HomeDefenseTroopIndex != 0 {
		n += 1 + sovHero(uint64(m.HomeDefenseTroopIndex))
	}
	if m.HomeTroopDefeatedMailProto != nil {
		l = m.HomeTroopDefeatedMailProto.Size()
		n += 1 + l + sovHero(uint64(l))
	}
	if m.MultiLevelNpcStartRecoveryTime != nil {
		l = m.MultiLevelNpcStartRecoveryTime.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.InvaseHeroStartRecoveryTime != nil {
		l = m.InvaseHeroStartRecoveryTime.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.JunTuanNpcStartTime != nil {
		l = m.JunTuanNpcStartTime.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.WhiteFlagGuildId != 0 {
		n += 2 + sovHero(uint64(m.WhiteFlagGuildId))
	}
	l = len(m.WhiteFlagGuildFlagName)
	if l > 0 {
		n += 2 + l + sovHero(uint64(l))
	}
	if m.WhiteFlagDisappearTime != 0 {
		n += 2 + sovHero(uint64(m.WhiteFlagDisappearTime))
	}
	if m.MianDisappearTime != 0 {
		n += 2 + sovHero(uint64(m.MianDisappearTime))
	}
	if m.MaxBaseLevel != 0 {
		n += 2 + sovHero(uint64(m.MaxBaseLevel))
	}
	if m.MoveBaseRestoreProsperityBufEndTime != 0 {
		n += 2 + sovHero(uint64(m.MoveBaseRestoreProsperityBufEndTime))
	}
	if m.NextUseMianGoodsTime != 0 {
		n += 2 + sovHero(uint64(m.NextUseMianGoodsTime))
	}
	if m.MianStartTime != 0 {
		n += 2 + sovHero(uint64(m.MianStartTime))
	}
	if len(m.CopyDefenserCaptainId) > 0 {
		for _, e := range m.CopyDefenserCaptainId {
			n += 2 + sovHero(uint64(e))
		}
	}
	if m.CopyDefenserSoldier != 0 {
		n += 2 + sovHero(uint64(m.CopyDefenserSoldier))
	}
	if m.CopyDefenserTotalSoldier != 0 {
		n += 2 + sovHero(uint64(m.CopyDefenserTotalSoldier))
	}
	if m.CopyDefenserEndTime != 0 {
		n += 2 + sovHero(uint64(m.CopyDefenserEndTime))
	}
	if m.CopyDefenserTroopIndex != 0 {
		n += 2 + sovHero(uint64(m.CopyDefenserTroopIndex))
	}
	if len(m.CopyDefenserCaptainXindex) > 0 {
		for _, e := range m.CopyDefenserCaptainXindex {
			n += 2 + sovHero(uint64(e))
		}
	}
	if m.FavoritePoses != nil {
		l = m.FavoritePoses.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.NextInvestigateTime != 0 {
		n += 2 + sovHero(uint64(m.NextInvestigateTime))
	}
	if len(m.MultiLevelNpc) > 0 {
		for _, e := range m.MultiLevelNpc {
			l = e.Size()
			n += 2 + l + sovHero(uint64(l))
		}
	}
	if m.MultiLevelNpcPassLevel != 0 {
		n += 2 + sovHero(uint64(m.MultiLevelNpcPassLevel))
	}
	return n
}

func (m *HeroMultiLevelNpcProto) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovHero(uint64(m.Type))
	}
	if m.PassLevel != 0 {
		n += 1 + sovHero(uint64(m.PassLevel))
	}
	if m.Hate != 0 {
		n += 1 + sovHero(uint64(m.Hate))
	}
	return n
}

func (m *FavoritePosesProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Poses) > 0 {
		for _, e := range m.Poses {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	return n
}

func (m *FavoritePosProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovHero(uint64(m.Id))
	}
	if m.X != 0 {
		n += 1 + sovHero(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovHero(uint64(m.Y))
	}
	return n
}

func (m *FavoritePosListProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Detail) > 0 {
		for _, e := range m.Detail {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	return n
}

func (m *FavoritePosDetailProto) Size() (n int) {
	var l int
	_ = l
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovHero(uint64(l))
	}
	if m.HaveHero {
		n += 2
	}
	if m.Hero != nil {
		l = m.Hero.Size()
		n += 1 + l + sovHero(uint64(l))
	}
	if m.IsHome {
		n += 2
	}
	return n
}

func (m *HeroBaseProto) Size() (n int) {
	var l int
	_ = l
	if m.BaseRegion != 0 {
		n += 1 + sovHero(uint64(m.BaseRegion))
	}
	if m.BaseLevel != 0 {
		n += 1 + sovHero(uint64(m.BaseLevel))
	}
	if m.BaseX != 0 {
		n += 1 + sovHero(uint64(m.BaseX))
	}
	if m.BaseY != 0 {
		n += 1 + sovHero(uint64(m.BaseY))
	}
	if m.Prosperity != 0 {
		n += 1 + sovHero(uint64(m.Prosperity))
	}
	return n
}

func (m *StratagemProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovHero(uint64(m.Id))
	}
	if m.DailyUsedTimes != 0 {
		n += 1 + sovHero(uint64(m.DailyUsedTimes))
	}
	if m.NextUseableTime != 0 {
		n += 1 + sovHero(uint64(m.NextUseableTime))
	}
	return n
}

func (m *TrappedStratagemProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovHero(uint64(m.Id))
	}
	if m.EndTime != 0 {
		n += 1 + sovHero(uint64(m.EndTime))
	}
	return n
}

func (m *StratagemTargetTimesProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovHero(uint64(l))
	}
	if m.Times != 0 {
		n += 1 + sovHero(uint64(m.Times))
	}
	return n
}

func (m *HeroStrategyProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Stratagems) > 0 {
		for _, e := range m.Stratagems {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if len(m.TrappedStratagems) > 0 {
		for _, e := range m.TrappedStratagems {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if len(m.TodayTargetTimes) > 0 {
		for _, e := range m.TodayTargetTimes {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	return n
}

func (m *HeroClientDatasProto) Size() (n int) {
	var l int
	_ = l
	if len(m.IntValue) > 0 {
		for _, e := range m.IntValue {
			n += 1 + sovHero(uint64(e))
		}
	}
	if len(m.ClientKeys) > 0 {
		for _, e := range m.ClientKeys {
			n += 1 + sovHero(uint64(e))
		}
	}
	return n
}

func sovHero(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozHero(x uint64) (n int) {
	return sovHero(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HeroProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domestic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Domestic == nil {
				m.Domestic = &HeroDomesticProto{}
			}
			if err := m.Domestic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Military", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Military == nil {
				m.Military = &HeroMilitaryProto{}
			}
			if err := m.Military.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildFlagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildFlagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryId", wireType)
			}
			m.CountryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountryId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Male", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Male = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasOldName", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasOldName = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextChangeNameTime", wireType)
			}
			m.NextChangeNameTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextChangeNameTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightAmount", wireType)
			}
			m.FightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeHeroNameTimes", wireType)
			}
			m.ChangeHeroNameTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeHeroNameTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiveFirstChangeHeroNamePrize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GiveFirstChangeHeroNamePrize = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			m.Head = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Head |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			m.Body = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Body |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfMilitaryInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelfMilitaryInfo = append(m.SelfMilitaryInfo, &MilitaryInfoProto{})
			if err := m.SelfMilitaryInfo[len(m.SelfMilitaryInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Region == nil {
				m.Region = &HeroRegionProto{}
			}
			if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guild", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Guild == nil {
				m.Guild = &HeroGuildProto{}
			}
			if err := m.Guild.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContributionCoin", wireType)
			}
			m.ContributionCoin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContributionCoin |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GuildDonateTimes = append(m.GuildDonateTimes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GuildDonateTimes = append(m.GuildDonateTimes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildDonateTimes", wireType)
			}
		case 34:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.JoinGuildIds = append(m.JoinGuildIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.JoinGuildIds = append(m.JoinGuildIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinGuildIds", wireType)
			}
		case 35:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BeenInvateGuildIds = append(m.BeenInvateGuildIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BeenInvateGuildIds = append(m.BeenInvateGuildIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BeenInvateGuildIds", wireType)
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextNotifyGuildTime", wireType)
			}
			m.NextNotifyGuildTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextNotifyGuildTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedFirstJoinGuildPrize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CollectedFirstJoinGuildPrize = bool(v != 0)
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yuanbao", wireType)
			}
			m.Yuanbao = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Yuanbao |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccumLoginDay", wireType)
			}
			m.AccumLoginDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccumLoginDay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedDailyGuildRankPrize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CollectedDailyGuildRankPrize = bool(v != 0)
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Charge == nil {
				m.Charge = &ChargeProto{}
			}
			if err := m.Charge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Depot == nil {
				m.Depot = &HeroDepotProto{}
			}
			if err := m.Depot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tower", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tower == nil {
				m.Tower = &HeroTowerProto{}
			}
			if err := m.Tower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Task == nil {
				m.Task = &HeroTaskProto{}
			}
			if err := m.Task.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainSoul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CaptainSoul == nil {
				m.CaptainSoul = &HeroCaptainSoulProto{}
			}
			if err := m.CaptainSoul.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenCombineEquip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenCombineEquip == nil {
				m.OpenCombineEquip = &HeroOpenCombineEquipProto{}
			}
			if err := m.OpenCombineEquip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shop == nil {
				m.Shop = &HeroShopProto{}
			}
			if err := m.Shop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretTower", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecretTower == nil {
				m.SecretTower = &HeroSecretTowerProto{}
			}
			if err := m.SecretTower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 59:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dungeon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dungeon == nil {
				m.Dungeon = &HeroDungeonProto{}
			}
			if err := m.Dungeon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tag == nil {
				m.Tag = &HeroTagProto{}
			}
			if err := m.Tag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 62:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Strategy == nil {
				m.Strategy = &HeroStrategyProto{}
			}
			if err := m.Strategy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 63:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientDatas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientDatas == nil {
				m.ClientDatas = &HeroClientDatasProto{}
			}
			if err := m.ClientDatas.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 64:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fishing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fishing == nil {
				m.Fishing = &HeroFishingProto{}
			}
			if err := m.Fishing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 65:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuncOpen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FuncOpen == nil {
				m.FuncOpen = &HeroFunctionProto{}
			}
			if err := m.FuncOpen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 66:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuiZu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GuiZu == nil {
				m.GuiZu = &HeroGuiZuProto{}
			}
			if err := m.GuiZu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 67:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryTree", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TreasuryTree == nil {
				m.TreasuryTree = &HeroTreasuryTreeProto{}
			}
			if err := m.TreasuryTree.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 68:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinGuildTime", wireType)
			}
			m.JoinGuildTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinGuildTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 69:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZhengWu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZhengWu == nil {
				m.ZhengWu = &HeroZhengWuProto{}
			}
			if err := m.ZhengWu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZhanJiang", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZhanJiang == nil {
				m.ZhanJiang = &HeroZhanJiangProto{}
			}
			if err := m.ZhanJiang.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 71:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Question", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Question == nil {
				m.Question = &HeroQuestionProto{}
			}
			if err := m.Question.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 72:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Relation == nil {
				m.Relation = &HeroRelationProto{}
			}
			if err := m.Relation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 73:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Survey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Survey == nil {
				m.Survey = &HeroSurveyProto{}
			}
			if err := m.Survey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 74:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Settings == nil {
				m.Settings = &HeroSettingsProto{}
			}
			if err := m.Settings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 75:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hebi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hebi == nil {
				m.Hebi = &HeroHebiProto{}
			}
			if err := m.Hebi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 76:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			m.Location = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Location |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 77:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopOutputStartTime", wireType)
			}
			m.WorkshopOutputStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopOutputStartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 78:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RandomEvent == nil {
				m.RandomEvent = &HeroRandomEventProto{}
			}
			if err := m.RandomEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bools", wireType)
			}
			m.Bools = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bools |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroGen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeroGen == nil {
				m.HeroGen = &HeroGenProto{}
			}
			if err := m.HeroGen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 104:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BoolsArray = append(m.BoolsArray, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BoolsArray = append(m.BoolsArray, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolsArray", wireType)
			}
		case 105:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Promotion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Promotion == nil {
				m.Promotion = &HeroPromotionProto{}
			}
			if err := m.Promotion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 106:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yinliang", wireType)
			}
			m.Yinliang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Yinliang |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 107:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sp", wireType)
			}
			m.Sp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 108:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuySpTimes", wireType)
			}
			m.BuySpTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuySpTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 109:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Buff == nil {
				m.Buff = &HeroBuffProto{}
			}
			if err := m.Buff.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 110:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vip == nil {
				m.Vip = &HeroVipProto{}
			}
			if err := m.Vip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 111:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McBuild", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.McBuild == nil {
				m.McBuild = &HeroMcBuildProto{}
			}
			if err := m.McBuild.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 112:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedPacket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RedPacket == nil {
				m.RedPacket = &HeroRedPacketProto{}
			}
			if err := m.RedPacket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 116:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Teach", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Teach == nil {
				m.Teach = &HeroTeachProto{}
			}
			if err := m.Teach.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 117:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryOfficial", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CountryOfficial == nil {
				m.CountryOfficial = &HeroCountryMiscProto{}
			}
			if err := m.CountryOfficial.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 126:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dianquan", wireType)
			}
			m.Dianquan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dianquan |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 127:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerInfo == nil {
				m.ServerInfo = &HeroServerInfoProto{}
			}
			if err := m.ServerInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 130:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedGuildTaskStages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectedGuildTaskStages = append(m.CollectedGuildTaskStages, &Int32PairInt32ArrayProto{})
			if err := m.CollectedGuildTaskStages[len(m.CollectedGuildTaskStages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroGuildProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroGuildProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroGuildProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			m.Country = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Country |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = append(m.Leader[:0], dAtA[iNdEx:postIndex]...)
			if m.Leader == nil {
				m.Leader = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroRelationProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroRelationProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroRelationProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Friend", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Friend = append(m.Friend, make([]byte, postIndex-iNdEx))
			copy(m.Friend[len(m.Friend)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Black", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Black = append(m.Black, make([]byte, postIndex-iNdEx))
			copy(m.Black[len(m.Black)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enemy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enemy = append(m.Enemy, &HeroEnemyProto{})
			if err := m.Enemy[len(m.Enemy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Important", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Important = append(m.Important, &HeroImportantFriendProto{})
			if err := m.Important[len(m.Important)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FriendCreateTime = append(m.FriendCreateTime, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FriendCreateTime = append(m.FriendCreateTime, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendCreateTime", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BlackCreateTime = append(m.BlackCreateTime, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BlackCreateTime = append(m.BlackCreateTime, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BlackCreateTime", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroRandomEventProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroRandomEventProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroRandomEventProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &EventPositionProto{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Handbooks = append(m.Handbooks, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Handbooks = append(m.Handbooks, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Handbooks", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroEnemyProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroEnemyProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroEnemyProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnemyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnemyId = append(m.EnemyId[:0], dAtA[iNdEx:postIndex]...)
			if m.EnemyId == nil {
				m.EnemyId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddTime", wireType)
			}
			m.AddTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroImportantFriendProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroImportantFriendProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroImportantFriendProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FriendId = append(m.FriendId[:0], dAtA[iNdEx:postIndex]...)
			if m.FriendId == nil {
				m.FriendId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetTime", wireType)
			}
			m.SetTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroServerInfoProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroServerInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroServerInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CosUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OtherHeroProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OtherHeroProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OtherHeroProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildFlagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildFlagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryId", wireType)
			}
			m.CountryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountryId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Male", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Male = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasOldName", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasOldName = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightAmount", wireType)
			}
			m.FightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTowerFloor", wireType)
			}
			m.MaxTowerFloor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTowerFloor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Home", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Home == nil {
				m.Home = &HeroBaseProto{}
			}
			if err := m.Home.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domestic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Domestic == nil {
				m.Domestic = &HeroDomesticOtherProto{}
			}
			if err := m.Domestic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JunXianLevel", wireType)
			}
			m.JunXianLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JunXianLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBaseLevel", wireType)
			}
			m.MaxBaseLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBaseLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryMaxJunXianLevel", wireType)
			}
			m.HistoryMaxJunXianLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistoryMaxJunXianLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasWhiteFlag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasWhiteFlag = bool(v != 0)
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tent == nil {
				m.Tent = &HeroBaseProto{}
			}
			if err := m.Tent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			m.Body = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Body |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhiteFlagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WhiteFlagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 59:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tag == nil {
				m.Tag = &HeroTagProto{}
			}
			if err := m.Tag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainSoul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CaptainSoul == nil {
				m.CaptainSoul = &HeroCaptainSoulOtherProto{}
			}
			if err := m.CaptainSoul.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectShowAchieves", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SelectShowAchieves == nil {
				m.SelectShowAchieves = &SelectShowAchievesProto{}
			}
			if err := m.SelectShowAchieves.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 76:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			m.Location = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Location |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroRegionProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroRegionProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroRegionProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Home", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Home == nil {
				m.Home = &HeroBaseProto{}
			}
			if err := m.Home.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeDefenseTroopIndex", wireType)
			}
			m.HomeDefenseTroopIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HomeDefenseTroopIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeTroopDefeatedMailProto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HomeTroopDefeatedMailProto == nil {
				m.HomeTroopDefeatedMailProto = &MailProto{}
			}
			if err := m.HomeTroopDefeatedMailProto.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiLevelNpcStartRecoveryTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MultiLevelNpcStartRecoveryTime == nil {
				m.MultiLevelNpcStartRecoveryTime = &RecoverableTimesWithExtraTimesProto{}
			}
			if err := m.MultiLevelNpcStartRecoveryTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvaseHeroStartRecoveryTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InvaseHeroStartRecoveryTime == nil {
				m.InvaseHeroStartRecoveryTime = &RecoverableTimesWithExtraTimesProto{}
			}
			if err := m.InvaseHeroStartRecoveryTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JunTuanNpcStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JunTuanNpcStartTime == nil {
				m.JunTuanNpcStartTime = &RecoverableTimesWithExtraTimesProto{}
			}
			if err := m.JunTuanNpcStartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhiteFlagGuildId", wireType)
			}
			m.WhiteFlagGuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WhiteFlagGuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhiteFlagGuildFlagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WhiteFlagGuildFlagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhiteFlagDisappearTime", wireType)
			}
			m.WhiteFlagDisappearTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WhiteFlagDisappearTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MianDisappearTime", wireType)
			}
			m.MianDisappearTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MianDisappearTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBaseLevel", wireType)
			}
			m.MaxBaseLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBaseLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveBaseRestoreProsperityBufEndTime", wireType)
			}
			m.MoveBaseRestoreProsperityBufEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveBaseRestoreProsperityBufEndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextUseMianGoodsTime", wireType)
			}
			m.NextUseMianGoodsTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextUseMianGoodsTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MianStartTime", wireType)
			}
			m.MianStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MianStartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CopyDefenserCaptainId = append(m.CopyDefenserCaptainId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CopyDefenserCaptainId = append(m.CopyDefenserCaptainId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyDefenserCaptainId", wireType)
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyDefenserSoldier", wireType)
			}
			m.CopyDefenserSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CopyDefenserSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyDefenserTotalSoldier", wireType)
			}
			m.CopyDefenserTotalSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CopyDefenserTotalSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyDefenserEndTime", wireType)
			}
			m.CopyDefenserEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CopyDefenserEndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyDefenserTroopIndex", wireType)
			}
			m.CopyDefenserTroopIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CopyDefenserTroopIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CopyDefenserCaptainXindex = append(m.CopyDefenserCaptainXindex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CopyDefenserCaptainXindex = append(m.CopyDefenserCaptainXindex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyDefenserCaptainXindex", wireType)
			}
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FavoritePoses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FavoritePoses == nil {
				m.FavoritePoses = &FavoritePosesProto{}
			}
			if err := m.FavoritePoses.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 68:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextInvestigateTime", wireType)
			}
			m.NextInvestigateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextInvestigateTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 69:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiLevelNpc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultiLevelNpc = append(m.MultiLevelNpc, &HeroMultiLevelNpcProto{})
			if err := m.MultiLevelNpc[len(m.MultiLevelNpc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 70:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiLevelNpcPassLevel", wireType)
			}
			m.MultiLevelNpcPassLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MultiLevelNpcPassLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroMultiLevelNpcProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroMultiLevelNpcProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroMultiLevelNpcProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MultiLevelNpcType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassLevel", wireType)
			}
			m.PassLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PassLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hate", wireType)
			}
			m.Hate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FavoritePosesProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FavoritePosesProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FavoritePosesProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poses = append(m.Poses, &FavoritePosProto{})
			if err := m.Poses[len(m.Poses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FavoritePosProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FavoritePosProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FavoritePosProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FavoritePosListProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FavoritePosListProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FavoritePosListProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = append(m.Detail, &FavoritePosDetailProto{})
			if err := m.Detail[len(m.Detail)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FavoritePosDetailProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FavoritePosDetailProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FavoritePosDetailProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &FavoritePosProto{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HaveHero", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HaveHero = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hero", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hero == nil {
				m.Hero = &HeroBasicProto{}
			}
			if err := m.Hero.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHome", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHome = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroBaseProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroBaseProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroBaseProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseRegion", wireType)
			}
			m.BaseRegion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseRegion |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseLevel", wireType)
			}
			m.BaseLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseX", wireType)
			}
			m.BaseX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseY", wireType)
			}
			m.BaseY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prosperity", wireType)
			}
			m.Prosperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prosperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StratagemProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StratagemProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StratagemProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyUsedTimes", wireType)
			}
			m.DailyUsedTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailyUsedTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextUseableTime", wireType)
			}
			m.NextUseableTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextUseableTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrappedStratagemProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrappedStratagemProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrappedStratagemProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StratagemTargetTimesProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StratagemTargetTimesProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StratagemTargetTimesProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Times", wireType)
			}
			m.Times = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Times |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroStrategyProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroStrategyProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroStrategyProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stratagems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stratagems = append(m.Stratagems, &StratagemProto{})
			if err := m.Stratagems[len(m.Stratagems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrappedStratagems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrappedStratagems = append(m.TrappedStratagems, &TrappedStratagemProto{})
			if err := m.TrappedStratagems[len(m.TrappedStratagems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TodayTargetTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TodayTargetTimes = append(m.TodayTargetTimes, &StratagemTargetTimesProto{})
			if err := m.TodayTargetTimes[len(m.TodayTargetTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroClientDatasProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroClientDatasProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroClientDatasProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IntValue = append(m.IntValue, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IntValue = append(m.IntValue, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IntValue", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ClientKeys = append(m.ClientKeys, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ClientKeys = append(m.ClientKeys, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientKeys", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHero(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHero
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHero
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHero
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthHero
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowHero
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipHero(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthHero = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHero   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/shared_proto/hero.proto", fileDescriptorHero)
}

var fileDescriptorHero = []byte{
	// 4066 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x5a, 0xdd, 0x72, 0x1b, 0xc7,
	0x72, 0x36, 0x48, 0xf1, 0x6f, 0xf8, 0xb7, 0x1c, 0xfe, 0x68, 0x49, 0x89, 0x14, 0x05, 0xd9, 0x3a,
	0x94, 0x6c, 0x4b, 0xb1, 0x64, 0x59, 0xd6, 0xd1, 0xb1, 0x73, 0x40, 0x60, 0x41, 0x42, 0x02, 0x01,
	0x9c, 0x05, 0x20, 0xc9, 0xaa, 0x54, 0x4d, 0x06, 0xd8, 0x01, 0xb0, 0x22, 0xb0, 0x0b, 0xef, 0x0f,
	0x49, 0xa8, 0x52, 0x49, 0x55, 0x5e, 0x20, 0xb7, 0xe7, 0x26, 0x95, 0x9b, 0xdc, 0xe4, 0x3a, 0xef,
	0x90, 0xca, 0x65, 0x1e, 0x21, 0xe5, 0x5c, 0xe4, 0x35, 0x4e, 0x75, 0xcf, 0xec, 0x62, 0x01, 0xd0,
	0xc7, 0x86, 0xaf, 0x84, 0xed, 0xfe, 0xba, 0xa7, 0xa7, 0xbb, 0xa7, 0xa7, 0x7b, 0x28, 0xf2, 0x75,
	0xdb, 0x0e, 0x3a, 0x61, 0xe3, 0x51, 0xd3, 0xed, 0x3d, 0xee, 0xda, 0xed, 0x4e, 0xd0, 0xe7, 0x97,
	0x8f, 0x7b, 0xbc, 0x2b, 0x9e, 0x3f, 0xee, 0x37, 0x1e, 0xfb, 0x1d, 0xee, 0x09, 0x8b, 0xf5, 0x3d,
	0x37, 0x70, 0x1f, 0x77, 0x84, 0xe7, 0x3e, 0xc2, 0x9f, 0x74, 0x0e, 0xff, 0xd9, 0xfb, 0x76, 0x3a,
	0x61, 0xd6, 0x16, 0xce, 0xa3, 0xa9, 0x25, 0x2d, 0xb7, 0x27, 0xfc, 0xc0, 0x6e, 0x4e, 0x2f, 0xd9,
	0xb3, 0xbb, 0x76, 0xc0, 0xbd, 0x81, 0x92, 0x7c, 0x36, 0xc5, 0x9a, 0xa2, 0xef, 0x06, 0xd3, 0x8b,
	0x05, 0xee, 0xa5, 0xf0, 0x94, 0xd8, 0x14, 0x8e, 0x0d, 0xb8, 0x7f, 0xae, 0xa4, 0xfe, 0xf0, 0xeb,
	0xa5, 0x9a, 0xbc, 0x1f, 0x70, 0xdb, 0x61, 0xbe, 0x1b, 0x76, 0xa7, 0x5f, 0xd3, 0xef, 0xb8, 0x7d,
	0x25, 0xf5, 0x74, 0x1a, 0x4b, 0xdb, 0x4a, 0xe8, 0xf9, 0x14, 0xce, 0x0c, 0x9d, 0xb6, 0x70, 0x9d,
	0xe9, 0x05, 0x5b, 0xb6, 0xdf, 0xb1, 0x9d, 0xf6, 0xf4, 0x81, 0xf7, 0x1d, 0xde, 0xf7, 0x3b, 0x71,
	0x04, 0xa7, 0x90, 0x6c, 0x85, 0x4e, 0x33, 0xb0, 0x63, 0x63, 0xa7, 0x88, 0x7d, 0x3b, 0xb4, 0x3f,
	0x86, 0xd3, 0xc7, 0xa1, 0xc7, 0xed, 0x28, 0x7a, 0xdf, 0xfc, 0x7a, 0x29, 0x4f, 0xb4, 0x87, 0x46,
	0x4e, 0x21, 0xd7, 0xe6, 0x9e, 0x25, 0x7e, 0x43, 0x24, 0x3e, 0x76, 0x84, 0xd3, 0xbe, 0x0c, 0xa7,
	0xf7, 0xe7, 0x8f, 0x21, 0x9c, 0xdd, 0xd8, 0xd4, 0x17, 0xd3, 0x2c, 0xc9, 0x9d, 0x0f, 0x36, 0x8f,
	0xc3, 0x3f, 0xc5, 0x2e, 0xfd, 0xd0, 0xbb, 0x10, 0x83, 0xe9, 0x63, 0xd1, 0x11, 0x0d, 0x7b, 0x7a,
	0xa9, 0x06, 0xf7, 0xc5, 0xf4, 0x1e, 0xf5, 0x45, 0x10, 0x0c, 0x73, 0x7b, 0x0a, 0xbf, 0xf4, 0x3d,
	0xb7, 0xe7, 0x26, 0x5c, 0x3a, 0x45, 0xc5, 0xf0, 0xb8, 0x63, 0xb9, 0x3d, 0x26, 0x2e, 0x84, 0x13,
	0xfc, 0x86, 0x7d, 0x86, 0xad, 0xd6, 0xf4, 0xb1, 0x68, 0x76, 0xb8, 0xd7, 0x16, 0xd3, 0x57, 0x9a,
	0x0b, 0xbb, 0x3f, 0xfd, 0x19, 0xec, 0xd9, 0x4e, 0xbb, 0xf9, 0x1b, 0xca, 0xb6, 0xe0, 0xcd, 0x8e,
	0x12, 0xfb, 0xfd, 0x34, 0x87, 0xd0, 0x62, 0x7d, 0xde, 0x3c, 0x17, 0xc1, 0xf4, 0xe1, 0x6f, 0xba,
	0xa1, 0x13, 0x44, 0x37, 0x53, 0xfa, 0xdf, 0x6e, 0x91, 0xa5, 0x53, 0xe1, 0xb9, 0x15, 0xbc, 0x5c,
	0xd7, 0xc8, 0x8c, 0x6d, 0xe9, 0xa9, 0xc3, 0xd4, 0xd1, 0x8a, 0x39, 0x63, 0x5b, 0x94, 0x92, 0x1b,
	0x0e, 0xef, 0x09, 0x7d, 0xe6, 0x30, 0x75, 0xb4, 0x64, 0xe2, 0x6f, 0xfa, 0x35, 0x59, 0x8c, 0xee,
	0x45, 0x7d, 0xf6, 0x30, 0x75, 0xb4, 0xfc, 0x44, 0x97, 0xba, 0x1e, 0x81, 0x9e, 0x9c, 0x62, 0xa1,
	0x3e, 0x33, 0x46, 0x82, 0x54, 0x74, 0x27, 0xea, 0x37, 0x26, 0xa4, 0xce, 0x14, 0x4b, 0x49, 0x45,
	0x48, 0x7a, 0x97, 0x90, 0x76, 0x68, 0x77, 0x2d, 0x86, 0x56, 0xcc, 0x81, 0x15, 0xc7, 0x33, 0x7a,
	0xca, 0x5c, 0x42, 0x6a, 0x09, 0xcc, 0xd9, 0x27, 0x8b, 0x12, 0x62, 0x5b, 0xfa, 0xfc, 0x61, 0xea,
	0x68, 0x0e, 0x01, 0x0b, 0x48, 0x2b, 0x58, 0xf4, 0x21, 0x59, 0x97, 0xec, 0x56, 0x97, 0xb7, 0xa5,
	0x9a, 0x85, 0x58, 0xcd, 0x2a, 0xb2, 0xf2, 0x5d, 0xde, 0x46, 0x55, 0x77, 0x09, 0x51, 0xce, 0x01,
	0x65, 0x8b, 0xb1, 0xb2, 0x25, 0x45, 0x2d, 0x58, 0x74, 0x8b, 0xcc, 0x75, 0xc5, 0x85, 0xe8, 0xea,
	0x2b, 0xc0, 0x35, 0xe5, 0x07, 0xd5, 0xc8, 0xac, 0xb8, 0xea, 0xeb, 0xab, 0x48, 0x83, 0x9f, 0xe0,
	0x38, 0xf0, 0xbe, 0xbe, 0x76, 0x98, 0x3a, 0x5a, 0x34, 0xf1, 0x37, 0x3d, 0x24, 0x2b, 0x1d, 0xee,
	0x33, 0x37, 0xda, 0xce, 0x3a, 0xf2, 0x48, 0x87, 0xfb, 0x65, 0xb5, 0x97, 0xaf, 0xc8, 0xb6, 0x23,
	0xae, 0x02, 0xd6, 0xec, 0x70, 0xa7, 0x2d, 0x10, 0xc5, 0x02, 0xbb, 0x27, 0x74, 0x0d, 0x35, 0x53,
	0x60, 0x66, 0x91, 0x07, 0xf0, 0x9a, 0x8d, 0x36, 0xaf, 0xb4, 0x20, 0xde, 0x8c, 0xf7, 0xc0, 0x48,
	0x7d, 0x03, 0x91, 0xcb, 0x48, 0xcb, 0x20, 0x89, 0x3e, 0x25, 0x3b, 0x4a, 0x21, 0x76, 0x42, 0xb1,
	0x56, 0x5f, 0xa7, 0x08, 0xde, 0x94, 0x5c, 0x88, 0x43, 0xa4, 0xd6, 0xa7, 0x27, 0xe4, 0x6e, 0xdb,
	0xbe, 0x10, 0xac, 0x65, 0x7b, 0x7e, 0x6c, 0xd0, 0x50, 0xbe, 0xef, 0xd9, 0x1f, 0x85, 0xbe, 0x89,
	0x3b, 0xb8, 0x0d, 0xc0, 0x3c, 0xe0, 0xb2, 0x23, 0x8a, 0x2a, 0x80, 0x01, 0x4f, 0x74, 0x04, 0xb7,
	0xf4, 0x2d, 0x5c, 0x0b, 0x7f, 0x03, 0xad, 0xe1, 0x5a, 0x03, 0x7d, 0x5b, 0xd2, 0xe0, 0x37, 0x78,
	0x16, 0x78, 0x4f, 0xf4, 0x1d, 0xcc, 0x35, 0xf9, 0x41, 0xf3, 0x84, 0xfa, 0xa2, 0xdb, 0x62, 0x51,
	0x46, 0x30, 0xdb, 0x69, 0xb9, 0xfa, 0xed, 0xc3, 0xd9, 0x44, 0x02, 0x45, 0xc9, 0x53, 0x70, 0x5a,
	0x32, 0x8d, 0x4d, 0x0d, 0x64, 0x92, 0x64, 0xfa, 0x88, 0xcc, 0xcb, 0x8b, 0x4b, 0xdf, 0xc7, 0xe4,
	0xdb, 0x49, 0x24, 0x9f, 0x89, 0x0c, 0x29, 0xa9, 0x50, 0xf4, 0x73, 0x32, 0x87, 0xb9, 0xa1, 0xdf,
	0x41, 0xf8, 0x76, 0x02, 0x7e, 0x02, 0x74, 0x89, 0x96, 0x18, 0xfa, 0x39, 0xd9, 0x68, 0xba, 0x4e,
	0xe0, 0xd9, 0x8d, 0x10, 0xaa, 0x23, 0x6b, 0xba, 0xb6, 0xa3, 0x1f, 0xe2, 0xde, 0xb4, 0x24, 0x23,
	0xeb, 0xda, 0x0e, 0xfd, 0x1b, 0x42, 0x65, 0x42, 0x5a, 0xae, 0xc3, 0x83, 0x28, 0x12, 0x77, 0x0f,
	0x67, 0x21, 0xd9, 0xb4, 0x4f, 0x4c, 0x0d, 0xb9, 0x39, 0x64, 0xca, 0x50, 0x1c, 0x91, 0xb5, 0x0f,
	0xae, 0xed, 0xb0, 0x28, 0xcd, 0x7d, 0x3d, 0x1d, 0xa3, 0x57, 0x80, 0x73, 0x22, 0x73, 0xdd, 0xa7,
	0xcf, 0xc8, 0x76, 0x43, 0x08, 0x87, 0xd9, 0xce, 0x05, 0xa8, 0x1e, 0x0a, 0xdc, 0x8b, 0x05, 0x28,
	0x00, 0x0a, 0xc8, 0x8f, 0xc5, 0x9e, 0x92, 0x1d, 0x4c, 0x3b, 0xc7, 0x0d, 0xec, 0xd6, 0x40, 0x89,
	0x61, 0xde, 0xfd, 0x4e, 0x26, 0x08, 0x70, 0x4b, 0xc8, 0x44, 0x19, 0x4c, 0xbc, 0x3c, 0x39, 0x6c,
	0xba, 0xdd, 0xae, 0x68, 0x06, 0xc2, 0x52, 0x59, 0x92, 0xb0, 0x52, 0xe6, 0xc7, 0x91, 0xcc, 0x8f,
	0x18, 0x87, 0x49, 0xf2, 0x2a, 0xb2, 0x58, 0xe6, 0x87, 0x4e, 0x16, 0x06, 0x21, 0x77, 0x1a, 0xdc,
	0xd5, 0x1f, 0xe0, 0x6a, 0xd1, 0x27, 0xbd, 0x43, 0x96, 0x9b, 0x9e, 0x88, 0x7c, 0xa4, 0x3f, 0x44,
	0x2e, 0x91, 0x24, 0x34, 0xe1, 0x3e, 0x59, 0xe7, 0xcd, 0x66, 0xd8, 0x63, 0x5d, 0xb7, 0x6d, 0x3b,
	0xcc, 0xe2, 0x03, 0xfd, 0x73, 0x04, 0xad, 0x22, 0xb9, 0x08, 0xd4, 0x1c, 0x1f, 0x8c, 0x9a, 0x6a,
	0x71, 0xbb, 0x1b, 0xed, 0xd1, 0xe3, 0xce, 0xb9, 0x32, 0xf5, 0x8b, 0x31, 0x53, 0x73, 0x00, 0x43,
	0x33, 0x4d, 0xee, 0x9c, 0x4b, 0x53, 0x1f, 0x92, 0x79, 0x79, 0xa7, 0xe8, 0x4f, 0x30, 0x2b, 0xa8,
	0xca, 0x8a, 0x2c, 0x12, 0x55, 0x02, 0x49, 0x04, 0x24, 0x10, 0x76, 0xf2, 0xfa, 0xd3, 0x89, 0x04,
	0xca, 0x01, 0x5d, 0x25, 0x10, 0x62, 0x00, 0x8c, 0xfd, 0xbb, 0xfe, 0xf5, 0x04, 0xb8, 0x06, 0x74,
	0x05, 0x46, 0x0c, 0x3d, 0x22, 0x37, 0xa0, 0x6b, 0xd7, 0x9f, 0x21, 0x76, 0x2b, 0x89, 0xe5, 0xfe,
	0xb9, 0x84, 0x22, 0x82, 0x7e, 0x4f, 0x56, 0x92, 0x9d, 0xba, 0xfe, 0x0d, 0x4a, 0xdc, 0x4a, 0x48,
	0x64, 0x25, 0xbb, 0xea, 0x86, 0x5d, 0x29, 0xb8, 0xdc, 0x1c, 0x52, 0x68, 0x89, 0x50, 0xb7, 0x2f,
	0x20, 0x9f, 0x7b, 0x0d, 0xdb, 0x11, 0x4c, 0xfc, 0x18, 0xda, 0x7d, 0xfd, 0x39, 0x6a, 0x39, 0x4c,
	0x68, 0x29, 0xf7, 0x85, 0x93, 0x95, 0x18, 0x03, 0x20, 0xea, 0x10, 0xba, 0x63, 0x64, 0xb0, 0x1c,
	0x7a, 0x7f, 0xfd, 0xdb, 0x09, 0xcb, 0xab, 0x1d, 0x57, 0x49, 0x21, 0x02, 0x2c, 0xf7, 0x45, 0xd3,
	0x13, 0x01, 0x93, 0x7e, 0x79, 0x31, 0x61, 0x79, 0x15, 0xd9, 0x09, 0xef, 0x2c, 0xfb, 0x43, 0x0a,
	0xfd, 0x8a, 0x2c, 0xa8, 0xd6, 0x5f, 0x7f, 0x89, 0xa2, 0x37, 0x93, 0xfe, 0x97, 0x1c, 0x29, 0x16,
	0xe1, 0xe8, 0x67, 0x64, 0x36, 0xe0, 0x6d, 0xfd, 0x3b, 0x84, 0x6f, 0x8e, 0x78, 0xb5, 0x2d, 0xa1,
	0xc0, 0x87, 0x7b, 0xcc, 0x0f, 0x3c, 0x1e, 0x88, 0xf6, 0x40, 0xff, 0x7e, 0xe2, 0x1e, 0xab, 0x2a,
	0x96, 0xba, 0xc7, 0x22, 0x24, 0x46, 0xa2, 0x6b, 0x0b, 0x27, 0x60, 0x16, 0x0f, 0xb8, 0xaf, 0xff,
	0xed, 0x64, 0x24, 0x90, 0x9d, 0x03, 0x6e, 0x14, 0x89, 0x21, 0x05, 0xf6, 0xa3, 0x26, 0x12, 0xfd,
	0x8f, 0x13, 0xfb, 0xc9, 0x4b, 0x8e, 0xda, 0x8f, 0xc2, 0xd1, 0x67, 0x64, 0x09, 0x26, 0x0a, 0x06,
	0x51, 0xd0, 0x33, 0x13, 0x96, 0xe6, 0xd5, 0xb4, 0xa1, 0x2c, 0x05, 0x28, 0x84, 0x91, 0x7e, 0x41,
	0xe6, 0xdb, 0xa1, 0xcd, 0x3e, 0x86, 0xfa, 0xf1, 0x75, 0x95, 0xef, 0x7d, 0x38, 0xac, 0x7c, 0xef,
	0x43, 0x9a, 0x21, 0xab, 0x81, 0x27, 0xb8, 0x1f, 0x7a, 0x03, 0x16, 0x78, 0x42, 0xe8, 0x59, 0x14,
	0xba, 0x9d, 0x74, 0x9f, 0xe2, 0xd7, 0x3c, 0xa1, 0x8e, 0xc8, 0x4a, 0x90, 0x20, 0xc1, 0x21, 0x4e,
	0xd4, 0x0d, 0x3c, 0xe9, 0x39, 0x79, 0x88, 0xe3, 0xd2, 0x86, 0x87, 0xfd, 0x09, 0x59, 0xc4, 0x51,
	0x80, 0x5d, 0x86, 0xba, 0x31, 0xe1, 0x83, 0xf7, 0xc0, 0x7a, 0xab, 0x8c, 0x5b, 0xf8, 0x28, 0xbf,
	0xe8, 0xb7, 0x84, 0x40, 0x2f, 0xcf, 0xb0, 0x99, 0xd7, 0xf3, 0x28, 0xb5, 0x3b, 0x22, 0xc5, 0x9d,
	0x57, 0xc0, 0x93, 0x72, 0x4b, 0x1f, 0xa3, 0x6f, 0x08, 0x73, 0x34, 0x3f, 0xe8, 0x27, 0x13, 0xce,
	0xfb, 0x93, 0x62, 0x29, 0xe7, 0x45, 0x48, 0x90, 0xf2, 0x44, 0x97, 0xa3, 0xd4, 0xe9, 0x84, 0x94,
	0xa9, 0x58, 0x4a, 0x2a, 0x42, 0xc2, 0xdd, 0x24, 0xc7, 0x06, 0xbd, 0x30, 0x71, 0x37, 0x55, 0x91,
	0xa1, 0x4a, 0x8b, 0x44, 0x61, 0x0a, 0xca, 0x16, 0xde, 0xd7, 0x5f, 0x4d, 0xa6, 0xa0, 0x62, 0x45,
	0x29, 0xa8, 0x3e, 0xe1, 0xf0, 0xc1, 0x90, 0xa1, 0xbf, 0x9e, 0x38, 0x7c, 0xa7, 0xa2, 0x61, 0xab,
	0xc3, 0x07, 0x08, 0xba, 0x47, 0x16, 0xbb, 0x6e, 0x53, 0xee, 0xa2, 0x88, 0xa1, 0x88, 0xbf, 0xe9,
	0x4b, 0xb2, 0x77, 0xe9, 0x7a, 0xe7, 0x70, 0x48, 0x99, 0x1b, 0x06, 0xfd, 0x30, 0x60, 0x7e, 0xc0,
	0xbd, 0x40, 0x06, 0xee, 0x0c, 0xd1, 0x37, 0x23, 0x44, 0x19, 0x01, 0x55, 0xe0, 0x63, 0x08, 0xbf,
	0x27, 0x2b, 0xc9, 0x39, 0x40, 0x2f, 0x4d, 0x9c, 0x02, 0x13, 0xd9, 0x06, 0x70, 0xd5, 0x29, 0xf0,
	0x86, 0x14, 0x68, 0x11, 0x9a, 0xb8, 0x8e, 0x90, 0xcd, 0x17, 0x7e, 0x00, 0xb5, 0xe1, 0xba, 0x5d,
	0x5f, 0x6f, 0x49, 0x2a, 0x7e, 0xd0, 0x47, 0x64, 0x31, 0x7a, 0xf7, 0xd1, 0xdb, 0x13, 0x67, 0xfa,
	0x44, 0x44, 0xc7, 0xbf, 0x23, 0xbf, 0xe8, 0x3d, 0xb2, 0x8c, 0x82, 0x8c, 0x7b, 0x1e, 0x1f, 0xe8,
	0x9d, 0xc3, 0xd9, 0xa3, 0x55, 0xbc, 0x30, 0x09, 0x92, 0x33, 0x40, 0xa5, 0xcf, 0xc9, 0x52, 0x3c,
	0x03, 0xe9, 0xf6, 0x44, 0x3a, 0x55, 0x22, 0x9e, 0x4a, 0xa7, 0x18, 0x0b, 0x2e, 0x1d, 0xd8, 0x4e,
	0x17, 0xd3, 0xf0, 0x83, 0x74, 0x69, 0xf4, 0x0d, 0x3d, 0xb7, 0xdf, 0xd7, 0xcf, 0x91, 0x3a, 0xe3,
	0xf7, 0xa1, 0x4d, 0x6c, 0x84, 0x03, 0xe6, 0xf7, 0x55, 0x6b, 0xd0, 0x95, 0xf7, 0x5e, 0x23, 0x1c,
	0x54, 0xfb, 0x51, 0x43, 0x70, 0x03, 0x26, 0x22, 0xbd, 0x37, 0x11, 0xca, 0xe3, 0xb0, 0xd5, 0x52,
	0xa1, 0x04, 0x04, 0x14, 0xb5, 0x0b, 0xbb, 0xaf, 0x3b, 0x13, 0x0e, 0x78, 0x13, 0x55, 0x69, 0xe0,
	0xc3, 0xd9, 0xea, 0x35, 0x59, 0x03, 0x1b, 0x1e, 0x77, 0xe2, 0x6c, 0x9d, 0x35, 0x8f, 0x87, 0x2d,
	0xcf, 0x42, 0x4f, 0x7e, 0xc1, 0xd9, 0x1a, 0x4e, 0x21, 0x7a, 0x7f, 0xc2, 0x19, 0xa6, 0xb0, 0x2a,
	0xc8, 0x53, 0xce, 0xf0, 0xa2, 0x6f, 0xbc, 0xed, 0x60, 0xec, 0xd1, 0x83, 0xc9, 0xdb, 0x0e, 0xe8,
	0xd1, 0x6d, 0x07, 0xbf, 0x69, 0x9e, 0x68, 0x51, 0x4f, 0xee, 0xb6, 0x5a, 0x76, 0xd3, 0xe6, 0x5d,
	0x3d, 0x9c, 0xac, 0x9e, 0x12, 0x72, 0x66, 0xfb, 0x6a, 0xf0, 0x58, 0x57, 0x42, 0x65, 0x25, 0x03,
	0x11, 0xb0, 0x6c, 0xee, 0xfc, 0x18, 0x72, 0x47, 0xff, 0x47, 0x19, 0x81, 0xe8, 0x9b, 0xbe, 0x24,
	0xcb, 0xbe, 0xf0, 0x2e, 0x84, 0x27, 0xbb, 0xcb, 0x7f, 0x42, 0xf5, 0x7b, 0x23, 0x67, 0x0a, 0xb8,
	0xc3, 0xfe, 0x92, 0xf8, 0x31, 0x81, 0x32, 0x72, 0x6b, 0xd8, 0x5c, 0xa8, 0x22, 0xc6, 0xfd, 0x73,
	0x38, 0x16, 0x6d, 0xe1, 0xeb, 0xff, 0x9c, 0xc2, 0x5e, 0xf5, 0x8e, 0xd2, 0x56, 0x70, 0x82, 0xa7,
	0x4f, 0x2a, 0xdc, 0xf6, 0xf0, 0x07, 0x66, 0x95, 0x54, 0xa9, 0xc7, 0x4a, 0x64, 0xc9, 0xe3, 0xfe,
	0x79, 0x15, 0x35, 0xa4, 0xff, 0x9c, 0x22, 0x6b, 0xa3, 0x7d, 0x67, 0x62, 0x4c, 0x9b, 0xfb, 0xd9,
	0x31, 0x6d, 0x8f, 0x2c, 0xb6, 0xd4, 0x60, 0x83, 0x63, 0xda, 0x92, 0x19, 0x7f, 0x43, 0xcf, 0xa5,
	0xfc, 0x83, 0xb3, 0xd8, 0x9c, 0x19, 0x7d, 0x0e, 0xe7, 0x9b, 0xb9, 0xe4, 0x7c, 0xb3, 0x43, 0xe6,
	0xbb, 0x82, 0x5b, 0xc2, 0xc3, 0x09, 0x6b, 0xc5, 0x54, 0x5f, 0xe9, 0x7f, 0x99, 0x21, 0x1b, 0x13,
	0x95, 0x0d, 0xd0, 0x2d, 0xcf, 0x16, 0x0e, 0x58, 0x38, 0x0b, 0x68, 0xf9, 0x85, 0x07, 0xb5, 0xcb,
	0x9b, 0xe7, 0xfa, 0x0c, 0x92, 0xe5, 0x07, 0x64, 0x83, 0x70, 0x44, 0x6f, 0xa0, 0xcf, 0xa2, 0xa3,
	0x92, 0xd9, 0x60, 0x00, 0x5d, 0x65, 0x03, 0x62, 0xe8, 0x77, 0x64, 0xc9, 0xee, 0xf5, 0x5d, 0x2f,
	0xe0, 0x4e, 0xa0, 0xdf, 0x18, 0xf1, 0x2c, 0x08, 0x14, 0x22, 0x5e, 0x1e, 0x57, 0x54, 0x99, 0x17,
	0x4b, 0x40, 0xef, 0x2d, 0x6d, 0x61, 0xc9, 0xc6, 0x72, 0x6e, 0xd8, 0x7b, 0x4b, 0x6e, 0x76, 0xd8,
	0x62, 0x3e, 0x22, 0x1b, 0x68, 0xe6, 0x88, 0xc0, 0x7c, 0x2c, 0xb0, 0x8e, 0xcc, 0x21, 0x3e, 0x7d,
	0x4e, 0xb6, 0xae, 0xab, 0x63, 0xf4, 0x2b, 0x32, 0x8f, 0x35, 0xcf, 0xd7, 0x65, 0x3e, 0x44, 0x27,
	0x45, 0x42, 0x5c, 0xdf, 0x1e, 0x96, 0x0d, 0x05, 0xa4, 0x87, 0x64, 0xa9, 0xc3, 0x1d, 0xab, 0xe1,
	0xba, 0xe7, 0x3e, 0xba, 0x4c, 0x2e, 0x39, 0x24, 0xa6, 0xf3, 0x32, 0x31, 0x86, 0x6e, 0xa2, 0xbb,
	0x64, 0x11, 0x1d, 0xc5, 0xe2, 0x29, 0x7e, 0x01, 0xbf, 0x0b, 0x16, 0xb0, 0xb8, 0xa5, 0x2e, 0xd8,
	0x19, 0x19, 0x74, 0x6e, 0xe1, 0xd5, 0x9a, 0x36, 0x89, 0xfe, 0x73, 0xde, 0xa3, 0xb7, 0xc8, 0x92,
	0x72, 0x59, 0xac, 0x72, 0x51, 0x12, 0xa4, 0x4e, 0x5f, 0x04, 0x23, 0x3a, 0x7d, 0x81, 0xb5, 0x3e,
	0xfd, 0x0f, 0x64, 0xf3, 0x9a, 0x93, 0x03, 0x93, 0xb2, 0x6f, 0x5b, 0x0a, 0x0c, 0x3f, 0xe9, 0x3e,
	0x21, 0x89, 0x1b, 0x64, 0x16, 0x19, 0x4b, 0x7e, 0x7c, 0x67, 0xdc, 0x22, 0x4b, 0x70, 0xf9, 0x74,
	0x59, 0xe8, 0x75, 0x31, 0x59, 0x97, 0xe4, 0x6d, 0xd4, 0xad, 0x7b, 0x5d, 0x7a, 0x13, 0xf2, 0xd8,
	0x47, 0x16, 0xbe, 0x0d, 0x98, 0xf3, 0x4d, 0xd7, 0xaf, 0x7b, 0xdd, 0xf4, 0x7f, 0x2e, 0x90, 0xb5,
	0x72, 0xd0, 0x11, 0xde, 0x74, 0x4f, 0x1b, 0xfb, 0x93, 0xcf, 0x0d, 0xc9, 0xa7, 0x86, 0xdd, 0xf1,
	0xa7, 0x86, 0xe1, 0x33, 0xc3, 0xfd, 0x9f, 0x79, 0x66, 0x18, 0x7f, 0x62, 0xd8, 0x9f, 0x7c, 0x62,
	0xf8, 0xe5, 0xe7, 0x85, 0xdf, 0xf6, 0x98, 0xf0, 0x2b, 0x5e, 0x06, 0xee, 0x93, 0xf5, 0x1e, 0xbf,
	0x92, 0x3d, 0x36, 0x6b, 0x75, 0x5d, 0xd7, 0x53, 0x4f, 0x02, 0xab, 0x3d, 0x7e, 0x85, 0x9d, 0x74,
	0x1e, 0x88, 0xf1, 0x0c, 0xbf, 0x29, 0x7d, 0x85, 0x33, 0x3c, 0xf4, 0x13, 0x6e, 0x4f, 0xe0, 0x5c,
	0x3f, 0x76, 0x09, 0x71, 0x5f, 0x44, 0xfd, 0x84, 0xdb, 0x13, 0xf4, 0x45, 0xe2, 0xc1, 0x68, 0x1b,
	0xd1, 0xfb, 0xd7, 0x3c, 0x18, 0x61, 0xb8, 0xc6, 0x5f, 0x8d, 0x3e, 0x25, 0x6b, 0x1f, 0x42, 0x87,
	0x5d, 0xd9, 0xdc, 0x61, 0xd2, 0x31, 0x3b, 0x68, 0xdf, 0xca, 0x87, 0xd0, 0x79, 0x67, 0x73, 0xa7,
	0x88, 0xfe, 0xf9, 0x94, 0xac, 0xc1, 0x36, 0x1a, 0xdc, 0x17, 0x0a, 0x75, 0x53, 0xa2, 0x7a, 0xfc,
	0x0a, 0x8c, 0x91, 0xa8, 0xdf, 0x93, 0xbd, 0x8e, 0xed, 0x07, 0xae, 0x37, 0x60, 0x80, 0x1e, 0xd3,
	0xab, 0xa3, 0xc4, 0x8e, 0x42, 0x9c, 0xf1, 0xab, 0x57, 0x63, 0x2b, 0x80, 0xb7, 0x2f, 0x3b, 0x76,
	0x20, 0x30, 0xc4, 0xfa, 0x2e, 0xfa, 0x1b, 0x62, 0xf0, 0x16, 0x88, 0x10, 0x60, 0x9c, 0xcc, 0xa0,
	0xaf, 0xd9, 0xfb, 0x6b, 0x2e, 0x01, 0x44, 0xfc, 0x00, 0x72, 0x2b, 0xf1, 0x00, 0x72, 0x9f, 0xac,
	0x0f, 0xf5, 0xcb, 0xa0, 0xde, 0x96, 0x29, 0x74, 0x19, 0xad, 0x80, 0x71, 0x55, 0x83, 0xca, 0xcb,
	0x5f, 0x18, 0x54, 0xb2, 0x63, 0xc3, 0xdf, 0x1f, 0x26, 0xc6, 0xb6, 0xc4, 0xf0, 0x97, 0x70, 0xfe,
	0xc8, 0x04, 0x58, 0x21, 0x5b, 0xbe, 0x80, 0x6b, 0x89, 0xf9, 0x1d, 0xf7, 0x92, 0xf1, 0x66, 0xc7,
	0x16, 0x17, 0xc2, 0x57, 0x53, 0xd2, 0x81, 0x52, 0x56, 0x45, 0x48, 0xb5, 0xe3, 0x5e, 0x66, 0x14,
	0x40, 0xaa, 0xa2, 0xfe, 0x04, 0xe3, 0xaf, 0x35, 0x97, 0xe9, 0xff, 0x58, 0x21, 0xeb, 0x63, 0x0f,
	0x32, 0x71, 0x9a, 0xa5, 0x7e, 0x31, 0xcd, 0x9e, 0x13, 0x1d, 0xfe, 0x65, 0x96, 0x68, 0x09, 0xc7,
	0x17, 0x2c, 0xf0, 0x5c, 0xb7, 0xcf, 0x6c, 0xc7, 0x12, 0x57, 0xfa, 0x32, 0xae, 0xb4, 0x0d, 0xfc,
	0x9c, 0x64, 0xd7, 0x80, 0x5b, 0x00, 0x26, 0xad, 0x91, 0x03, 0x14, 0x94, 0x02, 0x20, 0xce, 0xe1,
	0x2e, 0xef, 0x71, 0xbb, 0x2b, 0x9f, 0x4c, 0xf1, 0x61, 0x6f, 0xf9, 0x89, 0x16, 0xbd, 0x37, 0x71,
	0x5b, 0x4d, 0xcb, 0x7b, 0x20, 0x87, 0x9a, 0x72, 0x4a, 0x2a, 0xe6, 0xd1, 0x4b, 0x72, 0xaf, 0x17,
	0x76, 0x03, 0x5b, 0xe6, 0x17, 0x73, 0xfa, 0x4d, 0xd5, 0x29, 0x7b, 0xa2, 0xe9, 0x5e, 0x08, 0x18,
	0x98, 0xa0, 0xe0, 0xc9, 0x5c, 0x79, 0xa8, 0x54, 0x9b, 0x92, 0xc7, 0x1b, 0x5d, 0xf9, 0xf6, 0xf3,
	0xd6, 0x0e, 0x3a, 0xc6, 0x55, 0xe0, 0x71, 0xfc, 0x92, 0x8b, 0x1e, 0xa0, 0x5a, 0xcc, 0xcb, 0x52,
	0xbf, 0x89, 0xdd, 0xb5, 0x12, 0x1b, 0x60, 0xc5, 0xec, 0x93, 0x3b, 0xb6, 0x73, 0x01, 0x67, 0x01,
	0x1b, 0xe0, 0xeb, 0x16, 0xbd, 0x35, 0xf5, 0xa2, 0xb7, 0xa4, 0x4a, 0x39, 0xe3, 0x8e, 0xaf, 0xf8,
	0xf7, 0xe4, 0x26, 0x9c, 0xa6, 0x20, 0xe4, 0x4e, 0x62, 0x9f, 0xb8, 0xd2, 0xed, 0xa9, 0x57, 0xda,
	0xfc, 0x10, 0x3a, 0xb5, 0x90, 0x3b, 0xd1, 0xde, 0x70, 0x85, 0x2f, 0xc9, 0x66, 0xe2, 0x6c, 0xc4,
	0x45, 0xf8, 0x8e, 0x7c, 0x63, 0x8b, 0xcf, 0x87, 0x7a, 0xd1, 0x82, 0xa3, 0x3e, 0x01, 0x1f, 0x9e,
	0xaa, 0x43, 0x3c, 0x55, 0x3b, 0xa3, 0x52, 0xf1, 0xf1, 0x7a, 0x41, 0x76, 0x13, 0xb2, 0x96, 0xed,
	0xf3, 0x7e, 0x5f, 0x70, 0x4f, 0x6e, 0xe7, 0xae, 0xac, 0x12, 0xb1, 0x68, 0x2e, 0x62, 0xab, 0x66,
	0x61, 0xb3, 0x07, 0x15, 0x65, 0x4c, 0x28, 0x8d, 0x42, 0x1b, 0xc0, 0x1a, 0xc5, 0x4f, 0xd6, 0xad,
	0x7b, 0xd7, 0xd4, 0xad, 0x37, 0xe4, 0x41, 0xcf, 0xbd, 0x10, 0x12, 0xe6, 0x09, 0xa8, 0x4f, 0x02,
	0xf2, 0xd2, 0xef, 0x0b, 0xcf, 0x0e, 0x06, 0xac, 0x11, 0xb6, 0x18, 0xdc, 0xcf, 0xb8, 0xd6, 0xa7,
	0xa8, 0xe0, 0x1e, 0x08, 0x80, 0x06, 0x53, 0xc2, 0x2b, 0x31, 0xfa, 0x38, 0x6c, 0x19, 0x8e, 0x1c,
	0xa8, 0xbf, 0x21, 0x3a, 0xbe, 0xfa, 0x85, 0xbe, 0x60, 0x68, 0x76, 0xdb, 0x75, 0x2d, 0x5f, 0xaa,
	0xf9, 0x0c, 0xd5, 0x6c, 0x01, 0xbf, 0xee, 0x8b, 0x33, 0x9b, 0x3b, 0x27, 0xc0, 0x8c, 0x5e, 0xdd,
	0x10, 0x9e, 0x88, 0xf2, 0x7d, 0x75, 0x69, 0xd8, 0xdc, 0x19, 0xc6, 0xec, 0x25, 0xd1, 0x9b, 0x6e,
	0x7f, 0x10, 0x9d, 0x47, 0x8f, 0x45, 0xe5, 0xc8, 0xb6, 0xf4, 0x07, 0x71, 0x3b, 0xb3, 0x0d, 0x18,
	0x75, 0x26, 0x3d, 0x55, 0x91, 0x0a, 0x16, 0x7d, 0x42, 0xb6, 0x47, 0x85, 0x7d, 0xb7, 0x6b, 0xd9,
	0xc2, 0x53, 0xaf, 0x80, 0x9b, 0x49, 0xa9, 0xaa, 0x64, 0xd1, 0xef, 0xa0, 0x13, 0x4f, 0xca, 0x04,
	0x6e, 0xc0, 0xbb, 0xb1, 0xa4, 0x7c, 0x1a, 0xd4, 0x93, 0x92, 0x35, 0x00, 0x44, 0xe2, 0x4f, 0xc9,
	0xce, 0xa8, 0x78, 0xec, 0xd4, 0x2f, 0x26, 0xd7, 0x8c, 0x9c, 0xf8, 0x82, 0xec, 0x8e, 0xad, 0x99,
	0xa8, 0x3a, 0x5f, 0xca, 0x6c, 0x19, 0x59, 0x71, 0x58, 0x76, 0xb2, 0xe4, 0xf6, 0xf5, 0xfe, 0xb9,
	0x92, 0xd2, 0x8f, 0x62, 0x1f, 0xed, 0x5e, 0xe3, 0xa3, 0x77, 0x08, 0xa2, 0x7f, 0x24, 0x6b, 0x2d,
	0x7e, 0xe1, 0x7a, 0x90, 0xb0, 0x7d, 0xd7, 0x17, 0xbe, 0x7a, 0x9e, 0x8b, 0xfa, 0xcb, 0xbc, 0x62,
	0x56, 0x80, 0x27, 0x0f, 0xd8, 0x6a, 0x2b, 0x49, 0x03, 0x4f, 0x63, 0x1a, 0xd8, 0xce, 0x05, 0xdc,
	0xb9, 0xed, 0xb8, 0xcb, 0xcd, 0x0d, 0xdf, 0x7e, 0x0b, 0x43, 0x1e, 0xee, 0xda, 0x20, 0xeb, 0x63,
	0xb5, 0x4d, 0x37, 0xb0, 0xad, 0x4d, 0x5e, 0xec, 0x67, 0xc9, 0x32, 0xa5, 0x96, 0x1e, 0x29, 0x5d,
	0x70, 0x4c, 0xc7, 0x4b, 0x64, 0x9f, 0xfb, 0xbe, 0x3a, 0x0b, 0x79, 0xe9, 0xbd, 0x11, 0x91, 0x0a,
	0xf7, 0x7d, 0xfc, 0x9d, 0x1e, 0x90, 0x9d, 0xeb, 0x17, 0xa1, 0x5f, 0x90, 0x1b, 0xc1, 0xa0, 0x2f,
	0x6f, 0x8c, 0xb5, 0xe1, 0x1f, 0x09, 0x92, 0xc0, 0xda, 0xa0, 0x2f, 0x4c, 0x44, 0x41, 0x43, 0x96,
	0x58, 0x53, 0xf6, 0xa5, 0x4b, 0xfd, 0x68, 0x19, 0xec, 0x7c, 0x78, 0x10, 0xf5, 0xa5, 0xf8, 0x3b,
	0x9d, 0x25, 0x74, 0xd2, 0xad, 0xf4, 0x4b, 0x32, 0x27, 0x03, 0x20, 0x1b, 0xfc, 0x9b, 0x93, 0x01,
	0x50, 0x93, 0x0c, 0xa2, 0xd2, 0xdf, 0x13, 0x6d, 0x9c, 0x35, 0x31, 0xd6, 0xad, 0x90, 0xd4, 0x95,
	0x32, 0x29, 0x75, 0x05, 0x5f, 0x03, 0x65, 0x47, 0x6a, 0x90, 0x3e, 0x23, 0x5b, 0x09, 0xf9, 0xa2,
	0xed, 0xab, 0x41, 0xe3, 0x19, 0x99, 0xb7, 0x44, 0xc0, 0xed, 0xae, 0xb2, 0x63, 0x7f, 0xd2, 0x8e,
	0x1c, 0xf2, 0xd5, 0xb0, 0x21, 0xc1, 0xe9, 0x7f, 0x4f, 0x91, 0x9d, 0xeb, 0x21, 0xf4, 0x01, 0x99,
	0xed, 0xbb, 0xbe, 0xba, 0x80, 0x7f, 0x76, 0x5b, 0x80, 0x81, 0x66, 0xbd, 0xc3, 0x2f, 0xe4, 0xc5,
	0x83, 0xcd, 0xfa, 0xa2, 0xb9, 0x08, 0x04, 0x88, 0x14, 0x7d, 0x00, 0x4d, 0xa4, 0xe7, 0x62, 0x5b,
	0x3d, 0x3a, 0xe7, 0x1d, 0x73, 0x3f, 0xfa, 0x83, 0x21, 0x42, 0xa0, 0xaf, 0xb7, 0x7d, 0x86, 0xf7,
	0xfe, 0x3c, 0x6a, 0x99, 0xb7, 0xfd, 0x53, 0xb7, 0x27, 0xd2, 0xff, 0x9a, 0x22, 0xab, 0x23, 0x77,
	0x3f, 0xbd, 0x43, 0x96, 0x55, 0x61, 0xc4, 0xbf, 0xee, 0xa4, 0xd4, 0x63, 0x09, 0xd6, 0x3e, 0xfc,
	0x4b, 0xce, 0x3e, 0x21, 0x89, 0x02, 0xab, 0x02, 0xdc, 0x88, 0xab, 0xeb, 0x36, 0x99, 0x47, 0xf6,
	0x95, 0x72, 0xed, 0x1c, 0x7c, 0xbd, 0x8b, 0xc9, 0xd1, 0x80, 0x8c, 0xe4, 0x1f, 0xe8, 0x01, 0x21,
	0xc3, 0xca, 0xab, 0x66, 0xe4, 0x04, 0x25, 0x7d, 0x41, 0xd6, 0xf0, 0x09, 0x98, 0xb7, 0x45, 0xef,
	0xfa, 0x98, 0x1e, 0x11, 0x4d, 0xfe, 0x05, 0x22, 0xf4, 0x85, 0xa5, 0x5e, 0x78, 0xa4, 0x51, 0x6b,
	0x48, 0xaf, 0xfb, 0xc2, 0x92, 0xaf, 0x3c, 0x0f, 0xc9, 0x46, 0x54, 0x9f, 0xe1, 0xc2, 0x94, 0x87,
	0x52, 0x5a, 0xb3, 0xae, 0x0a, 0x73, 0x74, 0x91, 0xa6, 0x8f, 0xc9, 0x76, 0xcd, 0x83, 0x9b, 0xc5,
	0xfa, 0x85, 0xe5, 0x71, 0x40, 0xb4, 0x92, 0xb3, 0xd6, 0x82, 0x90, 0xa5, 0x2c, 0x9d, 0x21, 0xbb,
	0xb1, 0x70, 0x8d, 0x7b, 0x6d, 0x39, 0xc8, 0xf9, 0xd7, 0x4f, 0x4f, 0x5b, 0x64, 0x2e, 0x69, 0xbb,
	0xfc, 0x48, 0xff, 0x7f, 0x4a, 0xbe, 0x07, 0x8c, 0x3c, 0x83, 0xd3, 0x67, 0x30, 0xe1, 0x29, 0xc5,
	0xd1, 0xf1, 0x88, 0xc2, 0x3f, 0x6a, 0xae, 0x99, 0x00, 0xd2, 0xd7, 0x84, 0x06, 0x72, 0x4f, 0x2c,
	0x21, 0x3e, 0x83, 0xe2, 0xd1, 0x03, 0xf3, 0xb5, 0x9b, 0x36, 0x37, 0x82, 0x31, 0xb2, 0x4f, 0x4b,
	0x84, 0x06, 0xae, 0xc5, 0x07, 0x2c, 0xc0, 0x9d, 0x29, 0xc7, 0xcb, 0x27, 0x87, 0xc3, 0x71, 0x5b,
	0xc6, 0x77, 0x6f, 0x6a, 0x28, 0x9b, 0x20, 0xa7, 0xff, 0x4e, 0xce, 0xf9, 0xe3, 0xaf, 0xf6, 0xf4,
	0x0e, 0x59, 0xb2, 0x9d, 0x80, 0x5d, 0xf0, 0x6e, 0x28, 0x70, 0xab, 0xb2, 0x82, 0x2f, 0xda, 0x4e,
	0xf0, 0x06, 0x68, 0xf4, 0x1e, 0x51, 0x0f, 0xfb, 0xec, 0x5c, 0x0c, 0x92, 0x73, 0x3d, 0x91, 0xe4,
	0xd7, 0x62, 0xe0, 0x3f, 0xfc, 0xaf, 0x45, 0xb2, 0x82, 0x69, 0xee, 0xba, 0x5d, 0xa8, 0x55, 0x54,
	0x27, 0x5b, 0xc7, 0xe5, 0x72, 0x91, 0xbd, 0x2a, 0xd4, 0x4f, 0xea, 0x99, 0x12, 0x33, 0x8d, 0xbc,
	0x69, 0x54, 0x4f, 0xb5, 0x4f, 0x26, 0x38, 0xd9, 0x72, 0xa9, 0x5a, 0x2f, 0xd6, 0xb4, 0x14, 0xdd,
	0x23, 0x3b, 0xc8, 0xc9, 0x96, 0x8b, 0x45, 0x23, 0x5b, 0x63, 0x35, 0x33, 0x53, 0x28, 0x31, 0xe3,
	0x5d, 0x45, 0x9b, 0x89, 0xa5, 0xf2, 0x65, 0xf3, 0xc4, 0x60, 0xc6, 0x9f, 0xea, 0x85, 0xca, 0x99,
	0x51, 0xaa, 0x69, 0xb3, 0xf4, 0x26, 0xd9, 0x44, 0xce, 0x5b, 0x23, 0x63, 0x26, 0x18, 0x37, 0x62,
	0x75, 0xc8, 0xc8, 0x66, 0x2a, 0x35, 0xd0, 0x56, 0x2d, 0xd7, 0x8b, 0xda, 0x5c, 0xac, 0xce, 0x34,
	0xf2, 0x85, 0x92, 0x91, 0x8b, 0xd8, 0xda, 0x7c, 0xcc, 0x29, 0x94, 0xde, 0x64, 0xaa, 0x06, 0x3b,
	0x2d, 0x9f, 0x19, 0xac, 0x54, 0xc9, 0x6a, 0x0b, 0x74, 0x87, 0xd0, 0x24, 0xe7, 0xac, 0x88, 0xf4,
	0x45, 0xba, 0x4b, 0xb6, 0xe5, 0x3a, 0x65, 0xf3, 0x75, 0xf5, 0xb4, 0x5c, 0x89, 0xec, 0xd7, 0x96,
	0xe8, 0x26, 0x59, 0x47, 0x56, 0xd1, 0xc8, 0x98, 0x25, 0x56, 0x33, 0xb2, 0xa7, 0x1a, 0xa1, 0xdb,
	0x64, 0x63, 0x64, 0x9b, 0xf9, 0x8c, 0x79, 0xa6, 0x2d, 0x27, 0x4c, 0xca, 0x96, 0xdf, 0x18, 0x26,
	0xab, 0x96, 0x8b, 0xb9, 0x82, 0x61, 0x6a, 0x2b, 0x31, 0xa7, 0x5e, 0x39, 0x31, 0x33, 0x39, 0x23,
	0xe6, 0xac, 0xc6, 0xfa, 0x61, 0x69, 0xc3, 0x64, 0xd9, 0x9c, 0xa9, 0xad, 0xd1, 0x0d, 0xb2, 0x8a,
	0x44, 0x58, 0x0e, 0x49, 0xeb, 0x94, 0x92, 0x35, 0x24, 0xbd, 0x29, 0x18, 0x6f, 0xe5, 0x7a, 0x1a,
	0x3d, 0x24, 0xb7, 0x95, 0x19, 0x67, 0x15, 0xa3, 0x58, 0x33, 0x72, 0x2c, 0x5f, 0x30, 0xab, 0x35,
	0xf6, 0xfe, 0xd4, 0x28, 0x9d, 0xbc, 0xad, 0x6b, 0x1b, 0xb1, 0x54, 0xde, 0x34, 0x0c, 0x96, 0x2f,
	0x54, 0x4f, 0x35, 0x1a, 0x1b, 0xff, 0x43, 0x3d, 0x53, 0x3a, 0xce, 0x94, 0x25, 0x79, 0x33, 0x26,
	0x47, 0x26, 0x1e, 0x67, 0xaa, 0x86, 0xb6, 0x15, 0xdb, 0x77, 0x9c, 0xf9, 0xc1, 0x60, 0x15, 0xb3,
	0xf0, 0xde, 0xd0, 0xb6, 0x63, 0x7f, 0xd5, 0xab, 0x06, 0xab, 0xd5, 0x59, 0xde, 0x28, 0xb0, 0x93,
	0x72, 0x39, 0x57, 0xd5, 0x76, 0xa8, 0x46, 0x56, 0x62, 0xd6, 0x89, 0x71, 0xa6, 0xdd, 0x8c, 0xc1,
	0x27, 0x46, 0x6d, 0x34, 0x86, 0x7a, 0xbc, 0x66, 0xd5, 0x30, 0x5e, 0xb3, 0x6c, 0xa6, 0x56, 0x81,
	0x00, 0xee, 0xd2, 0x7d, 0xb2, 0x3b, 0x62, 0xca, 0x88, 0xd4, 0x1e, 0xbd, 0x4b, 0xf6, 0xe5, 0xb6,
	0x15, 0x39, 0x82, 0x95, 0xf3, 0xf9, 0x42, 0xb6, 0x90, 0x29, 0x6a, 0xb7, 0x62, 0xc5, 0x99, 0x7a,
	0xad, 0xcc, 0x72, 0xf5, 0xd2, 0x89, 0x51, 0x2e, 0x69, 0xb7, 0x63, 0x77, 0xbc, 0x83, 0xac, 0x85,
	0xfd, 0x6b, 0xfb, 0xc3, 0x94, 0x2d, 0x96, 0xab, 0xe0, 0xa3, 0x93, 0xd3, 0x1a, 0x3b, 0xa9, 0x17,
	0x72, 0x86, 0x76, 0x90, 0xb0, 0xaf, 0xc6, 0x72, 0x46, 0xde, 0x28, 0x55, 0x0d, 0x53, 0xbb, 0x13,
	0xe7, 0xeb, 0xab, 0x72, 0xa1, 0x04, 0x19, 0x04, 0xf8, 0x62, 0x4e, 0x3b, 0x8c, 0x9d, 0x55, 0x2b,
	0xbf, 0x35, 0x4c, 0x96, 0xcf, 0x14, 0x8a, 0xda, 0xdd, 0x38, 0xf6, 0x15, 0xb3, 0x5c, 0x83, 0x64,
	0x31, 0x8d, 0xb3, 0xf2, 0x1b, 0x23, 0xa7, 0xa5, 0xe3, 0x30, 0x1f, 0x1b, 0x46, 0x89, 0x99, 0xe5,
	0x63, 0xed, 0x1e, 0x5d, 0x23, 0x44, 0xa6, 0x43, 0xa6, 0x66, 0x98, 0xda, 0xa7, 0xb1, 0xc6, 0x4a,
	0x31, 0x53, 0x52, 0x79, 0xf6, 0x59, 0xbc, 0x0d, 0x58, 0xfa, 0x38, 0x53, 0x7e, 0x5b, 0xd7, 0xee,
	0x0f, 0xc3, 0x57, 0x2a, 0x96, 0xb3, 0xaf, 0x15, 0xf9, 0x77, 0xb1, 0xa9, 0xc7, 0xf5, 0x1f, 0x58,
	0xd1, 0x78, 0x63, 0x14, 0x59, 0xbe, 0x5e, 0xca, 0x69, 0x47, 0xc3, 0x14, 0x56, 0x4e, 0x3c, 0x2e,
	0x9b, 0x25, 0xed, 0x41, 0x6c, 0xec, 0xd0, 0xb7, 0xac, 0x5a, 0xcb, 0x98, 0xda, 0x43, 0xba, 0x45,
	0xb4, 0xe4, 0xd9, 0x39, 0xce, 0x94, 0xdf, 0x6b, 0x9f, 0xc7, 0x5b, 0xc0, 0xb4, 0x3c, 0xcb, 0x54,
	0xb4, 0x2f, 0x8e, 0x0f, 0xff, 0xfb, 0xa7, 0x83, 0xd4, 0xff, 0xfc, 0x74, 0x90, 0xfa, 0xdf, 0x9f,
	0x0e, 0x52, 0x7f, 0xfe, 0xbf, 0x83, 0x4f, 0x4e, 0x53, 0xef, 0x57, 0x92, 0xff, 0x1b, 0xa8, 0x31,
	0x8f, 0xff, 0x3c, 0xfd, 0x4b, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa1, 0x29, 0xd9, 0x08, 0x8d, 0x2b,
	0x00, 0x00,
}
