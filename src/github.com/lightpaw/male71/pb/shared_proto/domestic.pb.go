// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/shared_proto/domestic.proto
// DO NOT EDIT!

package shared_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type BuildingType int32

const (
	BuildingType_InvalidBuildingType BuildingType = 0
	BuildingType_GUAN_FU             BuildingType = 2
	BuildingType_CANG_KU             BuildingType = 3
	BuildingType_JIU_GUAN            BuildingType = 4
	BuildingType_JUN_YING            BuildingType = 5
	BuildingType_CHENG_QIANG         BuildingType = 6
	BuildingType_SHU_YUAN            BuildingType = 7
	BuildingType_WAI_SHI_YUAN        BuildingType = 8
	BuildingType_TIE_JIANG_PU        BuildingType = 9
	BuildingType_XIU_LIAN_GUAN       BuildingType = 10
	BuildingType_SHI_CHANG           BuildingType = 11
	BuildingType_XING_YING           BuildingType = 12
	BuildingType_MA_CHE              BuildingType = 13
	BuildingType_GOLD_PRODUCER       BuildingType = 21
	BuildingType_FOOD_PRODUCER       BuildingType = 22
	BuildingType_WOOD_PRODUCER       BuildingType = 23
	BuildingType_STONE_PRODUCER      BuildingType = 24
	BuildingType_SI_TU_FU            BuildingType = 30
	BuildingType_ZHU_BI_CHANG        BuildingType = 31
	BuildingType_CAI_SHI_CHANGE      BuildingType = 32
	BuildingType_JI_XIA_XUE_GONG     BuildingType = 33
	BuildingType_LU_BAN_GONG_FANG    BuildingType = 34
	BuildingType_SI_MA_FU            BuildingType = 40
	BuildingType_SHEN_SHE_YING       BuildingType = 41
	BuildingType_HU_BEN_YING         BuildingType = 42
	BuildingType_CHENG_FANG_JI_GUAN  BuildingType = 43
	BuildingType_YU_BEI_BING_SUO     BuildingType = 44
)

var BuildingType_name = map[int32]string{
	0:  "InvalidBuildingType",
	2:  "GUAN_FU",
	3:  "CANG_KU",
	4:  "JIU_GUAN",
	5:  "JUN_YING",
	6:  "CHENG_QIANG",
	7:  "SHU_YUAN",
	8:  "WAI_SHI_YUAN",
	9:  "TIE_JIANG_PU",
	10: "XIU_LIAN_GUAN",
	11: "SHI_CHANG",
	12: "XING_YING",
	13: "MA_CHE",
	21: "GOLD_PRODUCER",
	22: "FOOD_PRODUCER",
	23: "WOOD_PRODUCER",
	24: "STONE_PRODUCER",
	30: "SI_TU_FU",
	31: "ZHU_BI_CHANG",
	32: "CAI_SHI_CHANGE",
	33: "JI_XIA_XUE_GONG",
	34: "LU_BAN_GONG_FANG",
	40: "SI_MA_FU",
	41: "SHEN_SHE_YING",
	42: "HU_BEN_YING",
	43: "CHENG_FANG_JI_GUAN",
	44: "YU_BEI_BING_SUO",
}
var BuildingType_value = map[string]int32{
	"InvalidBuildingType": 0,
	"GUAN_FU":             2,
	"CANG_KU":             3,
	"JIU_GUAN":            4,
	"JUN_YING":            5,
	"CHENG_QIANG":         6,
	"SHU_YUAN":            7,
	"WAI_SHI_YUAN":        8,
	"TIE_JIANG_PU":        9,
	"XIU_LIAN_GUAN":       10,
	"SHI_CHANG":           11,
	"XING_YING":           12,
	"MA_CHE":              13,
	"GOLD_PRODUCER":       21,
	"FOOD_PRODUCER":       22,
	"WOOD_PRODUCER":       23,
	"STONE_PRODUCER":      24,
	"SI_TU_FU":            30,
	"ZHU_BI_CHANG":        31,
	"CAI_SHI_CHANGE":      32,
	"JI_XIA_XUE_GONG":     33,
	"LU_BAN_GONG_FANG":    34,
	"SI_MA_FU":            40,
	"SHEN_SHE_YING":       41,
	"HU_BEN_YING":         42,
	"CHENG_FANG_JI_GUAN":  43,
	"YU_BEI_BING_SUO":     44,
}

func (x BuildingType) String() string {
	return proto.EnumName(BuildingType_name, int32(x))
}
func (BuildingType) EnumDescriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{0} }

type TechType int32

const (
	TechType_InvalidTechType TechType = 0
	TechType_TECH_NEI_ZHENG  TechType = 1
	TechType_TECH_BU         TechType = 11
	TechType_TECH_QI         TechType = 12
	TechType_TECH_GONG       TechType = 13
	TechType_TECH_CHE        TechType = 14
	TechType_TECH_XIE        TechType = 15
	TechType_TECH_WALL       TechType = 20
)

var TechType_name = map[int32]string{
	0:  "InvalidTechType",
	1:  "TECH_NEI_ZHENG",
	11: "TECH_BU",
	12: "TECH_QI",
	13: "TECH_GONG",
	14: "TECH_CHE",
	15: "TECH_XIE",
	20: "TECH_WALL",
}
var TechType_value = map[string]int32{
	"InvalidTechType": 0,
	"TECH_NEI_ZHENG":  1,
	"TECH_BU":         11,
	"TECH_QI":         12,
	"TECH_GONG":       13,
	"TECH_CHE":        14,
	"TECH_XIE":        15,
	"TECH_WALL":       20,
}

func (x TechType) String() string {
	return proto.EnumName(TechType_name, int32(x))
}
func (TechType) EnumDescriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{1} }

// 君主策略效果类型
type StrategyEffectType int32

const (
	StrategyEffectType_Strategy_ET_invalid          StrategyEffectType = 0
	StrategyEffectType_Strategy_ET_prize            StrategyEffectType = 1
	StrategyEffectType_Strategy_ET_farm             StrategyEffectType = 2
	StrategyEffectType_Strategy_ET_random_fast_move StrategyEffectType = 3
	StrategyEffectType_Strategy_ET_reduce_tax       StrategyEffectType = 4
	StrategyEffectType_Strategy_ET_reduce_solider   StrategyEffectType = 5
	StrategyEffectType_Strategy_ET_baoz             StrategyEffectType = 6
)

var StrategyEffectType_name = map[int32]string{
	0: "Strategy_ET_invalid",
	1: "Strategy_ET_prize",
	2: "Strategy_ET_farm",
	3: "Strategy_ET_random_fast_move",
	4: "Strategy_ET_reduce_tax",
	5: "Strategy_ET_reduce_solider",
	6: "Strategy_ET_baoz",
}
var StrategyEffectType_value = map[string]int32{
	"Strategy_ET_invalid":          0,
	"Strategy_ET_prize":            1,
	"Strategy_ET_farm":             2,
	"Strategy_ET_random_fast_move": 3,
	"Strategy_ET_reduce_tax":       4,
	"Strategy_ET_reduce_solider":   5,
	"Strategy_ET_baoz":             6,
}

func (x StrategyEffectType) String() string {
	return proto.EnumName(StrategyEffectType_name, int32(x))
}
func (StrategyEffectType) EnumDescriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{2} }

type HeroLevelProto struct {
	Level                     int32   `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	UpgradeExp                int32   `protobuf:"varint,2,opt,name=upgrade_exp,json=upgradeExp,proto3" json:"upgrade_exp,omitempty"`
	AddSoldierCapacity        int32   `protobuf:"varint,22,opt,name=add_soldier_capacity,json=addSoldierCapacity,proto3" json:"add_soldier_capacity,omitempty"`
	EquipmentLevelLimit       int32   `protobuf:"varint,11,opt,name=equipment_level_limit,json=equipmentLevelLimit,proto3" json:"equipment_level_limit,omitempty"`
	CaptainSoulLevelLimit     int32   `protobuf:"varint,21,opt,name=captain_soul_level_limit,json=captainSoulLevelLimit,proto3" json:"captain_soul_level_limit,omitempty"`
	CaptainLevelLimit         int32   `protobuf:"varint,12,opt,name=captain_level_limit,json=captainLevelLimit,proto3" json:"captain_level_limit,omitempty"`
	CaptainCountLimit         int32   `protobuf:"varint,13,opt,name=captain_count_limit,json=captainCountLimit,proto3" json:"captain_count_limit,omitempty"`
	UnlockedRaces             []Race  `protobuf:"varint,15,rep,name=unlocked_races,json=unlockedRaces,enum=proto.Race" json:"unlocked_races,omitempty"`
	CaptainTrainingLevel      []int32 `protobuf:"varint,16,rep,name=captain_training_level,json=captainTrainingLevel" json:"captain_training_level,omitempty"`
	CaptainTrainingLevelLimit []int32 `protobuf:"varint,17,rep,name=captain_training_level_limit,json=captainTrainingLevelLimit" json:"captain_training_level_limit,omitempty"`
	StrategyLimit             int32   `protobuf:"varint,20,opt,name=strategy_limit,json=strategyLimit,proto3" json:"strategy_limit,omitempty"`
	SpLimit                   int32   `protobuf:"varint,26,opt,name=sp_limit,json=spLimit,proto3" json:"sp_limit,omitempty"`
	TroopsCount               int32   `protobuf:"varint,23,opt,name=troops_count,json=troopsCount,proto3" json:"troops_count,omitempty"`
	TroopsCaptainCount        int32   `protobuf:"varint,3,opt,name=troops_captain_count,json=troopsCaptainCount,proto3" json:"troops_captain_count,omitempty"`
	CaptainOfficialId         []int32 `protobuf:"varint,24,rep,name=captain_official_id,json=captainOfficialId" json:"captain_official_id,omitempty"`
	CaptainOfficialCount      []int32 `protobuf:"varint,25,rep,name=captain_official_count,json=captainOfficialCount" json:"captain_official_count,omitempty"`
}

func (m *HeroLevelProto) Reset()                    { *m = HeroLevelProto{} }
func (m *HeroLevelProto) String() string            { return proto.CompactTextString(m) }
func (*HeroLevelProto) ProtoMessage()               {}
func (*HeroLevelProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{0} }

func (m *HeroLevelProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *HeroLevelProto) GetUpgradeExp() int32 {
	if m != nil {
		return m.UpgradeExp
	}
	return 0
}

func (m *HeroLevelProto) GetAddSoldierCapacity() int32 {
	if m != nil {
		return m.AddSoldierCapacity
	}
	return 0
}

func (m *HeroLevelProto) GetEquipmentLevelLimit() int32 {
	if m != nil {
		return m.EquipmentLevelLimit
	}
	return 0
}

func (m *HeroLevelProto) GetCaptainSoulLevelLimit() int32 {
	if m != nil {
		return m.CaptainSoulLevelLimit
	}
	return 0
}

func (m *HeroLevelProto) GetCaptainLevelLimit() int32 {
	if m != nil {
		return m.CaptainLevelLimit
	}
	return 0
}

func (m *HeroLevelProto) GetCaptainCountLimit() int32 {
	if m != nil {
		return m.CaptainCountLimit
	}
	return 0
}

func (m *HeroLevelProto) GetUnlockedRaces() []Race {
	if m != nil {
		return m.UnlockedRaces
	}
	return nil
}

func (m *HeroLevelProto) GetCaptainTrainingLevel() []int32 {
	if m != nil {
		return m.CaptainTrainingLevel
	}
	return nil
}

func (m *HeroLevelProto) GetCaptainTrainingLevelLimit() []int32 {
	if m != nil {
		return m.CaptainTrainingLevelLimit
	}
	return nil
}

func (m *HeroLevelProto) GetStrategyLimit() int32 {
	if m != nil {
		return m.StrategyLimit
	}
	return 0
}

func (m *HeroLevelProto) GetSpLimit() int32 {
	if m != nil {
		return m.SpLimit
	}
	return 0
}

func (m *HeroLevelProto) GetTroopsCount() int32 {
	if m != nil {
		return m.TroopsCount
	}
	return 0
}

func (m *HeroLevelProto) GetTroopsCaptainCount() int32 {
	if m != nil {
		return m.TroopsCaptainCount
	}
	return 0
}

func (m *HeroLevelProto) GetCaptainOfficialId() []int32 {
	if m != nil {
		return m.CaptainOfficialId
	}
	return nil
}

func (m *HeroLevelProto) GetCaptainOfficialCount() []int32 {
	if m != nil {
		return m.CaptainOfficialCount
	}
	return nil
}

type BaseLevelProto struct {
	Level             int32  `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	UpgradeProsperity int32  `protobuf:"varint,2,opt,name=upgrade_prosperity,json=upgradeProsperity,proto3" json:"upgrade_prosperity,omitempty"`
	UnlockGuanFuLevel int32  `protobuf:"varint,3,opt,name=unlock_guan_fu_level,json=unlockGuanFuLevel,proto3" json:"unlock_guan_fu_level,omitempty"`
	UnlockPowerRange  string `protobuf:"bytes,4,opt,name=unlock_power_range,json=unlockPowerRange,proto3" json:"unlock_power_range,omitempty"`
	AppearanceRes     string `protobuf:"bytes,5,opt,name=appearance_res,json=appearanceRes,proto3" json:"appearance_res,omitempty"`
}

func (m *BaseLevelProto) Reset()                    { *m = BaseLevelProto{} }
func (m *BaseLevelProto) String() string            { return proto.CompactTextString(m) }
func (*BaseLevelProto) ProtoMessage()               {}
func (*BaseLevelProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{1} }

func (m *BaseLevelProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *BaseLevelProto) GetUpgradeProsperity() int32 {
	if m != nil {
		return m.UpgradeProsperity
	}
	return 0
}

func (m *BaseLevelProto) GetUnlockGuanFuLevel() int32 {
	if m != nil {
		return m.UnlockGuanFuLevel
	}
	return 0
}

func (m *BaseLevelProto) GetUnlockPowerRange() string {
	if m != nil {
		return m.UnlockPowerRange
	}
	return ""
}

func (m *BaseLevelProto) GetAppearanceRes() string {
	if m != nil {
		return m.AppearanceRes
	}
	return ""
}

type BuildingLayoutProto struct {
	Id               int32          `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Building         []BuildingType `protobuf:"varint,2,rep,name=building,enum=proto.BuildingType" json:"building,omitempty"`
	RequireBaseLevel int32          `protobuf:"varint,3,opt,name=require_base_level,json=requireBaseLevel,proto3" json:"require_base_level,omitempty"`
	RegionOffsetX    int32          `protobuf:"zigzag32,4,opt,name=region_offset_x,json=regionOffsetX,proto3" json:"region_offset_x,omitempty"`
	RegionOffsetY    int32          `protobuf:"zigzag32,5,opt,name=region_offset_y,json=regionOffsetY,proto3" json:"region_offset_y,omitempty"`
	IgnoreConflict   bool           `protobuf:"varint,6,opt,name=ignore_conflict,json=ignoreConflict,proto3" json:"ignore_conflict,omitempty"`
}

func (m *BuildingLayoutProto) Reset()                    { *m = BuildingLayoutProto{} }
func (m *BuildingLayoutProto) String() string            { return proto.CompactTextString(m) }
func (*BuildingLayoutProto) ProtoMessage()               {}
func (*BuildingLayoutProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{2} }

func (m *BuildingLayoutProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BuildingLayoutProto) GetBuilding() []BuildingType {
	if m != nil {
		return m.Building
	}
	return nil
}

func (m *BuildingLayoutProto) GetRequireBaseLevel() int32 {
	if m != nil {
		return m.RequireBaseLevel
	}
	return 0
}

func (m *BuildingLayoutProto) GetRegionOffsetX() int32 {
	if m != nil {
		return m.RegionOffsetX
	}
	return 0
}

func (m *BuildingLayoutProto) GetRegionOffsetY() int32 {
	if m != nil {
		return m.RegionOffsetY
	}
	return 0
}

func (m *BuildingLayoutProto) GetIgnoreConflict() bool {
	if m != nil {
		return m.IgnoreConflict
	}
	return false
}

type BuildingDataProto struct {
	Id         int32                `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type       BuildingType         `protobuf:"varint,2,opt,name=type,proto3,enum=proto.BuildingType" json:"type,omitempty"`
	Level      int32                `protobuf:"varint,3,opt,name=level,proto3" json:"level,omitempty"`
	WorkTime   int32                `protobuf:"varint,4,opt,name=work_time,json=workTime,proto3" json:"work_time,omitempty"`
	Prosperity int32                `protobuf:"varint,5,opt,name=prosperity,proto3" json:"prosperity,omitempty"`
	HeroExp    int32                `protobuf:"varint,6,opt,name=hero_exp,json=heroExp,proto3" json:"hero_exp,omitempty"`
	Desc       string               `protobuf:"bytes,7,opt,name=desc,proto3" json:"desc,omitempty"`
	Tips       string               `protobuf:"bytes,13,opt,name=tips,proto3" json:"tips,omitempty"`
	IconId     string               `protobuf:"bytes,8,opt,name=icon_id,json=iconId,proto3" json:"icon_id,omitempty"`
	Model      string               `protobuf:"bytes,9,opt,name=model,proto3" json:"model,omitempty"`
	EffectDesc string               `protobuf:"bytes,10,opt,name=effect_desc,json=effectDesc,proto3" json:"effect_desc,omitempty"`
	Effect     *DomesticEffectProto `protobuf:"bytes,11,opt,name=effect" json:"effect,omitempty"`
	Notice     string               `protobuf:"bytes,12,opt,name=notice,proto3" json:"notice,omitempty"`
	Cost       *CostProto           `protobuf:"bytes,21,opt,name=cost" json:"cost,omitempty"`
	RequireIds []int32              `protobuf:"varint,22,rep,name=require_ids,json=requireIds" json:"require_ids,omitempty"`
	BaseLevel  int32                `protobuf:"varint,23,opt,name=base_level,json=baseLevel,proto3" json:"base_level,omitempty"`
}

func (m *BuildingDataProto) Reset()                    { *m = BuildingDataProto{} }
func (m *BuildingDataProto) String() string            { return proto.CompactTextString(m) }
func (*BuildingDataProto) ProtoMessage()               {}
func (*BuildingDataProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{3} }

func (m *BuildingDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BuildingDataProto) GetType() BuildingType {
	if m != nil {
		return m.Type
	}
	return BuildingType_InvalidBuildingType
}

func (m *BuildingDataProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *BuildingDataProto) GetWorkTime() int32 {
	if m != nil {
		return m.WorkTime
	}
	return 0
}

func (m *BuildingDataProto) GetProsperity() int32 {
	if m != nil {
		return m.Prosperity
	}
	return 0
}

func (m *BuildingDataProto) GetHeroExp() int32 {
	if m != nil {
		return m.HeroExp
	}
	return 0
}

func (m *BuildingDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *BuildingDataProto) GetTips() string {
	if m != nil {
		return m.Tips
	}
	return ""
}

func (m *BuildingDataProto) GetIconId() string {
	if m != nil {
		return m.IconId
	}
	return ""
}

func (m *BuildingDataProto) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *BuildingDataProto) GetEffectDesc() string {
	if m != nil {
		return m.EffectDesc
	}
	return ""
}

func (m *BuildingDataProto) GetEffect() *DomesticEffectProto {
	if m != nil {
		return m.Effect
	}
	return nil
}

func (m *BuildingDataProto) GetNotice() string {
	if m != nil {
		return m.Notice
	}
	return ""
}

func (m *BuildingDataProto) GetCost() *CostProto {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *BuildingDataProto) GetRequireIds() []int32 {
	if m != nil {
		return m.RequireIds
	}
	return nil
}

func (m *BuildingDataProto) GetBaseLevel() int32 {
	if m != nil {
		return m.BaseLevel
	}
	return 0
}

type BuildingUnlockDataProto struct {
	BuildingType     BuildingType `protobuf:"varint,1,opt,name=building_type,json=buildingType,proto3,enum=proto.BuildingType" json:"building_type,omitempty"`
	GuanFuLevel      int32        `protobuf:"varint,2,opt,name=guan_fu_level,json=guanFuLevel,proto3" json:"guan_fu_level,omitempty"`
	HeroLevel        int32        `protobuf:"varint,3,opt,name=hero_level,json=heroLevel,proto3" json:"hero_level,omitempty"`
	MainTaskSequence int32        `protobuf:"varint,4,opt,name=main_task_sequence,json=mainTaskSequence,proto3" json:"main_task_sequence,omitempty"`
	BaYeStage        int32        `protobuf:"varint,5,opt,name=ba_ye_stage,json=baYeStage,proto3" json:"ba_ye_stage,omitempty"`
	Desc             string       `protobuf:"bytes,10,opt,name=desc,proto3" json:"desc,omitempty"`
	Icon             string       `protobuf:"bytes,11,opt,name=icon,proto3" json:"icon,omitempty"`
	NotifyOrder      int32        `protobuf:"varint,12,opt,name=notify_order,json=notifyOrder,proto3" json:"notify_order,omitempty"`
}

func (m *BuildingUnlockDataProto) Reset()                    { *m = BuildingUnlockDataProto{} }
func (m *BuildingUnlockDataProto) String() string            { return proto.CompactTextString(m) }
func (*BuildingUnlockDataProto) ProtoMessage()               {}
func (*BuildingUnlockDataProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{4} }

func (m *BuildingUnlockDataProto) GetBuildingType() BuildingType {
	if m != nil {
		return m.BuildingType
	}
	return BuildingType_InvalidBuildingType
}

func (m *BuildingUnlockDataProto) GetGuanFuLevel() int32 {
	if m != nil {
		return m.GuanFuLevel
	}
	return 0
}

func (m *BuildingUnlockDataProto) GetHeroLevel() int32 {
	if m != nil {
		return m.HeroLevel
	}
	return 0
}

func (m *BuildingUnlockDataProto) GetMainTaskSequence() int32 {
	if m != nil {
		return m.MainTaskSequence
	}
	return 0
}

func (m *BuildingUnlockDataProto) GetBaYeStage() int32 {
	if m != nil {
		return m.BaYeStage
	}
	return 0
}

func (m *BuildingUnlockDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *BuildingUnlockDataProto) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *BuildingUnlockDataProto) GetNotifyOrder() int32 {
	if m != nil {
		return m.NotifyOrder
	}
	return 0
}

type DomesticEffectProto struct {
	// 建筑cd系数, 这个值需要除以 1000，得到小数系数
	BuildingWorkerCoef            int32 `protobuf:"varint,1,opt,name=building_worker_coef,json=buildingWorkerCoef,proto3" json:"building_worker_coef,omitempty"`
	BuildingWorkerFatigueDuration int32 `protobuf:"varint,3,opt,name=building_worker_fatigue_duration,json=buildingWorkerFatigueDuration,proto3" json:"building_worker_fatigue_duration,omitempty"`
	// 科技cd系数, 这个值需要除以 1000，得到小数系数
	TechWorkerCoef            int32 `protobuf:"varint,2,opt,name=tech_worker_coef,json=techWorkerCoef,proto3" json:"tech_worker_coef,omitempty"`
	TechWorkerFatigueDuration int32 `protobuf:"varint,4,opt,name=tech_worker_fatigue_duration,json=techWorkerFatigueDuration,proto3" json:"tech_worker_fatigue_duration,omitempty"`
	// 外使院
	SeekHelpCdr      int32 `protobuf:"varint,21,opt,name=seek_help_cdr,json=seekHelpCdr,proto3" json:"seek_help_cdr,omitempty"`
	SeekHelpMaxTimes int32 `protobuf:"varint,22,opt,name=seek_help_max_times,json=seekHelpMaxTimes,proto3" json:"seek_help_max_times,omitempty"`
	GuildDonateTimes int32 `protobuf:"varint,23,opt,name=guild_donate_times,json=guildDonateTimes,proto3" json:"guild_donate_times,omitempty"`
	// 仓库相关
	Capcity          []*AmountProto `protobuf:"bytes,101,rep,name=capcity" json:"capcity,omitempty"`
	ProtectedCapcity *AmountProto   `protobuf:"bytes,102,opt,name=protected_capcity,json=protectedCapcity" json:"protected_capcity,omitempty"`
	OutputType       ResType        `protobuf:"varint,105,opt,name=output_type,json=outputType,proto3,enum=proto.ResType" json:"output_type,omitempty"`
	Output           *AmountProto   `protobuf:"bytes,103,opt,name=output" json:"output,omitempty"`
	OutputCapcity    *AmountProto   `protobuf:"bytes,104,opt,name=output_capcity,json=outputCapcity" json:"output_capcity,omitempty"`
	// 军营相关
	SoldierCapcity        int32 `protobuf:"varint,51,opt,name=soldier_capcity,json=soldierCapcity,proto3" json:"soldier_capcity,omitempty"`
	SoldierOutput         int32 `protobuf:"varint,72,opt,name=soldier_output,json=soldierOutput,proto3" json:"soldier_output,omitempty"`
	ForceSoldier          int32 `protobuf:"varint,73,opt,name=force_soldier,json=forceSoldier,proto3" json:"force_soldier,omitempty"`
	NewSoldierOutput      int32 `protobuf:"varint,52,opt,name=new_soldier_output,json=newSoldierOutput,proto3" json:"new_soldier_output,omitempty"`
	NewSoldierCapcity     int32 `protobuf:"varint,53,opt,name=new_soldier_capcity,json=newSoldierCapcity,proto3" json:"new_soldier_capcity,omitempty"`
	WoundedSoldierCapcity int32 `protobuf:"varint,54,opt,name=wounded_soldier_capcity,json=woundedSoldierCapcity,proto3" json:"wounded_soldier_capcity,omitempty"`
	RecruitSoldierCount   int32 `protobuf:"varint,64,opt,name=recruit_soldier_count,json=recruitSoldierCount,proto3" json:"recruit_soldier_count,omitempty"`
	// 士兵
	SoldierLoad            int32            `protobuf:"varint,55,opt,name=soldier_load,json=soldierLoad,proto3" json:"soldier_load,omitempty"`
	SoldierRace            []Race           `protobuf:"varint,56,rep,name=soldier_race,json=soldierRace,enum=proto.Race" json:"soldier_race,omitempty"`
	SoldierStat            *SpriteStatProto `protobuf:"bytes,57,opt,name=soldier_stat,json=soldierStat" json:"soldier_stat,omitempty"`
	FarStat                *SpriteStatProto `protobuf:"bytes,66,opt,name=far_stat,json=farStat" json:"far_stat,omitempty"`
	CloseStat              *SpriteStatProto `protobuf:"bytes,67,opt,name=close_stat,json=closeStat" json:"close_stat,omitempty"`
	AllSoldierStat         *SpriteStatProto `protobuf:"bytes,69,opt,name=all_soldier_stat,json=allSoldierStat" json:"all_soldier_stat,omitempty"`
	TrainOutput            int32            `protobuf:"varint,58,opt,name=train_output,json=trainOutput,proto3" json:"train_output,omitempty"`
	TrainCapcity           int32            `protobuf:"varint,59,opt,name=train_capcity,json=trainCapcity,proto3" json:"train_capcity,omitempty"`
	TrainCoef              int32            `protobuf:"varint,65,opt,name=train_coef,json=trainCoef,proto3" json:"train_coef,omitempty"`
	TrainExpPerHour        int32            `protobuf:"varint,63,opt,name=train_exp_per_hour,json=trainExpPerHour,proto3" json:"train_exp_per_hour,omitempty"`
	TentProsperityCapcity  int32            `protobuf:"varint,60,opt,name=tent_prosperity_capcity,json=tentProsperityCapcity,proto3" json:"tent_prosperity_capcity,omitempty"`
	HomeWallStat           *SpriteStatProto `protobuf:"bytes,61,opt,name=home_wall_stat,json=homeWallStat" json:"home_wall_stat,omitempty"`
	TentWallStat           *SpriteStatProto `protobuf:"bytes,62,opt,name=tent_wall_stat,json=tentWallStat" json:"tent_wall_stat,omitempty"`
	HomeWallFixDamage      int32            `protobuf:"varint,70,opt,name=home_wall_fix_damage,json=homeWallFixDamage,proto3" json:"home_wall_fix_damage,omitempty"`
	TentWallFixDamage      int32            `protobuf:"varint,71,opt,name=tent_wall_fix_damage,json=tentWallFixDamage,proto3" json:"tent_wall_fix_damage,omitempty"`
	FarmOutputType         ResType          `protobuf:"varint,106,opt,name=farm_output_type,json=farmOutputType,proto3,enum=proto.ResType" json:"farm_output_type,omitempty"`
	FarmOutput             *AmountProto     `protobuf:"bytes,107,opt,name=farm_output,json=farmOutput" json:"farm_output,omitempty"`
	Tax                    []*AmountProto   `protobuf:"bytes,108,rep,name=tax" json:"tax,omitempty"`
	AddedDefenseStat       *SpriteStatProto `protobuf:"bytes,109,opt,name=added_defense_stat,json=addedDefenseStat" json:"added_defense_stat,omitempty"`
	AddedAssistStat        *SpriteStatProto `protobuf:"bytes,110,opt,name=added_assist_stat,json=addedAssistStat" json:"added_assist_stat,omitempty"`
	AddedCopyDefenseStat   *SpriteStatProto `protobuf:"bytes,113,opt,name=added_copy_defense_stat,json=addedCopyDefenseStat" json:"added_copy_defense_stat,omitempty"`
	BuildingCostReduceCoef int32            `protobuf:"varint,111,opt,name=building_cost_reduce_coef,json=buildingCostReduceCoef,proto3" json:"building_cost_reduce_coef,omitempty"`
	TechCostReduceCoef     int32            `protobuf:"varint,112,opt,name=tech_cost_reduce_coef,json=techCostReduceCoef,proto3" json:"tech_cost_reduce_coef,omitempty"`
}

func (m *DomesticEffectProto) Reset()                    { *m = DomesticEffectProto{} }
func (m *DomesticEffectProto) String() string            { return proto.CompactTextString(m) }
func (*DomesticEffectProto) ProtoMessage()               {}
func (*DomesticEffectProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{5} }

func (m *DomesticEffectProto) GetBuildingWorkerCoef() int32 {
	if m != nil {
		return m.BuildingWorkerCoef
	}
	return 0
}

func (m *DomesticEffectProto) GetBuildingWorkerFatigueDuration() int32 {
	if m != nil {
		return m.BuildingWorkerFatigueDuration
	}
	return 0
}

func (m *DomesticEffectProto) GetTechWorkerCoef() int32 {
	if m != nil {
		return m.TechWorkerCoef
	}
	return 0
}

func (m *DomesticEffectProto) GetTechWorkerFatigueDuration() int32 {
	if m != nil {
		return m.TechWorkerFatigueDuration
	}
	return 0
}

func (m *DomesticEffectProto) GetSeekHelpCdr() int32 {
	if m != nil {
		return m.SeekHelpCdr
	}
	return 0
}

func (m *DomesticEffectProto) GetSeekHelpMaxTimes() int32 {
	if m != nil {
		return m.SeekHelpMaxTimes
	}
	return 0
}

func (m *DomesticEffectProto) GetGuildDonateTimes() int32 {
	if m != nil {
		return m.GuildDonateTimes
	}
	return 0
}

func (m *DomesticEffectProto) GetCapcity() []*AmountProto {
	if m != nil {
		return m.Capcity
	}
	return nil
}

func (m *DomesticEffectProto) GetProtectedCapcity() *AmountProto {
	if m != nil {
		return m.ProtectedCapcity
	}
	return nil
}

func (m *DomesticEffectProto) GetOutputType() ResType {
	if m != nil {
		return m.OutputType
	}
	return ResType_InvalidResType
}

func (m *DomesticEffectProto) GetOutput() *AmountProto {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *DomesticEffectProto) GetOutputCapcity() *AmountProto {
	if m != nil {
		return m.OutputCapcity
	}
	return nil
}

func (m *DomesticEffectProto) GetSoldierCapcity() int32 {
	if m != nil {
		return m.SoldierCapcity
	}
	return 0
}

func (m *DomesticEffectProto) GetSoldierOutput() int32 {
	if m != nil {
		return m.SoldierOutput
	}
	return 0
}

func (m *DomesticEffectProto) GetForceSoldier() int32 {
	if m != nil {
		return m.ForceSoldier
	}
	return 0
}

func (m *DomesticEffectProto) GetNewSoldierOutput() int32 {
	if m != nil {
		return m.NewSoldierOutput
	}
	return 0
}

func (m *DomesticEffectProto) GetNewSoldierCapcity() int32 {
	if m != nil {
		return m.NewSoldierCapcity
	}
	return 0
}

func (m *DomesticEffectProto) GetWoundedSoldierCapcity() int32 {
	if m != nil {
		return m.WoundedSoldierCapcity
	}
	return 0
}

func (m *DomesticEffectProto) GetRecruitSoldierCount() int32 {
	if m != nil {
		return m.RecruitSoldierCount
	}
	return 0
}

func (m *DomesticEffectProto) GetSoldierLoad() int32 {
	if m != nil {
		return m.SoldierLoad
	}
	return 0
}

func (m *DomesticEffectProto) GetSoldierRace() []Race {
	if m != nil {
		return m.SoldierRace
	}
	return nil
}

func (m *DomesticEffectProto) GetSoldierStat() *SpriteStatProto {
	if m != nil {
		return m.SoldierStat
	}
	return nil
}

func (m *DomesticEffectProto) GetFarStat() *SpriteStatProto {
	if m != nil {
		return m.FarStat
	}
	return nil
}

func (m *DomesticEffectProto) GetCloseStat() *SpriteStatProto {
	if m != nil {
		return m.CloseStat
	}
	return nil
}

func (m *DomesticEffectProto) GetAllSoldierStat() *SpriteStatProto {
	if m != nil {
		return m.AllSoldierStat
	}
	return nil
}

func (m *DomesticEffectProto) GetTrainOutput() int32 {
	if m != nil {
		return m.TrainOutput
	}
	return 0
}

func (m *DomesticEffectProto) GetTrainCapcity() int32 {
	if m != nil {
		return m.TrainCapcity
	}
	return 0
}

func (m *DomesticEffectProto) GetTrainCoef() int32 {
	if m != nil {
		return m.TrainCoef
	}
	return 0
}

func (m *DomesticEffectProto) GetTrainExpPerHour() int32 {
	if m != nil {
		return m.TrainExpPerHour
	}
	return 0
}

func (m *DomesticEffectProto) GetTentProsperityCapcity() int32 {
	if m != nil {
		return m.TentProsperityCapcity
	}
	return 0
}

func (m *DomesticEffectProto) GetHomeWallStat() *SpriteStatProto {
	if m != nil {
		return m.HomeWallStat
	}
	return nil
}

func (m *DomesticEffectProto) GetTentWallStat() *SpriteStatProto {
	if m != nil {
		return m.TentWallStat
	}
	return nil
}

func (m *DomesticEffectProto) GetHomeWallFixDamage() int32 {
	if m != nil {
		return m.HomeWallFixDamage
	}
	return 0
}

func (m *DomesticEffectProto) GetTentWallFixDamage() int32 {
	if m != nil {
		return m.TentWallFixDamage
	}
	return 0
}

func (m *DomesticEffectProto) GetFarmOutputType() ResType {
	if m != nil {
		return m.FarmOutputType
	}
	return ResType_InvalidResType
}

func (m *DomesticEffectProto) GetFarmOutput() *AmountProto {
	if m != nil {
		return m.FarmOutput
	}
	return nil
}

func (m *DomesticEffectProto) GetTax() []*AmountProto {
	if m != nil {
		return m.Tax
	}
	return nil
}

func (m *DomesticEffectProto) GetAddedDefenseStat() *SpriteStatProto {
	if m != nil {
		return m.AddedDefenseStat
	}
	return nil
}

func (m *DomesticEffectProto) GetAddedAssistStat() *SpriteStatProto {
	if m != nil {
		return m.AddedAssistStat
	}
	return nil
}

func (m *DomesticEffectProto) GetAddedCopyDefenseStat() *SpriteStatProto {
	if m != nil {
		return m.AddedCopyDefenseStat
	}
	return nil
}

func (m *DomesticEffectProto) GetBuildingCostReduceCoef() int32 {
	if m != nil {
		return m.BuildingCostReduceCoef
	}
	return 0
}

func (m *DomesticEffectProto) GetTechCostReduceCoef() int32 {
	if m != nil {
		return m.TechCostReduceCoef
	}
	return 0
}

type GuanFuLevelProto struct {
	Level                                    int32       `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	RestoreProsperity                        int32       `protobuf:"varint,5,opt,name=restore_prosperity,json=restoreProsperity,proto3" json:"restore_prosperity,omitempty"`
	MoveBaseRestoreHomeProsperity            int32       `protobuf:"varint,2,opt,name=move_base_restore_home_prosperity,json=moveBaseRestoreHomeProsperity,proto3" json:"move_base_restore_home_prosperity,omitempty"`
	BuyProsperityRestoreDurationWith1Yuanbao int32       `protobuf:"varint,3,opt,name=buy_prosperity_restore_duration_with1_yuanbao,json=buyProsperityRestoreDurationWith1Yuanbao,proto3" json:"buy_prosperity_restore_duration_with1_yuanbao,omitempty"`
	BuyProsperityRestoreDurationWith1Cost    int32       `protobuf:"varint,4,opt,name=buy_prosperity_restore_duration_with1_cost,json=buyProsperityRestoreDurationWith1Cost,proto3" json:"buy_prosperity_restore_duration_with1_cost,omitempty"`
	MoveBaseRestoreHomeProsperityDuration    int32       `protobuf:"varint,6,opt,name=move_base_restore_home_prosperity_duration,json=moveBaseRestoreHomeProsperityDuration,proto3" json:"move_base_restore_home_prosperity_duration,omitempty"`
	WorkshopPrize                            *PrizeProto `protobuf:"bytes,7,opt,name=workshop_prize,json=workshopPrize" json:"workshop_prize,omitempty"`
}

func (m *GuanFuLevelProto) Reset()                    { *m = GuanFuLevelProto{} }
func (m *GuanFuLevelProto) String() string            { return proto.CompactTextString(m) }
func (*GuanFuLevelProto) ProtoMessage()               {}
func (*GuanFuLevelProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{6} }

func (m *GuanFuLevelProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *GuanFuLevelProto) GetRestoreProsperity() int32 {
	if m != nil {
		return m.RestoreProsperity
	}
	return 0
}

func (m *GuanFuLevelProto) GetMoveBaseRestoreHomeProsperity() int32 {
	if m != nil {
		return m.MoveBaseRestoreHomeProsperity
	}
	return 0
}

func (m *GuanFuLevelProto) GetBuyProsperityRestoreDurationWith1Yuanbao() int32 {
	if m != nil {
		return m.BuyProsperityRestoreDurationWith1Yuanbao
	}
	return 0
}

func (m *GuanFuLevelProto) GetBuyProsperityRestoreDurationWith1Cost() int32 {
	if m != nil {
		return m.BuyProsperityRestoreDurationWith1Cost
	}
	return 0
}

func (m *GuanFuLevelProto) GetMoveBaseRestoreHomeProsperityDuration() int32 {
	if m != nil {
		return m.MoveBaseRestoreHomeProsperityDuration
	}
	return 0
}

func (m *GuanFuLevelProto) GetWorkshopPrize() *PrizeProto {
	if m != nil {
		return m.WorkshopPrize
	}
	return nil
}

type TieJiangPuLevelProto struct {
	Level int32 `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	// 铁匠铺
	MaxForgingTimes          int32   `protobuf:"varint,2,opt,name=max_forging_times,json=maxForgingTimes,proto3" json:"max_forging_times,omitempty"`
	RecoveryForgingDuration  int32   `protobuf:"varint,3,opt,name=recovery_forging_duration,json=recoveryForgingDuration,proto3" json:"recovery_forging_duration,omitempty"`
	CanForgingEquipPos       []int32 `protobuf:"varint,4,rep,name=can_forging_equip_pos,json=canForgingEquipPos" json:"can_forging_equip_pos,omitempty"`
	CanForgingEquip          []int32 `protobuf:"varint,5,rep,name=can_forging_equip,json=canForgingEquip" json:"can_forging_equip,omitempty"`
	LockedCanForgingEquipPos []int32 `protobuf:"varint,6,rep,name=locked_can_forging_equip_pos,json=lockedCanForgingEquipPos" json:"locked_can_forging_equip_pos,omitempty"`
	LockedCanForgingEquip    []int32 `protobuf:"varint,7,rep,name=locked_can_forging_equip,json=lockedCanForgingEquip" json:"locked_can_forging_equip,omitempty"`
	LockedEquipNeedLevel     []int32 `protobuf:"varint,8,rep,name=locked_equip_need_level,json=lockedEquipNeedLevel" json:"locked_equip_need_level,omitempty"`
	CanOneKeyForging         bool    `protobuf:"varint,9,opt,name=can_one_key_forging,json=canOneKeyForging,proto3" json:"can_one_key_forging,omitempty"`
}

func (m *TieJiangPuLevelProto) Reset()                    { *m = TieJiangPuLevelProto{} }
func (m *TieJiangPuLevelProto) String() string            { return proto.CompactTextString(m) }
func (*TieJiangPuLevelProto) ProtoMessage()               {}
func (*TieJiangPuLevelProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{7} }

func (m *TieJiangPuLevelProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *TieJiangPuLevelProto) GetMaxForgingTimes() int32 {
	if m != nil {
		return m.MaxForgingTimes
	}
	return 0
}

func (m *TieJiangPuLevelProto) GetRecoveryForgingDuration() int32 {
	if m != nil {
		return m.RecoveryForgingDuration
	}
	return 0
}

func (m *TieJiangPuLevelProto) GetCanForgingEquipPos() []int32 {
	if m != nil {
		return m.CanForgingEquipPos
	}
	return nil
}

func (m *TieJiangPuLevelProto) GetCanForgingEquip() []int32 {
	if m != nil {
		return m.CanForgingEquip
	}
	return nil
}

func (m *TieJiangPuLevelProto) GetLockedCanForgingEquipPos() []int32 {
	if m != nil {
		return m.LockedCanForgingEquipPos
	}
	return nil
}

func (m *TieJiangPuLevelProto) GetLockedCanForgingEquip() []int32 {
	if m != nil {
		return m.LockedCanForgingEquip
	}
	return nil
}

func (m *TieJiangPuLevelProto) GetLockedEquipNeedLevel() []int32 {
	if m != nil {
		return m.LockedEquipNeedLevel
	}
	return nil
}

func (m *TieJiangPuLevelProto) GetCanOneKeyForging() bool {
	if m != nil {
		return m.CanOneKeyForging
	}
	return false
}

type TechnologyDataProto struct {
	Id       int32                `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name     string               `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Desc     string               `protobuf:"bytes,8,opt,name=desc,proto3" json:"desc,omitempty"`
	Type     TechType             `protobuf:"varint,3,opt,name=type,proto3,enum=proto.TechType" json:"type,omitempty"`
	Sequence int32                `protobuf:"varint,9,opt,name=sequence,proto3" json:"sequence,omitempty"`
	Icon     string               `protobuf:"bytes,4,opt,name=icon,proto3" json:"icon,omitempty"`
	IntIcon  int32                `protobuf:"varint,10,opt,name=int_icon,json=intIcon,proto3" json:"int_icon,omitempty"`
	Group    int32                `protobuf:"varint,5,opt,name=group,proto3" json:"group,omitempty"`
	Level    int32                `protobuf:"varint,6,opt,name=level,proto3" json:"level,omitempty"`
	Effect   *DomesticEffectProto `protobuf:"bytes,7,opt,name=effect" json:"effect,omitempty"`
	// 研究条件
	RequireBuildingIds []int32    `protobuf:"varint,11,rep,name=require_building_ids,json=requireBuildingIds" json:"require_building_ids,omitempty"`
	RequireTechIds     []int32    `protobuf:"varint,12,rep,name=require_tech_ids,json=requireTechIds" json:"require_tech_ids,omitempty"`
	IsBigTech          bool       `protobuf:"varint,13,opt,name=is_big_tech,json=isBigTech,proto3" json:"is_big_tech,omitempty"`
	Cost               *CostProto `protobuf:"bytes,21,opt,name=cost" json:"cost,omitempty"`
	WorkTime           int32      `protobuf:"varint,22,opt,name=work_time,json=workTime,proto3" json:"work_time,omitempty"`
	NextLevelId        int32      `protobuf:"varint,23,opt,name=next_level_id,json=nextLevelId,proto3" json:"next_level_id,omitempty"`
	MaxLevel           int32      `protobuf:"varint,24,opt,name=max_level,json=maxLevel,proto3" json:"max_level,omitempty"`
}

func (m *TechnologyDataProto) Reset()                    { *m = TechnologyDataProto{} }
func (m *TechnologyDataProto) String() string            { return proto.CompactTextString(m) }
func (*TechnologyDataProto) ProtoMessage()               {}
func (*TechnologyDataProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{8} }

func (m *TechnologyDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TechnologyDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TechnologyDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *TechnologyDataProto) GetType() TechType {
	if m != nil {
		return m.Type
	}
	return TechType_InvalidTechType
}

func (m *TechnologyDataProto) GetSequence() int32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *TechnologyDataProto) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *TechnologyDataProto) GetIntIcon() int32 {
	if m != nil {
		return m.IntIcon
	}
	return 0
}

func (m *TechnologyDataProto) GetGroup() int32 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *TechnologyDataProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *TechnologyDataProto) GetEffect() *DomesticEffectProto {
	if m != nil {
		return m.Effect
	}
	return nil
}

func (m *TechnologyDataProto) GetRequireBuildingIds() []int32 {
	if m != nil {
		return m.RequireBuildingIds
	}
	return nil
}

func (m *TechnologyDataProto) GetRequireTechIds() []int32 {
	if m != nil {
		return m.RequireTechIds
	}
	return nil
}

func (m *TechnologyDataProto) GetIsBigTech() bool {
	if m != nil {
		return m.IsBigTech
	}
	return false
}

func (m *TechnologyDataProto) GetCost() *CostProto {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *TechnologyDataProto) GetWorkTime() int32 {
	if m != nil {
		return m.WorkTime
	}
	return 0
}

func (m *TechnologyDataProto) GetNextLevelId() int32 {
	if m != nil {
		return m.NextLevelId
	}
	return 0
}

func (m *TechnologyDataProto) GetMaxLevel() int32 {
	if m != nil {
		return m.MaxLevel
	}
	return 0
}

type CountdownPrizeDescDataProto struct {
	Id   int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Desc string `protobuf:"bytes,2,opt,name=desc,proto3" json:"desc,omitempty"`
}

func (m *CountdownPrizeDescDataProto) Reset()         { *m = CountdownPrizeDescDataProto{} }
func (m *CountdownPrizeDescDataProto) String() string { return proto.CompactTextString(m) }
func (*CountdownPrizeDescDataProto) ProtoMessage()    {}
func (*CountdownPrizeDescDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorDomestic, []int{9}
}

func (m *CountdownPrizeDescDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CountdownPrizeDescDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

type HeroDomesticProto struct {
	Gold                          int32                     `protobuf:"varint,1,opt,name=gold,proto3" json:"gold,omitempty"`
	Food                          int32                     `protobuf:"varint,2,opt,name=food,proto3" json:"food,omitempty"`
	Wood                          int32                     `protobuf:"varint,3,opt,name=wood,proto3" json:"wood,omitempty"`
	Stone                         int32                     `protobuf:"varint,4,opt,name=stone,proto3" json:"stone,omitempty"`
	SafeGold                      int32                     `protobuf:"varint,11,opt,name=safe_gold,json=safeGold,proto3" json:"safe_gold,omitempty"`
	SafeFood                      int32                     `protobuf:"varint,12,opt,name=safe_food,json=safeFood,proto3" json:"safe_food,omitempty"`
	SafeWood                      int32                     `protobuf:"varint,13,opt,name=safe_wood,json=safeWood,proto3" json:"safe_wood,omitempty"`
	SafeStone                     int32                     `protobuf:"varint,14,opt,name=safe_stone,json=safeStone,proto3" json:"safe_stone,omitempty"`
	GoldCapcity                   int32                     `protobuf:"varint,6,opt,name=gold_capcity,json=goldCapcity,proto3" json:"gold_capcity,omitempty"`
	FoodCapcity                   int32                     `protobuf:"varint,7,opt,name=food_capcity,json=foodCapcity,proto3" json:"food_capcity,omitempty"`
	WoodCapcity                   int32                     `protobuf:"varint,8,opt,name=wood_capcity,json=woodCapcity,proto3" json:"wood_capcity,omitempty"`
	StoneCapcity                  int32                     `protobuf:"varint,9,opt,name=stone_capcity,json=stoneCapcity,proto3" json:"stone_capcity,omitempty"`
	ProtectedCapcity              int32                     `protobuf:"varint,15,opt,name=protected_capcity,json=protectedCapcity,proto3" json:"protected_capcity,omitempty"`
	WorkerRestEndTime             []int32                   `protobuf:"varint,16,rep,name=worker_rest_end_time,json=workerRestEndTime" json:"worker_rest_end_time,omitempty"`
	WorkerSeekHelp                []bool                    `protobuf:"varint,51,rep,name=worker_seek_help,json=workerSeekHelp" json:"worker_seek_help,omitempty"`
	WorkerAlwaysUnlocked          []bool                    `protobuf:"varint,61,rep,name=worker_always_unlocked,json=workerAlwaysUnlocked" json:"worker_always_unlocked,omitempty"`
	WorkerLockStartTime           []int32                   `protobuf:"varint,62,rep,name=worker_lock_start_time,json=workerLockStartTime" json:"worker_lock_start_time,omitempty"`
	ResourceBuilding              []*Int32Pair              `protobuf:"bytes,17,rep,name=resource_building,json=resourceBuilding" json:"resource_building,omitempty"`
	Building                      []int32                   `protobuf:"varint,18,rep,name=building" json:"building,omitempty"`
	ResourcePoint                 []*HeroResourcePointProto `protobuf:"bytes,19,rep,name=resource_point,json=resourcePoint" json:"resource_point,omitempty"`
	Cities                        *OuterCitiesProto         `protobuf:"bytes,20,opt,name=cities" json:"cities,omitempty"`
	Technology                    []int32                   `protobuf:"varint,21,rep,name=technology" json:"technology,omitempty"`
	TechnologyRestEndTime         []int32                   `protobuf:"varint,22,rep,name=technology_rest_end_time,json=technologyRestEndTime" json:"technology_rest_end_time,omitempty"`
	TechnologySeekHelp            []bool                    `protobuf:"varint,52,rep,name=technology_seek_help,json=technologySeekHelp" json:"technology_seek_help,omitempty"`
	DailyHelpMemberTimes          int32                     `protobuf:"varint,53,opt,name=daily_help_member_times,json=dailyHelpMemberTimes,proto3" json:"daily_help_member_times,omitempty"`
	Prosperity                    int32                     `protobuf:"varint,26,opt,name=prosperity,proto3" json:"prosperity,omitempty"`
	MaxProsperity                 int32                     `protobuf:"varint,27,opt,name=max_prosperity,json=maxProsperity,proto3" json:"max_prosperity,omitempty"`
	LostProsperity                int32                     `protobuf:"varint,28,opt,name=lost_prosperity,json=lostProsperity,proto3" json:"lost_prosperity,omitempty"`
	BuildingWorkerCoef            int32                     `protobuf:"varint,31,opt,name=building_worker_coef,json=buildingWorkerCoef,proto3" json:"building_worker_coef,omitempty"`
	TechWorkerCoef                int32                     `protobuf:"varint,32,opt,name=tech_worker_coef,json=techWorkerCoef,proto3" json:"tech_worker_coef,omitempty"`
	BuildingWorkerFatigueDuration int32                     `protobuf:"varint,33,opt,name=building_worker_fatigue_duration,json=buildingWorkerFatigueDuration,proto3" json:"building_worker_fatigue_duration,omitempty"`
	TechWorkerFatigueDuration     int32                     `protobuf:"varint,34,opt,name=tech_worker_fatigue_duration,json=techWorkerFatigueDuration,proto3" json:"tech_worker_fatigue_duration,omitempty"`
	ForgingTimes                  int32                     `protobuf:"varint,35,opt,name=forging_times,json=forgingTimes,proto3" json:"forging_times,omitempty"`
	ForgingNextTime               int32                     `protobuf:"varint,36,opt,name=forging_next_time,json=forgingNextTime,proto3" json:"forging_next_time,omitempty"`
	NewForgingPos                 []int32                   `protobuf:"varint,46,rep,name=new_forging_pos,json=newForgingPos" json:"new_forging_pos,omitempty"`
	NextCollectTimeType           []ResType                 `protobuf:"varint,37,rep,name=next_collect_time_type,json=nextCollectTimeType,enum=proto.ResType" json:"next_collect_time_type,omitempty"`
	NextCollectTime               []int32                   `protobuf:"varint,38,rep,name=next_collect_time,json=nextCollectTime" json:"next_collect_time,omitempty"`
	DailyResourceCollectTimes     int32                     `protobuf:"varint,39,opt,name=daily_resource_collect_times,json=dailyResourceCollectTimes,proto3" json:"daily_resource_collect_times,omitempty"`
	CityEvent                     *CityEventProto           `protobuf:"bytes,40,opt,name=city_event,json=cityEvent" json:"city_event,omitempty"`
	// 签名
	Sign string `protobuf:"bytes,41,opt,name=sign,proto3" json:"sign,omitempty"`
	// 语音
	Voice []byte `protobuf:"bytes,42,opt,name=voice,proto3" json:"voice,omitempty"`
	// 资源点
	ResourcePointV2 *ResourcePointV2Proto `protobuf:"bytes,43,opt,name=resource_point_v2,json=resourcePointV2" json:"resource_point_v2,omitempty"`
	Jade            int32                 `protobuf:"varint,44,opt,name=jade,proto3" json:"jade,omitempty"`
	JadeOre         int32                 `protobuf:"varint,45,opt,name=jade_ore,json=jadeOre,proto3" json:"jade_ore,omitempty"`
	HistoryJade     int32                 `protobuf:"varint,49,opt,name=history_jade,json=historyJade,proto3" json:"history_jade,omitempty"`
	TodayObtainJade int32                 `protobuf:"varint,50,opt,name=today_obtain_jade,json=todayObtainJade,proto3" json:"today_obtain_jade,omitempty"`
	// 倒计时礼包
	CountdownCollectTime   int32 `protobuf:"varint,55,opt,name=countdown_collect_time,json=countdownCollectTime,proto3" json:"countdown_collect_time,omitempty"`
	IsCollectSeasonPrize   bool  `protobuf:"varint,57,opt,name=is_collect_season_prize,json=isCollectSeasonPrize,proto3" json:"is_collect_season_prize,omitempty"`
	WorkshopCollectTime    int32 `protobuf:"varint,58,opt,name=workshop_collect_time,json=workshopCollectTime,proto3" json:"workshop_collect_time,omitempty"`
	BuildingCostReduceCoef int32 `protobuf:"varint,59,opt,name=building_cost_reduce_coef,json=buildingCostReduceCoef,proto3" json:"building_cost_reduce_coef,omitempty"`
	TechCostReduceCoef     int32 `protobuf:"varint,60,opt,name=tech_cost_reduce_coef,json=techCostReduceCoef,proto3" json:"tech_cost_reduce_coef,omitempty"`
}

func (m *HeroDomesticProto) Reset()                    { *m = HeroDomesticProto{} }
func (m *HeroDomesticProto) String() string            { return proto.CompactTextString(m) }
func (*HeroDomesticProto) ProtoMessage()               {}
func (*HeroDomesticProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{10} }

func (m *HeroDomesticProto) GetGold() int32 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *HeroDomesticProto) GetFood() int32 {
	if m != nil {
		return m.Food
	}
	return 0
}

func (m *HeroDomesticProto) GetWood() int32 {
	if m != nil {
		return m.Wood
	}
	return 0
}

func (m *HeroDomesticProto) GetStone() int32 {
	if m != nil {
		return m.Stone
	}
	return 0
}

func (m *HeroDomesticProto) GetSafeGold() int32 {
	if m != nil {
		return m.SafeGold
	}
	return 0
}

func (m *HeroDomesticProto) GetSafeFood() int32 {
	if m != nil {
		return m.SafeFood
	}
	return 0
}

func (m *HeroDomesticProto) GetSafeWood() int32 {
	if m != nil {
		return m.SafeWood
	}
	return 0
}

func (m *HeroDomesticProto) GetSafeStone() int32 {
	if m != nil {
		return m.SafeStone
	}
	return 0
}

func (m *HeroDomesticProto) GetGoldCapcity() int32 {
	if m != nil {
		return m.GoldCapcity
	}
	return 0
}

func (m *HeroDomesticProto) GetFoodCapcity() int32 {
	if m != nil {
		return m.FoodCapcity
	}
	return 0
}

func (m *HeroDomesticProto) GetWoodCapcity() int32 {
	if m != nil {
		return m.WoodCapcity
	}
	return 0
}

func (m *HeroDomesticProto) GetStoneCapcity() int32 {
	if m != nil {
		return m.StoneCapcity
	}
	return 0
}

func (m *HeroDomesticProto) GetProtectedCapcity() int32 {
	if m != nil {
		return m.ProtectedCapcity
	}
	return 0
}

func (m *HeroDomesticProto) GetWorkerRestEndTime() []int32 {
	if m != nil {
		return m.WorkerRestEndTime
	}
	return nil
}

func (m *HeroDomesticProto) GetWorkerSeekHelp() []bool {
	if m != nil {
		return m.WorkerSeekHelp
	}
	return nil
}

func (m *HeroDomesticProto) GetWorkerAlwaysUnlocked() []bool {
	if m != nil {
		return m.WorkerAlwaysUnlocked
	}
	return nil
}

func (m *HeroDomesticProto) GetWorkerLockStartTime() []int32 {
	if m != nil {
		return m.WorkerLockStartTime
	}
	return nil
}

func (m *HeroDomesticProto) GetResourceBuilding() []*Int32Pair {
	if m != nil {
		return m.ResourceBuilding
	}
	return nil
}

func (m *HeroDomesticProto) GetBuilding() []int32 {
	if m != nil {
		return m.Building
	}
	return nil
}

func (m *HeroDomesticProto) GetResourcePoint() []*HeroResourcePointProto {
	if m != nil {
		return m.ResourcePoint
	}
	return nil
}

func (m *HeroDomesticProto) GetCities() *OuterCitiesProto {
	if m != nil {
		return m.Cities
	}
	return nil
}

func (m *HeroDomesticProto) GetTechnology() []int32 {
	if m != nil {
		return m.Technology
	}
	return nil
}

func (m *HeroDomesticProto) GetTechnologyRestEndTime() []int32 {
	if m != nil {
		return m.TechnologyRestEndTime
	}
	return nil
}

func (m *HeroDomesticProto) GetTechnologySeekHelp() []bool {
	if m != nil {
		return m.TechnologySeekHelp
	}
	return nil
}

func (m *HeroDomesticProto) GetDailyHelpMemberTimes() int32 {
	if m != nil {
		return m.DailyHelpMemberTimes
	}
	return 0
}

func (m *HeroDomesticProto) GetProsperity() int32 {
	if m != nil {
		return m.Prosperity
	}
	return 0
}

func (m *HeroDomesticProto) GetMaxProsperity() int32 {
	if m != nil {
		return m.MaxProsperity
	}
	return 0
}

func (m *HeroDomesticProto) GetLostProsperity() int32 {
	if m != nil {
		return m.LostProsperity
	}
	return 0
}

func (m *HeroDomesticProto) GetBuildingWorkerCoef() int32 {
	if m != nil {
		return m.BuildingWorkerCoef
	}
	return 0
}

func (m *HeroDomesticProto) GetTechWorkerCoef() int32 {
	if m != nil {
		return m.TechWorkerCoef
	}
	return 0
}

func (m *HeroDomesticProto) GetBuildingWorkerFatigueDuration() int32 {
	if m != nil {
		return m.BuildingWorkerFatigueDuration
	}
	return 0
}

func (m *HeroDomesticProto) GetTechWorkerFatigueDuration() int32 {
	if m != nil {
		return m.TechWorkerFatigueDuration
	}
	return 0
}

func (m *HeroDomesticProto) GetForgingTimes() int32 {
	if m != nil {
		return m.ForgingTimes
	}
	return 0
}

func (m *HeroDomesticProto) GetForgingNextTime() int32 {
	if m != nil {
		return m.ForgingNextTime
	}
	return 0
}

func (m *HeroDomesticProto) GetNewForgingPos() []int32 {
	if m != nil {
		return m.NewForgingPos
	}
	return nil
}

func (m *HeroDomesticProto) GetNextCollectTimeType() []ResType {
	if m != nil {
		return m.NextCollectTimeType
	}
	return nil
}

func (m *HeroDomesticProto) GetNextCollectTime() []int32 {
	if m != nil {
		return m.NextCollectTime
	}
	return nil
}

func (m *HeroDomesticProto) GetDailyResourceCollectTimes() int32 {
	if m != nil {
		return m.DailyResourceCollectTimes
	}
	return 0
}

func (m *HeroDomesticProto) GetCityEvent() *CityEventProto {
	if m != nil {
		return m.CityEvent
	}
	return nil
}

func (m *HeroDomesticProto) GetSign() string {
	if m != nil {
		return m.Sign
	}
	return ""
}

func (m *HeroDomesticProto) GetVoice() []byte {
	if m != nil {
		return m.Voice
	}
	return nil
}

func (m *HeroDomesticProto) GetResourcePointV2() *ResourcePointV2Proto {
	if m != nil {
		return m.ResourcePointV2
	}
	return nil
}

func (m *HeroDomesticProto) GetJade() int32 {
	if m != nil {
		return m.Jade
	}
	return 0
}

func (m *HeroDomesticProto) GetJadeOre() int32 {
	if m != nil {
		return m.JadeOre
	}
	return 0
}

func (m *HeroDomesticProto) GetHistoryJade() int32 {
	if m != nil {
		return m.HistoryJade
	}
	return 0
}

func (m *HeroDomesticProto) GetTodayObtainJade() int32 {
	if m != nil {
		return m.TodayObtainJade
	}
	return 0
}

func (m *HeroDomesticProto) GetCountdownCollectTime() int32 {
	if m != nil {
		return m.CountdownCollectTime
	}
	return 0
}

func (m *HeroDomesticProto) GetIsCollectSeasonPrize() bool {
	if m != nil {
		return m.IsCollectSeasonPrize
	}
	return false
}

func (m *HeroDomesticProto) GetWorkshopCollectTime() int32 {
	if m != nil {
		return m.WorkshopCollectTime
	}
	return 0
}

func (m *HeroDomesticProto) GetBuildingCostReduceCoef() int32 {
	if m != nil {
		return m.BuildingCostReduceCoef
	}
	return 0
}

func (m *HeroDomesticProto) GetTechCostReduceCoef() int32 {
	if m != nil {
		return m.TechCostReduceCoef
	}
	return 0
}

type HeroDomesticOtherProto struct {
	Prosperity     int32 `protobuf:"varint,26,opt,name=prosperity,proto3" json:"prosperity,omitempty"`
	MaxProsperity  int32 `protobuf:"varint,27,opt,name=max_prosperity,json=maxProsperity,proto3" json:"max_prosperity,omitempty"`
	LostProsperity int32 `protobuf:"varint,28,opt,name=lost_prosperity,json=lostProsperity,proto3" json:"lost_prosperity,omitempty"`
	// 签名
	Sign string `protobuf:"bytes,41,opt,name=sign,proto3" json:"sign,omitempty"`
	// 语音
	Voice []byte `protobuf:"bytes,42,opt,name=voice,proto3" json:"voice,omitempty"`
}

func (m *HeroDomesticOtherProto) Reset()                    { *m = HeroDomesticOtherProto{} }
func (m *HeroDomesticOtherProto) String() string            { return proto.CompactTextString(m) }
func (*HeroDomesticOtherProto) ProtoMessage()               {}
func (*HeroDomesticOtherProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{11} }

func (m *HeroDomesticOtherProto) GetProsperity() int32 {
	if m != nil {
		return m.Prosperity
	}
	return 0
}

func (m *HeroDomesticOtherProto) GetMaxProsperity() int32 {
	if m != nil {
		return m.MaxProsperity
	}
	return 0
}

func (m *HeroDomesticOtherProto) GetLostProsperity() int32 {
	if m != nil {
		return m.LostProsperity
	}
	return 0
}

func (m *HeroDomesticOtherProto) GetSign() string {
	if m != nil {
		return m.Sign
	}
	return ""
}

func (m *HeroDomesticOtherProto) GetVoice() []byte {
	if m != nil {
		return m.Voice
	}
	return nil
}

// 资源
type ResourcePointV2Proto struct {
	// 资源
	ResourcePoint    []*SingleResourcePointV2Proto `protobuf:"bytes,1,rep,name=resource_point,json=resourcePoint" json:"resource_point,omitempty"`
	ResCount         int32                         `protobuf:"varint,2,opt,name=res_count,json=resCount,proto3" json:"res_count,omitempty"`
	ConflictResCount int32                         `protobuf:"varint,3,opt,name=conflict_res_count,json=conflictResCount,proto3" json:"conflict_res_count,omitempty"`
}

func (m *ResourcePointV2Proto) Reset()                    { *m = ResourcePointV2Proto{} }
func (m *ResourcePointV2Proto) String() string            { return proto.CompactTextString(m) }
func (*ResourcePointV2Proto) ProtoMessage()               {}
func (*ResourcePointV2Proto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{12} }

func (m *ResourcePointV2Proto) GetResourcePoint() []*SingleResourcePointV2Proto {
	if m != nil {
		return m.ResourcePoint
	}
	return nil
}

func (m *ResourcePointV2Proto) GetResCount() int32 {
	if m != nil {
		return m.ResCount
	}
	return 0
}

func (m *ResourcePointV2Proto) GetConflictResCount() int32 {
	if m != nil {
		return m.ConflictResCount
	}
	return 0
}

type SingleResourcePointV2Proto struct {
	ResType      ResType `protobuf:"varint,1,opt,name=res_type,json=resType,proto3,enum=proto.ResType" json:"res_type,omitempty"`
	OriginOutput int32   `protobuf:"varint,4,opt,name=origin_output,json=originOutput,proto3" json:"origin_output,omitempty"`
	RealOutput   int32   `protobuf:"varint,5,opt,name=real_output,json=realOutput,proto3" json:"real_output,omitempty"`
}

func (m *SingleResourcePointV2Proto) Reset()         { *m = SingleResourcePointV2Proto{} }
func (m *SingleResourcePointV2Proto) String() string { return proto.CompactTextString(m) }
func (*SingleResourcePointV2Proto) ProtoMessage()    {}
func (*SingleResourcePointV2Proto) Descriptor() ([]byte, []int) {
	return fileDescriptorDomestic, []int{13}
}

func (m *SingleResourcePointV2Proto) GetResType() ResType {
	if m != nil {
		return m.ResType
	}
	return ResType_InvalidResType
}

func (m *SingleResourcePointV2Proto) GetOriginOutput() int32 {
	if m != nil {
		return m.OriginOutput
	}
	return 0
}

func (m *SingleResourcePointV2Proto) GetRealOutput() int32 {
	if m != nil {
		return m.RealOutput
	}
	return 0
}

type CityEventProto struct {
	// 城内事件接受次数
	AcceptTimes int32 `protobuf:"varint,1,opt,name=accept_times,json=acceptTimes,proto3" json:"accept_times,omitempty"`
	// 城内事件的时间
	CanExchangeTime int32 `protobuf:"varint,2,opt,name=can_exchange_time,json=canExchangeTime,proto3" json:"can_exchange_time,omitempty"`
	// 城内事件id,0表示没有事件
	EventId int32 `protobuf:"varint,3,opt,name=event_id,json=eventId,proto3" json:"event_id,omitempty"`
}

func (m *CityEventProto) Reset()                    { *m = CityEventProto{} }
func (m *CityEventProto) String() string            { return proto.CompactTextString(m) }
func (*CityEventProto) ProtoMessage()               {}
func (*CityEventProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{14} }

func (m *CityEventProto) GetAcceptTimes() int32 {
	if m != nil {
		return m.AcceptTimes
	}
	return 0
}

func (m *CityEventProto) GetCanExchangeTime() int32 {
	if m != nil {
		return m.CanExchangeTime
	}
	return 0
}

func (m *CityEventProto) GetEventId() int32 {
	if m != nil {
		return m.EventId
	}
	return 0
}

type CityEventDataProto struct {
	Id    int32             `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Desc  string            `protobuf:"bytes,2,opt,name=desc,proto3" json:"desc,omitempty"`
	Cost  *CombineCostProto `protobuf:"bytes,3,opt,name=cost" json:"cost,omitempty"`
	Prize *PrizeProto       `protobuf:"bytes,4,opt,name=prize" json:"prize,omitempty"`
}

func (m *CityEventDataProto) Reset()                    { *m = CityEventDataProto{} }
func (m *CityEventDataProto) String() string            { return proto.CompactTextString(m) }
func (*CityEventDataProto) ProtoMessage()               {}
func (*CityEventDataProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{15} }

func (m *CityEventDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CityEventDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *CityEventDataProto) GetCost() *CombineCostProto {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *CityEventDataProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

type CityEventMiscProto struct {
	MaxTimes        int32 `protobuf:"varint,1,opt,name=max_times,json=maxTimes,proto3" json:"max_times,omitempty"`
	RecoverDuration int32 `protobuf:"varint,2,opt,name=recover_duration,json=recoverDuration,proto3" json:"recover_duration,omitempty"`
	UnlockBaseLevel int32 `protobuf:"varint,3,opt,name=unlock_base_level,json=unlockBaseLevel,proto3" json:"unlock_base_level,omitempty"`
}

func (m *CityEventMiscProto) Reset()                    { *m = CityEventMiscProto{} }
func (m *CityEventMiscProto) String() string            { return proto.CompactTextString(m) }
func (*CityEventMiscProto) ProtoMessage()               {}
func (*CityEventMiscProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{16} }

func (m *CityEventMiscProto) GetMaxTimes() int32 {
	if m != nil {
		return m.MaxTimes
	}
	return 0
}

func (m *CityEventMiscProto) GetRecoverDuration() int32 {
	if m != nil {
		return m.RecoverDuration
	}
	return 0
}

func (m *CityEventMiscProto) GetUnlockBaseLevel() int32 {
	if m != nil {
		return m.UnlockBaseLevel
	}
	return 0
}

// 装备作坊刷新消耗
type WorkshopRefreshCostProto struct {
	Id   int32      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Cost *CostProto `protobuf:"bytes,2,opt,name=cost" json:"cost,omitempty"`
}

func (m *WorkshopRefreshCostProto) Reset()         { *m = WorkshopRefreshCostProto{} }
func (m *WorkshopRefreshCostProto) String() string { return proto.CompactTextString(m) }
func (*WorkshopRefreshCostProto) ProtoMessage()    {}
func (*WorkshopRefreshCostProto) Descriptor() ([]byte, []int) {
	return fileDescriptorDomestic, []int{17}
}

func (m *WorkshopRefreshCostProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *WorkshopRefreshCostProto) GetCost() *CostProto {
	if m != nil {
		return m.Cost
	}
	return nil
}

type StrategyDataProto struct {
	Id              int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type            int32  `protobuf:"varint,5,opt,name=type,proto3" json:"type,omitempty"`
	Target          int32  `protobuf:"varint,3,opt,name=target,proto3" json:"target,omitempty"`
	Name            string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Sp              int32  `protobuf:"varint,7,opt,name=sp,proto3" json:"sp,omitempty"`
	UnlockHeroLevel int32  `protobuf:"varint,8,opt,name=unlock_hero_level,json=unlockHeroLevel,proto3" json:"unlock_hero_level,omitempty"`
	Cd              int32  `protobuf:"varint,9,opt,name=cd,proto3" json:"cd,omitempty"`
	TodayLimit      int32  `protobuf:"varint,10,opt,name=today_limit,json=todayLimit,proto3" json:"today_limit,omitempty"`
	Icon            string `protobuf:"bytes,11,opt,name=icon,proto3" json:"icon,omitempty"`
	Desc            string `protobuf:"bytes,12,opt,name=desc,proto3" json:"desc,omitempty"`
}

func (m *StrategyDataProto) Reset()                    { *m = StrategyDataProto{} }
func (m *StrategyDataProto) String() string            { return proto.CompactTextString(m) }
func (*StrategyDataProto) ProtoMessage()               {}
func (*StrategyDataProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{18} }

func (m *StrategyDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StrategyDataProto) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *StrategyDataProto) GetTarget() int32 {
	if m != nil {
		return m.Target
	}
	return 0
}

func (m *StrategyDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StrategyDataProto) GetSp() int32 {
	if m != nil {
		return m.Sp
	}
	return 0
}

func (m *StrategyDataProto) GetUnlockHeroLevel() int32 {
	if m != nil {
		return m.UnlockHeroLevel
	}
	return 0
}

func (m *StrategyDataProto) GetCd() int32 {
	if m != nil {
		return m.Cd
	}
	return 0
}

func (m *StrategyDataProto) GetTodayLimit() int32 {
	if m != nil {
		return m.TodayLimit
	}
	return 0
}

func (m *StrategyDataProto) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *StrategyDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

type HeroResourcePointProto struct {
	LayoutId      int32 `protobuf:"varint,1,opt,name=layout_id,json=layoutId,proto3" json:"layout_id,omitempty"`
	BuildingId    int32 `protobuf:"varint,2,opt,name=building_id,json=buildingId,proto3" json:"building_id,omitempty"`
	OutputAmount  int32 `protobuf:"varint,3,opt,name=output_amount,json=outputAmount,proto3" json:"output_amount,omitempty"`
	OutputPerHour int32 `protobuf:"varint,4,opt,name=output_per_hour,json=outputPerHour,proto3" json:"output_per_hour,omitempty"`
	OutputCapcity int32 `protobuf:"varint,5,opt,name=output_capcity,json=outputCapcity,proto3" json:"output_capcity,omitempty"`
	// 资源点存在冲突，或者所需的主城等级不足，都不会产出资源
	Conflicted      bool `protobuf:"varint,6,opt,name=conflicted,proto3" json:"conflicted,omitempty"`
	BaseLevelLocked bool `protobuf:"varint,7,opt,name=base_level_locked,json=baseLevelLocked,proto3" json:"base_level_locked,omitempty"`
}

func (m *HeroResourcePointProto) Reset()                    { *m = HeroResourcePointProto{} }
func (m *HeroResourcePointProto) String() string            { return proto.CompactTextString(m) }
func (*HeroResourcePointProto) ProtoMessage()               {}
func (*HeroResourcePointProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{19} }

func (m *HeroResourcePointProto) GetLayoutId() int32 {
	if m != nil {
		return m.LayoutId
	}
	return 0
}

func (m *HeroResourcePointProto) GetBuildingId() int32 {
	if m != nil {
		return m.BuildingId
	}
	return 0
}

func (m *HeroResourcePointProto) GetOutputAmount() int32 {
	if m != nil {
		return m.OutputAmount
	}
	return 0
}

func (m *HeroResourcePointProto) GetOutputPerHour() int32 {
	if m != nil {
		return m.OutputPerHour
	}
	return 0
}

func (m *HeroResourcePointProto) GetOutputCapcity() int32 {
	if m != nil {
		return m.OutputCapcity
	}
	return 0
}

func (m *HeroResourcePointProto) GetConflicted() bool {
	if m != nil {
		return m.Conflicted
	}
	return false
}

func (m *HeroResourcePointProto) GetBaseLevelLocked() bool {
	if m != nil {
		return m.BaseLevelLocked
	}
	return false
}

type OuterCitiesProto struct {
	Cities []*OuterCityProto `protobuf:"bytes,1,rep,name=cities" json:"cities,omitempty"`
}

func (m *OuterCitiesProto) Reset()                    { *m = OuterCitiesProto{} }
func (m *OuterCitiesProto) String() string            { return proto.CompactTextString(m) }
func (*OuterCitiesProto) ProtoMessage()               {}
func (*OuterCitiesProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{20} }

func (m *OuterCitiesProto) GetCities() []*OuterCityProto {
	if m != nil {
		return m.Cities
	}
	return nil
}

type OuterCityProto struct {
	CityDataId int32   `protobuf:"varint,1,opt,name=city_data_id,json=cityDataId,proto3" json:"city_data_id,omitempty"`
	LayoutIds  []int32 `protobuf:"varint,2,rep,name=layout_ids,json=layoutIds" json:"layout_ids,omitempty"`
	CityType   int32   `protobuf:"varint,3,opt,name=city_type,json=cityType,proto3" json:"city_type,omitempty"`
}

func (m *OuterCityProto) Reset()                    { *m = OuterCityProto{} }
func (m *OuterCityProto) String() string            { return proto.CompactTextString(m) }
func (*OuterCityProto) ProtoMessage()               {}
func (*OuterCityProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{21} }

func (m *OuterCityProto) GetCityDataId() int32 {
	if m != nil {
		return m.CityDataId
	}
	return 0
}

func (m *OuterCityProto) GetLayoutIds() []int32 {
	if m != nil {
		return m.LayoutIds
	}
	return nil
}

func (m *OuterCityProto) GetCityType() int32 {
	if m != nil {
		return m.CityType
	}
	return 0
}

// 外城配置
type OuterCityDataProto struct {
	Id                    int32                             `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                  string                            `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Desc                  string                            `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	UnlockGuanFuLevel     int32                             `protobuf:"varint,4,opt,name=unlock_guan_fu_level,json=unlockGuanFuLevel,proto3" json:"unlock_guan_fu_level,omitempty"`
	LockIconId            string                            `protobuf:"bytes,5,opt,name=lock_icon_id,json=lockIconId,proto3" json:"lock_icon_id,omitempty"`
	UnlockIconId          string                            `protobuf:"bytes,6,opt,name=unlock_icon_id,json=unlockIconId,proto3" json:"unlock_icon_id,omitempty"`
	FirstLevelLayoutDatas []int32                           `protobuf:"varint,7,rep,name=first_level_layout_datas,json=firstLevelLayoutDatas" json:"first_level_layout_datas,omitempty"`
	Descs                 []*OuterCityBuildingDescDataProto `protobuf:"bytes,8,rep,name=descs" json:"descs,omitempty"`
	RegionModelRes        string                            `protobuf:"bytes,9,opt,name=region_model_res,json=regionModelRes,proto3" json:"region_model_res,omitempty"`
	UnlockBeforeImage     string                            `protobuf:"bytes,10,opt,name=unlock_before_image,json=unlockBeforeImage,proto3" json:"unlock_before_image,omitempty"`
	UnlockAfterImage      string                            `protobuf:"bytes,11,opt,name=unlock_after_image,json=unlockAfterImage,proto3" json:"unlock_after_image,omitempty"`
	UnlockDesc            []string                          `protobuf:"bytes,12,rep,name=unlock_desc,json=unlockDesc" json:"unlock_desc,omitempty"`
}

func (m *OuterCityDataProto) Reset()                    { *m = OuterCityDataProto{} }
func (m *OuterCityDataProto) String() string            { return proto.CompactTextString(m) }
func (*OuterCityDataProto) ProtoMessage()               {}
func (*OuterCityDataProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{22} }

func (m *OuterCityDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *OuterCityDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OuterCityDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *OuterCityDataProto) GetUnlockGuanFuLevel() int32 {
	if m != nil {
		return m.UnlockGuanFuLevel
	}
	return 0
}

func (m *OuterCityDataProto) GetLockIconId() string {
	if m != nil {
		return m.LockIconId
	}
	return ""
}

func (m *OuterCityDataProto) GetUnlockIconId() string {
	if m != nil {
		return m.UnlockIconId
	}
	return ""
}

func (m *OuterCityDataProto) GetFirstLevelLayoutDatas() []int32 {
	if m != nil {
		return m.FirstLevelLayoutDatas
	}
	return nil
}

func (m *OuterCityDataProto) GetDescs() []*OuterCityBuildingDescDataProto {
	if m != nil {
		return m.Descs
	}
	return nil
}

func (m *OuterCityDataProto) GetRegionModelRes() string {
	if m != nil {
		return m.RegionModelRes
	}
	return ""
}

func (m *OuterCityDataProto) GetUnlockBeforeImage() string {
	if m != nil {
		return m.UnlockBeforeImage
	}
	return ""
}

func (m *OuterCityDataProto) GetUnlockAfterImage() string {
	if m != nil {
		return m.UnlockAfterImage
	}
	return ""
}

func (m *OuterCityDataProto) GetUnlockDesc() []string {
	if m != nil {
		return m.UnlockDesc
	}
	return nil
}

type OuterCityBuildingDescDataProto struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	IconId string `protobuf:"bytes,2,opt,name=icon_id,json=iconId,proto3" json:"icon_id,omitempty"`
	Desc   string `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
}

func (m *OuterCityBuildingDescDataProto) Reset()         { *m = OuterCityBuildingDescDataProto{} }
func (m *OuterCityBuildingDescDataProto) String() string { return proto.CompactTextString(m) }
func (*OuterCityBuildingDescDataProto) ProtoMessage()    {}
func (*OuterCityBuildingDescDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorDomestic, []int{23}
}

func (m *OuterCityBuildingDescDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OuterCityBuildingDescDataProto) GetIconId() string {
	if m != nil {
		return m.IconId
	}
	return ""
}

func (m *OuterCityBuildingDescDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

type OuterCityLayoutDataProto struct {
	Id                     int32      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Layout                 int32      `protobuf:"varint,2,opt,name=layout,proto3" json:"layout,omitempty"`
	LockIconId             string     `protobuf:"bytes,3,opt,name=lock_icon_id,json=lockIconId,proto3" json:"lock_icon_id,omitempty"`
	UnlockIconId           string     `protobuf:"bytes,4,opt,name=unlock_icon_id,json=unlockIconId,proto3" json:"unlock_icon_id,omitempty"`
	BuildingId             int32      `protobuf:"varint,5,opt,name=building_id,json=buildingId,proto3" json:"building_id,omitempty"`
	UpgradeRequireLayoutId int32      `protobuf:"varint,6,opt,name=upgrade_require_layout_id,json=upgradeRequireLayoutId,proto3" json:"upgrade_require_layout_id,omitempty"`
	UpgradeRequireIds      []int32    `protobuf:"varint,7,rep,name=upgrade_require_ids,json=upgradeRequireIds" json:"upgrade_require_ids,omitempty"`
	NextLevel              int32      `protobuf:"varint,8,opt,name=next_level,json=nextLevel,proto3" json:"next_level,omitempty"`
	Desc                   string     `protobuf:"bytes,9,opt,name=desc,proto3" json:"desc,omitempty"`
	MilitaryBuilding       int32      `protobuf:"varint,10,opt,name=military_building,json=militaryBuilding,proto3" json:"military_building,omitempty"`
	EconomicBuilding       int32      `protobuf:"varint,11,opt,name=economic_building,json=economicBuilding,proto3" json:"economic_building,omitempty"`
	ChangeTypeCost         *CostProto `protobuf:"bytes,12,opt,name=change_type_cost,json=changeTypeCost" json:"change_type_cost,omitempty"`
}

func (m *OuterCityLayoutDataProto) Reset()         { *m = OuterCityLayoutDataProto{} }
func (m *OuterCityLayoutDataProto) String() string { return proto.CompactTextString(m) }
func (*OuterCityLayoutDataProto) ProtoMessage()    {}
func (*OuterCityLayoutDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorDomestic, []int{24}
}

func (m *OuterCityLayoutDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *OuterCityLayoutDataProto) GetLayout() int32 {
	if m != nil {
		return m.Layout
	}
	return 0
}

func (m *OuterCityLayoutDataProto) GetLockIconId() string {
	if m != nil {
		return m.LockIconId
	}
	return ""
}

func (m *OuterCityLayoutDataProto) GetUnlockIconId() string {
	if m != nil {
		return m.UnlockIconId
	}
	return ""
}

func (m *OuterCityLayoutDataProto) GetBuildingId() int32 {
	if m != nil {
		return m.BuildingId
	}
	return 0
}

func (m *OuterCityLayoutDataProto) GetUpgradeRequireLayoutId() int32 {
	if m != nil {
		return m.UpgradeRequireLayoutId
	}
	return 0
}

func (m *OuterCityLayoutDataProto) GetUpgradeRequireIds() []int32 {
	if m != nil {
		return m.UpgradeRequireIds
	}
	return nil
}

func (m *OuterCityLayoutDataProto) GetNextLevel() int32 {
	if m != nil {
		return m.NextLevel
	}
	return 0
}

func (m *OuterCityLayoutDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *OuterCityLayoutDataProto) GetMilitaryBuilding() int32 {
	if m != nil {
		return m.MilitaryBuilding
	}
	return 0
}

func (m *OuterCityLayoutDataProto) GetEconomicBuilding() int32 {
	if m != nil {
		return m.EconomicBuilding
	}
	return 0
}

func (m *OuterCityLayoutDataProto) GetChangeTypeCost() *CostProto {
	if m != nil {
		return m.ChangeTypeCost
	}
	return nil
}

func init() {
	proto.RegisterType((*HeroLevelProto)(nil), "proto.HeroLevelProto")
	proto.RegisterType((*BaseLevelProto)(nil), "proto.BaseLevelProto")
	proto.RegisterType((*BuildingLayoutProto)(nil), "proto.BuildingLayoutProto")
	proto.RegisterType((*BuildingDataProto)(nil), "proto.BuildingDataProto")
	proto.RegisterType((*BuildingUnlockDataProto)(nil), "proto.BuildingUnlockDataProto")
	proto.RegisterType((*DomesticEffectProto)(nil), "proto.DomesticEffectProto")
	proto.RegisterType((*GuanFuLevelProto)(nil), "proto.GuanFuLevelProto")
	proto.RegisterType((*TieJiangPuLevelProto)(nil), "proto.TieJiangPuLevelProto")
	proto.RegisterType((*TechnologyDataProto)(nil), "proto.TechnologyDataProto")
	proto.RegisterType((*CountdownPrizeDescDataProto)(nil), "proto.CountdownPrizeDescDataProto")
	proto.RegisterType((*HeroDomesticProto)(nil), "proto.HeroDomesticProto")
	proto.RegisterType((*HeroDomesticOtherProto)(nil), "proto.HeroDomesticOtherProto")
	proto.RegisterType((*ResourcePointV2Proto)(nil), "proto.ResourcePointV2Proto")
	proto.RegisterType((*SingleResourcePointV2Proto)(nil), "proto.SingleResourcePointV2Proto")
	proto.RegisterType((*CityEventProto)(nil), "proto.CityEventProto")
	proto.RegisterType((*CityEventDataProto)(nil), "proto.CityEventDataProto")
	proto.RegisterType((*CityEventMiscProto)(nil), "proto.CityEventMiscProto")
	proto.RegisterType((*WorkshopRefreshCostProto)(nil), "proto.WorkshopRefreshCostProto")
	proto.RegisterType((*StrategyDataProto)(nil), "proto.StrategyDataProto")
	proto.RegisterType((*HeroResourcePointProto)(nil), "proto.HeroResourcePointProto")
	proto.RegisterType((*OuterCitiesProto)(nil), "proto.OuterCitiesProto")
	proto.RegisterType((*OuterCityProto)(nil), "proto.OuterCityProto")
	proto.RegisterType((*OuterCityDataProto)(nil), "proto.OuterCityDataProto")
	proto.RegisterType((*OuterCityBuildingDescDataProto)(nil), "proto.OuterCityBuildingDescDataProto")
	proto.RegisterType((*OuterCityLayoutDataProto)(nil), "proto.OuterCityLayoutDataProto")
	proto.RegisterEnum("proto.BuildingType", BuildingType_name, BuildingType_value)
	proto.RegisterEnum("proto.TechType", TechType_name, TechType_value)
	proto.RegisterEnum("proto.StrategyEffectType", StrategyEffectType_name, StrategyEffectType_value)
}
func (m *HeroLevelProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroLevelProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Level))
	}
	if m.UpgradeExp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.UpgradeExp))
	}
	if m.TroopsCaptainCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.TroopsCaptainCount))
	}
	if m.EquipmentLevelLimit != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.EquipmentLevelLimit))
	}
	if m.CaptainLevelLimit != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.CaptainLevelLimit))
	}
	if m.CaptainCountLimit != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.CaptainCountLimit))
	}
	if len(m.UnlockedRaces) > 0 {
		for _, num := range m.UnlockedRaces {
			dAtA[i] = 0x78
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if len(m.CaptainTrainingLevel) > 0 {
		for _, num := range m.CaptainTrainingLevel {
			dAtA[i] = 0x80
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if len(m.CaptainTrainingLevelLimit) > 0 {
		for _, num := range m.CaptainTrainingLevelLimit {
			dAtA[i] = 0x88
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if m.StrategyLimit != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.StrategyLimit))
	}
	if m.CaptainSoulLevelLimit != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.CaptainSoulLevelLimit))
	}
	if m.AddSoldierCapacity != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.AddSoldierCapacity))
	}
	if m.TroopsCount != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.TroopsCount))
	}
	if len(m.CaptainOfficialId) > 0 {
		for _, num := range m.CaptainOfficialId {
			dAtA[i] = 0xc0
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if len(m.CaptainOfficialCount) > 0 {
		for _, num := range m.CaptainOfficialCount {
			dAtA[i] = 0xc8
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if m.SpLimit != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.SpLimit))
	}
	return i, nil
}

func (m *BaseLevelProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseLevelProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Level))
	}
	if m.UpgradeProsperity != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.UpgradeProsperity))
	}
	if m.UnlockGuanFuLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.UnlockGuanFuLevel))
	}
	if len(m.UnlockPowerRange) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.UnlockPowerRange)))
		i += copy(dAtA[i:], m.UnlockPowerRange)
	}
	if len(m.AppearanceRes) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.AppearanceRes)))
		i += copy(dAtA[i:], m.AppearanceRes)
	}
	return i, nil
}

func (m *BuildingLayoutProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildingLayoutProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Id))
	}
	if len(m.Building) > 0 {
		for _, num := range m.Building {
			dAtA[i] = 0x10
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if m.RequireBaseLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.RequireBaseLevel))
	}
	if m.RegionOffsetX != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDomestic(dAtA, i, uint64((uint32(m.RegionOffsetX)<<1)^uint32((m.RegionOffsetX>>31))))
	}
	if m.RegionOffsetY != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDomestic(dAtA, i, uint64((uint32(m.RegionOffsetY)<<1)^uint32((m.RegionOffsetY>>31))))
	}
	if m.IgnoreConflict {
		dAtA[i] = 0x30
		i++
		if m.IgnoreConflict {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *BuildingDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildingDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Type))
	}
	if m.Level != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Level))
	}
	if m.WorkTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.WorkTime))
	}
	if m.Prosperity != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Prosperity))
	}
	if m.HeroExp != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.HeroExp))
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.IconId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.IconId)))
		i += copy(dAtA[i:], m.IconId)
	}
	if len(m.Model) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Model)))
		i += copy(dAtA[i:], m.Model)
	}
	if len(m.EffectDesc) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.EffectDesc)))
		i += copy(dAtA[i:], m.EffectDesc)
	}
	if m.Effect != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Effect.Size()))
		n1, err := m.Effect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Notice) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Notice)))
		i += copy(dAtA[i:], m.Notice)
	}
	if len(m.Tips) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Tips)))
		i += copy(dAtA[i:], m.Tips)
	}
	if m.Cost != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Cost.Size()))
		n2, err := m.Cost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.RequireIds) > 0 {
		for _, num := range m.RequireIds {
			dAtA[i] = 0xb0
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if m.BaseLevel != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.BaseLevel))
	}
	return i, nil
}

func (m *BuildingUnlockDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildingUnlockDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BuildingType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.BuildingType))
	}
	if m.GuanFuLevel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.GuanFuLevel))
	}
	if m.HeroLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.HeroLevel))
	}
	if m.MainTaskSequence != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.MainTaskSequence))
	}
	if m.BaYeStage != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.BaYeStage))
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if m.NotifyOrder != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.NotifyOrder))
	}
	return i, nil
}

func (m *DomesticEffectProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomesticEffectProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BuildingWorkerCoef != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.BuildingWorkerCoef))
	}
	if m.TechWorkerCoef != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.TechWorkerCoef))
	}
	if m.BuildingWorkerFatigueDuration != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.BuildingWorkerFatigueDuration))
	}
	if m.TechWorkerFatigueDuration != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.TechWorkerFatigueDuration))
	}
	if m.SeekHelpCdr != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.SeekHelpCdr))
	}
	if m.SeekHelpMaxTimes != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.SeekHelpMaxTimes))
	}
	if m.GuildDonateTimes != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.GuildDonateTimes))
	}
	if m.SoldierCapcity != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.SoldierCapcity))
	}
	if m.NewSoldierOutput != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.NewSoldierOutput))
	}
	if m.NewSoldierCapcity != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.NewSoldierCapcity))
	}
	if m.WoundedSoldierCapcity != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.WoundedSoldierCapcity))
	}
	if m.SoldierLoad != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.SoldierLoad))
	}
	if len(m.SoldierRace) > 0 {
		for _, num := range m.SoldierRace {
			dAtA[i] = 0xc0
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if m.SoldierStat != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.SoldierStat.Size()))
		n3, err := m.SoldierStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.TrainOutput != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.TrainOutput))
	}
	if m.TrainCapcity != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.TrainCapcity))
	}
	if m.TentProsperityCapcity != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.TentProsperityCapcity))
	}
	if m.HomeWallStat != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.HomeWallStat.Size()))
		n4, err := m.HomeWallStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.TentWallStat != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.TentWallStat.Size()))
		n5, err := m.TentWallStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.TrainExpPerHour != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.TrainExpPerHour))
	}
	if m.RecruitSoldierCount != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.RecruitSoldierCount))
	}
	if m.TrainCoef != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.TrainCoef))
	}
	if m.FarStat != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.FarStat.Size()))
		n6, err := m.FarStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.CloseStat != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.CloseStat.Size()))
		n7, err := m.CloseStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.AllSoldierStat != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.AllSoldierStat.Size()))
		n8, err := m.AllSoldierStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.HomeWallFixDamage != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.HomeWallFixDamage))
	}
	if m.TentWallFixDamage != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.TentWallFixDamage))
	}
	if m.SoldierOutput != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.SoldierOutput))
	}
	if m.ForceSoldier != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.ForceSoldier))
	}
	if len(m.Capcity) > 0 {
		for _, msg := range m.Capcity {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ProtectedCapcity != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.ProtectedCapcity.Size()))
		n9, err := m.ProtectedCapcity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Output != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Output.Size()))
		n10, err := m.Output.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.OutputCapcity != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.OutputCapcity.Size()))
		n11, err := m.OutputCapcity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.OutputType != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.OutputType))
	}
	if m.FarmOutputType != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.FarmOutputType))
	}
	if m.FarmOutput != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.FarmOutput.Size()))
		n12, err := m.FarmOutput.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Tax) > 0 {
		for _, msg := range m.Tax {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AddedDefenseStat != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.AddedDefenseStat.Size()))
		n13, err := m.AddedDefenseStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.AddedAssistStat != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.AddedAssistStat.Size()))
		n14, err := m.AddedAssistStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.BuildingCostReduceCoef != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.BuildingCostReduceCoef))
	}
	if m.TechCostReduceCoef != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.TechCostReduceCoef))
	}
	if m.AddedCopyDefenseStat != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.AddedCopyDefenseStat.Size()))
		n15, err := m.AddedCopyDefenseStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *GuanFuLevelProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuanFuLevelProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Level))
	}
	if m.MoveBaseRestoreHomeProsperity != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.MoveBaseRestoreHomeProsperity))
	}
	if m.BuyProsperityRestoreDurationWith1Yuanbao != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.BuyProsperityRestoreDurationWith1Yuanbao))
	}
	if m.BuyProsperityRestoreDurationWith1Cost != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.BuyProsperityRestoreDurationWith1Cost))
	}
	if m.RestoreProsperity != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.RestoreProsperity))
	}
	if m.MoveBaseRestoreHomeProsperityDuration != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.MoveBaseRestoreHomeProsperityDuration))
	}
	if m.WorkshopPrize != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.WorkshopPrize.Size()))
		n16, err := m.WorkshopPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *TieJiangPuLevelProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TieJiangPuLevelProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Level))
	}
	if m.MaxForgingTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.MaxForgingTimes))
	}
	if m.RecoveryForgingDuration != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.RecoveryForgingDuration))
	}
	if len(m.CanForgingEquipPos) > 0 {
		for _, num := range m.CanForgingEquipPos {
			dAtA[i] = 0x20
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if len(m.CanForgingEquip) > 0 {
		for _, num := range m.CanForgingEquip {
			dAtA[i] = 0x28
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if len(m.LockedCanForgingEquipPos) > 0 {
		for _, num := range m.LockedCanForgingEquipPos {
			dAtA[i] = 0x30
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if len(m.LockedCanForgingEquip) > 0 {
		for _, num := range m.LockedCanForgingEquip {
			dAtA[i] = 0x38
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if len(m.LockedEquipNeedLevel) > 0 {
		for _, num := range m.LockedEquipNeedLevel {
			dAtA[i] = 0x40
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if m.CanOneKeyForging {
		dAtA[i] = 0x48
		i++
		if m.CanOneKeyForging {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *TechnologyDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TechnologyDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Type))
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if m.Group != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Group))
	}
	if m.Level != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Level))
	}
	if m.Effect != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Effect.Size()))
		n17, err := m.Effect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.Sequence != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Sequence))
	}
	if m.IntIcon != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.IntIcon))
	}
	if len(m.RequireBuildingIds) > 0 {
		for _, num := range m.RequireBuildingIds {
			dAtA[i] = 0x58
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if len(m.RequireTechIds) > 0 {
		for _, num := range m.RequireTechIds {
			dAtA[i] = 0x60
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if m.IsBigTech {
		dAtA[i] = 0x68
		i++
		if m.IsBigTech {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Cost != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Cost.Size()))
		n18, err := m.Cost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.WorkTime != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.WorkTime))
	}
	if m.NextLevelId != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.NextLevelId))
	}
	if m.MaxLevel != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.MaxLevel))
	}
	return i, nil
}

func (m *CountdownPrizeDescDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountdownPrizeDescDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Id))
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	return i, nil
}

func (m *HeroDomesticProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroDomesticProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gold != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Gold))
	}
	if m.Food != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Food))
	}
	if m.Wood != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Wood))
	}
	if m.Stone != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Stone))
	}
	if m.GoldCapcity != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.GoldCapcity))
	}
	if m.FoodCapcity != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.FoodCapcity))
	}
	if m.WoodCapcity != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.WoodCapcity))
	}
	if m.StoneCapcity != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.StoneCapcity))
	}
	if m.SafeGold != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.SafeGold))
	}
	if m.SafeFood != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.SafeFood))
	}
	if m.SafeWood != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.SafeWood))
	}
	if m.SafeStone != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.SafeStone))
	}
	if m.ProtectedCapcity != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.ProtectedCapcity))
	}
	if len(m.WorkerRestEndTime) > 0 {
		for _, num := range m.WorkerRestEndTime {
			dAtA[i] = 0x80
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if len(m.ResourceBuilding) > 0 {
		for _, msg := range m.ResourceBuilding {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Building) > 0 {
		for _, num := range m.Building {
			dAtA[i] = 0x90
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if len(m.ResourcePoint) > 0 {
		for _, msg := range m.ResourcePoint {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Cities != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Cities.Size()))
		n19, err := m.Cities.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.Technology) > 0 {
		for _, num := range m.Technology {
			dAtA[i] = 0xa8
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if len(m.TechnologyRestEndTime) > 0 {
		for _, num := range m.TechnologyRestEndTime {
			dAtA[i] = 0xb0
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if m.Prosperity != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Prosperity))
	}
	if m.MaxProsperity != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.MaxProsperity))
	}
	if m.LostProsperity != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.LostProsperity))
	}
	if m.BuildingWorkerCoef != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.BuildingWorkerCoef))
	}
	if m.TechWorkerCoef != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.TechWorkerCoef))
	}
	if m.BuildingWorkerFatigueDuration != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.BuildingWorkerFatigueDuration))
	}
	if m.TechWorkerFatigueDuration != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.TechWorkerFatigueDuration))
	}
	if m.ForgingTimes != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.ForgingTimes))
	}
	if m.ForgingNextTime != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.ForgingNextTime))
	}
	if len(m.NextCollectTimeType) > 0 {
		for _, num := range m.NextCollectTimeType {
			dAtA[i] = 0xa8
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if len(m.NextCollectTime) > 0 {
		for _, num := range m.NextCollectTime {
			dAtA[i] = 0xb0
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if m.DailyResourceCollectTimes != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.DailyResourceCollectTimes))
	}
	if m.CityEvent != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.CityEvent.Size()))
		n20, err := m.CityEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.Sign) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Sign)))
		i += copy(dAtA[i:], m.Sign)
	}
	if len(m.Voice) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Voice)))
		i += copy(dAtA[i:], m.Voice)
	}
	if m.ResourcePointV2 != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.ResourcePointV2.Size()))
		n21, err := m.ResourcePointV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Jade != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Jade))
	}
	if m.JadeOre != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.JadeOre))
	}
	if len(m.NewForgingPos) > 0 {
		for _, num := range m.NewForgingPos {
			dAtA[i] = 0xf0
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if m.HistoryJade != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.HistoryJade))
	}
	if m.TodayObtainJade != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.TodayObtainJade))
	}
	if len(m.WorkerSeekHelp) > 0 {
		for _, b := range m.WorkerSeekHelp {
			dAtA[i] = 0x98
			i++
			dAtA[i] = 0x3
			i++
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.TechnologySeekHelp) > 0 {
		for _, b := range m.TechnologySeekHelp {
			dAtA[i] = 0xa0
			i++
			dAtA[i] = 0x3
			i++
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if m.DailyHelpMemberTimes != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.DailyHelpMemberTimes))
	}
	if m.CountdownCollectTime != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.CountdownCollectTime))
	}
	if m.IsCollectSeasonPrize {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x3
		i++
		if m.IsCollectSeasonPrize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WorkshopCollectTime != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.WorkshopCollectTime))
	}
	if m.BuildingCostReduceCoef != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.BuildingCostReduceCoef))
	}
	if m.TechCostReduceCoef != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.TechCostReduceCoef))
	}
	if len(m.WorkerAlwaysUnlocked) > 0 {
		for _, b := range m.WorkerAlwaysUnlocked {
			dAtA[i] = 0xe8
			i++
			dAtA[i] = 0x3
			i++
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.WorkerLockStartTime) > 0 {
		for _, num := range m.WorkerLockStartTime {
			dAtA[i] = 0xf0
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *HeroDomesticOtherProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroDomesticOtherProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Prosperity != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Prosperity))
	}
	if m.MaxProsperity != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.MaxProsperity))
	}
	if m.LostProsperity != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.LostProsperity))
	}
	if len(m.Sign) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Sign)))
		i += copy(dAtA[i:], m.Sign)
	}
	if len(m.Voice) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Voice)))
		i += copy(dAtA[i:], m.Voice)
	}
	return i, nil
}

func (m *ResourcePointV2Proto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourcePointV2Proto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResourcePoint) > 0 {
		for _, msg := range m.ResourcePoint {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ResCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.ResCount))
	}
	if m.ConflictResCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.ConflictResCount))
	}
	return i, nil
}

func (m *SingleResourcePointV2Proto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SingleResourcePointV2Proto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.ResType))
	}
	if m.OriginOutput != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.OriginOutput))
	}
	if m.RealOutput != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.RealOutput))
	}
	return i, nil
}

func (m *CityEventProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CityEventProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AcceptTimes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.AcceptTimes))
	}
	if m.CanExchangeTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.CanExchangeTime))
	}
	if m.EventId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.EventId))
	}
	return i, nil
}

func (m *CityEventDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CityEventDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Id))
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.Cost != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Cost.Size()))
		n22, err := m.Cost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Prize != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Prize.Size()))
		n23, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *CityEventMiscProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CityEventMiscProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxTimes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.MaxTimes))
	}
	if m.RecoverDuration != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.RecoverDuration))
	}
	if m.UnlockBaseLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.UnlockBaseLevel))
	}
	return i, nil
}

func (m *WorkshopRefreshCostProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkshopRefreshCostProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Id))
	}
	if m.Cost != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Cost.Size()))
		n24, err := m.Cost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *StrategyDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StrategyDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Target != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Target))
	}
	if m.Type != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Type))
	}
	if m.Sp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Sp))
	}
	if m.UnlockHeroLevel != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.UnlockHeroLevel))
	}
	if m.Cd != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Cd))
	}
	if m.TodayLimit != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.TodayLimit))
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	return i, nil
}

func (m *HeroResourcePointProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroResourcePointProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LayoutId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.LayoutId))
	}
	if m.BuildingId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.BuildingId))
	}
	if m.OutputAmount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.OutputAmount))
	}
	if m.OutputPerHour != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.OutputPerHour))
	}
	if m.OutputCapcity != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.OutputCapcity))
	}
	if m.Conflicted {
		dAtA[i] = 0x30
		i++
		if m.Conflicted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BaseLevelLocked {
		dAtA[i] = 0x38
		i++
		if m.BaseLevelLocked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *OuterCitiesProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OuterCitiesProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cities) > 0 {
		for _, msg := range m.Cities {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *OuterCityProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OuterCityProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CityDataId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.CityDataId))
	}
	if len(m.LayoutIds) > 0 {
		for _, num := range m.LayoutIds {
			dAtA[i] = 0x10
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if m.CityType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.CityType))
	}
	return i, nil
}

func (m *OuterCityDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OuterCityDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.UnlockGuanFuLevel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.UnlockGuanFuLevel))
	}
	if len(m.LockIconId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.LockIconId)))
		i += copy(dAtA[i:], m.LockIconId)
	}
	if len(m.UnlockIconId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.UnlockIconId)))
		i += copy(dAtA[i:], m.UnlockIconId)
	}
	if len(m.FirstLevelLayoutDatas) > 0 {
		for _, num := range m.FirstLevelLayoutDatas {
			dAtA[i] = 0x38
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if len(m.Descs) > 0 {
		for _, msg := range m.Descs {
			dAtA[i] = 0x42
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RegionModelRes) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.RegionModelRes)))
		i += copy(dAtA[i:], m.RegionModelRes)
	}
	if len(m.UnlockBeforeImage) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.UnlockBeforeImage)))
		i += copy(dAtA[i:], m.UnlockBeforeImage)
	}
	if len(m.UnlockAfterImage) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.UnlockAfterImage)))
		i += copy(dAtA[i:], m.UnlockAfterImage)
	}
	if len(m.UnlockDesc) > 0 {
		for _, s := range m.UnlockDesc {
			dAtA[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *OuterCityBuildingDescDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OuterCityBuildingDescDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.IconId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.IconId)))
		i += copy(dAtA[i:], m.IconId)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	return i, nil
}

func (m *OuterCityLayoutDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OuterCityLayoutDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Id))
	}
	if m.Layout != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Layout))
	}
	if len(m.LockIconId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.LockIconId)))
		i += copy(dAtA[i:], m.LockIconId)
	}
	if len(m.UnlockIconId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.UnlockIconId)))
		i += copy(dAtA[i:], m.UnlockIconId)
	}
	if m.BuildingId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.BuildingId))
	}
	if m.UpgradeRequireLayoutId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.UpgradeRequireLayoutId))
	}
	if len(m.UpgradeRequireIds) > 0 {
		for _, num := range m.UpgradeRequireIds {
			dAtA[i] = 0x38
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(num))
		}
	}
	if m.NextLevel != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.NextLevel))
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.MilitaryBuilding != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.MilitaryBuilding))
	}
	if m.EconomicBuilding != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.EconomicBuilding))
	}
	if m.ChangeTypeCost != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.ChangeTypeCost.Size()))
		n25, err := m.ChangeTypeCost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func encodeFixed64Domestic(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Domestic(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintDomestic(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HeroLevelProto) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovDomestic(uint64(m.Level))
	}
	if m.UpgradeExp != 0 {
		n += 1 + sovDomestic(uint64(m.UpgradeExp))
	}
	if m.TroopsCaptainCount != 0 {
		n += 1 + sovDomestic(uint64(m.TroopsCaptainCount))
	}
	if m.EquipmentLevelLimit != 0 {
		n += 1 + sovDomestic(uint64(m.EquipmentLevelLimit))
	}
	if m.CaptainLevelLimit != 0 {
		n += 1 + sovDomestic(uint64(m.CaptainLevelLimit))
	}
	if m.CaptainCountLimit != 0 {
		n += 1 + sovDomestic(uint64(m.CaptainCountLimit))
	}
	if len(m.UnlockedRaces) > 0 {
		for _, e := range m.UnlockedRaces {
			n += 1 + sovDomestic(uint64(e))
		}
	}
	if len(m.CaptainTrainingLevel) > 0 {
		for _, e := range m.CaptainTrainingLevel {
			n += 2 + sovDomestic(uint64(e))
		}
	}
	if len(m.CaptainTrainingLevelLimit) > 0 {
		for _, e := range m.CaptainTrainingLevelLimit {
			n += 2 + sovDomestic(uint64(e))
		}
	}
	if m.StrategyLimit != 0 {
		n += 2 + sovDomestic(uint64(m.StrategyLimit))
	}
	if m.CaptainSoulLevelLimit != 0 {
		n += 2 + sovDomestic(uint64(m.CaptainSoulLevelLimit))
	}
	if m.AddSoldierCapacity != 0 {
		n += 2 + sovDomestic(uint64(m.AddSoldierCapacity))
	}
	if m.TroopsCount != 0 {
		n += 2 + sovDomestic(uint64(m.TroopsCount))
	}
	if len(m.CaptainOfficialId) > 0 {
		for _, e := range m.CaptainOfficialId {
			n += 2 + sovDomestic(uint64(e))
		}
	}
	if len(m.CaptainOfficialCount) > 0 {
		for _, e := range m.CaptainOfficialCount {
			n += 2 + sovDomestic(uint64(e))
		}
	}
	if m.SpLimit != 0 {
		n += 2 + sovDomestic(uint64(m.SpLimit))
	}
	return n
}

func (m *BaseLevelProto) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovDomestic(uint64(m.Level))
	}
	if m.UpgradeProsperity != 0 {
		n += 1 + sovDomestic(uint64(m.UpgradeProsperity))
	}
	if m.UnlockGuanFuLevel != 0 {
		n += 1 + sovDomestic(uint64(m.UnlockGuanFuLevel))
	}
	l = len(m.UnlockPowerRange)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	l = len(m.AppearanceRes)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	return n
}

func (m *BuildingLayoutProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDomestic(uint64(m.Id))
	}
	if len(m.Building) > 0 {
		for _, e := range m.Building {
			n += 1 + sovDomestic(uint64(e))
		}
	}
	if m.RequireBaseLevel != 0 {
		n += 1 + sovDomestic(uint64(m.RequireBaseLevel))
	}
	if m.RegionOffsetX != 0 {
		n += 1 + sozDomestic(uint64(m.RegionOffsetX))
	}
	if m.RegionOffsetY != 0 {
		n += 1 + sozDomestic(uint64(m.RegionOffsetY))
	}
	if m.IgnoreConflict {
		n += 2
	}
	return n
}

func (m *BuildingDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDomestic(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovDomestic(uint64(m.Type))
	}
	if m.Level != 0 {
		n += 1 + sovDomestic(uint64(m.Level))
	}
	if m.WorkTime != 0 {
		n += 1 + sovDomestic(uint64(m.WorkTime))
	}
	if m.Prosperity != 0 {
		n += 1 + sovDomestic(uint64(m.Prosperity))
	}
	if m.HeroExp != 0 {
		n += 1 + sovDomestic(uint64(m.HeroExp))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	l = len(m.IconId)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	l = len(m.EffectDesc)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	if m.Effect != nil {
		l = m.Effect.Size()
		n += 1 + l + sovDomestic(uint64(l))
	}
	l = len(m.Notice)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	l = len(m.Tips)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	if m.Cost != nil {
		l = m.Cost.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if len(m.RequireIds) > 0 {
		for _, e := range m.RequireIds {
			n += 2 + sovDomestic(uint64(e))
		}
	}
	if m.BaseLevel != 0 {
		n += 2 + sovDomestic(uint64(m.BaseLevel))
	}
	return n
}

func (m *BuildingUnlockDataProto) Size() (n int) {
	var l int
	_ = l
	if m.BuildingType != 0 {
		n += 1 + sovDomestic(uint64(m.BuildingType))
	}
	if m.GuanFuLevel != 0 {
		n += 1 + sovDomestic(uint64(m.GuanFuLevel))
	}
	if m.HeroLevel != 0 {
		n += 1 + sovDomestic(uint64(m.HeroLevel))
	}
	if m.MainTaskSequence != 0 {
		n += 1 + sovDomestic(uint64(m.MainTaskSequence))
	}
	if m.BaYeStage != 0 {
		n += 1 + sovDomestic(uint64(m.BaYeStage))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	if m.NotifyOrder != 0 {
		n += 1 + sovDomestic(uint64(m.NotifyOrder))
	}
	return n
}

func (m *DomesticEffectProto) Size() (n int) {
	var l int
	_ = l
	if m.BuildingWorkerCoef != 0 {
		n += 1 + sovDomestic(uint64(m.BuildingWorkerCoef))
	}
	if m.TechWorkerCoef != 0 {
		n += 1 + sovDomestic(uint64(m.TechWorkerCoef))
	}
	if m.BuildingWorkerFatigueDuration != 0 {
		n += 1 + sovDomestic(uint64(m.BuildingWorkerFatigueDuration))
	}
	if m.TechWorkerFatigueDuration != 0 {
		n += 1 + sovDomestic(uint64(m.TechWorkerFatigueDuration))
	}
	if m.SeekHelpCdr != 0 {
		n += 2 + sovDomestic(uint64(m.SeekHelpCdr))
	}
	if m.SeekHelpMaxTimes != 0 {
		n += 2 + sovDomestic(uint64(m.SeekHelpMaxTimes))
	}
	if m.GuildDonateTimes != 0 {
		n += 2 + sovDomestic(uint64(m.GuildDonateTimes))
	}
	if m.SoldierCapcity != 0 {
		n += 2 + sovDomestic(uint64(m.SoldierCapcity))
	}
	if m.NewSoldierOutput != 0 {
		n += 2 + sovDomestic(uint64(m.NewSoldierOutput))
	}
	if m.NewSoldierCapcity != 0 {
		n += 2 + sovDomestic(uint64(m.NewSoldierCapcity))
	}
	if m.WoundedSoldierCapcity != 0 {
		n += 2 + sovDomestic(uint64(m.WoundedSoldierCapcity))
	}
	if m.SoldierLoad != 0 {
		n += 2 + sovDomestic(uint64(m.SoldierLoad))
	}
	if len(m.SoldierRace) > 0 {
		for _, e := range m.SoldierRace {
			n += 2 + sovDomestic(uint64(e))
		}
	}
	if m.SoldierStat != nil {
		l = m.SoldierStat.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if m.TrainOutput != 0 {
		n += 2 + sovDomestic(uint64(m.TrainOutput))
	}
	if m.TrainCapcity != 0 {
		n += 2 + sovDomestic(uint64(m.TrainCapcity))
	}
	if m.TentProsperityCapcity != 0 {
		n += 2 + sovDomestic(uint64(m.TentProsperityCapcity))
	}
	if m.HomeWallStat != nil {
		l = m.HomeWallStat.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if m.TentWallStat != nil {
		l = m.TentWallStat.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if m.TrainExpPerHour != 0 {
		n += 2 + sovDomestic(uint64(m.TrainExpPerHour))
	}
	if m.RecruitSoldierCount != 0 {
		n += 2 + sovDomestic(uint64(m.RecruitSoldierCount))
	}
	if m.TrainCoef != 0 {
		n += 2 + sovDomestic(uint64(m.TrainCoef))
	}
	if m.FarStat != nil {
		l = m.FarStat.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if m.CloseStat != nil {
		l = m.CloseStat.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if m.AllSoldierStat != nil {
		l = m.AllSoldierStat.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if m.HomeWallFixDamage != 0 {
		n += 2 + sovDomestic(uint64(m.HomeWallFixDamage))
	}
	if m.TentWallFixDamage != 0 {
		n += 2 + sovDomestic(uint64(m.TentWallFixDamage))
	}
	if m.SoldierOutput != 0 {
		n += 2 + sovDomestic(uint64(m.SoldierOutput))
	}
	if m.ForceSoldier != 0 {
		n += 2 + sovDomestic(uint64(m.ForceSoldier))
	}
	if len(m.Capcity) > 0 {
		for _, e := range m.Capcity {
			l = e.Size()
			n += 2 + l + sovDomestic(uint64(l))
		}
	}
	if m.ProtectedCapcity != nil {
		l = m.ProtectedCapcity.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if m.Output != nil {
		l = m.Output.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if m.OutputCapcity != nil {
		l = m.OutputCapcity.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if m.OutputType != 0 {
		n += 2 + sovDomestic(uint64(m.OutputType))
	}
	if m.FarmOutputType != 0 {
		n += 2 + sovDomestic(uint64(m.FarmOutputType))
	}
	if m.FarmOutput != nil {
		l = m.FarmOutput.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if len(m.Tax) > 0 {
		for _, e := range m.Tax {
			l = e.Size()
			n += 2 + l + sovDomestic(uint64(l))
		}
	}
	if m.AddedDefenseStat != nil {
		l = m.AddedDefenseStat.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if m.AddedAssistStat != nil {
		l = m.AddedAssistStat.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if m.BuildingCostReduceCoef != 0 {
		n += 2 + sovDomestic(uint64(m.BuildingCostReduceCoef))
	}
	if m.TechCostReduceCoef != 0 {
		n += 2 + sovDomestic(uint64(m.TechCostReduceCoef))
	}
	if m.AddedCopyDefenseStat != nil {
		l = m.AddedCopyDefenseStat.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	return n
}

func (m *GuanFuLevelProto) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovDomestic(uint64(m.Level))
	}
	if m.MoveBaseRestoreHomeProsperity != 0 {
		n += 1 + sovDomestic(uint64(m.MoveBaseRestoreHomeProsperity))
	}
	if m.BuyProsperityRestoreDurationWith1Yuanbao != 0 {
		n += 1 + sovDomestic(uint64(m.BuyProsperityRestoreDurationWith1Yuanbao))
	}
	if m.BuyProsperityRestoreDurationWith1Cost != 0 {
		n += 1 + sovDomestic(uint64(m.BuyProsperityRestoreDurationWith1Cost))
	}
	if m.RestoreProsperity != 0 {
		n += 1 + sovDomestic(uint64(m.RestoreProsperity))
	}
	if m.MoveBaseRestoreHomeProsperityDuration != 0 {
		n += 1 + sovDomestic(uint64(m.MoveBaseRestoreHomeProsperityDuration))
	}
	if m.WorkshopPrize != nil {
		l = m.WorkshopPrize.Size()
		n += 1 + l + sovDomestic(uint64(l))
	}
	return n
}

func (m *TieJiangPuLevelProto) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovDomestic(uint64(m.Level))
	}
	if m.MaxForgingTimes != 0 {
		n += 1 + sovDomestic(uint64(m.MaxForgingTimes))
	}
	if m.RecoveryForgingDuration != 0 {
		n += 1 + sovDomestic(uint64(m.RecoveryForgingDuration))
	}
	if len(m.CanForgingEquipPos) > 0 {
		for _, e := range m.CanForgingEquipPos {
			n += 1 + sovDomestic(uint64(e))
		}
	}
	if len(m.CanForgingEquip) > 0 {
		for _, e := range m.CanForgingEquip {
			n += 1 + sovDomestic(uint64(e))
		}
	}
	if len(m.LockedCanForgingEquipPos) > 0 {
		for _, e := range m.LockedCanForgingEquipPos {
			n += 1 + sovDomestic(uint64(e))
		}
	}
	if len(m.LockedCanForgingEquip) > 0 {
		for _, e := range m.LockedCanForgingEquip {
			n += 1 + sovDomestic(uint64(e))
		}
	}
	if len(m.LockedEquipNeedLevel) > 0 {
		for _, e := range m.LockedEquipNeedLevel {
			n += 1 + sovDomestic(uint64(e))
		}
	}
	if m.CanOneKeyForging {
		n += 2
	}
	return n
}

func (m *TechnologyDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDomestic(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovDomestic(uint64(m.Type))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	if m.Group != 0 {
		n += 1 + sovDomestic(uint64(m.Group))
	}
	if m.Level != 0 {
		n += 1 + sovDomestic(uint64(m.Level))
	}
	if m.Effect != nil {
		l = m.Effect.Size()
		n += 1 + l + sovDomestic(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovDomestic(uint64(m.Sequence))
	}
	if m.IntIcon != 0 {
		n += 1 + sovDomestic(uint64(m.IntIcon))
	}
	if len(m.RequireBuildingIds) > 0 {
		for _, e := range m.RequireBuildingIds {
			n += 1 + sovDomestic(uint64(e))
		}
	}
	if len(m.RequireTechIds) > 0 {
		for _, e := range m.RequireTechIds {
			n += 1 + sovDomestic(uint64(e))
		}
	}
	if m.IsBigTech {
		n += 2
	}
	if m.Cost != nil {
		l = m.Cost.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if m.WorkTime != 0 {
		n += 2 + sovDomestic(uint64(m.WorkTime))
	}
	if m.NextLevelId != 0 {
		n += 2 + sovDomestic(uint64(m.NextLevelId))
	}
	if m.MaxLevel != 0 {
		n += 2 + sovDomestic(uint64(m.MaxLevel))
	}
	return n
}

func (m *CountdownPrizeDescDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDomestic(uint64(m.Id))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	return n
}

func (m *HeroDomesticProto) Size() (n int) {
	var l int
	_ = l
	if m.Gold != 0 {
		n += 1 + sovDomestic(uint64(m.Gold))
	}
	if m.Food != 0 {
		n += 1 + sovDomestic(uint64(m.Food))
	}
	if m.Wood != 0 {
		n += 1 + sovDomestic(uint64(m.Wood))
	}
	if m.Stone != 0 {
		n += 1 + sovDomestic(uint64(m.Stone))
	}
	if m.GoldCapcity != 0 {
		n += 1 + sovDomestic(uint64(m.GoldCapcity))
	}
	if m.FoodCapcity != 0 {
		n += 1 + sovDomestic(uint64(m.FoodCapcity))
	}
	if m.WoodCapcity != 0 {
		n += 1 + sovDomestic(uint64(m.WoodCapcity))
	}
	if m.StoneCapcity != 0 {
		n += 1 + sovDomestic(uint64(m.StoneCapcity))
	}
	if m.SafeGold != 0 {
		n += 1 + sovDomestic(uint64(m.SafeGold))
	}
	if m.SafeFood != 0 {
		n += 1 + sovDomestic(uint64(m.SafeFood))
	}
	if m.SafeWood != 0 {
		n += 1 + sovDomestic(uint64(m.SafeWood))
	}
	if m.SafeStone != 0 {
		n += 1 + sovDomestic(uint64(m.SafeStone))
	}
	if m.ProtectedCapcity != 0 {
		n += 1 + sovDomestic(uint64(m.ProtectedCapcity))
	}
	if len(m.WorkerRestEndTime) > 0 {
		for _, e := range m.WorkerRestEndTime {
			n += 2 + sovDomestic(uint64(e))
		}
	}
	if len(m.ResourceBuilding) > 0 {
		for _, e := range m.ResourceBuilding {
			l = e.Size()
			n += 2 + l + sovDomestic(uint64(l))
		}
	}
	if len(m.Building) > 0 {
		for _, e := range m.Building {
			n += 2 + sovDomestic(uint64(e))
		}
	}
	if len(m.ResourcePoint) > 0 {
		for _, e := range m.ResourcePoint {
			l = e.Size()
			n += 2 + l + sovDomestic(uint64(l))
		}
	}
	if m.Cities != nil {
		l = m.Cities.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if len(m.Technology) > 0 {
		for _, e := range m.Technology {
			n += 2 + sovDomestic(uint64(e))
		}
	}
	if len(m.TechnologyRestEndTime) > 0 {
		for _, e := range m.TechnologyRestEndTime {
			n += 2 + sovDomestic(uint64(e))
		}
	}
	if m.Prosperity != 0 {
		n += 2 + sovDomestic(uint64(m.Prosperity))
	}
	if m.MaxProsperity != 0 {
		n += 2 + sovDomestic(uint64(m.MaxProsperity))
	}
	if m.LostProsperity != 0 {
		n += 2 + sovDomestic(uint64(m.LostProsperity))
	}
	if m.BuildingWorkerCoef != 0 {
		n += 2 + sovDomestic(uint64(m.BuildingWorkerCoef))
	}
	if m.TechWorkerCoef != 0 {
		n += 2 + sovDomestic(uint64(m.TechWorkerCoef))
	}
	if m.BuildingWorkerFatigueDuration != 0 {
		n += 2 + sovDomestic(uint64(m.BuildingWorkerFatigueDuration))
	}
	if m.TechWorkerFatigueDuration != 0 {
		n += 2 + sovDomestic(uint64(m.TechWorkerFatigueDuration))
	}
	if m.ForgingTimes != 0 {
		n += 2 + sovDomestic(uint64(m.ForgingTimes))
	}
	if m.ForgingNextTime != 0 {
		n += 2 + sovDomestic(uint64(m.ForgingNextTime))
	}
	if len(m.NextCollectTimeType) > 0 {
		for _, e := range m.NextCollectTimeType {
			n += 2 + sovDomestic(uint64(e))
		}
	}
	if len(m.NextCollectTime) > 0 {
		for _, e := range m.NextCollectTime {
			n += 2 + sovDomestic(uint64(e))
		}
	}
	if m.DailyResourceCollectTimes != 0 {
		n += 2 + sovDomestic(uint64(m.DailyResourceCollectTimes))
	}
	if m.CityEvent != nil {
		l = m.CityEvent.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	l = len(m.Sign)
	if l > 0 {
		n += 2 + l + sovDomestic(uint64(l))
	}
	l = len(m.Voice)
	if l > 0 {
		n += 2 + l + sovDomestic(uint64(l))
	}
	if m.ResourcePointV2 != nil {
		l = m.ResourcePointV2.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if m.Jade != 0 {
		n += 2 + sovDomestic(uint64(m.Jade))
	}
	if m.JadeOre != 0 {
		n += 2 + sovDomestic(uint64(m.JadeOre))
	}
	if len(m.NewForgingPos) > 0 {
		for _, e := range m.NewForgingPos {
			n += 2 + sovDomestic(uint64(e))
		}
	}
	if m.HistoryJade != 0 {
		n += 2 + sovDomestic(uint64(m.HistoryJade))
	}
	if m.TodayObtainJade != 0 {
		n += 2 + sovDomestic(uint64(m.TodayObtainJade))
	}
	if len(m.WorkerSeekHelp) > 0 {
		n += 3 * len(m.WorkerSeekHelp)
	}
	if len(m.TechnologySeekHelp) > 0 {
		n += 3 * len(m.TechnologySeekHelp)
	}
	if m.DailyHelpMemberTimes != 0 {
		n += 2 + sovDomestic(uint64(m.DailyHelpMemberTimes))
	}
	if m.CountdownCollectTime != 0 {
		n += 2 + sovDomestic(uint64(m.CountdownCollectTime))
	}
	if m.IsCollectSeasonPrize {
		n += 3
	}
	if m.WorkshopCollectTime != 0 {
		n += 2 + sovDomestic(uint64(m.WorkshopCollectTime))
	}
	if m.BuildingCostReduceCoef != 0 {
		n += 2 + sovDomestic(uint64(m.BuildingCostReduceCoef))
	}
	if m.TechCostReduceCoef != 0 {
		n += 2 + sovDomestic(uint64(m.TechCostReduceCoef))
	}
	if len(m.WorkerAlwaysUnlocked) > 0 {
		n += 3 * len(m.WorkerAlwaysUnlocked)
	}
	if len(m.WorkerLockStartTime) > 0 {
		for _, e := range m.WorkerLockStartTime {
			n += 2 + sovDomestic(uint64(e))
		}
	}
	return n
}

func (m *HeroDomesticOtherProto) Size() (n int) {
	var l int
	_ = l
	if m.Prosperity != 0 {
		n += 2 + sovDomestic(uint64(m.Prosperity))
	}
	if m.MaxProsperity != 0 {
		n += 2 + sovDomestic(uint64(m.MaxProsperity))
	}
	if m.LostProsperity != 0 {
		n += 2 + sovDomestic(uint64(m.LostProsperity))
	}
	l = len(m.Sign)
	if l > 0 {
		n += 2 + l + sovDomestic(uint64(l))
	}
	l = len(m.Voice)
	if l > 0 {
		n += 2 + l + sovDomestic(uint64(l))
	}
	return n
}

func (m *ResourcePointV2Proto) Size() (n int) {
	var l int
	_ = l
	if len(m.ResourcePoint) > 0 {
		for _, e := range m.ResourcePoint {
			l = e.Size()
			n += 1 + l + sovDomestic(uint64(l))
		}
	}
	if m.ResCount != 0 {
		n += 1 + sovDomestic(uint64(m.ResCount))
	}
	if m.ConflictResCount != 0 {
		n += 1 + sovDomestic(uint64(m.ConflictResCount))
	}
	return n
}

func (m *SingleResourcePointV2Proto) Size() (n int) {
	var l int
	_ = l
	if m.ResType != 0 {
		n += 1 + sovDomestic(uint64(m.ResType))
	}
	if m.OriginOutput != 0 {
		n += 1 + sovDomestic(uint64(m.OriginOutput))
	}
	if m.RealOutput != 0 {
		n += 1 + sovDomestic(uint64(m.RealOutput))
	}
	return n
}

func (m *CityEventProto) Size() (n int) {
	var l int
	_ = l
	if m.AcceptTimes != 0 {
		n += 1 + sovDomestic(uint64(m.AcceptTimes))
	}
	if m.CanExchangeTime != 0 {
		n += 1 + sovDomestic(uint64(m.CanExchangeTime))
	}
	if m.EventId != 0 {
		n += 1 + sovDomestic(uint64(m.EventId))
	}
	return n
}

func (m *CityEventDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDomestic(uint64(m.Id))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	if m.Cost != nil {
		l = m.Cost.Size()
		n += 1 + l + sovDomestic(uint64(l))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovDomestic(uint64(l))
	}
	return n
}

func (m *CityEventMiscProto) Size() (n int) {
	var l int
	_ = l
	if m.MaxTimes != 0 {
		n += 1 + sovDomestic(uint64(m.MaxTimes))
	}
	if m.RecoverDuration != 0 {
		n += 1 + sovDomestic(uint64(m.RecoverDuration))
	}
	if m.UnlockBaseLevel != 0 {
		n += 1 + sovDomestic(uint64(m.UnlockBaseLevel))
	}
	return n
}

func (m *WorkshopRefreshCostProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDomestic(uint64(m.Id))
	}
	if m.Cost != nil {
		l = m.Cost.Size()
		n += 1 + l + sovDomestic(uint64(l))
	}
	return n
}

func (m *StrategyDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDomestic(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	if m.Target != 0 {
		n += 1 + sovDomestic(uint64(m.Target))
	}
	if m.Type != 0 {
		n += 1 + sovDomestic(uint64(m.Type))
	}
	if m.Sp != 0 {
		n += 1 + sovDomestic(uint64(m.Sp))
	}
	if m.UnlockHeroLevel != 0 {
		n += 1 + sovDomestic(uint64(m.UnlockHeroLevel))
	}
	if m.Cd != 0 {
		n += 1 + sovDomestic(uint64(m.Cd))
	}
	if m.TodayLimit != 0 {
		n += 1 + sovDomestic(uint64(m.TodayLimit))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	return n
}

func (m *HeroResourcePointProto) Size() (n int) {
	var l int
	_ = l
	if m.LayoutId != 0 {
		n += 1 + sovDomestic(uint64(m.LayoutId))
	}
	if m.BuildingId != 0 {
		n += 1 + sovDomestic(uint64(m.BuildingId))
	}
	if m.OutputAmount != 0 {
		n += 1 + sovDomestic(uint64(m.OutputAmount))
	}
	if m.OutputPerHour != 0 {
		n += 1 + sovDomestic(uint64(m.OutputPerHour))
	}
	if m.OutputCapcity != 0 {
		n += 1 + sovDomestic(uint64(m.OutputCapcity))
	}
	if m.Conflicted {
		n += 2
	}
	if m.BaseLevelLocked {
		n += 2
	}
	return n
}

func (m *OuterCitiesProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Cities) > 0 {
		for _, e := range m.Cities {
			l = e.Size()
			n += 1 + l + sovDomestic(uint64(l))
		}
	}
	return n
}

func (m *OuterCityProto) Size() (n int) {
	var l int
	_ = l
	if m.CityDataId != 0 {
		n += 1 + sovDomestic(uint64(m.CityDataId))
	}
	if len(m.LayoutIds) > 0 {
		for _, e := range m.LayoutIds {
			n += 1 + sovDomestic(uint64(e))
		}
	}
	if m.CityType != 0 {
		n += 1 + sovDomestic(uint64(m.CityType))
	}
	return n
}

func (m *OuterCityDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDomestic(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	if m.UnlockGuanFuLevel != 0 {
		n += 1 + sovDomestic(uint64(m.UnlockGuanFuLevel))
	}
	l = len(m.LockIconId)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	l = len(m.UnlockIconId)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	if len(m.FirstLevelLayoutDatas) > 0 {
		for _, e := range m.FirstLevelLayoutDatas {
			n += 1 + sovDomestic(uint64(e))
		}
	}
	if len(m.Descs) > 0 {
		for _, e := range m.Descs {
			l = e.Size()
			n += 1 + l + sovDomestic(uint64(l))
		}
	}
	l = len(m.RegionModelRes)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	l = len(m.UnlockBeforeImage)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	l = len(m.UnlockAfterImage)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	if len(m.UnlockDesc) > 0 {
		for _, s := range m.UnlockDesc {
			l = len(s)
			n += 1 + l + sovDomestic(uint64(l))
		}
	}
	return n
}

func (m *OuterCityBuildingDescDataProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	l = len(m.IconId)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	return n
}

func (m *OuterCityLayoutDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDomestic(uint64(m.Id))
	}
	if m.Layout != 0 {
		n += 1 + sovDomestic(uint64(m.Layout))
	}
	l = len(m.LockIconId)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	l = len(m.UnlockIconId)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	if m.BuildingId != 0 {
		n += 1 + sovDomestic(uint64(m.BuildingId))
	}
	if m.UpgradeRequireLayoutId != 0 {
		n += 1 + sovDomestic(uint64(m.UpgradeRequireLayoutId))
	}
	if len(m.UpgradeRequireIds) > 0 {
		for _, e := range m.UpgradeRequireIds {
			n += 1 + sovDomestic(uint64(e))
		}
	}
	if m.NextLevel != 0 {
		n += 1 + sovDomestic(uint64(m.NextLevel))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovDomestic(uint64(l))
	}
	if m.MilitaryBuilding != 0 {
		n += 1 + sovDomestic(uint64(m.MilitaryBuilding))
	}
	if m.EconomicBuilding != 0 {
		n += 1 + sovDomestic(uint64(m.EconomicBuilding))
	}
	if m.ChangeTypeCost != nil {
		l = m.ChangeTypeCost.Size()
		n += 1 + l + sovDomestic(uint64(l))
	}
	return n
}

func sovDomestic(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDomestic(x uint64) (n int) {
	return sovDomestic(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HeroLevelProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroLevelProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroLevelProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeExp", wireType)
			}
			m.UpgradeExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradeExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TroopsCaptainCount", wireType)
			}
			m.TroopsCaptainCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TroopsCaptainCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipmentLevelLimit", wireType)
			}
			m.EquipmentLevelLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EquipmentLevelLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainLevelLimit", wireType)
			}
			m.CaptainLevelLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainLevelLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainCountLimit", wireType)
			}
			m.CaptainCountLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainCountLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType == 0 {
				var v Race
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Race(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnlockedRaces = append(m.UnlockedRaces, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Race
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Race(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnlockedRaces = append(m.UnlockedRaces, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockedRaces", wireType)
			}
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainTrainingLevel = append(m.CaptainTrainingLevel, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainTrainingLevel = append(m.CaptainTrainingLevel, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainTrainingLevel", wireType)
			}
		case 17:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainTrainingLevelLimit = append(m.CaptainTrainingLevelLimit, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainTrainingLevelLimit = append(m.CaptainTrainingLevelLimit, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainTrainingLevelLimit", wireType)
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrategyLimit", wireType)
			}
			m.StrategyLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StrategyLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainSoulLevelLimit", wireType)
			}
			m.CaptainSoulLevelLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainSoulLevelLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddSoldierCapacity", wireType)
			}
			m.AddSoldierCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddSoldierCapacity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TroopsCount", wireType)
			}
			m.TroopsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TroopsCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainOfficialId = append(m.CaptainOfficialId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainOfficialId = append(m.CaptainOfficialId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainOfficialId", wireType)
			}
		case 25:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainOfficialCount = append(m.CaptainOfficialCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainOfficialCount = append(m.CaptainOfficialCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainOfficialCount", wireType)
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpLimit", wireType)
			}
			m.SpLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseLevelProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseLevelProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseLevelProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeProsperity", wireType)
			}
			m.UpgradeProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradeProsperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockGuanFuLevel", wireType)
			}
			m.UnlockGuanFuLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnlockGuanFuLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockPowerRange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnlockPowerRange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppearanceRes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppearanceRes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildingLayoutProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildingLayoutProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildingLayoutProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v BuildingType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (BuildingType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Building = append(m.Building, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v BuildingType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (BuildingType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Building = append(m.Building, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Building", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireBaseLevel", wireType)
			}
			m.RequireBaseLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequireBaseLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionOffsetX", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.RegionOffsetX = v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionOffsetY", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.RegionOffsetY = v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreConflict", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreConflict = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildingDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildingDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildingDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (BuildingType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkTime", wireType)
			}
			m.WorkTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prosperity", wireType)
			}
			m.Prosperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prosperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroExp", wireType)
			}
			m.HeroExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EffectDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Effect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Effect == nil {
				m.Effect = &DomesticEffectProto{}
			}
			if err := m.Effect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tips", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tips = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &CostProto{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RequireIds = append(m.RequireIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RequireIds = append(m.RequireIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireIds", wireType)
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseLevel", wireType)
			}
			m.BaseLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildingUnlockDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildingUnlockDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildingUnlockDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (BuildingType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuanFuLevel", wireType)
			}
			m.GuanFuLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuanFuLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroLevel", wireType)
			}
			m.HeroLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainTaskSequence", wireType)
			}
			m.MainTaskSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MainTaskSequence |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaYeStage", wireType)
			}
			m.BaYeStage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaYeStage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyOrder", wireType)
			}
			m.NotifyOrder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotifyOrder |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomesticEffectProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DomesticEffectProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DomesticEffectProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingWorkerCoef", wireType)
			}
			m.BuildingWorkerCoef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingWorkerCoef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TechWorkerCoef", wireType)
			}
			m.TechWorkerCoef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TechWorkerCoef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingWorkerFatigueDuration", wireType)
			}
			m.BuildingWorkerFatigueDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingWorkerFatigueDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TechWorkerFatigueDuration", wireType)
			}
			m.TechWorkerFatigueDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TechWorkerFatigueDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeekHelpCdr", wireType)
			}
			m.SeekHelpCdr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeekHelpCdr |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeekHelpMaxTimes", wireType)
			}
			m.SeekHelpMaxTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeekHelpMaxTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildDonateTimes", wireType)
			}
			m.GuildDonateTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildDonateTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldierCapcity", wireType)
			}
			m.SoldierCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoldierCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSoldierOutput", wireType)
			}
			m.NewSoldierOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewSoldierOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSoldierCapcity", wireType)
			}
			m.NewSoldierCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewSoldierCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WoundedSoldierCapcity", wireType)
			}
			m.WoundedSoldierCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WoundedSoldierCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldierLoad", wireType)
			}
			m.SoldierLoad = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoldierLoad |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 56:
			if wireType == 0 {
				var v Race
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Race(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SoldierRace = append(m.SoldierRace, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Race
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Race(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SoldierRace = append(m.SoldierRace, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldierRace", wireType)
			}
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldierStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SoldierStat == nil {
				m.SoldierStat = &SpriteStatProto{}
			}
			if err := m.SoldierStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainOutput", wireType)
			}
			m.TrainOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainCapcity", wireType)
			}
			m.TrainCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TentProsperityCapcity", wireType)
			}
			m.TentProsperityCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TentProsperityCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeWallStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HomeWallStat == nil {
				m.HomeWallStat = &SpriteStatProto{}
			}
			if err := m.HomeWallStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 62:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TentWallStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TentWallStat == nil {
				m.TentWallStat = &SpriteStatProto{}
			}
			if err := m.TentWallStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 63:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainExpPerHour", wireType)
			}
			m.TrainExpPerHour = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainExpPerHour |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 64:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecruitSoldierCount", wireType)
			}
			m.RecruitSoldierCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecruitSoldierCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 65:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainCoef", wireType)
			}
			m.TrainCoef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainCoef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 66:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FarStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FarStat == nil {
				m.FarStat = &SpriteStatProto{}
			}
			if err := m.FarStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 67:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseStat == nil {
				m.CloseStat = &SpriteStatProto{}
			}
			if err := m.CloseStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 69:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllSoldierStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllSoldierStat == nil {
				m.AllSoldierStat = &SpriteStatProto{}
			}
			if err := m.AllSoldierStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 70:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeWallFixDamage", wireType)
			}
			m.HomeWallFixDamage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HomeWallFixDamage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 71:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TentWallFixDamage", wireType)
			}
			m.TentWallFixDamage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TentWallFixDamage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 72:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldierOutput", wireType)
			}
			m.SoldierOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoldierOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 73:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceSoldier", wireType)
			}
			m.ForceSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capcity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Capcity = append(m.Capcity, &AmountProto{})
			if err := m.Capcity[len(m.Capcity)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectedCapcity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtectedCapcity == nil {
				m.ProtectedCapcity = &AmountProto{}
			}
			if err := m.ProtectedCapcity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &AmountProto{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 104:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputCapcity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputCapcity == nil {
				m.OutputCapcity = &AmountProto{}
			}
			if err := m.OutputCapcity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 105:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputType", wireType)
			}
			m.OutputType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputType |= (ResType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 106:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FarmOutputType", wireType)
			}
			m.FarmOutputType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FarmOutputType |= (ResType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 107:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FarmOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FarmOutput == nil {
				m.FarmOutput = &AmountProto{}
			}
			if err := m.FarmOutput.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 108:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tax", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tax = append(m.Tax, &AmountProto{})
			if err := m.Tax[len(m.Tax)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 109:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedDefenseStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddedDefenseStat == nil {
				m.AddedDefenseStat = &SpriteStatProto{}
			}
			if err := m.AddedDefenseStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 110:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedAssistStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddedAssistStat == nil {
				m.AddedAssistStat = &SpriteStatProto{}
			}
			if err := m.AddedAssistStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 111:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingCostReduceCoef", wireType)
			}
			m.BuildingCostReduceCoef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingCostReduceCoef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 112:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TechCostReduceCoef", wireType)
			}
			m.TechCostReduceCoef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TechCostReduceCoef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 113:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedCopyDefenseStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddedCopyDefenseStat == nil {
				m.AddedCopyDefenseStat = &SpriteStatProto{}
			}
			if err := m.AddedCopyDefenseStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuanFuLevelProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuanFuLevelProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuanFuLevelProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveBaseRestoreHomeProsperity", wireType)
			}
			m.MoveBaseRestoreHomeProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveBaseRestoreHomeProsperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyProsperityRestoreDurationWith1Yuanbao", wireType)
			}
			m.BuyProsperityRestoreDurationWith1Yuanbao = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyProsperityRestoreDurationWith1Yuanbao |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyProsperityRestoreDurationWith1Cost", wireType)
			}
			m.BuyProsperityRestoreDurationWith1Cost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyProsperityRestoreDurationWith1Cost |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestoreProsperity", wireType)
			}
			m.RestoreProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestoreProsperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveBaseRestoreHomeProsperityDuration", wireType)
			}
			m.MoveBaseRestoreHomeProsperityDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveBaseRestoreHomeProsperityDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkshopPrize == nil {
				m.WorkshopPrize = &PrizeProto{}
			}
			if err := m.WorkshopPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TieJiangPuLevelProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TieJiangPuLevelProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TieJiangPuLevelProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxForgingTimes", wireType)
			}
			m.MaxForgingTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxForgingTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryForgingDuration", wireType)
			}
			m.RecoveryForgingDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecoveryForgingDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CanForgingEquipPos = append(m.CanForgingEquipPos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CanForgingEquipPos = append(m.CanForgingEquipPos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CanForgingEquipPos", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CanForgingEquip = append(m.CanForgingEquip, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CanForgingEquip = append(m.CanForgingEquip, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CanForgingEquip", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LockedCanForgingEquipPos = append(m.LockedCanForgingEquipPos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LockedCanForgingEquipPos = append(m.LockedCanForgingEquipPos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedCanForgingEquipPos", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LockedCanForgingEquip = append(m.LockedCanForgingEquip, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LockedCanForgingEquip = append(m.LockedCanForgingEquip, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedCanForgingEquip", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LockedEquipNeedLevel = append(m.LockedEquipNeedLevel, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LockedEquipNeedLevel = append(m.LockedEquipNeedLevel, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedEquipNeedLevel", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanOneKeyForging", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanOneKeyForging = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TechnologyDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TechnologyDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TechnologyDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (TechType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Effect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Effect == nil {
				m.Effect = &DomesticEffectProto{}
			}
			if err := m.Effect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntIcon", wireType)
			}
			m.IntIcon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntIcon |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RequireBuildingIds = append(m.RequireBuildingIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RequireBuildingIds = append(m.RequireBuildingIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireBuildingIds", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RequireTechIds = append(m.RequireTechIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RequireTechIds = append(m.RequireTechIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireTechIds", wireType)
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBigTech", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBigTech = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &CostProto{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkTime", wireType)
			}
			m.WorkTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextLevelId", wireType)
			}
			m.NextLevelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextLevelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLevel", wireType)
			}
			m.MaxLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountdownPrizeDescDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountdownPrizeDescDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountdownPrizeDescDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroDomesticProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroDomesticProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroDomesticProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Food", wireType)
			}
			m.Food = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Food |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wood", wireType)
			}
			m.Wood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Wood |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stone", wireType)
			}
			m.Stone = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stone |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldCapcity", wireType)
			}
			m.GoldCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoldCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoodCapcity", wireType)
			}
			m.FoodCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FoodCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WoodCapcity", wireType)
			}
			m.WoodCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WoodCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoneCapcity", wireType)
			}
			m.StoneCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoneCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeGold", wireType)
			}
			m.SafeGold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafeGold |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeFood", wireType)
			}
			m.SafeFood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafeFood |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeWood", wireType)
			}
			m.SafeWood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafeWood |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeStone", wireType)
			}
			m.SafeStone = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafeStone |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectedCapcity", wireType)
			}
			m.ProtectedCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtectedCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WorkerRestEndTime = append(m.WorkerRestEndTime, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WorkerRestEndTime = append(m.WorkerRestEndTime, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerRestEndTime", wireType)
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceBuilding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceBuilding = append(m.ResourceBuilding, &Int32Pair{})
			if err := m.ResourceBuilding[len(m.ResourceBuilding)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Building = append(m.Building, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Building = append(m.Building, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Building", wireType)
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourcePoint = append(m.ResourcePoint, &HeroResourcePointProto{})
			if err := m.ResourcePoint[len(m.ResourcePoint)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cities == nil {
				m.Cities = &OuterCitiesProto{}
			}
			if err := m.Cities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Technology = append(m.Technology, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Technology = append(m.Technology, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Technology", wireType)
			}
		case 22:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TechnologyRestEndTime = append(m.TechnologyRestEndTime, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TechnologyRestEndTime = append(m.TechnologyRestEndTime, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TechnologyRestEndTime", wireType)
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prosperity", wireType)
			}
			m.Prosperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prosperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxProsperity", wireType)
			}
			m.MaxProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxProsperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LostProsperity", wireType)
			}
			m.LostProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LostProsperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingWorkerCoef", wireType)
			}
			m.BuildingWorkerCoef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingWorkerCoef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TechWorkerCoef", wireType)
			}
			m.TechWorkerCoef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TechWorkerCoef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingWorkerFatigueDuration", wireType)
			}
			m.BuildingWorkerFatigueDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingWorkerFatigueDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TechWorkerFatigueDuration", wireType)
			}
			m.TechWorkerFatigueDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TechWorkerFatigueDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForgingTimes", wireType)
			}
			m.ForgingTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForgingTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForgingNextTime", wireType)
			}
			m.ForgingNextTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForgingNextTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType == 0 {
				var v ResType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ResType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NextCollectTimeType = append(m.NextCollectTimeType, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ResType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ResType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NextCollectTimeType = append(m.NextCollectTimeType, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NextCollectTimeType", wireType)
			}
		case 38:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NextCollectTime = append(m.NextCollectTime, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NextCollectTime = append(m.NextCollectTime, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NextCollectTime", wireType)
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyResourceCollectTimes", wireType)
			}
			m.DailyResourceCollectTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailyResourceCollectTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CityEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CityEvent == nil {
				m.CityEvent = &CityEventProto{}
			}
			if err := m.CityEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voice", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voice = append(m.Voice[:0], dAtA[iNdEx:postIndex]...)
			if m.Voice == nil {
				m.Voice = []byte{}
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePointV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourcePointV2 == nil {
				m.ResourcePointV2 = &ResourcePointV2Proto{}
			}
			if err := m.ResourcePointV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jade", wireType)
			}
			m.Jade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Jade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JadeOre", wireType)
			}
			m.JadeOre = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JadeOre |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NewForgingPos = append(m.NewForgingPos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NewForgingPos = append(m.NewForgingPos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NewForgingPos", wireType)
			}
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryJade", wireType)
			}
			m.HistoryJade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistoryJade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TodayObtainJade", wireType)
			}
			m.TodayObtainJade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TodayObtainJade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WorkerSeekHelp = append(m.WorkerSeekHelp, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WorkerSeekHelp = append(m.WorkerSeekHelp, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerSeekHelp", wireType)
			}
		case 52:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TechnologySeekHelp = append(m.TechnologySeekHelp, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TechnologySeekHelp = append(m.TechnologySeekHelp, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TechnologySeekHelp", wireType)
			}
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyHelpMemberTimes", wireType)
			}
			m.DailyHelpMemberTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailyHelpMemberTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountdownCollectTime", wireType)
			}
			m.CountdownCollectTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountdownCollectTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 57:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCollectSeasonPrize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCollectSeasonPrize = bool(v != 0)
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopCollectTime", wireType)
			}
			m.WorkshopCollectTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopCollectTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingCostReduceCoef", wireType)
			}
			m.BuildingCostReduceCoef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingCostReduceCoef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TechCostReduceCoef", wireType)
			}
			m.TechCostReduceCoef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TechCostReduceCoef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 61:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WorkerAlwaysUnlocked = append(m.WorkerAlwaysUnlocked, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WorkerAlwaysUnlocked = append(m.WorkerAlwaysUnlocked, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerAlwaysUnlocked", wireType)
			}
		case 62:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WorkerLockStartTime = append(m.WorkerLockStartTime, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WorkerLockStartTime = append(m.WorkerLockStartTime, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerLockStartTime", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroDomesticOtherProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroDomesticOtherProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroDomesticOtherProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prosperity", wireType)
			}
			m.Prosperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prosperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxProsperity", wireType)
			}
			m.MaxProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxProsperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LostProsperity", wireType)
			}
			m.LostProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LostProsperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voice", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voice = append(m.Voice[:0], dAtA[iNdEx:postIndex]...)
			if m.Voice == nil {
				m.Voice = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourcePointV2Proto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourcePointV2Proto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourcePointV2Proto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourcePoint = append(m.ResourcePoint, &SingleResourcePointV2Proto{})
			if err := m.ResourcePoint[len(m.ResourcePoint)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResCount", wireType)
			}
			m.ResCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConflictResCount", wireType)
			}
			m.ConflictResCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConflictResCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleResourcePointV2Proto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleResourcePointV2Proto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleResourcePointV2Proto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResType", wireType)
			}
			m.ResType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResType |= (ResType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginOutput", wireType)
			}
			m.OriginOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealOutput", wireType)
			}
			m.RealOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RealOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CityEventProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CityEventProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CityEventProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptTimes", wireType)
			}
			m.AcceptTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcceptTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanExchangeTime", wireType)
			}
			m.CanExchangeTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CanExchangeTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			m.EventId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CityEventDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CityEventDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CityEventDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &CombineCostProto{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CityEventMiscProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CityEventMiscProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CityEventMiscProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimes", wireType)
			}
			m.MaxTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverDuration", wireType)
			}
			m.RecoverDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecoverDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockBaseLevel", wireType)
			}
			m.UnlockBaseLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnlockBaseLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkshopRefreshCostProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkshopRefreshCostProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkshopRefreshCostProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &CostProto{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StrategyDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StrategyDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StrategyDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			m.Target = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Target |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sp", wireType)
			}
			m.Sp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockHeroLevel", wireType)
			}
			m.UnlockHeroLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnlockHeroLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cd", wireType)
			}
			m.Cd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TodayLimit", wireType)
			}
			m.TodayLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TodayLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroResourcePointProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroResourcePointProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroResourcePointProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LayoutId", wireType)
			}
			m.LayoutId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LayoutId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingId", wireType)
			}
			m.BuildingId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputAmount", wireType)
			}
			m.OutputAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputPerHour", wireType)
			}
			m.OutputPerHour = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputPerHour |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputCapcity", wireType)
			}
			m.OutputCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conflicted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Conflicted = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseLevelLocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BaseLevelLocked = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OuterCitiesProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OuterCitiesProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OuterCitiesProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cities = append(m.Cities, &OuterCityProto{})
			if err := m.Cities[len(m.Cities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OuterCityProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OuterCityProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OuterCityProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CityDataId", wireType)
			}
			m.CityDataId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CityDataId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LayoutIds = append(m.LayoutIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LayoutIds = append(m.LayoutIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LayoutIds", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CityType", wireType)
			}
			m.CityType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CityType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OuterCityDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OuterCityDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OuterCityDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockGuanFuLevel", wireType)
			}
			m.UnlockGuanFuLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnlockGuanFuLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockIconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockIconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockIconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnlockIconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FirstLevelLayoutDatas = append(m.FirstLevelLayoutDatas, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FirstLevelLayoutDatas = append(m.FirstLevelLayoutDatas, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstLevelLayoutDatas", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Descs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Descs = append(m.Descs, &OuterCityBuildingDescDataProto{})
			if err := m.Descs[len(m.Descs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionModelRes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionModelRes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockBeforeImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnlockBeforeImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockAfterImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnlockAfterImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnlockDesc = append(m.UnlockDesc, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OuterCityBuildingDescDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OuterCityBuildingDescDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OuterCityBuildingDescDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OuterCityLayoutDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OuterCityLayoutDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OuterCityLayoutDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layout", wireType)
			}
			m.Layout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockIconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockIconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockIconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnlockIconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingId", wireType)
			}
			m.BuildingId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeRequireLayoutId", wireType)
			}
			m.UpgradeRequireLayoutId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradeRequireLayoutId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UpgradeRequireIds = append(m.UpgradeRequireIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UpgradeRequireIds = append(m.UpgradeRequireIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeRequireIds", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextLevel", wireType)
			}
			m.NextLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MilitaryBuilding", wireType)
			}
			m.MilitaryBuilding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MilitaryBuilding |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EconomicBuilding", wireType)
			}
			m.EconomicBuilding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EconomicBuilding |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeTypeCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeTypeCost == nil {
				m.ChangeTypeCost = &CostProto{}
			}
			if err := m.ChangeTypeCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDomestic(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDomestic
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDomestic(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDomestic = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDomestic   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/shared_proto/domestic.proto", fileDescriptorDomestic)
}

var fileDescriptorDomestic = []byte{
	// 4510 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x5a, 0xcd, 0x73, 0x1b, 0xc7,
	0x72, 0x37, 0xf8, 0x09, 0x36, 0x40, 0x70, 0x31, 0xfc, 0x5a, 0x49, 0x16, 0x4d, 0x41, 0x96, 0x45,
	0x53, 0xb2, 0xf4, 0x4c, 0xf9, 0x43, 0xb2, 0xfc, 0x9e, 0x1f, 0x09, 0x42, 0x24, 0xf4, 0x28, 0x92,
	0x0f, 0x24, 0x23, 0xc9, 0x97, 0xad, 0xe5, 0xee, 0x00, 0xdc, 0x27, 0x60, 0x17, 0xde, 0x5d, 0x88,
	0x84, 0x6f, 0xc9, 0x21, 0xc9, 0x25, 0x39, 0xa6, 0xf2, 0x0f, 0xe4, 0x94, 0x43, 0xaa, 0xf2, 0x57,
	0xe4, 0x98, 0xca, 0x25, 0x87, 0x5c, 0x52, 0x4e, 0x55, 0xca, 0xf7, 0x54, 0xa5, 0x72, 0x4c, 0x75,
	0xf7, 0xcc, 0xee, 0x02, 0xfc, 0x90, 0xfc, 0x2a, 0x95, 0x13, 0x30, 0xdd, 0xbf, 0x9e, 0x8f, 0x9e,
	0x9e, 0x9e, 0xee, 0xde, 0x81, 0xc7, 0x2d, 0x2f, 0x3e, 0xe9, 0x1d, 0x3f, 0x70, 0x82, 0xce, 0xc3,
	0xb6, 0xd7, 0x3a, 0x89, 0xbb, 0xf6, 0xe9, 0xc3, 0x8e, 0xdd, 0x96, 0x5f, 0x3f, 0xec, 0x1e, 0x3f,
	0x8c, 0x4e, 0xec, 0x50, 0xba, 0x56, 0x37, 0x0c, 0xe2, 0xe0, 0xa1, 0x1b, 0x74, 0x64, 0x14, 0x7b,
	0xce, 0x03, 0x6a, 0x8a, 0x71, 0xfa, 0xb9, 0xfe, 0xc5, 0xfb, 0x77, 0x70, 0x6c, 0x47, 0x92, 0x85,
	0x2b, 0x7f, 0x36, 0x01, 0xa5, 0x6d, 0x19, 0x06, 0x3b, 0xf2, 0xad, 0x6c, 0xef, 0x53, 0x7f, 0x73,
	0x30, 0xde, 0xc6, 0x96, 0x99, 0x5b, 0xce, 0xad, 0x8c, 0x37, 0xb8, 0x21, 0x3e, 0x82, 0x42, 0xaf,
	0xdb, 0x0a, 0x6d, 0x57, 0x5a, 0xf2, 0xac, 0x6b, 0x8e, 0x10, 0x0f, 0x14, 0xa9, 0x76, 0xd6, 0x15,
	0xbf, 0x82, 0xb9, 0x38, 0x0c, 0x82, 0x6e, 0x64, 0x39, 0x76, 0x37, 0xb6, 0x3d, 0xdf, 0x72, 0x82,
	0x9e, 0x1f, 0x9b, 0xa3, 0x84, 0x14, 0xcc, 0xab, 0x32, 0xab, 0x8a, 0x1c, 0xb1, 0x06, 0xf3, 0xf2,
	0x87, 0x9e, 0xd7, 0xed, 0x48, 0x3f, 0xb6, 0x68, 0x14, 0xab, 0xed, 0x75, 0xbc, 0xd8, 0x2c, 0x90,
	0xc8, 0x6c, 0xc2, 0xa4, 0xc9, 0xed, 0x20, 0x4b, 0x3c, 0x80, 0x59, 0xdd, 0x7d, 0x56, 0xa2, 0x48,
	0x12, 0x65, 0xc5, 0xba, 0x18, 0x4f, 0xd3, 0x51, 0xf8, 0xe9, 0x01, 0x3c, 0x4d, 0x87, 0xf1, 0x5f,
	0x41, 0xa9, 0xe7, 0xb7, 0x03, 0xe7, 0x8d, 0x74, 0xad, 0xd0, 0x76, 0x64, 0x64, 0xce, 0x2c, 0x8f,
	0xae, 0x94, 0xd6, 0x0a, 0xac, 0xaf, 0x07, 0x0d, 0xdb, 0x91, 0x1b, 0x23, 0xc6, 0x07, 0x8d, 0x69,
	0x0d, 0x43, 0x4a, 0x24, 0x1e, 0xc3, 0x82, 0x1e, 0x27, 0x0e, 0x6d, 0xcf, 0xf7, 0xfc, 0x16, 0x4f,
	0xd0, 0x34, 0x96, 0x47, 0x57, 0xc6, 0x49, 0x64, 0x4e, 0x21, 0x0e, 0x15, 0x80, 0xa6, 0x29, 0xaa,
	0xf0, 0xe1, 0xc5, 0x92, 0x6a, 0xaa, 0xe5, 0x44, 0xfe, 0xda, 0x45, 0xf2, 0x3c, 0xed, 0x3b, 0x50,
	0x8a, 0xe2, 0xd0, 0x8e, 0x65, 0xab, 0xaf, 0xc4, 0xe6, 0x68, 0x85, 0xd3, 0x9a, 0xca, 0xb0, 0xaf,
	0xc1, 0xd4, 0x63, 0x45, 0x41, 0xaf, 0x3d, 0x30, 0xce, 0x3c, 0x09, 0xcc, 0x2b, 0xfe, 0x41, 0xd0,
	0x6b, 0x67, 0xfa, 0xff, 0x15, 0xcc, 0xd9, 0xae, 0x6b, 0x45, 0x41, 0xdb, 0xf5, 0x64, 0x88, 0x3b,
	0x6c, 0x3b, 0x5e, 0xdc, 0x37, 0x17, 0x78, 0x73, 0x6d, 0xd7, 0x3d, 0x60, 0x56, 0x55, 0x71, 0xc4,
	0x2d, 0x28, 0x6a, 0x73, 0x20, 0x33, 0x58, 0x24, 0x64, 0x41, 0x99, 0x81, 0xda, 0xff, 0x64, 0x6f,
	0x82, 0x66, 0xd3, 0x73, 0x3c, 0xbb, 0x6d, 0x79, 0xae, 0x69, 0x26, 0x0b, 0xd6, 0xfb, 0xb3, 0xa7,
	0xb8, 0x75, 0x37, 0xab, 0xe7, 0x44, 0x86, 0x07, 0xb8, 0x76, 0x4e, 0xcf, 0x5a, 0x8c, 0x47, 0xbb,
	0x06, 0xf9, 0xa8, 0xab, 0xd6, 0x7a, 0x9d, 0x26, 0x33, 0x19, 0x75, 0x69, 0x75, 0x95, 0x7f, 0xcb,
	0x41, 0x69, 0xc3, 0x8e, 0xe4, 0x3b, 0x0f, 0xc1, 0x67, 0x20, 0xf4, 0x21, 0xe8, 0x86, 0x41, 0xd4,
	0x95, 0x21, 0x2a, 0x81, 0xcf, 0x42, 0x59, 0x71, 0xf6, 0x13, 0x86, 0x78, 0x08, 0x73, 0x6c, 0x25,
	0x56, 0xab, 0x67, 0xfb, 0x56, 0xb3, 0xa7, 0x4c, 0x62, 0x54, 0x09, 0x10, 0x6f, 0xab, 0x67, 0xfb,
	0xcf, 0x7a, 0x6c, 0x0b, 0xf7, 0x41, 0x28, 0x81, 0x6e, 0x70, 0x2a, 0x43, 0x2b, 0xb4, 0xfd, 0x96,
	0x34, 0xc7, 0x96, 0x73, 0x2b, 0x53, 0x0d, 0x83, 0x39, 0xfb, 0xc8, 0x68, 0x20, 0x1d, 0x37, 0xdd,
	0xee, 0x76, 0xa5, 0x1d, 0xda, 0xbe, 0x23, 0xad, 0x50, 0x46, 0xe6, 0x38, 0x21, 0xa7, 0x53, 0x6a,
	0x43, 0x46, 0x95, 0x3f, 0x1d, 0x81, 0xd9, 0x8d, 0x9e, 0xd7, 0x76, 0xd1, 0x64, 0xec, 0x7e, 0xd0,
	0x8b, 0x79, 0x89, 0x25, 0x18, 0xf1, 0x5c, 0xb5, 0xbe, 0x11, 0xcf, 0x15, 0x8f, 0x20, 0x7f, 0xac,
	0x60, 0xe6, 0x08, 0x19, 0xfd, 0xac, 0x32, 0x7a, 0x2d, 0x7d, 0xd8, 0xef, 0xb2, 0xf1, 0x27, 0x40,
	0x9c, 0x71, 0x88, 0xe7, 0x34, 0x94, 0x16, 0x7a, 0x95, 0x81, 0x05, 0x1a, 0x8a, 0x93, 0xa8, 0x56,
	0x7c, 0x02, 0x33, 0xa1, 0x6c, 0x79, 0x01, 0x6d, 0x5e, 0x24, 0x63, 0xeb, 0x8c, 0x16, 0x57, 0x6e,
	0x4c, 0x33, 0x79, 0x8f, 0xa8, 0xaf, 0xce, 0xe3, 0xfa, 0xb4, 0xb4, 0x21, 0xdc, 0x6b, 0x71, 0x17,
	0x66, 0xbc, 0x96, 0x1f, 0x84, 0xd2, 0x72, 0x02, 0xbf, 0xd9, 0xf6, 0x9c, 0xd8, 0x9c, 0x58, 0xce,
	0xad, 0xe4, 0x1b, 0x25, 0x26, 0x57, 0x15, 0xb5, 0xf2, 0xf3, 0x28, 0x94, 0xf5, 0x2a, 0x36, 0xed,
	0xd8, 0xbe, 0x58, 0x03, 0x77, 0x61, 0x2c, 0xee, 0x77, 0x25, 0x6d, 0xe8, 0xc5, 0xab, 0x6f, 0x10,
	0x20, 0xb5, 0x8e, 0xd1, 0xac, 0x75, 0xdc, 0x80, 0xa9, 0xd3, 0x20, 0x7c, 0x63, 0xc5, 0x5e, 0x87,
	0x37, 0x6d, 0xbc, 0x91, 0x47, 0xc2, 0xa1, 0xd7, 0x91, 0x62, 0x09, 0x20, 0x63, 0x32, 0xe3, 0xec,
	0x3e, 0x53, 0x0a, 0x9a, 0xe7, 0x89, 0x0c, 0x03, 0x72, 0xae, 0x13, 0x6c, 0x9e, 0xd8, 0x46, 0xcf,
	0x2a, 0x60, 0xcc, 0x95, 0x91, 0x63, 0x4e, 0xd2, 0xee, 0xd2, 0x7f, 0xb1, 0x08, 0x93, 0x9e, 0x13,
	0xf8, 0x78, 0x5e, 0xf2, 0x44, 0x9e, 0xc0, 0x66, 0xdd, 0xc5, 0xa9, 0x75, 0x02, 0x57, 0xb6, 0xcd,
	0x29, 0x22, 0x73, 0x03, 0xbd, 0xb7, 0x6c, 0x36, 0xa5, 0x13, 0x5b, 0xd4, 0x13, 0x10, 0x0f, 0x98,
	0xb4, 0x89, 0xfd, 0xad, 0xc1, 0x04, 0xb7, 0xc8, 0xf9, 0x16, 0xd6, 0xae, 0xab, 0xc5, 0x6f, 0xaa,
	0xbb, 0xa6, 0x46, 0x4c, 0x52, 0x5b, 0x43, 0x21, 0xc5, 0x02, 0x4c, 0xf8, 0x41, 0xec, 0x39, 0x92,
	0xdc, 0xef, 0x54, 0x43, 0xb5, 0x70, 0xbe, 0xb1, 0xd7, 0x8d, 0xc8, 0xc9, 0x4e, 0x35, 0xe8, 0xbf,
	0xf8, 0x18, 0xc6, 0x9c, 0x20, 0x62, 0x2f, 0x53, 0x58, 0x33, 0x54, 0xef, 0xd5, 0x20, 0x52, 0x7d,
	0x12, 0x57, 0xdc, 0x86, 0x82, 0xb6, 0x26, 0xcf, 0x8d, 0xcc, 0x85, 0xe4, 0x48, 0x83, 0x22, 0xd7,
	0xdd, 0x48, 0xdc, 0x04, 0xc8, 0x98, 0x1a, 0xfb, 0x95, 0xa9, 0x63, 0x6d, 0x63, 0x95, 0x7f, 0x18,
	0x81, 0x45, 0xbd, 0x65, 0x47, 0x74, 0x64, 0xd2, 0x0d, 0x7f, 0x0c, 0xd3, 0xda, 0x72, 0x2d, 0xda,
	0xe9, 0xdc, 0xe5, 0x3b, 0x5d, 0x3c, 0xce, 0xb4, 0x44, 0x05, 0xa6, 0x07, 0xcf, 0x30, 0x1f, 0xfa,
	0x42, 0x2b, 0x73, 0x7a, 0x6f, 0x02, 0xd0, 0x16, 0x66, 0x4d, 0x63, 0xea, 0x44, 0x5f, 0xae, 0x78,
	0x54, 0x3a, 0xe4, 0xe5, 0xed, 0xe8, 0x8d, 0x15, 0xc9, 0x1f, 0x7a, 0xd2, 0x77, 0xb4, 0x9d, 0x18,
	0xc8, 0x39, 0xb4, 0xa3, 0x37, 0x07, 0x8a, 0x2e, 0x96, 0xa0, 0x70, 0x6c, 0x5b, 0x7d, 0x69, 0x45,
	0xb1, 0xdd, 0x92, 0xca, 0x60, 0xa6, 0x8e, 0xed, 0xd7, 0xf2, 0x00, 0x09, 0x89, 0x51, 0x40, 0xc6,
	0x28, 0x04, 0x8c, 0xa1, 0x15, 0xd0, 0x16, 0x4e, 0x35, 0xe8, 0x3f, 0xfa, 0x61, 0xdc, 0x96, 0x66,
	0xdf, 0x0a, 0x42, 0x57, 0x86, 0xea, 0xa6, 0x2c, 0x30, 0x6d, 0x0f, 0x49, 0x95, 0x3f, 0x2f, 0xc3,
	0xec, 0x05, 0xfb, 0x8c, 0x4e, 0x3f, 0xd1, 0x16, 0xda, 0x31, 0x3a, 0xfe, 0x40, 0x36, 0xd5, 0x81,
	0x11, 0x9a, 0xf7, 0x92, 0x58, 0xd5, 0x40, 0x36, 0xc5, 0x0a, 0x18, 0xb1, 0x74, 0x4e, 0x06, 0xd0,
	0xac, 0xa8, 0x12, 0xd2, 0x33, 0xc8, 0x2d, 0x58, 0x1e, 0xee, 0xbb, 0x69, 0xc7, 0x5e, 0xab, 0x27,
	0x2d, 0xb7, 0x17, 0xda, 0xb1, 0x17, 0xf8, 0x4a, 0x83, 0x37, 0x07, 0xc7, 0x79, 0xc6, 0xa8, 0x4d,
	0x05, 0x12, 0xdf, 0xc1, 0x87, 0xd9, 0x21, 0xcf, 0x75, 0xc2, 0xfa, 0xbd, 0x96, 0x0e, 0x3f, 0xdc,
	0x41, 0x05, 0xa6, 0x23, 0x29, 0xdf, 0x58, 0x27, 0xb2, 0xdd, 0xb5, 0x1c, 0x37, 0x54, 0x17, 0x61,
	0x01, 0x89, 0xdb, 0xb2, 0xdd, 0xad, 0xba, 0xa1, 0xf8, 0x0c, 0x66, 0x53, 0x4c, 0xc7, 0x3e, 0xa3,
	0x23, 0x1e, 0xa9, 0xdb, 0xcf, 0xd0, 0xc8, 0x17, 0xf6, 0x19, 0x1e, 0xf5, 0x08, 0x77, 0xba, 0x85,
	0x93, 0xb6, 0xdc, 0xc0, 0xb7, 0x63, 0xa9, 0xd0, 0x6c, 0xa9, 0x06, 0x71, 0x36, 0x89, 0xc1, 0xe8,
	0xbb, 0x30, 0x93, 0xb9, 0x57, 0xe9, 0x5a, 0x7d, 0xc4, 0x3a, 0x8b, 0x92, 0x3b, 0x95, 0xae, 0xd4,
	0xfb, 0x20, 0x7c, 0x79, 0x9a, 0x5c, 0xc2, 0x41, 0x2f, 0xee, 0xf6, 0x62, 0xf3, 0x0b, 0xee, 0xd6,
	0x97, 0xa7, 0xea, 0x0a, 0xde, 0x23, 0x3a, 0x46, 0x3e, 0x59, 0xb4, 0xee, 0xfa, 0x4b, 0xbe, 0x7b,
	0x52, 0xb8, 0xee, 0xfd, 0x2b, 0x58, 0x3c, 0x0d, 0x7a, 0xbe, 0x2b, 0xdd, 0x73, 0x32, 0x5f, 0x71,
	0x68, 0xa0, 0xd8, 0x43, 0x72, 0xb7, 0xa0, 0xa8, 0xf1, 0xed, 0xc0, 0x76, 0xcd, 0xaf, 0x95, 0xfa,
	0x98, 0xb6, 0x13, 0xd8, 0xae, 0x58, 0x4b, 0x21, 0x18, 0x53, 0x99, 0x8f, 0x2f, 0x0e, 0xa9, 0xb4,
	0x0c, 0x12, 0xc4, 0x93, 0x54, 0x26, 0x8a, 0xed, 0xd8, 0x7c, 0x42, 0x8e, 0x63, 0x41, 0xc9, 0x1c,
	0x74, 0x43, 0x2f, 0xc6, 0x93, 0xa0, 0xdc, 0x87, 0x16, 0x45, 0x0a, 0x87, 0x1e, 0x14, 0x21, 0xb0,
	0x86, 0xbe, 0xd1, 0xa1, 0x07, 0xc6, 0x04, 0xac, 0x9c, 0xdb, 0x30, 0xcd, 0x10, 0xbd, 0xc4, 0xa7,
	0x84, 0x61, 0xb9, 0x8c, 0x46, 0x62, 0x0c, 0x4d, 0x53, 0x2f, 0x9d, 0xc0, 0xbf, 0x65, 0x8d, 0x20,
	0x3b, 0xbd, 0xef, 0xb5, 0xdc, 0xb7, 0x50, 0x3a, 0x09, 0x3a, 0xd2, 0x3a, 0xb5, 0xdb, 0x6d, 0x9e,
	0xfc, 0xaf, 0xaf, 0x9c, 0x7c, 0x11, 0xd1, 0x2f, 0xed, 0x76, 0x9b, 0x66, 0xff, 0x2d, 0x94, 0x68,
	0xd4, 0x54, 0xfa, 0x37, 0x57, 0x4b, 0x23, 0x3a, 0x91, 0xbe, 0x07, 0x82, 0x17, 0x26, 0xcf, 0xba,
	0x56, 0x57, 0x86, 0xd6, 0x49, 0xd0, 0x0b, 0xcd, 0xef, 0x68, 0xba, 0x33, 0xc4, 0xa9, 0x9d, 0x75,
	0xf7, 0x65, 0xb8, 0x1d, 0xf4, 0x42, 0x0c, 0xc0, 0x43, 0xe9, 0x84, 0x3d, 0x2f, 0x4e, 0xb7, 0x9c,
	0x62, 0xa9, 0xdf, 0x72, 0x00, 0xae, 0x98, 0x7a, 0xc3, 0x29, 0x8c, 0xba, 0x09, 0xa0, 0x34, 0x87,
	0x87, 0x7b, 0x9d, 0xdd, 0x12, 0xab, 0x0d, 0xcf, 0xf5, 0xe7, 0x90, 0x6f, 0xda, 0x6a, 0xcb, 0x36,
	0xae, 0x9c, 0xf7, 0x64, 0xd3, 0xe6, 0xed, 0xfa, 0x12, 0xc0, 0x69, 0x07, 0x91, 0x64, 0xa1, 0xea,
	0x95, 0x42, 0x53, 0x84, 0x24, 0xb1, 0xdf, 0x82, 0x41, 0x1a, 0xca, 0x1a, 0x49, 0xed, 0x4a, 0xe1,
	0x12, 0x2a, 0x29, 0x63, 0x27, 0x0f, 0x61, 0x2e, 0xdd, 0xa7, 0xa6, 0x77, 0x66, 0xb9, 0x76, 0x07,
	0x7d, 0xed, 0x33, 0x3e, 0x22, 0x7a, 0x57, 0x9e, 0x79, 0x67, 0x9b, 0xc4, 0x40, 0x81, 0x74, 0x6b,
	0x32, 0x02, 0x5b, 0x2c, 0xa0, 0x37, 0x22, 0x15, 0xc0, 0xb0, 0x7c, 0xf0, 0xb4, 0x6e, 0xab, 0xb0,
	0x7c, 0xe0, 0xa8, 0xde, 0x86, 0xe9, 0x66, 0x10, 0x3a, 0x52, 0x2f, 0xc6, 0xac, 0xb3, 0x35, 0x12,
	0x51, 0xcd, 0x58, 0xdc, 0x87, 0x49, 0x6d, 0x7d, 0x72, 0x79, 0x74, 0xa5, 0xb0, 0x26, 0xd4, 0x32,
	0xd7, 0x3b, 0xb8, 0x31, 0x4a, 0xa9, 0x0a, 0x22, 0xbe, 0x83, 0x32, 0x72, 0xa5, 0x13, 0x4b, 0x37,
	0xb1, 0xda, 0x26, 0xa9, 0xe7, 0x22, 0x39, 0x23, 0x01, 0x6b, 0x23, 0x5e, 0x85, 0x09, 0x35, 0xe5,
	0xd6, 0xa5, 0x52, 0x0a, 0x21, 0x9e, 0x40, 0x89, 0xff, 0x25, 0x23, 0x9d, 0x5c, 0x2a, 0x33, 0xcd,
	0x48, 0x3d, 0xcc, 0x43, 0x28, 0x28, 0x51, 0xba, 0x8f, 0x3d, 0xba, 0x8f, 0x4b, 0xda, 0x33, 0xc8,
	0x88, 0xae, 0x62, 0x60, 0x08, 0x5d, 0xc4, 0x8f, 0xc1, 0x68, 0xda, 0x61, 0xc7, 0xca, 0x4a, 0xfd,
	0xe1, 0x42, 0xa9, 0x12, 0xe2, 0xf6, 0x52, 0xc9, 0x47, 0x50, 0xc8, 0x48, 0x9a, 0x6f, 0x2e, 0x9d,
	0x22, 0xa4, 0x82, 0xe2, 0x63, 0x18, 0x8d, 0xed, 0x33, 0xb3, 0x7d, 0xa9, 0xc6, 0x91, 0x2d, 0x36,
	0x01, 0x53, 0x20, 0xe9, 0x5a, 0xae, 0x6c, 0x4a, 0x5f, 0x9b, 0x72, 0xe7, 0x4a, 0x6b, 0x34, 0x48,
	0x62, 0x93, 0x05, 0xc8, 0x1e, 0x37, 0xa0, 0xcc, 0xbd, 0xd8, 0x51, 0xe4, 0x45, 0x31, 0x77, 0xe2,
	0x5f, 0xd9, 0xc9, 0x0c, 0x09, 0xac, 0x13, 0x9e, 0xfa, 0x78, 0x02, 0xd7, 0x92, 0x7b, 0x15, 0x43,
	0x2a, 0x2b, 0x94, 0x6e, 0xcf, 0x91, 0x7c, 0x5a, 0x03, 0x32, 0xab, 0x05, 0x0d, 0xc0, 0xe8, 0xab,
	0x41, 0x6c, 0x75, 0x74, 0xe7, 0xe9, 0x26, 0x3d, 0x27, 0xd6, 0x55, 0x19, 0xbc, 0x74, 0x4e, 0x86,
	0x44, 0x5e, 0xc0, 0x22, 0xcf, 0xd8, 0x09, 0xba, 0xfd, 0xc1, 0xc5, 0xff, 0x70, 0xe5, 0xbc, 0xe7,
	0x48, 0xac, 0x1a, 0x74, 0xfb, 0x19, 0x05, 0x54, 0xfe, 0x7b, 0x14, 0x8c, 0x4c, 0x3a, 0x74, 0x55,
	0x26, 0xb6, 0x0d, 0xb7, 0x3a, 0xc1, 0x5b, 0x95, 0x74, 0x84, 0x32, 0x8a, 0x31, 0x09, 0xa0, 0xd3,
	0x7c, 0x2e, 0x31, 0xbb, 0x89, 0x40, 0xcc, 0x41, 0x1a, 0x0c, 0xdb, 0x0e, 0x3a, 0xd9, 0x24, 0xcd,
	0x81, 0xcf, 0x8e, 0x7b, 0xfd, 0xac, 0x93, 0xd7, 0xdd, 0xe9, 0x18, 0xc2, 0x3a, 0xf5, 0xe2, 0x93,
	0xcf, 0xad, 0x7e, 0xcf, 0xf6, 0x8f, 0xed, 0x80, 0xc3, 0x92, 0x8d, 0x11, 0x33, 0xd7, 0x58, 0x39,
	0xee, 0xf5, 0xd3, 0x9e, 0x54, 0xf7, 0x3a, 0xb0, 0x78, 0x89, 0x42, 0xaf, 0x59, 0x46, 0xbc, 0x86,
	0xd5, 0xf7, 0x1b, 0x84, 0x82, 0x64, 0x8e, 0x59, 0xee, 0xbc, 0xb3, 0x77, 0xdc, 0x0d, 0xcc, 0x49,
	0x75, 0x5f, 0xe7, 0x12, 0x8c, 0xb2, 0xe2, 0x64, 0x96, 0xfb, 0x1a, 0x56, 0xdf, 0xa9, 0xb8, 0x34,
	0x7a, 0xe2, 0x4c, 0xe4, 0xce, 0x95, 0x1a, 0x4c, 0x22, 0xa9, 0xc7, 0x50, 0xc2, 0x28, 0x2c, 0x3a,
	0x09, 0xba, 0x56, 0x37, 0xf4, 0x7e, 0x94, 0x94, 0xb1, 0x14, 0xd6, 0xca, 0xca, 0x08, 0xf6, 0x91,
	0xa6, 0xbc, 0x80, 0x06, 0x12, 0xad, 0xf2, 0x9f, 0xa3, 0x30, 0x77, 0xe8, 0xc9, 0xe7, 0x9e, 0xed,
	0xb7, 0xf6, 0xdf, 0xbd, 0xf9, 0xab, 0x50, 0xc6, 0x20, 0xac, 0x19, 0x84, 0x2d, 0x8a, 0xe4, 0x29,
	0xbc, 0xe2, 0xcd, 0x9e, 0xe9, 0xd8, 0x67, 0xcf, 0x98, 0xce, 0xd1, 0xd5, 0x37, 0x70, 0x2d, 0x94,
	0x4e, 0xf0, 0x56, 0x86, 0xfd, 0x44, 0x60, 0x28, 0xc2, 0x5c, 0xd4, 0x00, 0x25, 0x98, 0x2c, 0xe8,
	0x4b, 0x98, 0x77, 0x30, 0xe6, 0x57, 0x62, 0x54, 0x8f, 0xb2, 0xba, 0x41, 0x64, 0x8e, 0x25, 0x89,
	0x89, 0x70, 0x6c, 0x5f, 0x89, 0xd5, 0x90, 0xbd, 0x1f, 0x44, 0xe2, 0x01, 0x94, 0xcf, 0x89, 0x99,
	0xe3, 0x89, 0xc8, 0xcc, 0x90, 0x88, 0xd8, 0x80, 0x0f, 0x55, 0xc5, 0xe9, 0xe2, 0xd1, 0x26, 0x12,
	0x51, 0x93, 0x71, 0xd5, 0xf3, 0x63, 0x3e, 0x05, 0xf3, 0xb2, 0x3e, 0xcc, 0xc9, 0x44, 0x7e, 0xfe,
	0x42, 0x79, 0xf1, 0x04, 0x16, 0x95, 0x30, 0x0f, 0xea, 0x4b, 0xe9, 0xaa, 0x2c, 0x26, 0x9f, 0x56,
	0x55, 0x18, 0x42, 0x12, 0xbb, 0x52, 0xba, 0x3b, 0xaa, 0x22, 0x32, 0x8b, 0x03, 0x06, 0xbe, 0xb4,
	0xde, 0xc8, 0x44, 0xc3, 0x94, 0x7c, 0xe6, 0x1b, 0x86, 0x63, 0xfb, 0x7b, 0xbe, 0xfc, 0x9d, 0xd4,
	0x9a, 0xad, 0xfc, 0xdd, 0x18, 0xcc, 0x1e, 0x4a, 0xe7, 0xc4, 0x0f, 0xda, 0x41, 0xab, 0x7f, 0x79,
	0x26, 0x2e, 0x60, 0xcc, 0xb7, 0x3b, 0x9c, 0x89, 0x4f, 0x35, 0xe8, 0xbf, 0xb8, 0xad, 0xb2, 0xf3,
	0x51, 0xf2, 0xf6, 0x33, 0xca, 0xa8, 0xb0, 0xb7, 0x4c, 0x66, 0xae, 0x53, 0xa0, 0xb1, 0x4c, 0x0a,
	0x34, 0x07, 0xe3, 0xad, 0x30, 0xe8, 0x75, 0xd5, 0xa1, 0xe0, 0x46, 0x6a, 0x5a, 0x13, 0x59, 0xd3,
	0x4a, 0xf3, 0xe0, 0xc9, 0xf7, 0xce, 0x83, 0x75, 0x2a, 0x96, 0xcf, 0xa4, 0x62, 0xd7, 0x21, 0x9f,
	0xa4, 0x78, 0x53, 0x5c, 0x0a, 0xd0, 0x6d, 0x4c, 0xf5, 0x3d, 0x3f, 0xb6, 0x68, 0x9e, 0xc0, 0xa9,
	0xbe, 0xe7, 0xc7, 0x75, 0x9c, 0xea, 0x17, 0x30, 0x97, 0x94, 0x53, 0xb4, 0x1b, 0xc7, 0x4c, 0xb8,
	0x90, 0x1a, 0x9c, 0x2e, 0xaa, 0x28, 0x36, 0x66, 0xc4, 0xf7, 0x41, 0x97, 0x5a, 0x2c, 0xf2, 0xe0,
	0x28, 0x51, 0x4c, 0x24, 0x4a, 0x8a, 0x87, 0x9a, 0x42, 0xf4, 0x12, 0x14, 0xbc, 0xc8, 0x3a, 0xf6,
	0x5a, 0x04, 0xa6, 0x2c, 0x3d, 0xdf, 0x98, 0xf2, 0xa2, 0x0d, 0xaf, 0x85, 0x90, 0xf7, 0x4c, 0xd5,
	0x07, 0x8a, 0x1d, 0x0b, 0x43, 0xc5, 0x8e, 0x0a, 0x4c, 0xfb, 0xf2, 0x4c, 0x17, 0x75, 0x3d, 0x57,
	0x57, 0xff, 0x90, 0x48, 0x76, 0x53, 0x77, 0xb1, 0x03, 0x3c, 0xc4, 0xbc, 0x07, 0x26, 0x77, 0xd0,
	0xb1, 0xcf, 0x38, 0x89, 0x5f, 0x87, 0x1b, 0x14, 0x6e, 0xba, 0xc1, 0xa9, 0x4f, 0x2e, 0x62, 0x53,
	0x46, 0xce, 0x95, 0xe6, 0x42, 0x3b, 0x30, 0x92, 0xee, 0x40, 0xe5, 0x5f, 0xcb, 0x50, 0xde, 0x96,
	0x61, 0xa0, 0x77, 0x8e, 0x25, 0x05, 0x8c, 0xb5, 0x82, 0xb6, 0x96, 0xa5, 0xff, 0x48, 0x6b, 0x06,
	0x81, 0xab, 0x3c, 0x08, 0xfd, 0x47, 0xda, 0x29, 0xd2, 0xd8, 0x43, 0xd0, 0x7f, 0xb4, 0x98, 0x28,
	0x0e, 0x7c, 0x9d, 0xb3, 0x73, 0x03, 0xb3, 0x0d, 0xec, 0x25, 0x09, 0x7d, 0x26, 0x54, 0x61, 0x20,
	0x68, 0xbb, 0x99, 0x14, 0x09, 0x3b, 0x4d, 0x20, 0x93, 0x0c, 0x41, 0x5a, 0x06, 0x72, 0x9a, 0x85,
	0xe4, 0x19, 0x72, 0x9a, 0x81, 0xdc, 0x86, 0x69, 0x1a, 0x31, 0xc1, 0xb0, 0x5d, 0x15, 0x89, 0xa8,
	0x41, 0x37, 0x60, 0x2a, 0xb2, 0x9b, 0xd2, 0xa2, 0x45, 0x16, 0x94, 0xe1, 0xd9, 0x4d, 0xb9, 0x85,
	0x0b, 0xd5, 0x4c, 0x5a, 0x6d, 0x31, 0x65, 0x3e, 0xc3, 0xd5, 0x69, 0x26, 0x2d, 0x7b, 0x3a, 0x65,
	0xbe, 0x44, 0xe6, 0x4d, 0x00, 0x62, 0xf2, 0xfa, 0x4b, 0x1c, 0xf5, 0x23, 0xe5, 0x80, 0x74, 0x70,
	0xef, 0xa2, 0x68, 0x73, 0x86, 0x13, 0xd3, 0x73, 0x91, 0xe5, 0x23, 0x98, 0x53, 0xc9, 0x3a, 0x5e,
	0x3f, 0x96, 0xf4, 0x5d, 0x36, 0xa2, 0xb4, 0x50, 0x5e, 0x66, 0x3e, 0xde, 0x36, 0x35, 0xdf, 0x25,
	0x8b, 0x5a, 0x07, 0xbc, 0xcb, 0x82, 0x1e, 0x46, 0xc9, 0x49, 0x95, 0xb2, 0x4c, 0x51, 0x99, 0xb6,
	0xd0, 0xba, 0x1f, 0x3f, 0x5a, 0xdb, 0xb7, 0xbd, 0x90, 0xee, 0x66, 0x43, 0xc3, 0xf5, 0x41, 0x11,
	0x4b, 0x99, 0xfa, 0xa6, 0x48, 0xc6, 0x4a, 0x4b, 0x99, 0x9b, 0x50, 0x4a, 0x86, 0xe8, 0x06, 0x9e,
	0x1f, 0x9b, 0xb3, 0xd4, 0xff, 0x4d, 0xd5, 0x3f, 0x1a, 0x53, 0x43, 0x01, 0xf6, 0x91, 0xaf, 0xae,
	0xb2, 0x30, 0x4b, 0x13, 0x0f, 0x61, 0xc2, 0xf1, 0x62, 0x4f, 0x46, 0x54, 0x81, 0x2f, 0xac, 0x2d,
	0x2a, 0xe9, 0xbd, 0x5e, 0x2c, 0xc3, 0x2a, 0x71, 0x94, 0xf7, 0x60, 0x98, 0xa8, 0x00, 0xc4, 0x89,
	0x47, 0x34, 0xe7, 0xd3, 0x92, 0x57, 0x4a, 0x45, 0xef, 0x9e, 0xb6, 0x86, 0xd4, 0x96, 0x16, 0xc9,
	0xe6, 0x53, 0x4c, 0x56, 0x75, 0x83, 0x95, 0xc7, 0xeb, 0xe7, 0x2a, 0x8f, 0x77, 0xa0, 0x84, 0x07,
	0x31, 0x83, 0xb9, 0xc1, 0x49, 0x4a, 0xc7, 0x3e, 0xcb, 0x04, 0x0e, 0x77, 0x61, 0xa6, 0x8d, 0x91,
	0x61, 0x06, 0xf7, 0x21, 0x97, 0x29, 0xda, 0xec, 0x1a, 0x34, 0xf0, 0xb2, 0xb2, 0xd1, 0x47, 0xbf,
	0xa8, 0x6c, 0xb4, 0xfc, 0x47, 0x97, 0x8d, 0x6e, 0xfd, 0x5f, 0x94, 0x8d, 0x2a, 0xef, 0x2a, 0x1b,
	0x71, 0xce, 0x96, 0x89, 0x3f, 0x6e, 0x27, 0x39, 0x5b, 0x1a, 0x7c, 0xac, 0x42, 0x59, 0x83, 0xc8,
	0x1f, 0xd2, 0x86, 0x7d, 0xcc, 0x81, 0x8a, 0x62, 0xec, 0xca, 0xb3, 0x98, 0xb6, 0x69, 0x0b, 0x16,
	0x08, 0xe3, 0x04, 0xed, 0xb6, 0x74, 0x18, 0xcb, 0xe9, 0xcd, 0x1d, 0x2a, 0x97, 0x0c, 0xa5, 0x37,
	0xb4, 0xe3, 0xb3, 0x28, 0x51, 0x65, 0x01, 0xec, 0x84, 0xf2, 0x9c, 0x07, 0x50, 0x3e, 0xd7, 0x91,
	0xf9, 0x49, 0x1a, 0x7e, 0x0c, 0xc9, 0xa0, 0x2a, 0x5c, 0xdb, 0x6b, 0x93, 0x5d, 0xb1, 0xf5, 0x67,
	0x25, 0x23, 0xf3, 0x2e, 0xab, 0x82, 0x30, 0xda, 0xfe, 0x33, 0xf2, 0x91, 0xf8, 0x02, 0x00, 0x0f,
	0xb6, 0x25, 0xdf, 0x4a, 0x3f, 0x36, 0x57, 0xc8, 0xec, 0xe7, 0xf5, 0xb5, 0xe1, 0xc5, 0xfd, 0xda,
	0x5b, 0xe9, 0x27, 0xf9, 0xbb, 0x6e, 0xa3, 0x87, 0x8d, 0xbc, 0x96, 0x6f, 0x7e, 0xca, 0x3e, 0x1b,
	0xff, 0xa3, 0x87, 0x7d, 0x1b, 0x78, 0x8e, 0x34, 0x57, 0x97, 0x73, 0x2b, 0xc5, 0x06, 0x37, 0xc4,
	0x56, 0xe6, 0xec, 0xd3, 0xc1, 0xb4, 0xde, 0xae, 0x99, 0xf7, 0x68, 0x98, 0x1b, 0xa9, 0x52, 0xd2,
	0x33, 0xf8, 0x27, 0x6b, 0x2a, 0x39, 0x0a, 0x07, 0xa9, 0x38, 0xe4, 0x1f, 0x6c, 0x57, 0x9a, 0xf7,
	0xd9, 0xa9, 0xe3, 0x7f, 0xbc, 0x8c, 0xf1, 0xd7, 0x0a, 0x42, 0x69, 0x7e, 0xc6, 0x97, 0x31, 0xb6,
	0xf7, 0x42, 0x29, 0x56, 0x61, 0xc6, 0x97, 0xa7, 0x49, 0x30, 0x85, 0xa1, 0xd8, 0x83, 0x44, 0x8d,
	0xd3, 0xbe, 0x3c, 0x55, 0x51, 0x0d, 0xc6, 0x5f, 0xb7, 0xa0, 0x78, 0xe2, 0x61, 0x70, 0xdc, 0xb7,
	0x68, 0x88, 0xcf, 0xd9, 0x7f, 0x2b, 0xda, 0x73, 0x1c, 0x69, 0x15, 0xca, 0x71, 0xe0, 0xda, 0x7d,
	0x2b, 0x38, 0xa6, 0xef, 0x57, 0x84, 0x5b, 0x53, 0x95, 0x19, 0x64, 0xec, 0x11, 0x9d, 0xb0, 0xf7,
	0xc1, 0x50, 0x96, 0x99, 0xd4, 0x1d, 0xcd, 0x47, 0xcb, 0xa3, 0x2b, 0x79, 0xbe, 0xd1, 0x99, 0x77,
	0xa0, 0xea, 0x8e, 0x18, 0x35, 0x64, 0xdc, 0x43, 0x2a, 0xf1, 0x45, 0x22, 0x21, 0x52, 0x7e, 0x22,
	0xf5, 0x25, 0x2c, 0xf2, 0xbe, 0x73, 0x55, 0x53, 0x76, 0x8e, 0x65, 0xa8, 0xb6, 0x9c, 0x8b, 0x84,
	0x73, 0xc4, 0xa6, 0xca, 0x26, 0x31, 0xf5, 0x6e, 0x2f, 0x38, 0xfa, 0x6a, 0x1e, 0xb4, 0x31, 0xae,
	0xfc, 0xcd, 0x25, 0xdc, 0xac, 0x91, 0x7d, 0x09, 0x8b, 0x5e, 0x94, 0xc0, 0x23, 0x69, 0x47, 0x81,
	0xaf, 0x92, 0x84, 0x27, 0x14, 0x80, 0xcc, 0x79, 0x91, 0xc2, 0x1f, 0x10, 0x93, 0x6e, 0x7d, 0xb1,
	0x06, 0xf3, 0x49, 0x4a, 0x31, 0x30, 0x16, 0xd7, 0xf4, 0x66, 0x35, 0x33, 0x3b, 0xd4, 0x95, 0x29,
	0xf0, 0xd3, 0x3f, 0x2e, 0x05, 0xfe, 0xf6, 0xd2, 0x14, 0xf8, 0x31, 0x2c, 0xa8, 0x9d, 0xb2, 0xdb,
	0xa7, 0x76, 0x3f, 0xb2, 0xf4, 0x77, 0x61, 0xf3, 0xd7, 0x89, 0xf6, 0xd5, 0x7d, 0xb7, 0x4e, 0x80,
	0x23, 0xc5, 0x17, 0x5f, 0x27, 0x92, 0xf4, 0xc5, 0x2f, 0x8a, 0xed, 0x50, 0x2d, 0xee, 0x37, 0x89,
	0x95, 0xcd, 0x32, 0x62, 0x27, 0x70, 0xde, 0x1c, 0x20, 0x1f, 0x17, 0x58, 0xf9, 0xc7, 0x1c, 0x2c,
	0x64, 0x23, 0x9b, 0xbd, 0xf8, 0x44, 0x86, 0x1c, 0xde, 0xfc, 0x7f, 0xfb, 0xfa, 0xf7, 0x3e, 0xc4,
	0x95, 0xbf, 0xcf, 0xc1, 0xdc, 0x45, 0xa7, 0x54, 0x6c, 0x9f, 0xbb, 0x76, 0x73, 0x74, 0xed, 0xde,
	0xd2, 0xa5, 0x03, 0xcf, 0x6f, 0xb5, 0xe5, 0x85, 0x07, 0x7c, 0xe8, 0xea, 0xbd, 0x01, 0x53, 0xa1,
	0xd4, 0xdf, 0x9b, 0x39, 0x98, 0xcb, 0x87, 0x52, 0x7d, 0x6c, 0xbe, 0x0f, 0x42, 0x7f, 0x23, 0xb4,
	0x52, 0x94, 0xfa, 0x50, 0xa9, 0x39, 0x0d, 0x85, 0xae, 0xfc, 0x55, 0x0e, 0xae, 0x5f, 0x3e, 0xb0,
	0xf8, 0x14, 0xb0, 0xe3, 0xec, 0x27, 0xa4, 0xe1, 0xe2, 0xd3, 0x64, 0xc8, 0x7f, 0xf0, 0x9e, 0x08,
	0x42, 0xaf, 0x95, 0x56, 0xa3, 0x39, 0x78, 0x2c, 0x32, 0x51, 0x55, 0x99, 0x3e, 0x82, 0x42, 0x28,
	0xed, 0xb6, 0x86, 0xa8, 0xaf, 0x83, 0x48, 0x62, 0x40, 0xe5, 0x47, 0x28, 0x0d, 0x7a, 0x52, 0x74,
	0x38, 0xb6, 0xe3, 0xc8, 0xae, 0xf6, 0xd2, 0x1c, 0xd0, 0x16, 0x98, 0x96, 0xdc, 0x3e, 0x98, 0x9b,
	0xc9, 0x33, 0xe7, 0xc4, 0xf6, 0x5b, 0xfc, 0x19, 0x42, 0xa7, 0xc9, 0x8e, 0xed, 0xd7, 0x14, 0x9d,
	0x0e, 0xcd, 0x35, 0xc8, 0x93, 0xfb, 0xc6, 0x60, 0x9d, 0x95, 0x32, 0x49, 0xed, 0xba, 0x5b, 0xf9,
	0xeb, 0x1c, 0x88, 0x64, 0xf0, 0x5f, 0x14, 0x83, 0x8b, 0x7b, 0x2a, 0x95, 0x18, 0x1d, 0x08, 0x85,
	0xaa, 0x41, 0xe7, 0xd8, 0xf3, 0xe5, 0x70, 0x46, 0x71, 0x17, 0xc6, 0xd9, 0x21, 0x8c, 0x5d, 0x56,
	0x35, 0x60, 0x7e, 0xe5, 0x2f, 0xb3, 0x13, 0x7a, 0xe1, 0x45, 0x2a, 0xb4, 0x57, 0x09, 0x45, 0x56,
	0x1d, 0x98, 0x50, 0xb0, 0x2e, 0x3e, 0xc5, 0x14, 0x89, 0xb2, 0xfc, 0xf4, 0x8e, 0x57, 0xaa, 0x50,
	0xf4, 0xe4, 0x66, 0x5f, 0x05, 0xf5, 0x65, 0xfe, 0xfc, 0x17, 0xed, 0x19, 0x66, 0x24, 0x1f, 0xb4,
	0x2b, 0xfb, 0x60, 0xbe, 0x54, 0x2e, 0xa8, 0x21, 0x9b, 0xa1, 0x8c, 0x4e, 0x92, 0x55, 0x9d, 0x53,
	0x90, 0xce, 0xab, 0x46, 0xae, 0xca, 0xab, 0x2a, 0xff, 0x93, 0x83, 0xf2, 0x81, 0x7a, 0xb4, 0xf1,
	0xcb, 0xf2, 0xe3, 0x05, 0x98, 0x88, 0xed, 0xb0, 0x25, 0xb5, 0x55, 0xab, 0x16, 0x7d, 0x8e, 0x45,
	0x43, 0x65, 0xab, 0xe2, 0x34, 0xb9, 0x04, 0x23, 0x51, 0x57, 0xe5, 0x21, 0x23, 0x51, 0x37, 0xb3,
	0xe6, 0xcc, 0x17, 0xcc, 0x7c, 0x76, 0xcd, 0xc9, 0x23, 0x21, 0x94, 0x75, 0x5c, 0x95, 0x7c, 0x8c,
	0x38, 0x2e, 0x1a, 0x2f, 0xdf, 0x6b, 0xfc, 0xb6, 0x82, 0x33, 0x5a, 0x20, 0x12, 0x3f, 0x1e, 0xb9,
	0xe8, 0xb3, 0xa4, 0xb6, 0x96, 0x62, 0x26, 0x63, 0xfb, 0x9b, 0x11, 0xf6, 0x6b, 0xe7, 0x83, 0x6c,
	0xdc, 0xdb, 0x36, 0x3d, 0x5d, 0xb0, 0x12, 0x35, 0xe4, 0x99, 0x50, 0xa7, 0x09, 0x64, 0x92, 0x65,
	0xfd, 0x34, 0xe9, 0x38, 0x49, 0x90, 0xe9, 0x0c, 0x72, 0xb9, 0xd8, 0xee, 0x64, 0x8e, 0x7d, 0x91,
	0x89, 0x5c, 0xcd, 0x15, 0x9f, 0xc0, 0x8c, 0x02, 0x25, 0x9f, 0x4d, 0xf8, 0xa8, 0x2a, 0x59, 0xfd,
	0xd1, 0xe4, 0xce, 0xb9, 0x62, 0xf7, 0x78, 0x16, 0xa6, 0xb3, 0x9c, 0x25, 0x00, 0xed, 0x55, 0xa4,
	0xab, 0x5e, 0x25, 0x64, 0x28, 0xa8, 0xf1, 0xd4, 0xbc, 0x2c, 0x75, 0x65, 0x4c, 0x12, 0x6c, 0x26,
	0xf9, 0x98, 0xbd, 0x43, 0xe4, 0xca, 0x3a, 0x18, 0xc3, 0xe9, 0x83, 0xf8, 0x2c, 0xc9, 0x33, 0xd8,
	0x5d, 0xce, 0x0f, 0xe5, 0x19, 0xfd, 0x81, 0x2c, 0xa3, 0x12, 0x42, 0x69, 0x90, 0x23, 0x96, 0xa1,
	0x48, 0x51, 0x9b, 0x6b, 0xc7, 0x76, 0xaa, 0x55, 0x8a, 0xe4, 0xd0, 0xee, 0xea, 0xae, 0xb8, 0x05,
	0x90, 0x28, 0x3d, 0xa2, 0x27, 0x21, 0x7c, 0x29, 0x4d, 0x69, 0xcd, 0x47, 0xb8, 0x2f, 0xd4, 0x49,
	0x52, 0x98, 0x19, 0x6f, 0xe4, 0x91, 0x80, 0xae, 0xaf, 0xf2, 0xf3, 0x28, 0x88, 0x64, 0xd0, 0x5f,
	0x66, 0xcb, 0xda, 0x3c, 0x46, 0x33, 0xce, 0xe4, 0xb2, 0xd7, 0x34, 0x63, 0x97, 0xbd, 0xa6, 0x59,
	0x86, 0x22, 0xc1, 0xf5, 0x43, 0x09, 0x7e, 0x1d, 0x03, 0x48, 0xab, 0xf3, 0x63, 0x89, 0x8f, 0xf5,
	0x6b, 0xaf, 0x04, 0x33, 0x41, 0x98, 0x22, 0x53, 0x15, 0xea, 0x29, 0x98, 0x4d, 0x2f, 0x8c, 0x92,
	0x37, 0x6a, 0xac, 0x13, 0xd4, 0x5b, 0x94, 0xad, 0xad, 0x11, 0x86, 0xb7, 0x8d, 0x10, 0xb8, 0xe2,
	0x48, 0x3c, 0x85, 0x71, 0x9c, 0x7d, 0x44, 0x95, 0xb4, 0xc2, 0xda, 0x9d, 0xe1, 0x6d, 0x4a, 0x5e,
	0xa5, 0x64, 0x0b, 0x1c, 0x0d, 0x96, 0xc1, 0xc4, 0x48, 0xbd, 0x83, 0xa1, 0x67, 0x1c, 0xf4, 0xc6,
	0x87, 0xdf, 0x75, 0x94, 0x98, 0xfe, 0x02, 0xc9, 0x0d, 0x19, 0x89, 0x07, 0x30, 0xab, 0x9d, 0x96,
	0x6c, 0x06, 0xa1, 0xb4, 0x3c, 0xfa, 0x32, 0xc5, 0xaf, 0x03, 0x94, 0x6e, 0x36, 0x88, 0x53, 0xa7,
	0x2f, 0x53, 0xe9, 0x4b, 0x23, 0xbb, 0x19, 0xcb, 0x50, 0xc1, 0x0b, 0xd9, 0x97, 0x46, 0xeb, 0xc8,
	0x60, 0xf4, 0x47, 0x50, 0x50, 0x68, 0x75, 0x68, 0x47, 0x51, 0x91, 0x4c, 0xc2, 0x89, 0x57, 0x6c,
	0x58, 0xba, 0x7a, 0x45, 0xc9, 0x2e, 0xe7, 0x32, 0xbb, 0x9c, 0x79, 0xc4, 0x32, 0x32, 0xf0, 0x88,
	0xe5, 0x82, 0xed, 0xaf, 0xfc, 0xd7, 0x28, 0x98, 0xc9, 0x18, 0xa9, 0x86, 0x2f, 0xb6, 0xa9, 0x05,
	0x98, 0xe0, 0x6d, 0x52, 0xde, 0x40, 0xb5, 0xc4, 0xc7, 0x43, 0x26, 0x41, 0x03, 0x50, 0xbd, 0x20,
	0x6b, 0x16, 0x2b, 0xe7, 0xcc, 0x62, 0x2c, 0xc1, 0x0d, 0x9a, 0xc6, 0xed, 0x41, 0xd7, 0x33, 0x9e,
	0x7c, 0x1a, 0xc8, 0xba, 0x9f, 0x27, 0x70, 0x4d, 0xbf, 0x1a, 0xd3, 0x65, 0xba, 0xd4, 0x99, 0x71,
	0xb9, 0x68, 0x41, 0x01, 0x1a, 0xcc, 0xdf, 0xd1, 0xae, 0x6d, 0x0d, 0x66, 0x87, 0x45, 0xf1, 0x2c,
	0xa6, 0x56, 0x57, 0x1e, 0x14, 0x54, 0xef, 0x63, 0xd2, 0xe2, 0x9b, 0x72, 0xe2, 0x53, 0x49, 0xe5,
	0x4d, 0x2c, 0x28, 0xdd, 0x4e, 0x25, 0x4b, 0xd2, 0x77, 0x75, 0xb9, 0xe3, 0xb5, 0xbd, 0xd8, 0x0e,
	0xfb, 0x69, 0x85, 0x05, 0xd4, 0xeb, 0x14, 0xc5, 0x48, 0x6a, 0x29, 0xf7, 0xa0, 0x2c, 0x9d, 0xc0,
	0x0f, 0x3a, 0x9e, 0x93, 0x82, 0xb9, 0xdc, 0x64, 0x68, 0x46, 0x02, 0xfe, 0x06, 0x0c, 0x1d, 0x81,
	0xf4, 0xbb, 0x92, 0x3f, 0x71, 0x14, 0x2f, 0xb9, 0x04, 0x4b, 0x2a, 0x26, 0xe9, 0x77, 0x29, 0x3e,
	0x58, 0xfd, 0x79, 0x14, 0x8a, 0xd9, 0x67, 0x39, 0x62, 0x11, 0x66, 0xeb, 0xfe, 0x5b, 0xbb, 0xed,
	0xb9, 0x59, 0xb2, 0xf1, 0x81, 0x28, 0xc0, 0xe4, 0xd6, 0xd1, 0xfa, 0xae, 0xf5, 0xec, 0xc8, 0x18,
	0xc1, 0x46, 0x75, 0x7d, 0x77, 0xcb, 0xfa, 0xdd, 0x91, 0x31, 0x2a, 0x8a, 0x90, 0x7f, 0x5e, 0x3f,
	0xb2, 0x90, 0x6b, 0x8c, 0x51, 0xeb, 0x68, 0xd7, 0x7a, 0x5d, 0xdf, 0xdd, 0x32, 0xc6, 0xc5, 0x0c,
	0x14, 0xaa, 0xdb, 0xb5, 0xdd, 0x2d, 0xeb, 0xf7, 0xf5, 0xf5, 0xdd, 0x2d, 0x63, 0x02, 0xd9, 0x07,
	0xdb, 0x47, 0xd6, 0x6b, 0x04, 0x4f, 0x0a, 0x03, 0x8a, 0x2f, 0xd7, 0xeb, 0xd6, 0xc1, 0x76, 0x9d,
	0x29, 0x79, 0xa4, 0x1c, 0xd6, 0x6b, 0xd6, 0x73, 0x84, 0x5b, 0xfb, 0x47, 0xc6, 0x94, 0x28, 0xc3,
	0xf4, 0xab, 0xfa, 0x91, 0xb5, 0x53, 0x5f, 0xdf, 0xe5, 0x31, 0x40, 0x4c, 0xc3, 0x14, 0x8a, 0x54,
	0xb7, 0xb1, 0xcf, 0x02, 0x36, 0x5f, 0xd5, 0x77, 0xb7, 0x78, 0xcc, 0xa2, 0x00, 0x98, 0x78, 0xb1,
	0x6e, 0x55, 0xb7, 0x6b, 0xc6, 0x34, 0x0a, 0x6f, 0xed, 0xed, 0x6c, 0x5a, 0xfb, 0x8d, 0xbd, 0xcd,
	0xa3, 0x6a, 0xad, 0x61, 0xcc, 0x23, 0xe9, 0xd9, 0xde, 0x5e, 0x86, 0xb4, 0x80, 0xa4, 0x97, 0x03,
	0xa4, 0x45, 0x21, 0xa0, 0x74, 0x70, 0xb8, 0xb7, 0x5b, 0x4b, 0x69, 0x26, 0xcd, 0xbd, 0x6e, 0x1d,
	0x1e, 0xa1, 0x0e, 0x96, 0x70, 0xa6, 0xdf, 0x6f, 0x1f, 0x59, 0x1b, 0x7a, 0x1e, 0x1f, 0xa1, 0x4c,
	0x55, 0xad, 0x86, 0x48, 0x35, 0x63, 0x59, 0xcc, 0xc2, 0xcc, 0xf3, 0xba, 0xf5, 0xaa, 0xbe, 0x6e,
	0xbd, 0x3a, 0xaa, 0x59, 0x5b, 0x7b, 0xbb, 0x5b, 0xc6, 0x2d, 0x31, 0x07, 0xc6, 0xce, 0x91, 0xb5,
	0x81, 0x0b, 0xda, 0xdb, 0xdd, 0xb2, 0x9e, 0xa1, 0x78, 0x45, 0x75, 0xff, 0x62, 0x1d, 0xbb, 0x5f,
	0xc1, 0x39, 0x1d, 0x6c, 0xd7, 0x76, 0xad, 0x83, 0xed, 0x1a, 0x2f, 0xec, 0x53, 0x54, 0x26, 0x0e,
	0x58, 0x53, 0xda, 0x5d, 0x15, 0x0b, 0x20, 0x58, 0xbb, 0xd8, 0x83, 0xf5, 0xbc, 0xce, 0xfa, 0xb9,
	0x87, 0x83, 0xbe, 0x46, 0x60, 0xdd, 0xda, 0x40, 0xbd, 0x1c, 0x1c, 0xed, 0x19, 0xf7, 0x57, 0xff,
	0x22, 0x07, 0x79, 0x5d, 0xcd, 0x47, 0x84, 0xda, 0x66, 0x4d, 0x32, 0x3e, 0xc0, 0xf9, 0x1f, 0xd6,
	0xaa, 0xdb, 0xd6, 0x6e, 0xad, 0x6e, 0x7d, 0x8f, 0xfd, 0x1a, 0x39, 0xdc, 0x69, 0xa2, 0x6d, 0x1c,
	0x19, 0x85, 0xa4, 0xf1, 0xfb, 0xba, 0x51, 0x44, 0xad, 0x53, 0x83, 0xd6, 0x34, 0x8d, 0xb3, 0xa7,
	0x26, 0xea, 0xbd, 0x94, 0xb4, 0x5e, 0xd5, 0x6b, 0xc6, 0x4c, 0x02, 0x7d, 0xb9, 0xbe, 0xb3, 0x63,
	0xcc, 0xad, 0xfe, 0x4b, 0x0e, 0x84, 0x8e, 0xc1, 0xb8, 0xe0, 0xaf, 0x4d, 0x4f, 0x53, 0xad, 0xda,
	0xa1, 0xe5, 0xf1, 0xfc, 0x8c, 0x0f, 0xc4, 0x7c, 0x1a, 0xb2, 0x21, 0x83, 0xa2, 0x54, 0x23, 0x87,
	0x5a, 0xcc, 0x92, 0x9b, 0x76, 0xd8, 0x31, 0x46, 0xc4, 0x32, 0x7c, 0x98, 0xa5, 0x86, 0xb6, 0xef,
	0x06, 0x1d, 0xab, 0x69, 0x47, 0xb1, 0xd5, 0x09, 0xde, 0x4a, 0x63, 0x54, 0x2c, 0xc1, 0xc2, 0x00,
	0x82, 0xf3, 0xd0, 0xd8, 0x3e, 0x33, 0xc6, 0xae, 0x8f, 0xe4, 0x73, 0x62, 0x09, 0xae, 0x5f, 0xc0,
	0x8f, 0x82, 0xb6, 0xe7, 0xca, 0xd0, 0x18, 0x1f, 0x1e, 0xf7, 0xd8, 0x0e, 0x7e, 0x34, 0x26, 0x36,
	0x96, 0xff, 0xe9, 0xa7, 0xa5, 0xdc, 0x3f, 0xff, 0xb4, 0x94, 0xfb, 0xf7, 0x9f, 0x96, 0x72, 0x7f,
	0xfb, 0x1f, 0x4b, 0x1f, 0x6c, 0xe7, 0xbe, 0x2f, 0x66, 0x9f, 0x85, 0x1f, 0x4f, 0xd0, 0xcf, 0xa3,
	0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x0d, 0x12, 0x21, 0xb4, 0x8b, 0x2e, 0x00, 0x00,
}
