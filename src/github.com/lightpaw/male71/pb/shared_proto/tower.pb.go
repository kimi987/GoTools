// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/shared_proto/tower.proto
// DO NOT EDIT!

package shared_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type TowerTeamMode int32

const (
	TowerTeamMode_CHALLENGE TowerTeamMode = 0
	TowerTeamMode_HELP      TowerTeamMode = 1
)

var TowerTeamMode_name = map[int32]string{
	0: "CHALLENGE",
	1: "HELP",
}
var TowerTeamMode_value = map[string]int32{
	"CHALLENGE": 0,
	"HELP":      1,
}

func (x TowerTeamMode) String() string {
	return proto.EnumName(TowerTeamMode_name, int32(x))
}
func (TowerTeamMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorTower, []int{0} }

type TowerDataProto struct {
	Floor               int32       `protobuf:"varint,1,opt,name=floor,proto3" json:"floor,omitempty"`
	FirstPassPrize      *PrizeProto `protobuf:"bytes,2,opt,name=first_pass_prize,json=firstPassPrize" json:"first_pass_prize,omitempty"`
	ShowPrize           *PrizeProto `protobuf:"bytes,3,opt,name=show_prize,json=showPrize" json:"show_prize,omitempty"`
	BoxPrize            *PrizeProto `protobuf:"bytes,4,opt,name=box_prize,json=boxPrize" json:"box_prize,omitempty"`
	Desc                string      `protobuf:"bytes,5,opt,name=desc,proto3" json:"desc,omitempty"`
	UnlockSecretTowerId int32       `protobuf:"varint,6,opt,name=unlock_secret_tower_id,json=unlockSecretTowerId,proto3" json:"unlock_secret_tower_id,omitempty"`
	// 防守武将信息
	Monster *MonsterMasterDataProto `protobuf:"bytes,21,opt,name=monster" json:"monster,omitempty"`
}

func (m *TowerDataProto) Reset()                    { *m = TowerDataProto{} }
func (m *TowerDataProto) String() string            { return proto.CompactTextString(m) }
func (*TowerDataProto) ProtoMessage()               {}
func (*TowerDataProto) Descriptor() ([]byte, []int) { return fileDescriptorTower, []int{0} }

func (m *TowerDataProto) GetFloor() int32 {
	if m != nil {
		return m.Floor
	}
	return 0
}

func (m *TowerDataProto) GetFirstPassPrize() *PrizeProto {
	if m != nil {
		return m.FirstPassPrize
	}
	return nil
}

func (m *TowerDataProto) GetShowPrize() *PrizeProto {
	if m != nil {
		return m.ShowPrize
	}
	return nil
}

func (m *TowerDataProto) GetBoxPrize() *PrizeProto {
	if m != nil {
		return m.BoxPrize
	}
	return nil
}

func (m *TowerDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *TowerDataProto) GetUnlockSecretTowerId() int32 {
	if m != nil {
		return m.UnlockSecretTowerId
	}
	return 0
}

func (m *TowerDataProto) GetMonster() *MonsterMasterDataProto {
	if m != nil {
		return m.Monster
	}
	return nil
}

type TowerFloorReplayProto struct {
	Floor        int32               `protobuf:"varint,1,opt,name=floor,proto3" json:"floor,omitempty"`
	Replay       []*TowerReplayProto `protobuf:"bytes,2,rep,name=replay" json:"replay,omitempty"`
	LowestReplay *TowerReplayProto   `protobuf:"bytes,3,opt,name=lowest_replay,json=lowestReplay" json:"lowest_replay,omitempty"`
}

func (m *TowerFloorReplayProto) Reset()                    { *m = TowerFloorReplayProto{} }
func (m *TowerFloorReplayProto) String() string            { return proto.CompactTextString(m) }
func (*TowerFloorReplayProto) ProtoMessage()               {}
func (*TowerFloorReplayProto) Descriptor() ([]byte, []int) { return fileDescriptorTower, []int{1} }

func (m *TowerFloorReplayProto) GetFloor() int32 {
	if m != nil {
		return m.Floor
	}
	return 0
}

func (m *TowerFloorReplayProto) GetReplay() []*TowerReplayProto {
	if m != nil {
		return m.Replay
	}
	return nil
}

func (m *TowerFloorReplayProto) GetLowestReplay() *TowerReplayProto {
	if m != nil {
		return m.LowestReplay
	}
	return nil
}

type TowerReplayProto struct {
	Floor          int32             `protobuf:"varint,1,opt,name=floor,proto3" json:"floor,omitempty"`
	Time           int32             `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	Link           string            `protobuf:"bytes,3,opt,name=link,proto3" json:"link,omitempty"`
	Share          *CombatShareProto `protobuf:"bytes,6,opt,name=share" json:"share,omitempty"`
	FirstPassPrize *PrizeProto       `protobuf:"bytes,4,opt,name=first_pass_prize,json=firstPassPrize" json:"first_pass_prize,omitempty"`
	Prize          *PrizeProto       `protobuf:"bytes,5,opt,name=prize" json:"prize,omitempty"`
	Hero           *HeroBasicProto   `protobuf:"bytes,10,opt,name=hero" json:"hero,omitempty"`
	HeroId         []byte            `protobuf:"bytes,11,opt,name=hero_id,json=heroId,proto3" json:"hero_id,omitempty"`
	HeroName       string            `protobuf:"bytes,12,opt,name=hero_name,json=heroName,proto3" json:"hero_name,omitempty"`
	HeroHead       string            `protobuf:"bytes,18,opt,name=hero_head,json=heroHead,proto3" json:"hero_head,omitempty"`
	GuildId        int32             `protobuf:"varint,13,opt,name=guild_id,json=guildId,proto3" json:"guild_id,omitempty"`
	GuildName      string            `protobuf:"bytes,14,opt,name=guild_name,json=guildName,proto3" json:"guild_name,omitempty"`
	GuildFlagName  string            `protobuf:"bytes,15,opt,name=guild_flag_name,json=guildFlagName,proto3" json:"guild_flag_name,omitempty"`
	Race           []int32           `protobuf:"varint,16,rep,name=race" json:"race,omitempty"`
	FightAmount    int32             `protobuf:"varint,17,opt,name=fight_amount,json=fightAmount,proto3" json:"fight_amount,omitempty"`
}

func (m *TowerReplayProto) Reset()                    { *m = TowerReplayProto{} }
func (m *TowerReplayProto) String() string            { return proto.CompactTextString(m) }
func (*TowerReplayProto) ProtoMessage()               {}
func (*TowerReplayProto) Descriptor() ([]byte, []int) { return fileDescriptorTower, []int{2} }

func (m *TowerReplayProto) GetFloor() int32 {
	if m != nil {
		return m.Floor
	}
	return 0
}

func (m *TowerReplayProto) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TowerReplayProto) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *TowerReplayProto) GetShare() *CombatShareProto {
	if m != nil {
		return m.Share
	}
	return nil
}

func (m *TowerReplayProto) GetFirstPassPrize() *PrizeProto {
	if m != nil {
		return m.FirstPassPrize
	}
	return nil
}

func (m *TowerReplayProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

func (m *TowerReplayProto) GetHero() *HeroBasicProto {
	if m != nil {
		return m.Hero
	}
	return nil
}

func (m *TowerReplayProto) GetHeroId() []byte {
	if m != nil {
		return m.HeroId
	}
	return nil
}

func (m *TowerReplayProto) GetHeroName() string {
	if m != nil {
		return m.HeroName
	}
	return ""
}

func (m *TowerReplayProto) GetHeroHead() string {
	if m != nil {
		return m.HeroHead
	}
	return ""
}

func (m *TowerReplayProto) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *TowerReplayProto) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

func (m *TowerReplayProto) GetGuildFlagName() string {
	if m != nil {
		return m.GuildFlagName
	}
	return ""
}

func (m *TowerReplayProto) GetRace() []int32 {
	if m != nil {
		return m.Race
	}
	return nil
}

func (m *TowerReplayProto) GetFightAmount() int32 {
	if m != nil {
		return m.FightAmount
	}
	return 0
}

type SecretTowerDataProto struct {
	Id               int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name             string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	MaxAttackerCount int32       `protobuf:"varint,3,opt,name=max_attacker_count,json=maxAttackerCount,proto3" json:"max_attacker_count,omitempty"`
	MinAttackerCount int32       `protobuf:"varint,4,opt,name=min_attacker_count,json=minAttackerCount,proto3" json:"min_attacker_count,omitempty"`
	Desc             string      `protobuf:"bytes,5,opt,name=desc,proto3" json:"desc,omitempty"`
	Image            string      `protobuf:"bytes,14,opt,name=image,proto3" json:"image,omitempty"`
	UnlockTowerData  int32       `protobuf:"varint,15,opt,name=unlock_tower_data,json=unlockTowerData,proto3" json:"unlock_tower_data,omitempty"`
	FirstPassPrize   *PrizeProto `protobuf:"bytes,6,opt,name=first_pass_prize,json=firstPassPrize" json:"first_pass_prize,omitempty"`
	Prize            *PrizeProto `protobuf:"bytes,7,opt,name=prize" json:"prize,omitempty"`
	SuperPrize       *PrizeProto `protobuf:"bytes,8,opt,name=super_prize,json=superPrize" json:"super_prize,omitempty"`
	// 防守部队的武将信息
	Monster []*MonsterMasterDataProto `protobuf:"bytes,9,rep,name=monster" json:"monster,omitempty"`
	// 武将队长的id
	MonsterLeaderId              int32 `protobuf:"varint,12,opt,name=monster_leader_id,json=monsterLeaderId,proto3" json:"monster_leader_id,omitempty"`
	GuildHelpContribution        int32 `protobuf:"varint,10,opt,name=guild_help_contribution,json=guildHelpContribution,proto3" json:"guild_help_contribution,omitempty"`
	MaxAttackerContinuewWinTimes int32 `protobuf:"varint,11,opt,name=max_attacker_continuew_win_times,json=maxAttackerContinuewWinTimes,proto3" json:"max_attacker_continuew_win_times,omitempty"`
}

func (m *SecretTowerDataProto) Reset()                    { *m = SecretTowerDataProto{} }
func (m *SecretTowerDataProto) String() string            { return proto.CompactTextString(m) }
func (*SecretTowerDataProto) ProtoMessage()               {}
func (*SecretTowerDataProto) Descriptor() ([]byte, []int) { return fileDescriptorTower, []int{3} }

func (m *SecretTowerDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SecretTowerDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SecretTowerDataProto) GetMaxAttackerCount() int32 {
	if m != nil {
		return m.MaxAttackerCount
	}
	return 0
}

func (m *SecretTowerDataProto) GetMinAttackerCount() int32 {
	if m != nil {
		return m.MinAttackerCount
	}
	return 0
}

func (m *SecretTowerDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *SecretTowerDataProto) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *SecretTowerDataProto) GetUnlockTowerData() int32 {
	if m != nil {
		return m.UnlockTowerData
	}
	return 0
}

func (m *SecretTowerDataProto) GetFirstPassPrize() *PrizeProto {
	if m != nil {
		return m.FirstPassPrize
	}
	return nil
}

func (m *SecretTowerDataProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

func (m *SecretTowerDataProto) GetSuperPrize() *PrizeProto {
	if m != nil {
		return m.SuperPrize
	}
	return nil
}

func (m *SecretTowerDataProto) GetMonster() []*MonsterMasterDataProto {
	if m != nil {
		return m.Monster
	}
	return nil
}

func (m *SecretTowerDataProto) GetMonsterLeaderId() int32 {
	if m != nil {
		return m.MonsterLeaderId
	}
	return 0
}

func (m *SecretTowerDataProto) GetGuildHelpContribution() int32 {
	if m != nil {
		return m.GuildHelpContribution
	}
	return 0
}

func (m *SecretTowerDataProto) GetMaxAttackerContinuewWinTimes() int32 {
	if m != nil {
		return m.MaxAttackerContinuewWinTimes
	}
	return 0
}

type SecretTowerMiscProto struct {
	RecoverDuration int32 `protobuf:"varint,1,opt,name=recover_duration,json=recoverDuration,proto3" json:"recover_duration,omitempty"`
	MaxTimes        int32 `protobuf:"varint,2,opt,name=max_times,json=maxTimes,proto3" json:"max_times,omitempty"`
	MaxHelpTimes    int32 `protobuf:"varint,3,opt,name=max_help_times,json=maxHelpTimes,proto3" json:"max_help_times,omitempty"`
	MaxRecord       int32 `protobuf:"varint,5,opt,name=max_record,json=maxRecord,proto3" json:"max_record,omitempty"`
}

func (m *SecretTowerMiscProto) Reset()                    { *m = SecretTowerMiscProto{} }
func (m *SecretTowerMiscProto) String() string            { return proto.CompactTextString(m) }
func (*SecretTowerMiscProto) ProtoMessage()               {}
func (*SecretTowerMiscProto) Descriptor() ([]byte, []int) { return fileDescriptorTower, []int{4} }

func (m *SecretTowerMiscProto) GetRecoverDuration() int32 {
	if m != nil {
		return m.RecoverDuration
	}
	return 0
}

func (m *SecretTowerMiscProto) GetMaxTimes() int32 {
	if m != nil {
		return m.MaxTimes
	}
	return 0
}

func (m *SecretTowerMiscProto) GetMaxHelpTimes() int32 {
	if m != nil {
		return m.MaxHelpTimes
	}
	return 0
}

func (m *SecretTowerMiscProto) GetMaxRecord() int32 {
	if m != nil {
		return m.MaxRecord
	}
	return 0
}

// 队伍展示信息
type SecretTeamShowProto struct {
	TeamId           int32   `protobuf:"varint,1,opt,name=team_id,json=teamId,proto3" json:"team_id,omitempty"`
	Leader           []byte  `protobuf:"bytes,2,opt,name=leader,proto3" json:"leader,omitempty"`
	SecretTowerId    int32   `protobuf:"varint,3,opt,name=secret_tower_id,json=secretTowerId,proto3" json:"secret_tower_id,omitempty"`
	CurMemberCount   int32   `protobuf:"varint,4,opt,name=cur_member_count,json=curMemberCount,proto3" json:"cur_member_count,omitempty"`
	MaxMemberCount   int32   `protobuf:"varint,5,opt,name=max_member_count,json=maxMemberCount,proto3" json:"max_member_count,omitempty"`
	GuildId          int32   `protobuf:"varint,6,opt,name=guild_id,json=guildId,proto3" json:"guild_id,omitempty"`
	CreateTime       int32   `protobuf:"varint,7,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	MemberTowerFloor []int32 `protobuf:"varint,8,rep,name=member_tower_floor,json=memberTowerFloor" json:"member_tower_floor,omitempty"`
}

func (m *SecretTeamShowProto) Reset()                    { *m = SecretTeamShowProto{} }
func (m *SecretTeamShowProto) String() string            { return proto.CompactTextString(m) }
func (*SecretTeamShowProto) ProtoMessage()               {}
func (*SecretTeamShowProto) Descriptor() ([]byte, []int) { return fileDescriptorTower, []int{5} }

func (m *SecretTeamShowProto) GetTeamId() int32 {
	if m != nil {
		return m.TeamId
	}
	return 0
}

func (m *SecretTeamShowProto) GetLeader() []byte {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *SecretTeamShowProto) GetSecretTowerId() int32 {
	if m != nil {
		return m.SecretTowerId
	}
	return 0
}

func (m *SecretTeamShowProto) GetCurMemberCount() int32 {
	if m != nil {
		return m.CurMemberCount
	}
	return 0
}

func (m *SecretTeamShowProto) GetMaxMemberCount() int32 {
	if m != nil {
		return m.MaxMemberCount
	}
	return 0
}

func (m *SecretTeamShowProto) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *SecretTeamShowProto) GetCreateTime() int32 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *SecretTeamShowProto) GetMemberTowerFloor() []int32 {
	if m != nil {
		return m.MemberTowerFloor
	}
	return nil
}

// 队伍详细信息
type SecretTeamDetailProto struct {
	TeamId         int32    `protobuf:"varint,1,opt,name=team_id,json=teamId,proto3" json:"team_id,omitempty"`
	LeaderId       []byte   `protobuf:"bytes,2,opt,name=leader_id,json=leaderId,proto3" json:"leader_id,omitempty"`
	Members        [][]byte `protobuf:"bytes,3,rep,name=members" json:"members,omitempty"`
	SecretTowerId  int32    `protobuf:"varint,4,opt,name=secret_tower_id,json=secretTowerId,proto3" json:"secret_tower_id,omitempty"`
	GuildId        int32    `protobuf:"varint,5,opt,name=guild_id,json=guildId,proto3" json:"guild_id,omitempty"`
	ProtectEndTime int32    `protobuf:"varint,6,opt,name=protect_end_time,json=protectEndTime,proto3" json:"protect_end_time,omitempty"`
}

func (m *SecretTeamDetailProto) Reset()                    { *m = SecretTeamDetailProto{} }
func (m *SecretTeamDetailProto) String() string            { return proto.CompactTextString(m) }
func (*SecretTeamDetailProto) ProtoMessage()               {}
func (*SecretTeamDetailProto) Descriptor() ([]byte, []int) { return fileDescriptorTower, []int{6} }

func (m *SecretTeamDetailProto) GetTeamId() int32 {
	if m != nil {
		return m.TeamId
	}
	return 0
}

func (m *SecretTeamDetailProto) GetLeaderId() []byte {
	if m != nil {
		return m.LeaderId
	}
	return nil
}

func (m *SecretTeamDetailProto) GetMembers() [][]byte {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *SecretTeamDetailProto) GetSecretTowerId() int32 {
	if m != nil {
		return m.SecretTowerId
	}
	return 0
}

func (m *SecretTeamDetailProto) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *SecretTeamDetailProto) GetProtectEndTime() int32 {
	if m != nil {
		return m.ProtectEndTime
	}
	return 0
}

type SecretTowerTeamMemberProto struct {
	SaidWords int32                   `protobuf:"varint,1,opt,name=said_words,json=saidWords,proto3" json:"said_words,omitempty"`
	SaidTime  int32                   `protobuf:"varint,2,opt,name=said_time,json=saidTime,proto3" json:"said_time,omitempty"`
	Hero      *HeroBasicSnapshotProto `protobuf:"bytes,8,opt,name=hero" json:"hero,omitempty"`
	// 模式
	Mode        TowerTeamMode `protobuf:"varint,10,opt,name=mode,proto3,enum=proto.TowerTeamMode" json:"mode,omitempty"`
	CaptainRace []Race        `protobuf:"varint,15,rep,name=captain_race,json=captainRace,enum=proto.Race" json:"captain_race,omitempty"`
	// 战斗力
	FightAmount int32 `protobuf:"varint,16,opt,name=fight_amount,json=fightAmount,proto3" json:"fight_amount,omitempty"`
}

func (m *SecretTowerTeamMemberProto) Reset()                    { *m = SecretTowerTeamMemberProto{} }
func (m *SecretTowerTeamMemberProto) String() string            { return proto.CompactTextString(m) }
func (*SecretTowerTeamMemberProto) ProtoMessage()               {}
func (*SecretTowerTeamMemberProto) Descriptor() ([]byte, []int) { return fileDescriptorTower, []int{7} }

func (m *SecretTowerTeamMemberProto) GetSaidWords() int32 {
	if m != nil {
		return m.SaidWords
	}
	return 0
}

func (m *SecretTowerTeamMemberProto) GetSaidTime() int32 {
	if m != nil {
		return m.SaidTime
	}
	return 0
}

func (m *SecretTowerTeamMemberProto) GetHero() *HeroBasicSnapshotProto {
	if m != nil {
		return m.Hero
	}
	return nil
}

func (m *SecretTowerTeamMemberProto) GetMode() TowerTeamMode {
	if m != nil {
		return m.Mode
	}
	return TowerTeamMode_CHALLENGE
}

func (m *SecretTowerTeamMemberProto) GetCaptainRace() []Race {
	if m != nil {
		return m.CaptainRace
	}
	return nil
}

func (m *SecretTowerTeamMemberProto) GetFightAmount() int32 {
	if m != nil {
		return m.FightAmount
	}
	return 0
}

type SecretChallengeResultProto struct {
	AttackLeaderId  []byte            `protobuf:"bytes,9,opt,name=attack_leader_id,json=attackLeaderId,proto3" json:"attack_leader_id,omitempty"`
	DefenceLeaderId []byte            `protobuf:"bytes,10,opt,name=defence_leader_id,json=defenceLeaderId,proto3" json:"defence_leader_id,omitempty"`
	AttackCount     int32             `protobuf:"varint,13,opt,name=attack_count,json=attackCount,proto3" json:"attack_count,omitempty"`
	DefenceCount    int32             `protobuf:"varint,14,opt,name=defence_count,json=defenceCount,proto3" json:"defence_count,omitempty"`
	Win             bool              `protobuf:"varint,1,opt,name=win,proto3" json:"win,omitempty"`
	Link            string            `protobuf:"bytes,2,opt,name=link,proto3" json:"link,omitempty"`
	MultiLink       []string          `protobuf:"bytes,12,rep,name=multi_link,json=multiLink" json:"multi_link,omitempty"`
	Share           *CombatShareProto `protobuf:"bytes,11,opt,name=share" json:"share,omitempty"`
	SecretTowerId   int32             `protobuf:"varint,8,opt,name=secret_tower_id,json=secretTowerId,proto3" json:"secret_tower_id,omitempty"`
	KillMonster     int32             `protobuf:"varint,3,opt,name=kill_monster,json=killMonster,proto3" json:"kill_monster,omitempty"`
	LeftMonster     int32             `protobuf:"varint,4,opt,name=left_monster,json=leftMonster,proto3" json:"left_monster,omitempty"`
	// 赢了的内容
	SuperPrizeId []byte      `protobuf:"bytes,5,opt,name=super_prize_id,json=superPrizeId,proto3" json:"super_prize_id,omitempty"`
	SuperPrize   *PrizeProto `protobuf:"bytes,7,opt,name=super_prize,json=superPrize" json:"super_prize,omitempty"`
	// 挑战成员
	Members []*SecretMemberResultProto `protobuf:"bytes,6,rep,name=members" json:"members,omitempty"`
}

func (m *SecretChallengeResultProto) Reset()                    { *m = SecretChallengeResultProto{} }
func (m *SecretChallengeResultProto) String() string            { return proto.CompactTextString(m) }
func (*SecretChallengeResultProto) ProtoMessage()               {}
func (*SecretChallengeResultProto) Descriptor() ([]byte, []int) { return fileDescriptorTower, []int{8} }

func (m *SecretChallengeResultProto) GetAttackLeaderId() []byte {
	if m != nil {
		return m.AttackLeaderId
	}
	return nil
}

func (m *SecretChallengeResultProto) GetDefenceLeaderId() []byte {
	if m != nil {
		return m.DefenceLeaderId
	}
	return nil
}

func (m *SecretChallengeResultProto) GetAttackCount() int32 {
	if m != nil {
		return m.AttackCount
	}
	return 0
}

func (m *SecretChallengeResultProto) GetDefenceCount() int32 {
	if m != nil {
		return m.DefenceCount
	}
	return 0
}

func (m *SecretChallengeResultProto) GetWin() bool {
	if m != nil {
		return m.Win
	}
	return false
}

func (m *SecretChallengeResultProto) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *SecretChallengeResultProto) GetMultiLink() []string {
	if m != nil {
		return m.MultiLink
	}
	return nil
}

func (m *SecretChallengeResultProto) GetShare() *CombatShareProto {
	if m != nil {
		return m.Share
	}
	return nil
}

func (m *SecretChallengeResultProto) GetSecretTowerId() int32 {
	if m != nil {
		return m.SecretTowerId
	}
	return 0
}

func (m *SecretChallengeResultProto) GetKillMonster() int32 {
	if m != nil {
		return m.KillMonster
	}
	return 0
}

func (m *SecretChallengeResultProto) GetLeftMonster() int32 {
	if m != nil {
		return m.LeftMonster
	}
	return 0
}

func (m *SecretChallengeResultProto) GetSuperPrizeId() []byte {
	if m != nil {
		return m.SuperPrizeId
	}
	return nil
}

func (m *SecretChallengeResultProto) GetSuperPrize() *PrizeProto {
	if m != nil {
		return m.SuperPrize
	}
	return nil
}

func (m *SecretChallengeResultProto) GetMembers() []*SecretMemberResultProto {
	if m != nil {
		return m.Members
	}
	return nil
}

type SecretMemberResultProto struct {
	Id    []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name  string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Head  string `protobuf:"bytes,3,opt,name=head,proto3" json:"head,omitempty"`
	Level int32  `protobuf:"varint,4,opt,name=level,proto3" json:"level,omitempty"`
	// 帮派数据
	GuildId           int32  `protobuf:"varint,5,opt,name=guildId,proto3" json:"guildId,omitempty"`
	GuildFlagName     string `protobuf:"bytes,6,opt,name=guildFlagName,proto3" json:"guildFlagName,omitempty"`
	GuildName         string `protobuf:"bytes,7,opt,name=guildName,proto3" json:"guildName,omitempty"`
	ContinueKillCount int32  `protobuf:"varint,10,opt,name=continue_kill_count,json=continueKillCount,proto3" json:"continue_kill_count,omitempty"`
	// 赢了的内容
	FirstPassPrize    bool        `protobuf:"varint,15,opt,name=first_pass_prize,json=firstPassPrize,proto3" json:"first_pass_prize,omitempty"`
	GuildContribution int32       `protobuf:"varint,16,opt,name=guild_contribution,json=guildContribution,proto3" json:"guild_contribution,omitempty"`
	Prize             *PrizeProto `protobuf:"bytes,17,opt,name=prize" json:"prize,omitempty"`
}

func (m *SecretMemberResultProto) Reset()                    { *m = SecretMemberResultProto{} }
func (m *SecretMemberResultProto) String() string            { return proto.CompactTextString(m) }
func (*SecretMemberResultProto) ProtoMessage()               {}
func (*SecretMemberResultProto) Descriptor() ([]byte, []int) { return fileDescriptorTower, []int{9} }

func (m *SecretMemberResultProto) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SecretMemberResultProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SecretMemberResultProto) GetHead() string {
	if m != nil {
		return m.Head
	}
	return ""
}

func (m *SecretMemberResultProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *SecretMemberResultProto) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *SecretMemberResultProto) GetGuildFlagName() string {
	if m != nil {
		return m.GuildFlagName
	}
	return ""
}

func (m *SecretMemberResultProto) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

func (m *SecretMemberResultProto) GetContinueKillCount() int32 {
	if m != nil {
		return m.ContinueKillCount
	}
	return 0
}

func (m *SecretMemberResultProto) GetFirstPassPrize() bool {
	if m != nil {
		return m.FirstPassPrize
	}
	return false
}

func (m *SecretMemberResultProto) GetGuildContribution() int32 {
	if m != nil {
		return m.GuildContribution
	}
	return 0
}

func (m *SecretMemberResultProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

// 重楼密室战报
type SecretRecordProto struct {
	Win         bool              `protobuf:"varint,1,opt,name=win,proto3" json:"win,omitempty"`
	Share       *CombatShareProto `protobuf:"bytes,2,opt,name=share" json:"share,omitempty"`
	KillMonster int32             `protobuf:"varint,3,opt,name=kill_monster,json=killMonster,proto3" json:"kill_monster,omitempty"`
	LeftMonster int32             `protobuf:"varint,4,opt,name=left_monster,json=leftMonster,proto3" json:"left_monster,omitempty"`
}

func (m *SecretRecordProto) Reset()                    { *m = SecretRecordProto{} }
func (m *SecretRecordProto) String() string            { return proto.CompactTextString(m) }
func (*SecretRecordProto) ProtoMessage()               {}
func (*SecretRecordProto) Descriptor() ([]byte, []int) { return fileDescriptorTower, []int{10} }

func (m *SecretRecordProto) GetWin() bool {
	if m != nil {
		return m.Win
	}
	return false
}

func (m *SecretRecordProto) GetShare() *CombatShareProto {
	if m != nil {
		return m.Share
	}
	return nil
}

func (m *SecretRecordProto) GetKillMonster() int32 {
	if m != nil {
		return m.KillMonster
	}
	return 0
}

func (m *SecretRecordProto) GetLeftMonster() int32 {
	if m != nil {
		return m.LeftMonster
	}
	return 0
}

type HeroTowerProto struct {
	ChallengeTimes         int32   `protobuf:"varint,1,opt,name=challenge_times,json=challengeTimes,proto3" json:"challenge_times,omitempty"`
	NextResetChallengeTime int32   `protobuf:"varint,8,opt,name=next_reset_challenge_time,json=nextResetChallengeTime,proto3" json:"next_reset_challenge_time,omitempty"`
	CurrentFloor           int32   `protobuf:"varint,2,opt,name=current_floor,json=currentFloor,proto3" json:"current_floor,omitempty"`
	HistoryMaxFloor        int32   `protobuf:"varint,3,opt,name=history_max_floor,json=historyMaxFloor,proto3" json:"history_max_floor,omitempty"`
	AutoMaxFloor           int32   `protobuf:"varint,4,opt,name=auto_max_floor,json=autoMaxFloor,proto3" json:"auto_max_floor,omitempty"`
	CollectedBoxFloors     []int32 `protobuf:"varint,6,rep,name=collected_box_floors,json=collectedBoxFloors" json:"collected_box_floors,omitempty"`
}

func (m *HeroTowerProto) Reset()                    { *m = HeroTowerProto{} }
func (m *HeroTowerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroTowerProto) ProtoMessage()               {}
func (*HeroTowerProto) Descriptor() ([]byte, []int) { return fileDescriptorTower, []int{11} }

func (m *HeroTowerProto) GetChallengeTimes() int32 {
	if m != nil {
		return m.ChallengeTimes
	}
	return 0
}

func (m *HeroTowerProto) GetNextResetChallengeTime() int32 {
	if m != nil {
		return m.NextResetChallengeTime
	}
	return 0
}

func (m *HeroTowerProto) GetCurrentFloor() int32 {
	if m != nil {
		return m.CurrentFloor
	}
	return 0
}

func (m *HeroTowerProto) GetHistoryMaxFloor() int32 {
	if m != nil {
		return m.HistoryMaxFloor
	}
	return 0
}

func (m *HeroTowerProto) GetAutoMaxFloor() int32 {
	if m != nil {
		return m.AutoMaxFloor
	}
	return 0
}

func (m *HeroTowerProto) GetCollectedBoxFloors() []int32 {
	if m != nil {
		return m.CollectedBoxFloors
	}
	return nil
}

// 密室数据
type HeroSecretTowerProto struct {
	ChallengeTimes        int32   `protobuf:"varint,11,opt,name=challenge_times,json=challengeTimes,proto3" json:"challenge_times,omitempty"`
	HelpTimes             int32   `protobuf:"varint,1,opt,name=help_times,json=helpTimes,proto3" json:"help_times,omitempty"`
	MaxOpenTowerId        int32   `protobuf:"varint,3,opt,name=max_open_tower_id,json=maxOpenTowerId,proto3" json:"max_open_tower_id,omitempty"`
	CollectedFirstPrizeId []int32 `protobuf:"varint,4,rep,name=collected_first_prize_id,json=collectedFirstPrizeId" json:"collected_first_prize_id,omitempty"`
	HistoryChallengeTimes int32   `protobuf:"varint,5,opt,name=history_challenge_times,json=historyChallengeTimes,proto3" json:"history_challenge_times,omitempty"`
}

func (m *HeroSecretTowerProto) Reset()                    { *m = HeroSecretTowerProto{} }
func (m *HeroSecretTowerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroSecretTowerProto) ProtoMessage()               {}
func (*HeroSecretTowerProto) Descriptor() ([]byte, []int) { return fileDescriptorTower, []int{12} }

func (m *HeroSecretTowerProto) GetChallengeTimes() int32 {
	if m != nil {
		return m.ChallengeTimes
	}
	return 0
}

func (m *HeroSecretTowerProto) GetHelpTimes() int32 {
	if m != nil {
		return m.HelpTimes
	}
	return 0
}

func (m *HeroSecretTowerProto) GetMaxOpenTowerId() int32 {
	if m != nil {
		return m.MaxOpenTowerId
	}
	return 0
}

func (m *HeroSecretTowerProto) GetCollectedFirstPrizeId() []int32 {
	if m != nil {
		return m.CollectedFirstPrizeId
	}
	return nil
}

func (m *HeroSecretTowerProto) GetHistoryChallengeTimes() int32 {
	if m != nil {
		return m.HistoryChallengeTimes
	}
	return 0
}

// 重楼密室聊天记录
type SecretTowerChatRecordProto struct {
	HeroId        []byte `protobuf:"bytes,1,opt,name=hero_id,json=heroId,proto3" json:"hero_id,omitempty"`
	HeroName      string `protobuf:"bytes,2,opt,name=hero_name,json=heroName,proto3" json:"hero_name,omitempty"`
	GuildFlagName string `protobuf:"bytes,3,opt,name=guild_flag_name,json=guildFlagName,proto3" json:"guild_flag_name,omitempty"`
	WordsId       int32  `protobuf:"varint,4,opt,name=words_id,json=wordsId,proto3" json:"words_id,omitempty"`
	Text          string `protobuf:"bytes,5,opt,name=text,proto3" json:"text,omitempty"`
}

func (m *SecretTowerChatRecordProto) Reset()                    { *m = SecretTowerChatRecordProto{} }
func (m *SecretTowerChatRecordProto) String() string            { return proto.CompactTextString(m) }
func (*SecretTowerChatRecordProto) ProtoMessage()               {}
func (*SecretTowerChatRecordProto) Descriptor() ([]byte, []int) { return fileDescriptorTower, []int{13} }

func (m *SecretTowerChatRecordProto) GetHeroId() []byte {
	if m != nil {
		return m.HeroId
	}
	return nil
}

func (m *SecretTowerChatRecordProto) GetHeroName() string {
	if m != nil {
		return m.HeroName
	}
	return ""
}

func (m *SecretTowerChatRecordProto) GetGuildFlagName() string {
	if m != nil {
		return m.GuildFlagName
	}
	return ""
}

func (m *SecretTowerChatRecordProto) GetWordsId() int32 {
	if m != nil {
		return m.WordsId
	}
	return 0
}

func (m *SecretTowerChatRecordProto) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func init() {
	proto.RegisterType((*TowerDataProto)(nil), "proto.TowerDataProto")
	proto.RegisterType((*TowerFloorReplayProto)(nil), "proto.TowerFloorReplayProto")
	proto.RegisterType((*TowerReplayProto)(nil), "proto.TowerReplayProto")
	proto.RegisterType((*SecretTowerDataProto)(nil), "proto.SecretTowerDataProto")
	proto.RegisterType((*SecretTowerMiscProto)(nil), "proto.SecretTowerMiscProto")
	proto.RegisterType((*SecretTeamShowProto)(nil), "proto.SecretTeamShowProto")
	proto.RegisterType((*SecretTeamDetailProto)(nil), "proto.SecretTeamDetailProto")
	proto.RegisterType((*SecretTowerTeamMemberProto)(nil), "proto.SecretTowerTeamMemberProto")
	proto.RegisterType((*SecretChallengeResultProto)(nil), "proto.SecretChallengeResultProto")
	proto.RegisterType((*SecretMemberResultProto)(nil), "proto.SecretMemberResultProto")
	proto.RegisterType((*SecretRecordProto)(nil), "proto.SecretRecordProto")
	proto.RegisterType((*HeroTowerProto)(nil), "proto.HeroTowerProto")
	proto.RegisterType((*HeroSecretTowerProto)(nil), "proto.HeroSecretTowerProto")
	proto.RegisterType((*SecretTowerChatRecordProto)(nil), "proto.SecretTowerChatRecordProto")
	proto.RegisterEnum("proto.TowerTeamMode", TowerTeamMode_name, TowerTeamMode_value)
}
func (m *TowerDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TowerDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Floor != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.Floor))
	}
	if m.FirstPassPrize != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.FirstPassPrize.Size()))
		n1, err := m.FirstPassPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.ShowPrize != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.ShowPrize.Size()))
		n2, err := m.ShowPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.BoxPrize != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.BoxPrize.Size()))
		n3, err := m.BoxPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.UnlockSecretTowerId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.UnlockSecretTowerId))
	}
	if m.Monster != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.Monster.Size()))
		n4, err := m.Monster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *TowerFloorReplayProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TowerFloorReplayProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Floor != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.Floor))
	}
	if len(m.Replay) > 0 {
		for _, msg := range m.Replay {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTower(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LowestReplay != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.LowestReplay.Size()))
		n5, err := m.LowestReplay.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *TowerReplayProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TowerReplayProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Floor != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.Floor))
	}
	if m.Time != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.Time))
	}
	if len(m.Link) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.Link)))
		i += copy(dAtA[i:], m.Link)
	}
	if m.FirstPassPrize != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.FirstPassPrize.Size()))
		n6, err := m.FirstPassPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Prize != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.Prize.Size()))
		n7, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Share != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.Share.Size()))
		n8, err := m.Share.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Hero != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.Hero.Size()))
		n9, err := m.Hero.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.HeroId) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.HeroId)))
		i += copy(dAtA[i:], m.HeroId)
	}
	if len(m.HeroName) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.HeroName)))
		i += copy(dAtA[i:], m.HeroName)
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.GuildId))
	}
	if len(m.GuildName) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.GuildName)))
		i += copy(dAtA[i:], m.GuildName)
	}
	if len(m.GuildFlagName) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.GuildFlagName)))
		i += copy(dAtA[i:], m.GuildFlagName)
	}
	if len(m.Race) > 0 {
		for _, num := range m.Race {
			dAtA[i] = 0x80
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTower(dAtA, i, uint64(num))
		}
	}
	if m.FightAmount != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.FightAmount))
	}
	if len(m.HeroHead) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.HeroHead)))
		i += copy(dAtA[i:], m.HeroHead)
	}
	return i, nil
}

func (m *SecretTowerDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretTowerDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.MaxAttackerCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.MaxAttackerCount))
	}
	if m.MinAttackerCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.MinAttackerCount))
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.FirstPassPrize != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.FirstPassPrize.Size()))
		n10, err := m.FirstPassPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Prize != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.Prize.Size()))
		n11, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.SuperPrize != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.SuperPrize.Size()))
		n12, err := m.SuperPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Monster) > 0 {
		for _, msg := range m.Monster {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintTower(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.GuildHelpContribution != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.GuildHelpContribution))
	}
	if m.MaxAttackerContinuewWinTimes != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.MaxAttackerContinuewWinTimes))
	}
	if m.MonsterLeaderId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.MonsterLeaderId))
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if m.UnlockTowerData != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.UnlockTowerData))
	}
	return i, nil
}

func (m *SecretTowerMiscProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretTowerMiscProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RecoverDuration != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.RecoverDuration))
	}
	if m.MaxTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.MaxTimes))
	}
	if m.MaxHelpTimes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.MaxHelpTimes))
	}
	if m.MaxRecord != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.MaxRecord))
	}
	return i, nil
}

func (m *SecretTeamShowProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretTeamShowProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TeamId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.TeamId))
	}
	if len(m.Leader) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.Leader)))
		i += copy(dAtA[i:], m.Leader)
	}
	if m.SecretTowerId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.SecretTowerId))
	}
	if m.CurMemberCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.CurMemberCount))
	}
	if m.MaxMemberCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.MaxMemberCount))
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.GuildId))
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.CreateTime))
	}
	if len(m.MemberTowerFloor) > 0 {
		for _, num := range m.MemberTowerFloor {
			dAtA[i] = 0x40
			i++
			i = encodeVarintTower(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *SecretTeamDetailProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretTeamDetailProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TeamId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.TeamId))
	}
	if len(m.LeaderId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.LeaderId)))
		i += copy(dAtA[i:], m.LeaderId)
	}
	if len(m.Members) > 0 {
		for _, b := range m.Members {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTower(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.SecretTowerId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.SecretTowerId))
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.GuildId))
	}
	if m.ProtectEndTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.ProtectEndTime))
	}
	return i, nil
}

func (m *SecretTowerTeamMemberProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretTowerTeamMemberProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SaidWords != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.SaidWords))
	}
	if m.SaidTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.SaidTime))
	}
	if m.Hero != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.Hero.Size()))
		n13, err := m.Hero.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Mode != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.Mode))
	}
	if len(m.CaptainRace) > 0 {
		for _, num := range m.CaptainRace {
			dAtA[i] = 0x78
			i++
			i = encodeVarintTower(dAtA, i, uint64(num))
		}
	}
	if m.FightAmount != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.FightAmount))
	}
	return i, nil
}

func (m *SecretChallengeResultProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretChallengeResultProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Win {
		dAtA[i] = 0x8
		i++
		if m.Win {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Link) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.Link)))
		i += copy(dAtA[i:], m.Link)
	}
	if m.KillMonster != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.KillMonster))
	}
	if m.LeftMonster != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.LeftMonster))
	}
	if len(m.SuperPrizeId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.SuperPrizeId)))
		i += copy(dAtA[i:], m.SuperPrizeId)
	}
	if len(m.Members) > 0 {
		for _, msg := range m.Members {
			dAtA[i] = 0x32
			i++
			i = encodeVarintTower(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SuperPrize != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.SuperPrize.Size()))
		n14, err := m.SuperPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.SecretTowerId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.SecretTowerId))
	}
	if len(m.AttackLeaderId) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.AttackLeaderId)))
		i += copy(dAtA[i:], m.AttackLeaderId)
	}
	if len(m.DefenceLeaderId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.DefenceLeaderId)))
		i += copy(dAtA[i:], m.DefenceLeaderId)
	}
	if m.Share != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.Share.Size()))
		n15, err := m.Share.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.MultiLink) > 0 {
		for _, s := range m.MultiLink {
			dAtA[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.AttackCount != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.AttackCount))
	}
	if m.DefenceCount != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.DefenceCount))
	}
	return i, nil
}

func (m *SecretMemberResultProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretMemberResultProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Head) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.Head)))
		i += copy(dAtA[i:], m.Head)
	}
	if m.Level != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.Level))
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.GuildId))
	}
	if len(m.GuildFlagName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.GuildFlagName)))
		i += copy(dAtA[i:], m.GuildFlagName)
	}
	if len(m.GuildName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.GuildName)))
		i += copy(dAtA[i:], m.GuildName)
	}
	if m.ContinueKillCount != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.ContinueKillCount))
	}
	if m.FirstPassPrize {
		dAtA[i] = 0x78
		i++
		if m.FirstPassPrize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GuildContribution != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.GuildContribution))
	}
	if m.Prize != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.Prize.Size()))
		n16, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *SecretRecordProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretRecordProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Win {
		dAtA[i] = 0x8
		i++
		if m.Win {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Share != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.Share.Size()))
		n17, err := m.Share.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.KillMonster != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.KillMonster))
	}
	if m.LeftMonster != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.LeftMonster))
	}
	return i, nil
}

func (m *HeroTowerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroTowerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChallengeTimes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.ChallengeTimes))
	}
	if m.CurrentFloor != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.CurrentFloor))
	}
	if m.HistoryMaxFloor != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.HistoryMaxFloor))
	}
	if m.AutoMaxFloor != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.AutoMaxFloor))
	}
	if len(m.CollectedBoxFloors) > 0 {
		for _, num := range m.CollectedBoxFloors {
			dAtA[i] = 0x30
			i++
			i = encodeVarintTower(dAtA, i, uint64(num))
		}
	}
	if m.NextResetChallengeTime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.NextResetChallengeTime))
	}
	return i, nil
}

func (m *HeroSecretTowerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroSecretTowerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HelpTimes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.HelpTimes))
	}
	if m.MaxOpenTowerId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.MaxOpenTowerId))
	}
	if len(m.CollectedFirstPrizeId) > 0 {
		for _, num := range m.CollectedFirstPrizeId {
			dAtA[i] = 0x20
			i++
			i = encodeVarintTower(dAtA, i, uint64(num))
		}
	}
	if m.HistoryChallengeTimes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.HistoryChallengeTimes))
	}
	if m.ChallengeTimes != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.ChallengeTimes))
	}
	return i, nil
}

func (m *SecretTowerChatRecordProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretTowerChatRecordProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HeroId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.HeroId)))
		i += copy(dAtA[i:], m.HeroId)
	}
	if len(m.HeroName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.HeroName)))
		i += copy(dAtA[i:], m.HeroName)
	}
	if len(m.GuildFlagName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.GuildFlagName)))
		i += copy(dAtA[i:], m.GuildFlagName)
	}
	if m.WordsId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTower(dAtA, i, uint64(m.WordsId))
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTower(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	return i, nil
}

func encodeFixed64Tower(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Tower(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTower(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TowerDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Floor != 0 {
		n += 1 + sovTower(uint64(m.Floor))
	}
	if m.FirstPassPrize != nil {
		l = m.FirstPassPrize.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	if m.ShowPrize != nil {
		l = m.ShowPrize.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	if m.BoxPrize != nil {
		l = m.BoxPrize.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	if m.UnlockSecretTowerId != 0 {
		n += 1 + sovTower(uint64(m.UnlockSecretTowerId))
	}
	if m.Monster != nil {
		l = m.Monster.Size()
		n += 2 + l + sovTower(uint64(l))
	}
	return n
}

func (m *TowerFloorReplayProto) Size() (n int) {
	var l int
	_ = l
	if m.Floor != 0 {
		n += 1 + sovTower(uint64(m.Floor))
	}
	if len(m.Replay) > 0 {
		for _, e := range m.Replay {
			l = e.Size()
			n += 1 + l + sovTower(uint64(l))
		}
	}
	if m.LowestReplay != nil {
		l = m.LowestReplay.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	return n
}

func (m *TowerReplayProto) Size() (n int) {
	var l int
	_ = l
	if m.Floor != 0 {
		n += 1 + sovTower(uint64(m.Floor))
	}
	if m.Time != 0 {
		n += 1 + sovTower(uint64(m.Time))
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	if m.FirstPassPrize != nil {
		l = m.FirstPassPrize.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	if m.Share != nil {
		l = m.Share.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	if m.Hero != nil {
		l = m.Hero.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	l = len(m.HeroId)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	l = len(m.HeroName)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	if m.GuildId != 0 {
		n += 1 + sovTower(uint64(m.GuildId))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	l = len(m.GuildFlagName)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	if len(m.Race) > 0 {
		for _, e := range m.Race {
			n += 2 + sovTower(uint64(e))
		}
	}
	if m.FightAmount != 0 {
		n += 2 + sovTower(uint64(m.FightAmount))
	}
	l = len(m.HeroHead)
	if l > 0 {
		n += 2 + l + sovTower(uint64(l))
	}
	return n
}

func (m *SecretTowerDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTower(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	if m.MaxAttackerCount != 0 {
		n += 1 + sovTower(uint64(m.MaxAttackerCount))
	}
	if m.MinAttackerCount != 0 {
		n += 1 + sovTower(uint64(m.MinAttackerCount))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	if m.FirstPassPrize != nil {
		l = m.FirstPassPrize.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	if m.SuperPrize != nil {
		l = m.SuperPrize.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	if len(m.Monster) > 0 {
		for _, e := range m.Monster {
			l = e.Size()
			n += 1 + l + sovTower(uint64(l))
		}
	}
	if m.GuildHelpContribution != 0 {
		n += 1 + sovTower(uint64(m.GuildHelpContribution))
	}
	if m.MaxAttackerContinuewWinTimes != 0 {
		n += 1 + sovTower(uint64(m.MaxAttackerContinuewWinTimes))
	}
	if m.MonsterLeaderId != 0 {
		n += 1 + sovTower(uint64(m.MonsterLeaderId))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	if m.UnlockTowerData != 0 {
		n += 1 + sovTower(uint64(m.UnlockTowerData))
	}
	return n
}

func (m *SecretTowerMiscProto) Size() (n int) {
	var l int
	_ = l
	if m.RecoverDuration != 0 {
		n += 1 + sovTower(uint64(m.RecoverDuration))
	}
	if m.MaxTimes != 0 {
		n += 1 + sovTower(uint64(m.MaxTimes))
	}
	if m.MaxHelpTimes != 0 {
		n += 1 + sovTower(uint64(m.MaxHelpTimes))
	}
	if m.MaxRecord != 0 {
		n += 1 + sovTower(uint64(m.MaxRecord))
	}
	return n
}

func (m *SecretTeamShowProto) Size() (n int) {
	var l int
	_ = l
	if m.TeamId != 0 {
		n += 1 + sovTower(uint64(m.TeamId))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	if m.SecretTowerId != 0 {
		n += 1 + sovTower(uint64(m.SecretTowerId))
	}
	if m.CurMemberCount != 0 {
		n += 1 + sovTower(uint64(m.CurMemberCount))
	}
	if m.MaxMemberCount != 0 {
		n += 1 + sovTower(uint64(m.MaxMemberCount))
	}
	if m.GuildId != 0 {
		n += 1 + sovTower(uint64(m.GuildId))
	}
	if m.CreateTime != 0 {
		n += 1 + sovTower(uint64(m.CreateTime))
	}
	if len(m.MemberTowerFloor) > 0 {
		for _, e := range m.MemberTowerFloor {
			n += 1 + sovTower(uint64(e))
		}
	}
	return n
}

func (m *SecretTeamDetailProto) Size() (n int) {
	var l int
	_ = l
	if m.TeamId != 0 {
		n += 1 + sovTower(uint64(m.TeamId))
	}
	l = len(m.LeaderId)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, b := range m.Members {
			l = len(b)
			n += 1 + l + sovTower(uint64(l))
		}
	}
	if m.SecretTowerId != 0 {
		n += 1 + sovTower(uint64(m.SecretTowerId))
	}
	if m.GuildId != 0 {
		n += 1 + sovTower(uint64(m.GuildId))
	}
	if m.ProtectEndTime != 0 {
		n += 1 + sovTower(uint64(m.ProtectEndTime))
	}
	return n
}

func (m *SecretTowerTeamMemberProto) Size() (n int) {
	var l int
	_ = l
	if m.SaidWords != 0 {
		n += 1 + sovTower(uint64(m.SaidWords))
	}
	if m.SaidTime != 0 {
		n += 1 + sovTower(uint64(m.SaidTime))
	}
	if m.Hero != nil {
		l = m.Hero.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	if m.Mode != 0 {
		n += 1 + sovTower(uint64(m.Mode))
	}
	if len(m.CaptainRace) > 0 {
		for _, e := range m.CaptainRace {
			n += 1 + sovTower(uint64(e))
		}
	}
	if m.FightAmount != 0 {
		n += 2 + sovTower(uint64(m.FightAmount))
	}
	return n
}

func (m *SecretChallengeResultProto) Size() (n int) {
	var l int
	_ = l
	if m.Win {
		n += 2
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	if m.KillMonster != 0 {
		n += 1 + sovTower(uint64(m.KillMonster))
	}
	if m.LeftMonster != 0 {
		n += 1 + sovTower(uint64(m.LeftMonster))
	}
	l = len(m.SuperPrizeId)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovTower(uint64(l))
		}
	}
	if m.SuperPrize != nil {
		l = m.SuperPrize.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	if m.SecretTowerId != 0 {
		n += 1 + sovTower(uint64(m.SecretTowerId))
	}
	l = len(m.AttackLeaderId)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	l = len(m.DefenceLeaderId)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	if m.Share != nil {
		l = m.Share.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	if len(m.MultiLink) > 0 {
		for _, s := range m.MultiLink {
			l = len(s)
			n += 1 + l + sovTower(uint64(l))
		}
	}
	if m.AttackCount != 0 {
		n += 1 + sovTower(uint64(m.AttackCount))
	}
	if m.DefenceCount != 0 {
		n += 1 + sovTower(uint64(m.DefenceCount))
	}
	return n
}

func (m *SecretMemberResultProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovTower(uint64(m.Level))
	}
	if m.GuildId != 0 {
		n += 1 + sovTower(uint64(m.GuildId))
	}
	l = len(m.GuildFlagName)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	if m.ContinueKillCount != 0 {
		n += 1 + sovTower(uint64(m.ContinueKillCount))
	}
	if m.FirstPassPrize {
		n += 2
	}
	if m.GuildContribution != 0 {
		n += 2 + sovTower(uint64(m.GuildContribution))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 2 + l + sovTower(uint64(l))
	}
	return n
}

func (m *SecretRecordProto) Size() (n int) {
	var l int
	_ = l
	if m.Win {
		n += 2
	}
	if m.Share != nil {
		l = m.Share.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	if m.KillMonster != 0 {
		n += 1 + sovTower(uint64(m.KillMonster))
	}
	if m.LeftMonster != 0 {
		n += 1 + sovTower(uint64(m.LeftMonster))
	}
	return n
}

func (m *HeroTowerProto) Size() (n int) {
	var l int
	_ = l
	if m.ChallengeTimes != 0 {
		n += 1 + sovTower(uint64(m.ChallengeTimes))
	}
	if m.CurrentFloor != 0 {
		n += 1 + sovTower(uint64(m.CurrentFloor))
	}
	if m.HistoryMaxFloor != 0 {
		n += 1 + sovTower(uint64(m.HistoryMaxFloor))
	}
	if m.AutoMaxFloor != 0 {
		n += 1 + sovTower(uint64(m.AutoMaxFloor))
	}
	if len(m.CollectedBoxFloors) > 0 {
		for _, e := range m.CollectedBoxFloors {
			n += 1 + sovTower(uint64(e))
		}
	}
	if m.NextResetChallengeTime != 0 {
		n += 1 + sovTower(uint64(m.NextResetChallengeTime))
	}
	return n
}

func (m *HeroSecretTowerProto) Size() (n int) {
	var l int
	_ = l
	if m.HelpTimes != 0 {
		n += 1 + sovTower(uint64(m.HelpTimes))
	}
	if m.MaxOpenTowerId != 0 {
		n += 1 + sovTower(uint64(m.MaxOpenTowerId))
	}
	if len(m.CollectedFirstPrizeId) > 0 {
		for _, e := range m.CollectedFirstPrizeId {
			n += 1 + sovTower(uint64(e))
		}
	}
	if m.HistoryChallengeTimes != 0 {
		n += 1 + sovTower(uint64(m.HistoryChallengeTimes))
	}
	if m.ChallengeTimes != 0 {
		n += 1 + sovTower(uint64(m.ChallengeTimes))
	}
	return n
}

func (m *SecretTowerChatRecordProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.HeroId)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	l = len(m.HeroName)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	l = len(m.GuildFlagName)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	if m.WordsId != 0 {
		n += 1 + sovTower(uint64(m.WordsId))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovTower(uint64(l))
	}
	return n
}

func sovTower(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTower(x uint64) (n int) {
	return sovTower(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TowerDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Floor", wireType)
			}
			m.Floor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Floor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstPassPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FirstPassPrize == nil {
				m.FirstPassPrize = &PrizeProto{}
			}
			if err := m.FirstPassPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowPrize == nil {
				m.ShowPrize = &PrizeProto{}
			}
			if err := m.ShowPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoxPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BoxPrize == nil {
				m.BoxPrize = &PrizeProto{}
			}
			if err := m.BoxPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockSecretTowerId", wireType)
			}
			m.UnlockSecretTowerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnlockSecretTowerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Monster == nil {
				m.Monster = &MonsterMasterDataProto{}
			}
			if err := m.Monster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TowerFloorReplayProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerFloorReplayProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerFloorReplayProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Floor", wireType)
			}
			m.Floor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Floor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replay = append(m.Replay, &TowerReplayProto{})
			if err := m.Replay[len(m.Replay)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowestReplay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LowestReplay == nil {
				m.LowestReplay = &TowerReplayProto{}
			}
			if err := m.LowestReplay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TowerReplayProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerReplayProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerReplayProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Floor", wireType)
			}
			m.Floor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Floor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstPassPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FirstPassPrize == nil {
				m.FirstPassPrize = &PrizeProto{}
			}
			if err := m.FirstPassPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Share == nil {
				m.Share = &CombatShareProto{}
			}
			if err := m.Share.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hero", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hero == nil {
				m.Hero = &HeroBasicProto{}
			}
			if err := m.Hero.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeroId = append(m.HeroId[:0], dAtA[iNdEx:postIndex]...)
			if m.HeroId == nil {
				m.HeroId = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeroName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildFlagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildFlagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTower
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Race = append(m.Race, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTower
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTower
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTower
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Race = append(m.Race, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Race", wireType)
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightAmount", wireType)
			}
			m.FightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroHead", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeroHead = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretTowerDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretTowerDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretTowerDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAttackerCount", wireType)
			}
			m.MaxAttackerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAttackerCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAttackerCount", wireType)
			}
			m.MinAttackerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinAttackerCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstPassPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FirstPassPrize == nil {
				m.FirstPassPrize = &PrizeProto{}
			}
			if err := m.FirstPassPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuperPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SuperPrize == nil {
				m.SuperPrize = &PrizeProto{}
			}
			if err := m.SuperPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Monster = append(m.Monster, &MonsterMasterDataProto{})
			if err := m.Monster[len(m.Monster)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildHelpContribution", wireType)
			}
			m.GuildHelpContribution = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildHelpContribution |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAttackerContinuewWinTimes", wireType)
			}
			m.MaxAttackerContinuewWinTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAttackerContinuewWinTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterLeaderId", wireType)
			}
			m.MonsterLeaderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonsterLeaderId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockTowerData", wireType)
			}
			m.UnlockTowerData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnlockTowerData |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretTowerMiscProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretTowerMiscProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretTowerMiscProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverDuration", wireType)
			}
			m.RecoverDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecoverDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimes", wireType)
			}
			m.MaxTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxHelpTimes", wireType)
			}
			m.MaxHelpTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxHelpTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRecord", wireType)
			}
			m.MaxRecord = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRecord |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretTeamShowProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretTeamShowProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretTeamShowProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			m.TeamId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = append(m.Leader[:0], dAtA[iNdEx:postIndex]...)
			if m.Leader == nil {
				m.Leader = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretTowerId", wireType)
			}
			m.SecretTowerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecretTowerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurMemberCount", wireType)
			}
			m.CurMemberCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurMemberCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMemberCount", wireType)
			}
			m.MaxMemberCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMemberCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTower
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MemberTowerFloor = append(m.MemberTowerFloor, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTower
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTower
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTower
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MemberTowerFloor = append(m.MemberTowerFloor, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberTowerFloor", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretTeamDetailProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretTeamDetailProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretTeamDetailProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			m.TeamId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaderId = append(m.LeaderId[:0], dAtA[iNdEx:postIndex]...)
			if m.LeaderId == nil {
				m.LeaderId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, make([]byte, postIndex-iNdEx))
			copy(m.Members[len(m.Members)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretTowerId", wireType)
			}
			m.SecretTowerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecretTowerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectEndTime", wireType)
			}
			m.ProtectEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtectEndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretTowerTeamMemberProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretTowerTeamMemberProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretTowerTeamMemberProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaidWords", wireType)
			}
			m.SaidWords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SaidWords |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaidTime", wireType)
			}
			m.SaidTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SaidTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hero", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hero == nil {
				m.Hero = &HeroBasicSnapshotProto{}
			}
			if err := m.Hero.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (TowerTeamMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType == 0 {
				var v Race
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTower
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Race(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainRace = append(m.CaptainRace, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTower
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTower
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Race
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTower
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Race(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainRace = append(m.CaptainRace, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainRace", wireType)
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightAmount", wireType)
			}
			m.FightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretChallengeResultProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretChallengeResultProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretChallengeResultProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Win = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillMonster", wireType)
			}
			m.KillMonster = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillMonster |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftMonster", wireType)
			}
			m.LeftMonster = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftMonster |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuperPrizeId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuperPrizeId = append(m.SuperPrizeId[:0], dAtA[iNdEx:postIndex]...)
			if m.SuperPrizeId == nil {
				m.SuperPrizeId = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &SecretMemberResultProto{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuperPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SuperPrize == nil {
				m.SuperPrize = &PrizeProto{}
			}
			if err := m.SuperPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretTowerId", wireType)
			}
			m.SecretTowerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecretTowerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackLeaderId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttackLeaderId = append(m.AttackLeaderId[:0], dAtA[iNdEx:postIndex]...)
			if m.AttackLeaderId == nil {
				m.AttackLeaderId = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenceLeaderId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefenceLeaderId = append(m.DefenceLeaderId[:0], dAtA[iNdEx:postIndex]...)
			if m.DefenceLeaderId == nil {
				m.DefenceLeaderId = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Share == nil {
				m.Share = &CombatShareProto{}
			}
			if err := m.Share.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultiLink = append(m.MultiLink, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackCount", wireType)
			}
			m.AttackCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenceCount", wireType)
			}
			m.DefenceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefenceCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretMemberResultProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretMemberResultProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretMemberResultProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildFlagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildFlagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContinueKillCount", wireType)
			}
			m.ContinueKillCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContinueKillCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstPassPrize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FirstPassPrize = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildContribution", wireType)
			}
			m.GuildContribution = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildContribution |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretRecordProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretRecordProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretRecordProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Win = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Share == nil {
				m.Share = &CombatShareProto{}
			}
			if err := m.Share.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillMonster", wireType)
			}
			m.KillMonster = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillMonster |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftMonster", wireType)
			}
			m.LeftMonster = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftMonster |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroTowerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroTowerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroTowerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTimes", wireType)
			}
			m.ChallengeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentFloor", wireType)
			}
			m.CurrentFloor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentFloor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryMaxFloor", wireType)
			}
			m.HistoryMaxFloor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistoryMaxFloor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoMaxFloor", wireType)
			}
			m.AutoMaxFloor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoMaxFloor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTower
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CollectedBoxFloors = append(m.CollectedBoxFloors, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTower
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTower
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTower
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CollectedBoxFloors = append(m.CollectedBoxFloors, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedBoxFloors", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextResetChallengeTime", wireType)
			}
			m.NextResetChallengeTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextResetChallengeTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroSecretTowerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroSecretTowerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroSecretTowerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelpTimes", wireType)
			}
			m.HelpTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HelpTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxOpenTowerId", wireType)
			}
			m.MaxOpenTowerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxOpenTowerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTower
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CollectedFirstPrizeId = append(m.CollectedFirstPrizeId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTower
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTower
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTower
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CollectedFirstPrizeId = append(m.CollectedFirstPrizeId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedFirstPrizeId", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryChallengeTimes", wireType)
			}
			m.HistoryChallengeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistoryChallengeTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTimes", wireType)
			}
			m.ChallengeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretTowerChatRecordProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretTowerChatRecordProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretTowerChatRecordProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeroId = append(m.HeroId[:0], dAtA[iNdEx:postIndex]...)
			if m.HeroId == nil {
				m.HeroId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeroName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildFlagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildFlagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WordsId", wireType)
			}
			m.WordsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WordsId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTower(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTower
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTower
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTower
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTower
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTower
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTower(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTower = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTower   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/shared_proto/tower.proto", fileDescriptorTower)
}

var fileDescriptorTower = []byte{
	// 1829 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xcf, 0x8e, 0xdb, 0xe6,
	0x11, 0x37, 0xf5, 0x67, 0x57, 0x1a, 0x51, 0xff, 0x3e, 0xef, 0x7a, 0x65, 0x3b, 0xde, 0xc8, 0x8a,
	0x91, 0xc8, 0x46, 0xb3, 0x9b, 0x6e, 0x52, 0x3b, 0x45, 0x7a, 0xb1, 0xd7, 0x76, 0x77, 0xd1, 0xdd,
	0xd4, 0xa0, 0x03, 0x04, 0xe8, 0x85, 0xf8, 0x44, 0x7e, 0xbb, 0x22, 0xcc, 0x3f, 0x02, 0x49, 0x45,
	0x4a, 0x9f, 0xa1, 0x0f, 0x10, 0x14, 0xbd, 0x14, 0x3d, 0xf5, 0x96, 0xb7, 0x68, 0x8f, 0x3d, 0xf4,
	0x01, 0x0a, 0xf7, 0xd8, 0x07, 0xe8, 0xad, 0x28, 0x66, 0xe6, 0x23, 0x45, 0xc9, 0x52, 0xa2, 0x02,
	0xbd, 0xac, 0xc8, 0x99, 0xdf, 0x90, 0x33, 0xf3, 0xcd, 0xfc, 0x66, 0xb8, 0xf0, 0xb3, 0x6b, 0x2f,
	0x1d, 0x4f, 0x47, 0x47, 0x4e, 0x14, 0x1c, 0xfb, 0xde, 0xf5, 0x38, 0x9d, 0xc8, 0xd9, 0x71, 0x20,
	0x7d, 0xf5, 0xe4, 0x78, 0x32, 0x3a, 0x4e, 0xc6, 0x32, 0x56, 0xae, 0x3d, 0x89, 0xa3, 0x34, 0x3a,
	0x4e, 0xa3, 0x99, 0x8a, 0x8f, 0xe8, 0x5a, 0x54, 0xe9, 0xe7, 0xce, 0x67, 0xdb, 0x5b, 0x8f, 0x64,
	0xa2, 0xd8, 0xf8, 0xce, 0xe3, 0xed, 0xad, 0x9c, 0x28, 0x18, 0xc9, 0x54, 0xdb, 0x3d, 0xd9, 0xde,
	0x2e, 0x88, 0xc2, 0x24, 0xcd, 0xbc, 0xbd, 0xf3, 0xf9, 0xf6, 0x86, 0x49, 0x28, 0x27, 0xc9, 0x38,
	0xd2, 0xaf, 0x1c, 0xfc, 0xa5, 0x04, 0xad, 0xaf, 0x30, 0xee, 0xe7, 0x32, 0x95, 0xaf, 0x28, 0xf4,
	0x3d, 0xa8, 0x5e, 0xf9, 0x51, 0x14, 0xf7, 0x8c, 0xbe, 0x31, 0xac, 0x5a, 0x7c, 0x23, 0xbe, 0x80,
	0xce, 0x95, 0x17, 0x27, 0xa9, 0x3d, 0x91, 0x49, 0x62, 0x4f, 0x62, 0xef, 0xb7, 0xaa, 0x57, 0xea,
	0x1b, 0xc3, 0xc6, 0x49, 0x97, 0x1f, 0x75, 0xf4, 0x0a, 0x65, 0xf4, 0x08, 0xab, 0x45, 0xd0, 0x57,
	0x32, 0x49, 0x48, 0x28, 0x3e, 0x01, 0x48, 0xc6, 0xd1, 0x4c, 0x9b, 0x95, 0x37, 0x99, 0xd5, 0x11,
	0xc4, 0x16, 0x47, 0x50, 0x1f, 0x45, 0x73, 0x6d, 0x50, 0xd9, 0x64, 0x50, 0x1b, 0x45, 0x73, 0xc6,
	0x0b, 0xa8, 0xb8, 0x2a, 0x71, 0x7a, 0xd5, 0xbe, 0x31, 0xac, 0x5b, 0x74, 0x2d, 0x3e, 0x85, 0x5b,
	0xd3, 0xd0, 0x8f, 0x9c, 0x37, 0x76, 0xa2, 0x9c, 0x58, 0xa5, 0x36, 0x1d, 0xb0, 0xed, 0xb9, 0xbd,
	0x1d, 0x8a, 0xec, 0x26, 0x6b, 0x5f, 0x93, 0x92, 0x92, 0x70, 0xee, 0x8a, 0x27, 0xb0, 0xab, 0x73,
	0xdb, 0xdb, 0xa7, 0xd7, 0xde, 0xd3, 0xaf, 0xbd, 0x64, 0xe9, 0xa5, 0xc4, 0xbf, 0x79, 0xb6, 0xac,
	0x0c, 0x3d, 0xf8, 0x83, 0x01, 0xfb, 0xf4, 0x90, 0x97, 0x98, 0x2f, 0x4b, 0x4d, 0x7c, 0xf9, 0xed,
	0x0f, 0x25, 0xf4, 0x18, 0x76, 0x62, 0x02, 0xf5, 0x4a, 0xfd, 0xf2, 0xb0, 0x71, 0x72, 0xa0, 0xdf,
	0x43, 0xcf, 0x28, 0x98, 0x5b, 0x1a, 0x26, 0x7e, 0x01, 0x4d, 0x3f, 0x9a, 0xa9, 0x24, 0xb5, 0xb5,
	0x1d, 0xe7, 0x71, 0xa3, 0x9d, 0xc9, 0x68, 0x16, 0x0d, 0xbe, 0xab, 0x40, 0x67, 0x15, 0xb2, 0xc1,
	0x33, 0x01, 0x95, 0xd4, 0x0b, 0xf8, 0x78, 0xab, 0x16, 0x5d, 0xa3, 0xcc, 0xf7, 0xc2, 0x37, 0xf4,
	0xce, 0xba, 0x45, 0xd7, 0x6b, 0x4b, 0xa2, 0xb2, 0x6d, 0x49, 0x7c, 0x04, 0x55, 0xb6, 0xa8, 0x6e,
	0xb2, 0x60, 0xbd, 0xf8, 0x18, 0xaa, 0x54, 0xc0, 0x74, 0x68, 0x8b, 0x70, 0x4f, 0xa9, 0x71, 0x5e,
	0xa3, 0x46, 0xc3, 0x09, 0x25, 0x1e, 0x42, 0x65, 0xac, 0xe2, 0xa8, 0x07, 0x84, 0xde, 0xd7, 0xe8,
	0x33, 0x15, 0x47, 0xcf, 0x64, 0xe2, 0x39, 0x8c, 0x25, 0x88, 0xb8, 0x0b, 0xbb, 0xf8, 0x8b, 0x05,
	0xd1, 0xe8, 0x1b, 0x43, 0xf3, 0x59, 0xa9, 0x67, 0x58, 0x3b, 0x28, 0x3a, 0x77, 0xc5, 0xfb, 0x50,
	0x27, 0x65, 0x28, 0x03, 0xd5, 0x33, 0x31, 0x6a, 0x52, 0xd7, 0x50, 0xf8, 0xa5, 0x0c, 0x94, 0xb8,
	0x07, 0xb5, 0xeb, 0xa9, 0xe7, 0xbb, 0x68, 0xde, 0xc4, 0x4c, 0x91, 0x7e, 0x97, 0x64, 0xe7, 0xae,
	0xb8, 0x0f, 0xc0, 0x6a, 0x7a, 0x40, 0x2b, 0x7f, 0x40, 0x9d, 0xa4, 0xf4, 0x84, 0x47, 0xd0, 0x66,
	0xc8, 0x95, 0x2f, 0xaf, 0x19, 0xd7, 0xce, 0x71, 0x4d, 0x52, 0xbd, 0xf4, 0xe5, 0x35, 0x61, 0x6f,
	0x41, 0x25, 0x96, 0x8e, 0xea, 0x75, 0xfa, 0x65, 0x7c, 0x53, 0xe7, 0x86, 0x45, 0xf7, 0xe2, 0x3e,
	0x98, 0x57, 0xd8, 0xf0, 0xb6, 0x0c, 0xa2, 0x69, 0x98, 0xf6, 0xba, 0x74, 0x66, 0x0d, 0x92, 0x3d,
	0x25, 0x51, 0x1e, 0xc9, 0x58, 0x49, 0xb7, 0x27, 0x96, 0x23, 0x39, 0x53, 0xd2, 0x1d, 0xfc, 0xab,
	0x02, 0x7b, 0x85, 0x26, 0x58, 0x30, 0x41, 0x0b, 0x4a, 0x9e, 0xab, 0x6b, 0xa3, 0xe4, 0xb9, 0x58,
	0x04, 0xe4, 0x65, 0x89, 0x8b, 0x00, 0xaf, 0xc5, 0x4f, 0x40, 0x04, 0x72, 0x6e, 0xcb, 0x34, 0x95,
	0xce, 0x1b, 0x15, 0xdb, 0x0e, 0xb9, 0x51, 0x26, 0x9b, 0x4e, 0x20, 0xe7, 0x4f, 0xb5, 0xe2, 0x94,
	0x7c, 0x41, 0xb4, 0x17, 0xae, 0xa2, 0x2b, 0x1a, 0xed, 0x85, 0xcb, 0xe8, 0x75, 0x4d, 0xbd, 0xae,
	0xe8, 0x76, 0xfe, 0xe7, 0xa2, 0xdb, 0xfd, 0x91, 0xa2, 0x3b, 0x81, 0x46, 0x32, 0x9d, 0xa8, 0x58,
	0xbf, 0xa0, 0xb6, 0x09, 0x0e, 0x84, 0xe2, 0x87, 0x17, 0x98, 0xa3, 0x4e, 0x1d, 0xbd, 0x25, 0x73,
	0x88, 0xc7, 0x70, 0xc0, 0x75, 0x30, 0x56, 0xfe, 0xc4, 0x76, 0xa2, 0x30, 0x8d, 0xbd, 0xd1, 0x34,
	0xf5, 0xa2, 0x90, 0xaa, 0xb8, 0x6a, 0xed, 0x93, 0xfa, 0x4c, 0xf9, 0x93, 0xd3, 0x82, 0x52, 0xbc,
	0x84, 0xfe, 0x4a, 0xea, 0xc3, 0xd4, 0x0b, 0xa7, 0x6a, 0x66, 0xcf, 0xbc, 0xd0, 0xc6, 0xb6, 0x4d,
	0xa8, 0xb0, 0xab, 0xd6, 0x7b, 0x4b, 0x07, 0xa1, 0x51, 0x5f, 0x7b, 0xe1, 0x57, 0x88, 0x11, 0x8f,
	0xa0, 0xab, 0x5d, 0xb1, 0x7d, 0x25, 0x5d, 0xa6, 0x48, 0x93, 0x0c, 0xdb, 0x5a, 0x71, 0x41, 0xf2,
	0x73, 0x17, 0x19, 0xc3, 0x0b, 0xe4, 0xb5, 0xae, 0x68, 0x8b, 0x6f, 0xf0, 0x09, 0x9a, 0x69, 0x99,
	0x62, 0x5d, 0x99, 0x4a, 0xaa, 0xe5, 0xaa, 0xd5, 0x66, 0x45, 0x5e, 0x59, 0x83, 0x3f, 0x19, 0x4b,
	0xd5, 0x76, 0xe9, 0x25, 0xdc, 0x94, 0xe2, 0x21, 0x74, 0x62, 0xe5, 0x44, 0xdf, 0xa0, 0xfd, 0x34,
	0x96, 0x14, 0x3f, 0xd7, 0x5e, 0x5b, 0xcb, 0x9f, 0x6b, 0xb1, 0xb8, 0x0b, 0x75, 0x8c, 0x9c, 0x43,
	0x64, 0x9a, 0xaa, 0x05, 0x72, 0xce, 0xe1, 0x3c, 0x80, 0x16, 0x2a, 0x29, 0x99, 0x8c, 0xe0, 0x6a,
	0x34, 0x03, 0x39, 0xc7, 0x1c, 0x32, 0xea, 0x1e, 0x00, 0xa2, 0xf0, 0xc9, 0xb1, 0x4b, 0x15, 0x56,
	0xb5, 0xf0, 0xa1, 0x16, 0x09, 0x06, 0xdf, 0x97, 0xe0, 0xa6, 0xf6, 0x52, 0xc9, 0xe0, 0x35, 0xcd,
	0x25, 0x74, 0xf2, 0x00, 0x76, 0x53, 0x25, 0x03, 0x3b, 0xef, 0x8b, 0x1d, 0xbc, 0x3d, 0x77, 0xc5,
	0x2d, 0xd8, 0xe1, 0xe4, 0x91, 0x3f, 0xa6, 0xa5, 0xef, 0xc4, 0x87, 0xd0, 0x5e, 0x9d, 0x3e, 0xec,
	0x4e, 0x33, 0x59, 0x9a, 0x3b, 0x43, 0xe8, 0x38, 0xd3, 0xd8, 0x0e, 0x54, 0x30, 0x5a, 0xe9, 0x8b,
	0x96, 0x33, 0x8d, 0x2f, 0x49, 0xcc, 0x5d, 0x31, 0x04, 0xec, 0xab, 0x65, 0x24, 0xfb, 0x8f, 0x71,
	0x17, 0x91, 0xb7, 0x0b, 0x14, 0xc5, 0x23, 0x2f, 0xa7, 0xa7, 0xf7, 0xa1, 0xe1, 0xc4, 0x4a, 0xa6,
	0x8a, 0x52, 0x44, 0xfd, 0x50, 0xb5, 0x80, 0x45, 0x98, 0x20, 0xf1, 0x09, 0x08, 0xfd, 0x06, 0xf6,
	0x9b, 0xe7, 0x44, 0x2d, 0xa7, 0x9f, 0x0e, 0x6b, 0x17, 0x13, 0x6f, 0xf0, 0x77, 0x03, 0xf6, 0x17,
	0x29, 0x7b, 0xae, 0x52, 0xe9, 0xf9, 0x3f, 0x92, 0xb4, 0xbb, 0x50, 0x5f, 0x54, 0x1c, 0xe7, 0xad,
	0xe6, 0x67, 0xa5, 0xd6, 0x83, 0x5d, 0x7e, 0x07, 0x1e, 0x60, 0x79, 0x68, 0x5a, 0xd9, 0xed, 0xba,
	0x9c, 0x56, 0xd6, 0xe5, 0xb4, 0x18, 0x7f, 0x75, 0x39, 0xfe, 0x21, 0x74, 0xb0, 0x39, 0x95, 0x93,
	0xda, 0x2a, 0x74, 0x39, 0x09, 0x9c, 0xa2, 0x96, 0x96, 0xbf, 0x08, 0x5d, 0x4c, 0xc4, 0xe0, 0x77,
	0x25, 0xb8, 0x53, 0xa8, 0x57, 0x8c, 0x8d, 0x73, 0xcc, 0xb1, 0xdd, 0x03, 0x48, 0xa4, 0xe7, 0xda,
	0xb3, 0x28, 0x76, 0x13, 0x1d, 0x5e, 0x1d, 0x25, 0x5f, 0xa3, 0x00, 0x23, 0x24, 0x75, 0x61, 0xa0,
	0xd6, 0x50, 0x40, 0x39, 0xfe, 0xa9, 0x9e, 0x55, 0xb5, 0xa5, 0x45, 0x23, 0x9f, 0x55, 0xaf, 0xf5,
	0xaa, 0x56, 0x9c, 0x59, 0x43, 0xa8, 0x04, 0x91, 0xab, 0x88, 0x18, 0x5a, 0x27, 0x7b, 0xc5, 0xd9,
	0x4f, 0x9e, 0x45, 0xae, 0xb2, 0x08, 0x21, 0x4e, 0xc0, 0x74, 0xe4, 0x24, 0x95, 0x5e, 0x68, 0xd3,
	0xe4, 0x68, 0xf7, 0xcb, 0xc3, 0xd6, 0x49, 0x43, 0x5b, 0x58, 0xd2, 0x51, 0x74, 0x8e, 0x0d, 0x0d,
	0xb2, 0xd6, 0x4d, 0x93, 0xce, 0x3b, 0xd3, 0x64, 0xf0, 0x7d, 0x25, 0x4b, 0xc7, 0xe9, 0x58, 0xfa,
	0xbe, 0x0a, 0xaf, 0x95, 0xa5, 0x92, 0xa9, 0xcf, 0x5e, 0x8a, 0x0e, 0x94, 0x67, 0x1e, 0xf7, 0x6d,
	0xcd, 0xc2, 0xcb, 0x7c, 0x73, 0x28, 0x15, 0x36, 0x87, 0xfb, 0x60, 0xbe, 0xf1, 0x7c, 0xdf, 0xce,
	0xf8, 0x92, 0x3b, 0xa2, 0x81, 0x32, 0x4d, 0x96, 0x08, 0xf1, 0xd5, 0x55, 0x9a, 0x43, 0xf8, 0x80,
	0x1b, 0x28, 0xcb, 0x20, 0x0f, 0xa0, 0x55, 0x20, 0xe9, 0xec, 0x90, 0x4d, 0xcb, 0x5c, 0x90, 0xf2,
	0xb9, 0x2b, 0x3e, 0x5f, 0x94, 0xd1, 0x0e, 0xd1, 0xf2, 0xa1, 0x4e, 0x01, 0x47, 0xc1, 0x67, 0x59,
	0x08, 0x61, 0x51, 0x66, 0x2b, 0x43, 0x60, 0x77, 0x9b, 0x21, 0xb0, 0xa6, 0x34, 0x6b, 0x1b, 0xda,
	0x9d, 0x79, 0xbb, 0x40, 0xb9, 0x75, 0xf2, 0xbe, 0xc5, 0xf2, 0x9c, 0x71, 0x1f, 0x41, 0xd7, 0x55,
	0x57, 0x2a, 0x74, 0x54, 0x01, 0x0a, 0x04, 0x6d, 0x6b, 0x45, 0x8e, 0xcd, 0x77, 0xa5, 0xc6, 0x56,
	0xbb, 0x12, 0x72, 0xe0, 0xd4, 0x4f, 0x3d, 0x9b, 0x0e, 0xc8, 0xec, 0x97, 0x87, 0x75, 0xab, 0x4e,
	0x92, 0x0b, 0x7d, 0x4a, 0xda, 0x47, 0x26, 0x99, 0x26, 0x1f, 0x01, 0xcb, 0x98, 0x61, 0x3e, 0x80,
	0x66, 0xe6, 0x1c, 0x63, 0x5a, 0x4c, 0xb5, 0x5a, 0x48, 0xa0, 0xc1, 0xbf, 0x4b, 0x70, 0xb0, 0x21,
	0xd9, 0x85, 0x15, 0xc3, 0xdc, 0xb8, 0x62, 0x08, 0x6c, 0x13, 0xe9, 0x66, 0xbb, 0x27, 0x5e, 0xe3,
	0x1c, 0xf2, 0xd5, 0x37, 0xca, 0xd7, 0x75, 0xc1, 0x37, 0x48, 0x19, 0xba, 0xc1, 0x57, 0xfb, 0xfd,
	0x01, 0x2c, 0x2f, 0x54, 0xd4, 0xec, 0xf5, 0xd5, 0x2d, 0xeb, 0x3d, 0x58, 0xac, 0x67, 0x74, 0xde,
	0xf5, 0xe2, 0xbe, 0x76, 0x04, 0x37, 0xb3, 0x11, 0x6b, 0x53, 0xf9, 0x72, 0xc8, 0x3c, 0xa3, 0xbb,
	0x99, 0xea, 0x57, 0x9e, 0xef, 0xe7, 0x44, 0xfd, 0xce, 0xaa, 0xd2, 0xa6, 0xc6, 0x58, 0xdd, 0x4b,
	0x3e, 0x06, 0xc1, 0x44, 0xb5, 0x34, 0xfc, 0xb9, 0xfb, 0xba, 0xa4, 0x59, 0x1a, 0xfc, 0xf9, 0x1a,
	0xd3, 0xfd, 0xe1, 0x35, 0x66, 0xf0, 0x7b, 0x03, 0xba, 0x9c, 0x79, 0x1e, 0x6b, 0x9b, 0x7a, 0x34,
	0xaf, 0x9b, 0xd2, 0x56, 0x75, 0xf3, 0x7f, 0x69, 0xdf, 0xc1, 0x1f, 0x4b, 0xd0, 0x42, 0xae, 0xa3,
	0x96, 0x60, 0xcf, 0x3e, 0x82, 0xb6, 0x93, 0xb1, 0x8a, 0x9e, 0xdd, 0x86, 0x9e, 0x81, 0x99, 0x98,
	0xa7, 0xf7, 0x07, 0xd0, 0x74, 0xa6, 0x71, 0xac, 0xc2, 0x54, 0x0f, 0x26, 0xa6, 0x56, 0x53, 0x0b,
	0x69, 0x20, 0x61, 0xe7, 0x8c, 0xbd, 0x24, 0x8d, 0xe2, 0x6f, 0x6d, 0x1c, 0x98, 0x0c, 0x64, 0x5f,
	0xdb, 0x5a, 0x71, 0x29, 0xe7, 0x8c, 0x7d, 0x00, 0x2d, 0x39, 0x4d, 0xa3, 0x02, 0x90, 0x3d, 0x36,
	0x51, 0x9a, 0xa3, 0x3e, 0x83, 0x3d, 0x27, 0xf2, 0x7d, 0xe5, 0xa4, 0xca, 0xb5, 0xf1, 0xfb, 0x94,
	0xa0, 0x4c, 0x2c, 0x3c, 0x16, 0x45, 0xae, 0x7f, 0x16, 0xb1, 0x51, 0x22, 0x7e, 0x0e, 0xb7, 0x43,
	0x35, 0xc7, 0xcf, 0xb6, 0x44, 0xa5, 0xf6, 0x72, 0x80, 0x9a, 0x1d, 0x6e, 0x21, 0xc0, 0x42, 0xfd,
	0x69, 0x31, 0xd0, 0xc1, 0x7f, 0x0c, 0xd8, 0xc3, 0x1c, 0x15, 0x06, 0x50, 0x3e, 0x76, 0x0a, 0x0b,
	0x8e, 0x1e, 0x3b, 0xe3, 0x7c, 0xbb, 0x79, 0x08, 0x5d, 0x8c, 0x24, 0x9a, 0xa8, 0x70, 0x75, 0xef,
	0xc0, 0x25, 0xe1, 0xd7, 0x13, 0x15, 0x66, 0x4c, 0xf4, 0x05, 0xf4, 0x16, 0x31, 0xe9, 0x7a, 0xcd,
	0xf8, 0xb4, 0x92, 0xc7, 0xb5, 0x9f, 0x63, 0x5e, 0x52, 0xe9, 0x6a, 0x72, 0x7d, 0x0c, 0x07, 0x59,
	0x8a, 0x57, 0x0f, 0x8e, 0x1b, 0x70, 0x5f, 0xab, 0x4f, 0x97, 0xcf, 0x6f, 0xcd, 0x41, 0x37, 0xd6,
	0x1d, 0xf4, 0xe0, 0xcf, 0xc6, 0xd2, 0xf4, 0x3d, 0x1d, 0xcb, 0xa5, 0x52, 0x3e, 0x58, 0x7c, 0xc2,
	0x31, 0x87, 0x64, 0x9f, 0x6f, 0x77, 0x8b, 0x9f, 0x6f, 0x4c, 0x26, 0x8b, 0x4f, 0xb7, 0x0f, 0xdf,
	0xfd, 0xf0, 0x2a, 0xaf, 0xa3, 0x83, 0xdb, 0x50, 0xa3, 0xb1, 0xbe, 0x58, 0x30, 0x76, 0xe9, 0xfe,
	0x9c, 0x78, 0x2a, 0x55, 0xf3, 0x34, 0xfb, 0x34, 0xc1, 0xeb, 0x47, 0x43, 0x68, 0x2e, 0x0d, 0x62,
	0xd1, 0x84, 0xfa, 0xe9, 0xd9, 0xd3, 0x8b, 0x8b, 0x17, 0x5f, 0xfe, 0xf2, 0x45, 0xe7, 0x86, 0xa8,
	0x41, 0xe5, 0xec, 0xc5, 0xc5, 0xab, 0x8e, 0xf1, 0xac, 0xff, 0xd7, 0xb7, 0x87, 0xc6, 0xdf, 0xde,
	0x1e, 0x1a, 0xff, 0x78, 0x7b, 0x68, 0x7c, 0xf7, 0xcf, 0xc3, 0x1b, 0x67, 0xc6, 0x6f, 0xcc, 0xe2,
	0xbf, 0x69, 0x46, 0x3b, 0xf4, 0xf3, 0xe9, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x9e, 0xb0, 0xad,
	0xd7, 0xbf, 0x12, 0x00, 0x00,
}
