// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/shared_proto/goods.proto
// DO NOT EDIT!

package shared_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type GoodsEffectType int32

const (
	GoodsEffectType_Normal           GoodsEffectType = 0
	GoodsEffectType_EFFECT_RESOURCE  GoodsEffectType = 1
	GoodsEffectType_EFFECT_CDR       GoodsEffectType = 2
	GoodsEffectType_EFFECT_MOVE_BASE GoodsEffectType = 3
	GoodsEffectType_EFFECT_EXP       GoodsEffectType = 4
	GoodsEffectType_EFFECT_MIAN      GoodsEffectType = 5
	GoodsEffectType_EFFECT_SPEED_UP  GoodsEffectType = 6
	GoodsEffectType_EFFECT_TRAIN_EXP GoodsEffectType = 7
	GoodsEffectType_EFFECT_PARTS     GoodsEffectType = 8
	GoodsEffectType_EFFECT_TFL       GoodsEffectType = 9
	GoodsEffectType_EFFECT_DURATION  GoodsEffectType = 10
	GoodsEffectType_EFFECT_AMOUNT    GoodsEffectType = 11
	GoodsEffectType_EFFECT_GCL       GoodsEffectType = 12
	GoodsEffectType_EFFECT_BUFF      GoodsEffectType = 13
)

var GoodsEffectType_name = map[int32]string{
	0:  "Normal",
	1:  "EFFECT_RESOURCE",
	2:  "EFFECT_CDR",
	3:  "EFFECT_MOVE_BASE",
	4:  "EFFECT_EXP",
	5:  "EFFECT_MIAN",
	6:  "EFFECT_SPEED_UP",
	7:  "EFFECT_TRAIN_EXP",
	8:  "EFFECT_PARTS",
	9:  "EFFECT_TFL",
	10: "EFFECT_DURATION",
	11: "EFFECT_AMOUNT",
	12: "EFFECT_GCL",
	13: "EFFECT_BUFF",
}
var GoodsEffectType_value = map[string]int32{
	"Normal":           0,
	"EFFECT_RESOURCE":  1,
	"EFFECT_CDR":       2,
	"EFFECT_MOVE_BASE": 3,
	"EFFECT_EXP":       4,
	"EFFECT_MIAN":      5,
	"EFFECT_SPEED_UP":  6,
	"EFFECT_TRAIN_EXP": 7,
	"EFFECT_PARTS":     8,
	"EFFECT_TFL":       9,
	"EFFECT_DURATION":  10,
	"EFFECT_AMOUNT":    11,
	"EFFECT_GCL":       12,
	"EFFECT_BUFF":      13,
}

func (x GoodsEffectType) String() string {
	return proto.EnumName(GoodsEffectType_name, int32(x))
}
func (GoodsEffectType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGoods, []int{0} }

type GoodsExpEffectType int32

const (
	GoodsExpEffectType_InvalidGoodsExp          GoodsExpEffectType = 0
	GoodsExpEffectType_EXP_HERO                 GoodsExpEffectType = 1
	GoodsExpEffectType_EXP_CAPTAIN_REFINED      GoodsExpEffectType = 2
	GoodsExpEffectType_EXP_CAPTAIN_REBIRTH      GoodsExpEffectType = 3
	GoodsExpEffectType_EXP_CAPTAIN_SOUL_UPGRADE GoodsExpEffectType = 4
	GoodsExpEffectType_EXP_GONG_XUN             GoodsExpEffectType = 5
	GoodsExpEffectType_EXP_CAPTAIN              GoodsExpEffectType = 6
)

var GoodsExpEffectType_name = map[int32]string{
	0: "InvalidGoodsExp",
	1: "EXP_HERO",
	2: "EXP_CAPTAIN_REFINED",
	3: "EXP_CAPTAIN_REBIRTH",
	4: "EXP_CAPTAIN_SOUL_UPGRADE",
	5: "EXP_GONG_XUN",
	6: "EXP_CAPTAIN",
}
var GoodsExpEffectType_value = map[string]int32{
	"InvalidGoodsExp":          0,
	"EXP_HERO":                 1,
	"EXP_CAPTAIN_REFINED":      2,
	"EXP_CAPTAIN_REBIRTH":      3,
	"EXP_CAPTAIN_SOUL_UPGRADE": 4,
	"EXP_GONG_XUN":             5,
	"EXP_CAPTAIN":              6,
}

func (x GoodsExpEffectType) String() string {
	return proto.EnumName(GoodsExpEffectType_name, int32(x))
}
func (GoodsExpEffectType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGoods, []int{1} }

type GoodsMoveBaseType int32

const (
	GoodsMoveBaseType_InvalidGoodsMoveBase GoodsMoveBaseType = 0
	GoodsMoveBaseType_MOVE_BASE_POINT      GoodsMoveBaseType = 1
	GoodsMoveBaseType_MOVE_BASE_RANDOM     GoodsMoveBaseType = 2
	GoodsMoveBaseType_MOVE_BASE_GUILD      GoodsMoveBaseType = 3
)

var GoodsMoveBaseType_name = map[int32]string{
	0: "InvalidGoodsMoveBase",
	1: "MOVE_BASE_POINT",
	2: "MOVE_BASE_RANDOM",
	3: "MOVE_BASE_GUILD",
}
var GoodsMoveBaseType_value = map[string]int32{
	"InvalidGoodsMoveBase": 0,
	"MOVE_BASE_POINT":      1,
	"MOVE_BASE_RANDOM":     2,
	"MOVE_BASE_GUILD":      3,
}

func (x GoodsMoveBaseType) String() string {
	return proto.EnumName(GoodsMoveBaseType_name, int32(x))
}
func (GoodsMoveBaseType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGoods, []int{2} }

type GoodsAmountType int32

const (
	GoodsAmountType_InvalidAmount   GoodsAmountType = 0
	GoodsAmountType_AmountHufu      GoodsAmountType = 1
	GoodsAmountType_AmountZhanjiang GoodsAmountType = 2
	GoodsAmountType_AmountTower     GoodsAmountType = 3
	GoodsAmountType_AmountJunTuan   GoodsAmountType = 4
)

var GoodsAmountType_name = map[int32]string{
	0: "InvalidAmount",
	1: "AmountHufu",
	2: "AmountZhanjiang",
	3: "AmountTower",
	4: "AmountJunTuan",
}
var GoodsAmountType_value = map[string]int32{
	"InvalidAmount":   0,
	"AmountHufu":      1,
	"AmountZhanjiang": 2,
	"AmountTower":     3,
	"AmountJunTuan":   4,
}

func (x GoodsAmountType) String() string {
	return proto.EnumName(GoodsAmountType_name, int32(x))
}
func (GoodsAmountType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGoods, []int{3} }

type GoodsSpecType int32

const (
	GoodsSpecType_InvalidGoodsAmountType      GoodsSpecType = 0
	GoodsSpecType_GAT_GOLD                    GoodsSpecType = 1
	GoodsSpecType_GAT_FOOD                    GoodsSpecType = 2
	GoodsSpecType_GAT_WOOD                    GoodsSpecType = 3
	GoodsSpecType_GAT_STONE                   GoodsSpecType = 4
	GoodsSpecType_GAT_YUANBAO                 GoodsSpecType = 5
	GoodsSpecType_GAT_CAPTAIN_EXP             GoodsSpecType = 6
	GoodsSpecType_GAT_HERO_EXP                GoodsSpecType = 7
	GoodsSpecType_GAT_PROSPERITY              GoodsSpecType = 8
	GoodsSpecType_GAT_DIANQUAN                GoodsSpecType = 9
	GoodsSpecType_GAT_GUILD_CONTRIBUTION_COIN GoodsSpecType = 10
	GoodsSpecType_GAT_GUILD_CONTRIBUTION      GoodsSpecType = 11
	GoodsSpecType_GAT_HEBI                    GoodsSpecType = 12
	GoodsSpecType_GAT_HEBI_COPY_SELF          GoodsSpecType = 13
	GoodsSpecType_GAT_CHANGE_COUNTRY          GoodsSpecType = 14
	GoodsSpecType_GAT_YIN_LIANG               GoodsSpecType = 15
	GoodsSpecType_GAT_SP                      GoodsSpecType = 16
)

var GoodsSpecType_name = map[int32]string{
	0:  "InvalidGoodsAmountType",
	1:  "GAT_GOLD",
	2:  "GAT_FOOD",
	3:  "GAT_WOOD",
	4:  "GAT_STONE",
	5:  "GAT_YUANBAO",
	6:  "GAT_CAPTAIN_EXP",
	7:  "GAT_HERO_EXP",
	8:  "GAT_PROSPERITY",
	9:  "GAT_DIANQUAN",
	10: "GAT_GUILD_CONTRIBUTION_COIN",
	11: "GAT_GUILD_CONTRIBUTION",
	12: "GAT_HEBI",
	13: "GAT_HEBI_COPY_SELF",
	14: "GAT_CHANGE_COUNTRY",
	15: "GAT_YIN_LIANG",
	16: "GAT_SP",
}
var GoodsSpecType_value = map[string]int32{
	"InvalidGoodsAmountType":      0,
	"GAT_GOLD":                    1,
	"GAT_FOOD":                    2,
	"GAT_WOOD":                    3,
	"GAT_STONE":                   4,
	"GAT_YUANBAO":                 5,
	"GAT_CAPTAIN_EXP":             6,
	"GAT_HERO_EXP":                7,
	"GAT_PROSPERITY":              8,
	"GAT_DIANQUAN":                9,
	"GAT_GUILD_CONTRIBUTION_COIN": 10,
	"GAT_GUILD_CONTRIBUTION":      11,
	"GAT_HEBI":                    12,
	"GAT_HEBI_COPY_SELF":          13,
	"GAT_CHANGE_COUNTRY":          14,
	"GAT_YIN_LIANG":               15,
	"GAT_SP":                      16,
}

func (x GoodsSpecType) String() string {
	return proto.EnumName(GoodsSpecType_name, int32(x))
}
func (GoodsSpecType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGoods, []int{4} }

type GoodsDurationEffectType int32

const (
	GoodsDurationEffectType_InvalidGoodsDuration GoodsDurationEffectType = 0
	GoodsDurationEffectType_COPY_DEFENSER        GoodsDurationEffectType = 1
)

var GoodsDurationEffectType_name = map[int32]string{
	0: "InvalidGoodsDuration",
	1: "COPY_DEFENSER",
}
var GoodsDurationEffectType_value = map[string]int32{
	"InvalidGoodsDuration": 0,
	"COPY_DEFENSER":        1,
}

func (x GoodsDurationEffectType) String() string {
	return proto.EnumName(GoodsDurationEffectType_name, int32(x))
}
func (GoodsDurationEffectType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGoods, []int{5} }

// 玉璧类型
type HebiType int32

const (
	HebiType_HebiInvalidType HebiType = 0
	HebiType_HeShiBi         HebiType = 1
	HebiType_HuWenBi         HebiType = 2
	HebiType_XueFengBi       HebiType = 3
)

var HebiType_name = map[int32]string{
	0: "HebiInvalidType",
	1: "HeShiBi",
	2: "HuWenBi",
	3: "XueFengBi",
}
var HebiType_value = map[string]int32{
	"HebiInvalidType": 0,
	"HeShiBi":         1,
	"HuWenBi":         2,
	"XueFengBi":       3,
}

func (x HebiType) String() string {
	return proto.EnumName(HebiType_name, int32(x))
}
func (HebiType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGoods, []int{6} }

// 玉璧左右
type HebiSubType int32

const (
	HebiSubType_HebiInvalidSubType HebiSubType = 0
	HebiSubType_HebiLeft           HebiSubType = 1
	HebiSubType_HebiRight          HebiSubType = 2
)

var HebiSubType_name = map[int32]string{
	0: "HebiInvalidSubType",
	1: "HebiLeft",
	2: "HebiRight",
}
var HebiSubType_value = map[string]int32{
	"HebiInvalidSubType": 0,
	"HebiLeft":           1,
	"HebiRight":          2,
}

func (x HebiSubType) String() string {
	return proto.EnumName(HebiSubType_name, int32(x))
}
func (HebiSubType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGoods, []int{7} }

type EquipmentType int32

const (
	EquipmentType_InvalidEquipmentType EquipmentType = 0
	EquipmentType_WU_QI                EquipmentType = 1
	EquipmentType_TOU_KUI              EquipmentType = 2
	EquipmentType_KAI_JIA              EquipmentType = 3
	EquipmentType_SHI_PIN              EquipmentType = 4
	EquipmentType_HU_TUI               EquipmentType = 5
)

var EquipmentType_name = map[int32]string{
	0: "InvalidEquipmentType",
	1: "WU_QI",
	2: "TOU_KUI",
	3: "KAI_JIA",
	4: "SHI_PIN",
	5: "HU_TUI",
}
var EquipmentType_value = map[string]int32{
	"InvalidEquipmentType": 0,
	"WU_QI":                1,
	"TOU_KUI":              2,
	"KAI_JIA":              3,
	"SHI_PIN":              4,
	"HU_TUI":               5,
}

func (x EquipmentType) String() string {
	return proto.EnumName(EquipmentType_name, int32(x))
}
func (EquipmentType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGoods, []int{8} }

type GoodsDataProto struct {
	Id            int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name          string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Desc          string   `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	IconId        string   `protobuf:"bytes,7,opt,name=icon_id,json=iconId,proto3" json:"icon_id,omitempty"`
	ObtainWays    []string `protobuf:"bytes,12,rep,name=obtain_ways,json=obtainWays" json:"obtain_ways,omitempty"`
	Quality       Quality  `protobuf:"varint,5,opt,name=quality,proto3,enum=proto.Quality" json:"quality,omitempty"`
	GoodsQuality  int32    `protobuf:"varint,10,opt,name=goods_quality,json=goodsQuality,proto3" json:"goods_quality,omitempty"`
	YuanbaoPrice  int32    `protobuf:"varint,6,opt,name=yuanbao_price,json=yuanbaoPrice,proto3" json:"yuanbao_price,omitempty"`
	DianquanPrice int32    `protobuf:"varint,9,opt,name=dianquan_price,json=dianquanPrice,proto3" json:"dianquan_price,omitempty"`
	YinliangPrice int32    `protobuf:"varint,11,opt,name=yinliang_price,json=yinliangPrice,proto3" json:"yinliang_price,omitempty"`
	Cd            int32    `protobuf:"varint,8,opt,name=cd,proto3" json:"cd,omitempty"`
	Captain       int32    `protobuf:"varint,4,opt,name=captain,proto3" json:"captain,omitempty"`
	// 效果
	EffectType       GoodsEffectType   `protobuf:"varint,20,opt,name=effect_type,json=effectType,proto3,enum=proto.GoodsEffectType" json:"effect_type,omitempty"`
	GoodsEffect      *GoodsEffectProto `protobuf:"bytes,25,opt,name=goods_effect,json=goodsEffect" json:"goods_effect,omitempty"`
	SpecType         GoodsSpecType     `protobuf:"varint,31,opt,name=spec_type,json=specType,proto3,enum=proto.GoodsSpecType" json:"spec_type,omitempty"`
	HebiType         HebiType          `protobuf:"varint,32,opt,name=hebi_type,json=hebiType,proto3,enum=proto.HebiType" json:"hebi_type,omitempty"`
	HebiSubType      HebiSubType       `protobuf:"varint,33,opt,name=hebi_sub_type,json=hebiSubType,proto3,enum=proto.HebiSubType" json:"hebi_sub_type,omitempty"`
	PartnerHebiGoods int32             `protobuf:"varint,34,opt,name=partner_hebi_goods,json=partnerHebiGoods,proto3" json:"partner_hebi_goods,omitempty"`
}

func (m *GoodsDataProto) Reset()                    { *m = GoodsDataProto{} }
func (m *GoodsDataProto) String() string            { return proto.CompactTextString(m) }
func (*GoodsDataProto) ProtoMessage()               {}
func (*GoodsDataProto) Descriptor() ([]byte, []int) { return fileDescriptorGoods, []int{0} }

func (m *GoodsDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GoodsDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GoodsDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *GoodsDataProto) GetIconId() string {
	if m != nil {
		return m.IconId
	}
	return ""
}

func (m *GoodsDataProto) GetObtainWays() []string {
	if m != nil {
		return m.ObtainWays
	}
	return nil
}

func (m *GoodsDataProto) GetQuality() Quality {
	if m != nil {
		return m.Quality
	}
	return Quality_InvalidQuality
}

func (m *GoodsDataProto) GetGoodsQuality() int32 {
	if m != nil {
		return m.GoodsQuality
	}
	return 0
}

func (m *GoodsDataProto) GetYuanbaoPrice() int32 {
	if m != nil {
		return m.YuanbaoPrice
	}
	return 0
}

func (m *GoodsDataProto) GetDianquanPrice() int32 {
	if m != nil {
		return m.DianquanPrice
	}
	return 0
}

func (m *GoodsDataProto) GetYinliangPrice() int32 {
	if m != nil {
		return m.YinliangPrice
	}
	return 0
}

func (m *GoodsDataProto) GetCd() int32 {
	if m != nil {
		return m.Cd
	}
	return 0
}

func (m *GoodsDataProto) GetCaptain() int32 {
	if m != nil {
		return m.Captain
	}
	return 0
}

func (m *GoodsDataProto) GetEffectType() GoodsEffectType {
	if m != nil {
		return m.EffectType
	}
	return GoodsEffectType_Normal
}

func (m *GoodsDataProto) GetGoodsEffect() *GoodsEffectProto {
	if m != nil {
		return m.GoodsEffect
	}
	return nil
}

func (m *GoodsDataProto) GetSpecType() GoodsSpecType {
	if m != nil {
		return m.SpecType
	}
	return GoodsSpecType_InvalidGoodsAmountType
}

func (m *GoodsDataProto) GetHebiType() HebiType {
	if m != nil {
		return m.HebiType
	}
	return HebiType_HebiInvalidType
}

func (m *GoodsDataProto) GetHebiSubType() HebiSubType {
	if m != nil {
		return m.HebiSubType
	}
	return HebiSubType_HebiInvalidSubType
}

func (m *GoodsDataProto) GetPartnerHebiGoods() int32 {
	if m != nil {
		return m.PartnerHebiGoods
	}
	return 0
}

// 物品品质
type GoodsQualityProto struct {
	Level   int32   `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	Quality Quality `protobuf:"varint,3,opt,name=quality,proto3,enum=proto.Quality" json:"quality,omitempty"`
	Name    string  `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GoodsQualityProto) Reset()                    { *m = GoodsQualityProto{} }
func (m *GoodsQualityProto) String() string            { return proto.CompactTextString(m) }
func (*GoodsQualityProto) ProtoMessage()               {}
func (*GoodsQualityProto) Descriptor() ([]byte, []int) { return fileDescriptorGoods, []int{1} }

func (m *GoodsQualityProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *GoodsQualityProto) GetQuality() Quality {
	if m != nil {
		return m.Quality
	}
	return Quality_InvalidQuality
}

func (m *GoodsQualityProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type GoodsEffectProto struct {
	// 资源类物品
	Gold  int32 `protobuf:"varint,1,opt,name=gold,proto3" json:"gold,omitempty"`
	Food  int32 `protobuf:"varint,2,opt,name=food,proto3" json:"food,omitempty"`
	Wood  int32 `protobuf:"varint,3,opt,name=wood,proto3" json:"wood,omitempty"`
	Stone int32 `protobuf:"varint,4,opt,name=stone,proto3" json:"stone,omitempty"`
	// 减少cd类物品
	BuildingCdr bool  `protobuf:"varint,5,opt,name=building_cdr,json=buildingCdr,proto3" json:"building_cdr,omitempty"`
	TechCdr     bool  `protobuf:"varint,6,opt,name=tech_cdr,json=techCdr,proto3" json:"tech_cdr,omitempty"`
	WorkshopCdr bool  `protobuf:"varint,14,opt,name=workshop_cdr,json=workshopCdr,proto3" json:"workshop_cdr,omitempty"`
	Cdr         int32 `protobuf:"varint,7,opt,name=cdr,proto3" json:"cdr,omitempty"`
	// 经验丹物品
	ExpType GoodsExpEffectType `protobuf:"varint,8,opt,name=exp_type,json=expType,proto3,enum=proto.GoodsExpEffectType" json:"exp_type,omitempty"`
	Exp     int32              `protobuf:"varint,9,opt,name=exp,proto3" json:"exp,omitempty"`
	// 迁移城池物品
	MoveBaseType  GoodsMoveBaseType `protobuf:"varint,15,opt,name=move_base_type,json=moveBaseType,proto3,enum=proto.GoodsMoveBaseType" json:"move_base_type,omitempty"`
	MoveBase      bool              `protobuf:"varint,10,opt,name=move_base,json=moveBase,proto3" json:"move_base,omitempty"`
	MoveTent      bool              `protobuf:"varint,12,opt,name=move_tent,json=moveTent,proto3" json:"move_tent,omitempty"`
	RandomPos     bool              `protobuf:"varint,11,opt,name=random_pos,json=randomPos,proto3" json:"random_pos,omitempty"`
	GuildMoveBase bool              `protobuf:"varint,13,opt,name=guild_move_base,json=guildMoveBase,proto3" json:"guild_move_base,omitempty"`
	// 免战牌
	MianDuration     int32 `protobuf:"varint,21,opt,name=mian_duration,json=mianDuration,proto3" json:"mian_duration,omitempty"`
	TroopSpeedUpRate int32 `protobuf:"varint,22,opt,name=troop_speed_up_rate,json=troopSpeedUpRate,proto3" json:"troop_speed_up_rate,omitempty"`
	// 修炼馆经验丹
	TrainDuration int32 `protobuf:"varint,23,opt,name=train_duration,json=trainDuration,proto3" json:"train_duration,omitempty"`
	// 零件
	PartsCombineId    int32         `protobuf:"varint,24,opt,name=parts_combine_id,json=partsCombineId,proto3" json:"parts_combine_id,omitempty"`
	PartsCombineCount int32         `protobuf:"varint,25,opt,name=parts_combine_count,json=partsCombineCount,proto3" json:"parts_combine_count,omitempty"`
	PartsShowPrize    []*PrizeProto `protobuf:"bytes,27,rep,name=parts_show_prize,json=partsShowPrize" json:"parts_show_prize,omitempty"`
	PartsShowType     int32         `protobuf:"varint,28,opt,name=parts_show_type,json=partsShowType,proto3" json:"parts_show_type,omitempty"`
	// 讨伐令
	AddMultiLevelNpcTimes bool `protobuf:"varint,26,opt,name=add_multi_level_npc_times,json=addMultiLevelNpcTimes,proto3" json:"add_multi_level_npc_times,omitempty"`
	// 攻城令
	AddInvaseHeroTimes bool `protobuf:"varint,33,opt,name=add_invase_hero_times,json=addInvaseHeroTimes,proto3" json:"add_invase_hero_times,omitempty"`
	// 时间物品
	DurationType GoodsDurationEffectType `protobuf:"varint,29,opt,name=duration_type,json=durationType,proto3,enum=proto.GoodsDurationEffectType" json:"duration_type,omitempty"`
	Duration     int32                   `protobuf:"varint,30,opt,name=duration,proto3" json:"duration,omitempty"`
	// 数据类物品(比如虎符)
	AmountType GoodsAmountType `protobuf:"varint,31,opt,name=amount_type,json=amountType,proto3,enum=proto.GoodsAmountType" json:"amount_type,omitempty"`
	Amount     int32           `protobuf:"varint,32,opt,name=amount,proto3" json:"amount,omitempty"`
	// buff id
	BuffId int32 `protobuf:"varint,34,opt,name=buff_id,json=buffId,proto3" json:"buff_id,omitempty"`
}

func (m *GoodsEffectProto) Reset()                    { *m = GoodsEffectProto{} }
func (m *GoodsEffectProto) String() string            { return proto.CompactTextString(m) }
func (*GoodsEffectProto) ProtoMessage()               {}
func (*GoodsEffectProto) Descriptor() ([]byte, []int) { return fileDescriptorGoods, []int{2} }

func (m *GoodsEffectProto) GetGold() int32 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *GoodsEffectProto) GetFood() int32 {
	if m != nil {
		return m.Food
	}
	return 0
}

func (m *GoodsEffectProto) GetWood() int32 {
	if m != nil {
		return m.Wood
	}
	return 0
}

func (m *GoodsEffectProto) GetStone() int32 {
	if m != nil {
		return m.Stone
	}
	return 0
}

func (m *GoodsEffectProto) GetBuildingCdr() bool {
	if m != nil {
		return m.BuildingCdr
	}
	return false
}

func (m *GoodsEffectProto) GetTechCdr() bool {
	if m != nil {
		return m.TechCdr
	}
	return false
}

func (m *GoodsEffectProto) GetWorkshopCdr() bool {
	if m != nil {
		return m.WorkshopCdr
	}
	return false
}

func (m *GoodsEffectProto) GetCdr() int32 {
	if m != nil {
		return m.Cdr
	}
	return 0
}

func (m *GoodsEffectProto) GetExpType() GoodsExpEffectType {
	if m != nil {
		return m.ExpType
	}
	return GoodsExpEffectType_InvalidGoodsExp
}

func (m *GoodsEffectProto) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *GoodsEffectProto) GetMoveBaseType() GoodsMoveBaseType {
	if m != nil {
		return m.MoveBaseType
	}
	return GoodsMoveBaseType_InvalidGoodsMoveBase
}

func (m *GoodsEffectProto) GetMoveBase() bool {
	if m != nil {
		return m.MoveBase
	}
	return false
}

func (m *GoodsEffectProto) GetMoveTent() bool {
	if m != nil {
		return m.MoveTent
	}
	return false
}

func (m *GoodsEffectProto) GetRandomPos() bool {
	if m != nil {
		return m.RandomPos
	}
	return false
}

func (m *GoodsEffectProto) GetGuildMoveBase() bool {
	if m != nil {
		return m.GuildMoveBase
	}
	return false
}

func (m *GoodsEffectProto) GetMianDuration() int32 {
	if m != nil {
		return m.MianDuration
	}
	return 0
}

func (m *GoodsEffectProto) GetTroopSpeedUpRate() int32 {
	if m != nil {
		return m.TroopSpeedUpRate
	}
	return 0
}

func (m *GoodsEffectProto) GetTrainDuration() int32 {
	if m != nil {
		return m.TrainDuration
	}
	return 0
}

func (m *GoodsEffectProto) GetPartsCombineId() int32 {
	if m != nil {
		return m.PartsCombineId
	}
	return 0
}

func (m *GoodsEffectProto) GetPartsCombineCount() int32 {
	if m != nil {
		return m.PartsCombineCount
	}
	return 0
}

func (m *GoodsEffectProto) GetPartsShowPrize() []*PrizeProto {
	if m != nil {
		return m.PartsShowPrize
	}
	return nil
}

func (m *GoodsEffectProto) GetPartsShowType() int32 {
	if m != nil {
		return m.PartsShowType
	}
	return 0
}

func (m *GoodsEffectProto) GetAddMultiLevelNpcTimes() bool {
	if m != nil {
		return m.AddMultiLevelNpcTimes
	}
	return false
}

func (m *GoodsEffectProto) GetAddInvaseHeroTimes() bool {
	if m != nil {
		return m.AddInvaseHeroTimes
	}
	return false
}

func (m *GoodsEffectProto) GetDurationType() GoodsDurationEffectType {
	if m != nil {
		return m.DurationType
	}
	return GoodsDurationEffectType_InvalidGoodsDuration
}

func (m *GoodsEffectProto) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *GoodsEffectProto) GetAmountType() GoodsAmountType {
	if m != nil {
		return m.AmountType
	}
	return GoodsAmountType_InvalidAmount
}

func (m *GoodsEffectProto) GetAmount() int32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *GoodsEffectProto) GetBuffId() int32 {
	if m != nil {
		return m.BuffId
	}
	return 0
}

type EquipmentDataProto struct {
	Id       int32            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name     string           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Desc     string           `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	IconId   string           `protobuf:"bytes,8,opt,name=icon_id,json=iconId,proto3" json:"icon_id,omitempty"`
	Type     EquipmentType    `protobuf:"varint,5,opt,name=type,proto3,enum=proto.EquipmentType" json:"type,omitempty"`
	BaseStat *SpriteStatProto `protobuf:"bytes,6,opt,name=base_stat,json=baseStat" json:"base_stat,omitempty"`
	Quality  int32            `protobuf:"varint,7,opt,name=quality,proto3" json:"quality,omitempty"`
}

func (m *EquipmentDataProto) Reset()                    { *m = EquipmentDataProto{} }
func (m *EquipmentDataProto) String() string            { return proto.CompactTextString(m) }
func (*EquipmentDataProto) ProtoMessage()               {}
func (*EquipmentDataProto) Descriptor() ([]byte, []int) { return fileDescriptorGoods, []int{3} }

func (m *EquipmentDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EquipmentDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EquipmentDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *EquipmentDataProto) GetIconId() string {
	if m != nil {
		return m.IconId
	}
	return ""
}

func (m *EquipmentDataProto) GetType() EquipmentType {
	if m != nil {
		return m.Type
	}
	return EquipmentType_InvalidEquipmentType
}

func (m *EquipmentDataProto) GetBaseStat() *SpriteStatProto {
	if m != nil {
		return m.BaseStat
	}
	return nil
}

func (m *EquipmentDataProto) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

type EquipmentQualityProto struct {
	Id                int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Level             int32 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
	GoodsQuality      int32 `protobuf:"varint,5,opt,name=goods_quality,json=goodsQuality,proto3" json:"goods_quality,omitempty"`
	RefinedLevelLimit int32 `protobuf:"varint,3,opt,name=refined_level_limit,json=refinedLevelLimit,proto3" json:"refined_level_limit,omitempty"`
	SmeltBackCount    int32 `protobuf:"varint,4,opt,name=smelt_back_count,json=smeltBackCount,proto3" json:"smelt_back_count,omitempty"`
}

func (m *EquipmentQualityProto) Reset()                    { *m = EquipmentQualityProto{} }
func (m *EquipmentQualityProto) String() string            { return proto.CompactTextString(m) }
func (*EquipmentQualityProto) ProtoMessage()               {}
func (*EquipmentQualityProto) Descriptor() ([]byte, []int) { return fileDescriptorGoods, []int{4} }

func (m *EquipmentQualityProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EquipmentQualityProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *EquipmentQualityProto) GetGoodsQuality() int32 {
	if m != nil {
		return m.GoodsQuality
	}
	return 0
}

func (m *EquipmentQualityProto) GetRefinedLevelLimit() int32 {
	if m != nil {
		return m.RefinedLevelLimit
	}
	return 0
}

func (m *EquipmentQualityProto) GetSmeltBackCount() int32 {
	if m != nil {
		return m.SmeltBackCount
	}
	return 0
}

type EquipmentRefinedProto struct {
	Level          int32 `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	CostCount      int32 `protobuf:"varint,2,opt,name=cost_count,json=costCount,proto3" json:"cost_count,omitempty"`
	TotalCostCount int32 `protobuf:"varint,3,opt,name=total_cost_count,json=totalCostCount,proto3" json:"total_cost_count,omitempty"`
	HeroLevelLimit int32 `protobuf:"varint,4,opt,name=hero_level_limit,json=heroLevelLimit,proto3" json:"hero_level_limit,omitempty"`
}

func (m *EquipmentRefinedProto) Reset()                    { *m = EquipmentRefinedProto{} }
func (m *EquipmentRefinedProto) String() string            { return proto.CompactTextString(m) }
func (*EquipmentRefinedProto) ProtoMessage()               {}
func (*EquipmentRefinedProto) Descriptor() ([]byte, []int) { return fileDescriptorGoods, []int{5} }

func (m *EquipmentRefinedProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *EquipmentRefinedProto) GetCostCount() int32 {
	if m != nil {
		return m.CostCount
	}
	return 0
}

func (m *EquipmentRefinedProto) GetTotalCostCount() int32 {
	if m != nil {
		return m.TotalCostCount
	}
	return 0
}

func (m *EquipmentRefinedProto) GetHeroLevelLimit() int32 {
	if m != nil {
		return m.HeroLevelLimit
	}
	return 0
}

// 装备套装属性
type EquipmentTaozProto struct {
	Level        int32            `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	Count        int32            `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	RefinedLevel int32            `protobuf:"varint,3,opt,name=refined_level,json=refinedLevel,proto3" json:"refined_level,omitempty"`
	Morale       int32            `protobuf:"varint,4,opt,name=morale,proto3" json:"morale,omitempty"`
	SpriteStat   *SpriteStatProto `protobuf:"bytes,5,opt,name=sprite_stat,json=spriteStat" json:"sprite_stat,omitempty"`
}

func (m *EquipmentTaozProto) Reset()                    { *m = EquipmentTaozProto{} }
func (m *EquipmentTaozProto) String() string            { return proto.CompactTextString(m) }
func (*EquipmentTaozProto) ProtoMessage()               {}
func (*EquipmentTaozProto) Descriptor() ([]byte, []int) { return fileDescriptorGoods, []int{6} }

func (m *EquipmentTaozProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *EquipmentTaozProto) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *EquipmentTaozProto) GetRefinedLevel() int32 {
	if m != nil {
		return m.RefinedLevel
	}
	return 0
}

func (m *EquipmentTaozProto) GetMorale() int32 {
	if m != nil {
		return m.Morale
	}
	return 0
}

func (m *EquipmentTaozProto) GetSpriteStat() *SpriteStatProto {
	if m != nil {
		return m.SpriteStat
	}
	return nil
}

type EquipmentProto struct {
	Id                 int32            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	DataId             int32            `protobuf:"varint,2,opt,name=data_id,json=dataId,proto3" json:"data_id,omitempty"`
	Level              int32            `protobuf:"varint,3,opt,name=level,proto3" json:"level,omitempty"`
	RefinedLevel       int32            `protobuf:"varint,4,opt,name=refined_level,json=refinedLevel,proto3" json:"refined_level,omitempty"`
	TotalStat          *SpriteStatProto `protobuf:"bytes,5,opt,name=total_stat,json=totalStat" json:"total_stat,omitempty"`
	LevelStat          *SpriteStatProto `protobuf:"bytes,6,opt,name=level_stat,json=levelStat" json:"level_stat,omitempty"`
	CurrentRefinedStat *SpriteStatProto `protobuf:"bytes,7,opt,name=current_refined_stat,json=currentRefinedStat" json:"current_refined_stat,omitempty"`
	// 升级相关（客户端要处理最后一级，这个时候是没有数据的）
	UpgradeLevelStat      *SpriteStatProto `protobuf:"bytes,21,opt,name=upgrade_level_stat,json=upgradeLevelStat" json:"upgrade_level_stat,omitempty"`
	UpgradeLevelCost      int32            `protobuf:"varint,22,opt,name=upgrade_level_cost,json=upgradeLevelCost,proto3" json:"upgrade_level_cost,omitempty"`
	UpgradeLevelTotalCost int32            `protobuf:"varint,23,opt,name=upgrade_level_total_cost,json=upgradeLevelTotalCost,proto3" json:"upgrade_level_total_cost,omitempty"`
	// 强化相关
	RefinedStat        *SpriteStatProto `protobuf:"bytes,24,opt,name=refined_stat,json=refinedStat" json:"refined_stat,omitempty"`
	RefinedStatPercent int32            `protobuf:"varint,25,opt,name=refined_stat_percent,json=refinedStatPercent,proto3" json:"refined_stat_percent,omitempty"`
}

func (m *EquipmentProto) Reset()                    { *m = EquipmentProto{} }
func (m *EquipmentProto) String() string            { return proto.CompactTextString(m) }
func (*EquipmentProto) ProtoMessage()               {}
func (*EquipmentProto) Descriptor() ([]byte, []int) { return fileDescriptorGoods, []int{7} }

func (m *EquipmentProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EquipmentProto) GetDataId() int32 {
	if m != nil {
		return m.DataId
	}
	return 0
}

func (m *EquipmentProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *EquipmentProto) GetRefinedLevel() int32 {
	if m != nil {
		return m.RefinedLevel
	}
	return 0
}

func (m *EquipmentProto) GetTotalStat() *SpriteStatProto {
	if m != nil {
		return m.TotalStat
	}
	return nil
}

func (m *EquipmentProto) GetLevelStat() *SpriteStatProto {
	if m != nil {
		return m.LevelStat
	}
	return nil
}

func (m *EquipmentProto) GetCurrentRefinedStat() *SpriteStatProto {
	if m != nil {
		return m.CurrentRefinedStat
	}
	return nil
}

func (m *EquipmentProto) GetUpgradeLevelStat() *SpriteStatProto {
	if m != nil {
		return m.UpgradeLevelStat
	}
	return nil
}

func (m *EquipmentProto) GetUpgradeLevelCost() int32 {
	if m != nil {
		return m.UpgradeLevelCost
	}
	return 0
}

func (m *EquipmentProto) GetUpgradeLevelTotalCost() int32 {
	if m != nil {
		return m.UpgradeLevelTotalCost
	}
	return 0
}

func (m *EquipmentProto) GetRefinedStat() *SpriteStatProto {
	if m != nil {
		return m.RefinedStat
	}
	return nil
}

func (m *EquipmentProto) GetRefinedStatPercent() int32 {
	if m != nil {
		return m.RefinedStatPercent
	}
	return 0
}

type GoodsCombineDataProto struct {
	Id    int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Cost  *CostProto  `protobuf:"bytes,2,opt,name=cost" json:"cost,omitempty"`
	Prize *PrizeProto `protobuf:"bytes,3,opt,name=prize" json:"prize,omitempty"`
}

func (m *GoodsCombineDataProto) Reset()                    { *m = GoodsCombineDataProto{} }
func (m *GoodsCombineDataProto) String() string            { return proto.CompactTextString(m) }
func (*GoodsCombineDataProto) ProtoMessage()               {}
func (*GoodsCombineDataProto) Descriptor() ([]byte, []int) { return fileDescriptorGoods, []int{8} }

func (m *GoodsCombineDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GoodsCombineDataProto) GetCost() *CostProto {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *GoodsCombineDataProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

type EquipCombineDataProto struct {
	Id             int32                    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	GroupName      string                   `protobuf:"bytes,2,opt,name=group_name,json=groupName,proto3" json:"group_name,omitempty"`
	CostGoodsId    int32                    `protobuf:"varint,3,opt,name=cost_goods_id,json=costGoodsId,proto3" json:"cost_goods_id,omitempty"`
	CombineEquipId []int32                  `protobuf:"varint,4,rep,name=combine_equip_id,json=combineEquipId" json:"combine_equip_id,omitempty"`
	CombineData    []*GoodsCombineDataProto `protobuf:"bytes,5,rep,name=combine_data,json=combineData" json:"combine_data,omitempty"`
}

func (m *EquipCombineDataProto) Reset()                    { *m = EquipCombineDataProto{} }
func (m *EquipCombineDataProto) String() string            { return proto.CompactTextString(m) }
func (*EquipCombineDataProto) ProtoMessage()               {}
func (*EquipCombineDataProto) Descriptor() ([]byte, []int) { return fileDescriptorGoods, []int{9} }

func (m *EquipCombineDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EquipCombineDataProto) GetGroupName() string {
	if m != nil {
		return m.GroupName
	}
	return ""
}

func (m *EquipCombineDataProto) GetCostGoodsId() int32 {
	if m != nil {
		return m.CostGoodsId
	}
	return 0
}

func (m *EquipCombineDataProto) GetCombineEquipId() []int32 {
	if m != nil {
		return m.CombineEquipId
	}
	return nil
}

func (m *EquipCombineDataProto) GetCombineData() []*GoodsCombineDataProto {
	if m != nil {
		return m.CombineData
	}
	return nil
}

type GemDataProto struct {
	Id           int32            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name         string           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Desc         string           `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	IconId       string           `protobuf:"bytes,12,opt,name=icon_id,json=iconId,proto3" json:"icon_id,omitempty"`
	GemType      int32            `protobuf:"varint,5,opt,name=gem_type,json=gemType,proto3" json:"gem_type,omitempty"`
	Level        int32            `protobuf:"varint,6,opt,name=level,proto3" json:"level,omitempty"`
	Quality      Quality          `protobuf:"varint,7,opt,name=quality,proto3,enum=proto.Quality" json:"quality,omitempty"`
	BaseStat     *SpriteStatProto `protobuf:"bytes,8,opt,name=base_stat,json=baseStat" json:"base_stat,omitempty"`
	YuanbaoPrice int32            `protobuf:"varint,13,opt,name=yuanbao_price,json=yuanbaoPrice,proto3" json:"yuanbao_price,omitempty"`
	// 计算升级到该级总共需要多少一级宝石
	// totalNeedCount = 1
	// for(this.prevLevel != 0) {
	//      totalNeedCount *= this.prevLevel.upgrade_need_count
	//      this = this.prevLevel
	// }
	UpgradeNeedCount int32 `protobuf:"varint,9,opt,name=upgrade_need_count,json=upgradeNeedCount,proto3" json:"upgrade_need_count,omitempty"`
	PrevLevel        int32 `protobuf:"varint,10,opt,name=prev_level,json=prevLevel,proto3" json:"prev_level,omitempty"`
	NextLevel        int32 `protobuf:"varint,11,opt,name=next_level,json=nextLevel,proto3" json:"next_level,omitempty"`
}

func (m *GemDataProto) Reset()                    { *m = GemDataProto{} }
func (m *GemDataProto) String() string            { return proto.CompactTextString(m) }
func (*GemDataProto) ProtoMessage()               {}
func (*GemDataProto) Descriptor() ([]byte, []int) { return fileDescriptorGoods, []int{10} }

func (m *GemDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GemDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GemDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *GemDataProto) GetIconId() string {
	if m != nil {
		return m.IconId
	}
	return ""
}

func (m *GemDataProto) GetGemType() int32 {
	if m != nil {
		return m.GemType
	}
	return 0
}

func (m *GemDataProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *GemDataProto) GetQuality() Quality {
	if m != nil {
		return m.Quality
	}
	return Quality_InvalidQuality
}

func (m *GemDataProto) GetBaseStat() *SpriteStatProto {
	if m != nil {
		return m.BaseStat
	}
	return nil
}

func (m *GemDataProto) GetYuanbaoPrice() int32 {
	if m != nil {
		return m.YuanbaoPrice
	}
	return 0
}

func (m *GemDataProto) GetUpgradeNeedCount() int32 {
	if m != nil {
		return m.UpgradeNeedCount
	}
	return 0
}

func (m *GemDataProto) GetPrevLevel() int32 {
	if m != nil {
		return m.PrevLevel
	}
	return 0
}

func (m *GemDataProto) GetNextLevel() int32 {
	if m != nil {
		return m.NextLevel
	}
	return 0
}

type GemSlotDataProto struct {
	SlotIdx     int32         `protobuf:"varint,1,opt,name=slot_idx,json=slotIdx,proto3" json:"slot_idx,omitempty"`
	NeedAbility int32         `protobuf:"varint,2,opt,name=need_ability,json=needAbility,proto3" json:"need_ability,omitempty"`
	Type        EquipmentType `protobuf:"varint,3,opt,name=type,proto3,enum=proto.EquipmentType" json:"type,omitempty"`
}

func (m *GemSlotDataProto) Reset()                    { *m = GemSlotDataProto{} }
func (m *GemSlotDataProto) String() string            { return proto.CompactTextString(m) }
func (*GemSlotDataProto) ProtoMessage()               {}
func (*GemSlotDataProto) Descriptor() ([]byte, []int) { return fileDescriptorGoods, []int{11} }

func (m *GemSlotDataProto) GetSlotIdx() int32 {
	if m != nil {
		return m.SlotIdx
	}
	return 0
}

func (m *GemSlotDataProto) GetNeedAbility() int32 {
	if m != nil {
		return m.NeedAbility
	}
	return 0
}

func (m *GemSlotDataProto) GetType() EquipmentType {
	if m != nil {
		return m.Type
	}
	return EquipmentType_InvalidEquipmentType
}

func init() {
	proto.RegisterType((*GoodsDataProto)(nil), "proto.GoodsDataProto")
	proto.RegisterType((*GoodsQualityProto)(nil), "proto.GoodsQualityProto")
	proto.RegisterType((*GoodsEffectProto)(nil), "proto.GoodsEffectProto")
	proto.RegisterType((*EquipmentDataProto)(nil), "proto.EquipmentDataProto")
	proto.RegisterType((*EquipmentQualityProto)(nil), "proto.EquipmentQualityProto")
	proto.RegisterType((*EquipmentRefinedProto)(nil), "proto.EquipmentRefinedProto")
	proto.RegisterType((*EquipmentTaozProto)(nil), "proto.EquipmentTaozProto")
	proto.RegisterType((*EquipmentProto)(nil), "proto.EquipmentProto")
	proto.RegisterType((*GoodsCombineDataProto)(nil), "proto.GoodsCombineDataProto")
	proto.RegisterType((*EquipCombineDataProto)(nil), "proto.EquipCombineDataProto")
	proto.RegisterType((*GemDataProto)(nil), "proto.GemDataProto")
	proto.RegisterType((*GemSlotDataProto)(nil), "proto.GemSlotDataProto")
	proto.RegisterEnum("proto.GoodsEffectType", GoodsEffectType_name, GoodsEffectType_value)
	proto.RegisterEnum("proto.GoodsExpEffectType", GoodsExpEffectType_name, GoodsExpEffectType_value)
	proto.RegisterEnum("proto.GoodsMoveBaseType", GoodsMoveBaseType_name, GoodsMoveBaseType_value)
	proto.RegisterEnum("proto.GoodsAmountType", GoodsAmountType_name, GoodsAmountType_value)
	proto.RegisterEnum("proto.GoodsSpecType", GoodsSpecType_name, GoodsSpecType_value)
	proto.RegisterEnum("proto.GoodsDurationEffectType", GoodsDurationEffectType_name, GoodsDurationEffectType_value)
	proto.RegisterEnum("proto.HebiType", HebiType_name, HebiType_value)
	proto.RegisterEnum("proto.HebiSubType", HebiSubType_name, HebiSubType_value)
	proto.RegisterEnum("proto.EquipmentType", EquipmentType_name, EquipmentType_value)
}
func (m *GoodsDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoodsDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGoods(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGoods(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.Captain != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Captain))
	}
	if m.Quality != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Quality))
	}
	if m.YuanbaoPrice != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.YuanbaoPrice))
	}
	if len(m.IconId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGoods(dAtA, i, uint64(len(m.IconId)))
		i += copy(dAtA[i:], m.IconId)
	}
	if m.Cd != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Cd))
	}
	if m.DianquanPrice != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.DianquanPrice))
	}
	if m.GoodsQuality != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.GoodsQuality))
	}
	if m.YinliangPrice != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.YinliangPrice))
	}
	if len(m.ObtainWays) > 0 {
		for _, s := range m.ObtainWays {
			dAtA[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.EffectType != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.EffectType))
	}
	if m.GoodsEffect != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.GoodsEffect.Size()))
		n1, err := m.GoodsEffect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.SpecType != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.SpecType))
	}
	if m.HebiType != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.HebiType))
	}
	if m.HebiSubType != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.HebiSubType))
	}
	if m.PartnerHebiGoods != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.PartnerHebiGoods))
	}
	return i, nil
}

func (m *GoodsQualityProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoodsQualityProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Level))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGoods(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Quality != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Quality))
	}
	return i, nil
}

func (m *GoodsEffectProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoodsEffectProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gold != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Gold))
	}
	if m.Food != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Food))
	}
	if m.Wood != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Wood))
	}
	if m.Stone != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Stone))
	}
	if m.BuildingCdr {
		dAtA[i] = 0x28
		i++
		if m.BuildingCdr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TechCdr {
		dAtA[i] = 0x30
		i++
		if m.TechCdr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Cdr != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Cdr))
	}
	if m.ExpType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.ExpType))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Exp))
	}
	if m.MoveBase {
		dAtA[i] = 0x50
		i++
		if m.MoveBase {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RandomPos {
		dAtA[i] = 0x58
		i++
		if m.RandomPos {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MoveTent {
		dAtA[i] = 0x60
		i++
		if m.MoveTent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GuildMoveBase {
		dAtA[i] = 0x68
		i++
		if m.GuildMoveBase {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WorkshopCdr {
		dAtA[i] = 0x70
		i++
		if m.WorkshopCdr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MoveBaseType != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.MoveBaseType))
	}
	if m.MianDuration != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.MianDuration))
	}
	if m.TroopSpeedUpRate != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.TroopSpeedUpRate))
	}
	if m.TrainDuration != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.TrainDuration))
	}
	if m.PartsCombineId != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.PartsCombineId))
	}
	if m.PartsCombineCount != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.PartsCombineCount))
	}
	if m.AddMultiLevelNpcTimes {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		if m.AddMultiLevelNpcTimes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PartsShowPrize) > 0 {
		for _, msg := range m.PartsShowPrize {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintGoods(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PartsShowType != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.PartsShowType))
	}
	if m.DurationType != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.DurationType))
	}
	if m.Duration != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Duration))
	}
	if m.AmountType != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.AmountType))
	}
	if m.Amount != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Amount))
	}
	if m.AddInvaseHeroTimes {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		if m.AddInvaseHeroTimes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BuffId != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.BuffId))
	}
	return i, nil
}

func (m *EquipmentDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipmentDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGoods(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGoods(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.Type != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Type))
	}
	if m.BaseStat != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.BaseStat.Size()))
		n2, err := m.BaseStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Quality != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Quality))
	}
	if len(m.IconId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGoods(dAtA, i, uint64(len(m.IconId)))
		i += copy(dAtA[i:], m.IconId)
	}
	return i, nil
}

func (m *EquipmentQualityProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipmentQualityProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Id))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Level))
	}
	if m.RefinedLevelLimit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.RefinedLevelLimit))
	}
	if m.SmeltBackCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.SmeltBackCount))
	}
	if m.GoodsQuality != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.GoodsQuality))
	}
	return i, nil
}

func (m *EquipmentRefinedProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipmentRefinedProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Level))
	}
	if m.CostCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.CostCount))
	}
	if m.TotalCostCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.TotalCostCount))
	}
	if m.HeroLevelLimit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.HeroLevelLimit))
	}
	return i, nil
}

func (m *EquipmentTaozProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipmentTaozProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Level))
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Count))
	}
	if m.RefinedLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.RefinedLevel))
	}
	if m.Morale != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Morale))
	}
	if m.SpriteStat != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.SpriteStat.Size()))
		n3, err := m.SpriteStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *EquipmentProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipmentProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Id))
	}
	if m.DataId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.DataId))
	}
	if m.Level != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Level))
	}
	if m.RefinedLevel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.RefinedLevel))
	}
	if m.TotalStat != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.TotalStat.Size()))
		n4, err := m.TotalStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.LevelStat != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.LevelStat.Size()))
		n5, err := m.LevelStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.CurrentRefinedStat != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.CurrentRefinedStat.Size()))
		n6, err := m.CurrentRefinedStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.UpgradeLevelStat != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.UpgradeLevelStat.Size()))
		n7, err := m.UpgradeLevelStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.UpgradeLevelCost != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.UpgradeLevelCost))
	}
	if m.UpgradeLevelTotalCost != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.UpgradeLevelTotalCost))
	}
	if m.RefinedStat != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.RefinedStat.Size()))
		n8, err := m.RefinedStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.RefinedStatPercent != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.RefinedStatPercent))
	}
	return i, nil
}

func (m *GoodsCombineDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoodsCombineDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Id))
	}
	if m.Cost != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Cost.Size()))
		n9, err := m.Cost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Prize != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Prize.Size()))
		n10, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *EquipCombineDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipCombineDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Id))
	}
	if len(m.GroupName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGoods(dAtA, i, uint64(len(m.GroupName)))
		i += copy(dAtA[i:], m.GroupName)
	}
	if m.CostGoodsId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.CostGoodsId))
	}
	if len(m.CombineEquipId) > 0 {
		for _, num := range m.CombineEquipId {
			dAtA[i] = 0x20
			i++
			i = encodeVarintGoods(dAtA, i, uint64(num))
		}
	}
	if len(m.CombineData) > 0 {
		for _, msg := range m.CombineData {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintGoods(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GemDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GemDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGoods(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGoods(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.GemType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.GemType))
	}
	if m.Level != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Level))
	}
	if m.Quality != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Quality))
	}
	if m.BaseStat != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.BaseStat.Size()))
		n11, err := m.BaseStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.UpgradeNeedCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.UpgradeNeedCount))
	}
	if m.PrevLevel != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.PrevLevel))
	}
	if m.NextLevel != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.NextLevel))
	}
	if len(m.IconId) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintGoods(dAtA, i, uint64(len(m.IconId)))
		i += copy(dAtA[i:], m.IconId)
	}
	if m.YuanbaoPrice != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.YuanbaoPrice))
	}
	return i, nil
}

func (m *GemSlotDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GemSlotDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SlotIdx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.SlotIdx))
	}
	if m.NeedAbility != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.NeedAbility))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGoods(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func encodeFixed64Goods(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Goods(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintGoods(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GoodsDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGoods(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGoods(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovGoods(uint64(l))
	}
	if m.Captain != 0 {
		n += 1 + sovGoods(uint64(m.Captain))
	}
	if m.Quality != 0 {
		n += 1 + sovGoods(uint64(m.Quality))
	}
	if m.YuanbaoPrice != 0 {
		n += 1 + sovGoods(uint64(m.YuanbaoPrice))
	}
	l = len(m.IconId)
	if l > 0 {
		n += 1 + l + sovGoods(uint64(l))
	}
	if m.Cd != 0 {
		n += 1 + sovGoods(uint64(m.Cd))
	}
	if m.DianquanPrice != 0 {
		n += 1 + sovGoods(uint64(m.DianquanPrice))
	}
	if m.GoodsQuality != 0 {
		n += 1 + sovGoods(uint64(m.GoodsQuality))
	}
	if m.YinliangPrice != 0 {
		n += 1 + sovGoods(uint64(m.YinliangPrice))
	}
	if len(m.ObtainWays) > 0 {
		for _, s := range m.ObtainWays {
			l = len(s)
			n += 1 + l + sovGoods(uint64(l))
		}
	}
	if m.EffectType != 0 {
		n += 2 + sovGoods(uint64(m.EffectType))
	}
	if m.GoodsEffect != nil {
		l = m.GoodsEffect.Size()
		n += 2 + l + sovGoods(uint64(l))
	}
	if m.SpecType != 0 {
		n += 2 + sovGoods(uint64(m.SpecType))
	}
	if m.HebiType != 0 {
		n += 2 + sovGoods(uint64(m.HebiType))
	}
	if m.HebiSubType != 0 {
		n += 2 + sovGoods(uint64(m.HebiSubType))
	}
	if m.PartnerHebiGoods != 0 {
		n += 2 + sovGoods(uint64(m.PartnerHebiGoods))
	}
	return n
}

func (m *GoodsQualityProto) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovGoods(uint64(m.Level))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGoods(uint64(l))
	}
	if m.Quality != 0 {
		n += 1 + sovGoods(uint64(m.Quality))
	}
	return n
}

func (m *GoodsEffectProto) Size() (n int) {
	var l int
	_ = l
	if m.Gold != 0 {
		n += 1 + sovGoods(uint64(m.Gold))
	}
	if m.Food != 0 {
		n += 1 + sovGoods(uint64(m.Food))
	}
	if m.Wood != 0 {
		n += 1 + sovGoods(uint64(m.Wood))
	}
	if m.Stone != 0 {
		n += 1 + sovGoods(uint64(m.Stone))
	}
	if m.BuildingCdr {
		n += 2
	}
	if m.TechCdr {
		n += 2
	}
	if m.Cdr != 0 {
		n += 1 + sovGoods(uint64(m.Cdr))
	}
	if m.ExpType != 0 {
		n += 1 + sovGoods(uint64(m.ExpType))
	}
	if m.Exp != 0 {
		n += 1 + sovGoods(uint64(m.Exp))
	}
	if m.MoveBase {
		n += 2
	}
	if m.RandomPos {
		n += 2
	}
	if m.MoveTent {
		n += 2
	}
	if m.GuildMoveBase {
		n += 2
	}
	if m.WorkshopCdr {
		n += 2
	}
	if m.MoveBaseType != 0 {
		n += 1 + sovGoods(uint64(m.MoveBaseType))
	}
	if m.MianDuration != 0 {
		n += 2 + sovGoods(uint64(m.MianDuration))
	}
	if m.TroopSpeedUpRate != 0 {
		n += 2 + sovGoods(uint64(m.TroopSpeedUpRate))
	}
	if m.TrainDuration != 0 {
		n += 2 + sovGoods(uint64(m.TrainDuration))
	}
	if m.PartsCombineId != 0 {
		n += 2 + sovGoods(uint64(m.PartsCombineId))
	}
	if m.PartsCombineCount != 0 {
		n += 2 + sovGoods(uint64(m.PartsCombineCount))
	}
	if m.AddMultiLevelNpcTimes {
		n += 3
	}
	if len(m.PartsShowPrize) > 0 {
		for _, e := range m.PartsShowPrize {
			l = e.Size()
			n += 2 + l + sovGoods(uint64(l))
		}
	}
	if m.PartsShowType != 0 {
		n += 2 + sovGoods(uint64(m.PartsShowType))
	}
	if m.DurationType != 0 {
		n += 2 + sovGoods(uint64(m.DurationType))
	}
	if m.Duration != 0 {
		n += 2 + sovGoods(uint64(m.Duration))
	}
	if m.AmountType != 0 {
		n += 2 + sovGoods(uint64(m.AmountType))
	}
	if m.Amount != 0 {
		n += 2 + sovGoods(uint64(m.Amount))
	}
	if m.AddInvaseHeroTimes {
		n += 3
	}
	if m.BuffId != 0 {
		n += 2 + sovGoods(uint64(m.BuffId))
	}
	return n
}

func (m *EquipmentDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGoods(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGoods(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovGoods(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovGoods(uint64(m.Type))
	}
	if m.BaseStat != nil {
		l = m.BaseStat.Size()
		n += 1 + l + sovGoods(uint64(l))
	}
	if m.Quality != 0 {
		n += 1 + sovGoods(uint64(m.Quality))
	}
	l = len(m.IconId)
	if l > 0 {
		n += 1 + l + sovGoods(uint64(l))
	}
	return n
}

func (m *EquipmentQualityProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGoods(uint64(m.Id))
	}
	if m.Level != 0 {
		n += 1 + sovGoods(uint64(m.Level))
	}
	if m.RefinedLevelLimit != 0 {
		n += 1 + sovGoods(uint64(m.RefinedLevelLimit))
	}
	if m.SmeltBackCount != 0 {
		n += 1 + sovGoods(uint64(m.SmeltBackCount))
	}
	if m.GoodsQuality != 0 {
		n += 1 + sovGoods(uint64(m.GoodsQuality))
	}
	return n
}

func (m *EquipmentRefinedProto) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovGoods(uint64(m.Level))
	}
	if m.CostCount != 0 {
		n += 1 + sovGoods(uint64(m.CostCount))
	}
	if m.TotalCostCount != 0 {
		n += 1 + sovGoods(uint64(m.TotalCostCount))
	}
	if m.HeroLevelLimit != 0 {
		n += 1 + sovGoods(uint64(m.HeroLevelLimit))
	}
	return n
}

func (m *EquipmentTaozProto) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovGoods(uint64(m.Level))
	}
	if m.Count != 0 {
		n += 1 + sovGoods(uint64(m.Count))
	}
	if m.RefinedLevel != 0 {
		n += 1 + sovGoods(uint64(m.RefinedLevel))
	}
	if m.Morale != 0 {
		n += 1 + sovGoods(uint64(m.Morale))
	}
	if m.SpriteStat != nil {
		l = m.SpriteStat.Size()
		n += 1 + l + sovGoods(uint64(l))
	}
	return n
}

func (m *EquipmentProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGoods(uint64(m.Id))
	}
	if m.DataId != 0 {
		n += 1 + sovGoods(uint64(m.DataId))
	}
	if m.Level != 0 {
		n += 1 + sovGoods(uint64(m.Level))
	}
	if m.RefinedLevel != 0 {
		n += 1 + sovGoods(uint64(m.RefinedLevel))
	}
	if m.TotalStat != nil {
		l = m.TotalStat.Size()
		n += 1 + l + sovGoods(uint64(l))
	}
	if m.LevelStat != nil {
		l = m.LevelStat.Size()
		n += 1 + l + sovGoods(uint64(l))
	}
	if m.CurrentRefinedStat != nil {
		l = m.CurrentRefinedStat.Size()
		n += 1 + l + sovGoods(uint64(l))
	}
	if m.UpgradeLevelStat != nil {
		l = m.UpgradeLevelStat.Size()
		n += 2 + l + sovGoods(uint64(l))
	}
	if m.UpgradeLevelCost != 0 {
		n += 2 + sovGoods(uint64(m.UpgradeLevelCost))
	}
	if m.UpgradeLevelTotalCost != 0 {
		n += 2 + sovGoods(uint64(m.UpgradeLevelTotalCost))
	}
	if m.RefinedStat != nil {
		l = m.RefinedStat.Size()
		n += 2 + l + sovGoods(uint64(l))
	}
	if m.RefinedStatPercent != 0 {
		n += 2 + sovGoods(uint64(m.RefinedStatPercent))
	}
	return n
}

func (m *GoodsCombineDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGoods(uint64(m.Id))
	}
	if m.Cost != nil {
		l = m.Cost.Size()
		n += 1 + l + sovGoods(uint64(l))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovGoods(uint64(l))
	}
	return n
}

func (m *EquipCombineDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGoods(uint64(m.Id))
	}
	l = len(m.GroupName)
	if l > 0 {
		n += 1 + l + sovGoods(uint64(l))
	}
	if m.CostGoodsId != 0 {
		n += 1 + sovGoods(uint64(m.CostGoodsId))
	}
	if len(m.CombineEquipId) > 0 {
		for _, e := range m.CombineEquipId {
			n += 1 + sovGoods(uint64(e))
		}
	}
	if len(m.CombineData) > 0 {
		for _, e := range m.CombineData {
			l = e.Size()
			n += 1 + l + sovGoods(uint64(l))
		}
	}
	return n
}

func (m *GemDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGoods(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGoods(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovGoods(uint64(l))
	}
	if m.GemType != 0 {
		n += 1 + sovGoods(uint64(m.GemType))
	}
	if m.Level != 0 {
		n += 1 + sovGoods(uint64(m.Level))
	}
	if m.Quality != 0 {
		n += 1 + sovGoods(uint64(m.Quality))
	}
	if m.BaseStat != nil {
		l = m.BaseStat.Size()
		n += 1 + l + sovGoods(uint64(l))
	}
	if m.UpgradeNeedCount != 0 {
		n += 1 + sovGoods(uint64(m.UpgradeNeedCount))
	}
	if m.PrevLevel != 0 {
		n += 1 + sovGoods(uint64(m.PrevLevel))
	}
	if m.NextLevel != 0 {
		n += 1 + sovGoods(uint64(m.NextLevel))
	}
	l = len(m.IconId)
	if l > 0 {
		n += 1 + l + sovGoods(uint64(l))
	}
	if m.YuanbaoPrice != 0 {
		n += 1 + sovGoods(uint64(m.YuanbaoPrice))
	}
	return n
}

func (m *GemSlotDataProto) Size() (n int) {
	var l int
	_ = l
	if m.SlotIdx != 0 {
		n += 1 + sovGoods(uint64(m.SlotIdx))
	}
	if m.NeedAbility != 0 {
		n += 1 + sovGoods(uint64(m.NeedAbility))
	}
	if m.Type != 0 {
		n += 1 + sovGoods(uint64(m.Type))
	}
	return n
}

func sovGoods(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGoods(x uint64) (n int) {
	return sovGoods(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GoodsDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGoods
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoodsDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoodsDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Captain", wireType)
			}
			m.Captain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Captain |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (Quality(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YuanbaoPrice", wireType)
			}
			m.YuanbaoPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YuanbaoPrice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cd", wireType)
			}
			m.Cd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DianquanPrice", wireType)
			}
			m.DianquanPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DianquanPrice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsQuality", wireType)
			}
			m.GoodsQuality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoodsQuality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YinliangPrice", wireType)
			}
			m.YinliangPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YinliangPrice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObtainWays", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObtainWays = append(m.ObtainWays, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectType", wireType)
			}
			m.EffectType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectType |= (GoodsEffectType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsEffect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GoodsEffect == nil {
				m.GoodsEffect = &GoodsEffectProto{}
			}
			if err := m.GoodsEffect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecType", wireType)
			}
			m.SpecType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpecType |= (GoodsSpecType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HebiType", wireType)
			}
			m.HebiType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HebiType |= (HebiType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HebiSubType", wireType)
			}
			m.HebiSubType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HebiSubType |= (HebiSubType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartnerHebiGoods", wireType)
			}
			m.PartnerHebiGoods = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartnerHebiGoods |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGoods(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGoods
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoodsQualityProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGoods
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoodsQualityProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoodsQualityProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (Quality(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGoods(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGoods
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoodsEffectProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGoods
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoodsEffectProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoodsEffectProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Food", wireType)
			}
			m.Food = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Food |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wood", wireType)
			}
			m.Wood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Wood |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stone", wireType)
			}
			m.Stone = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stone |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingCdr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BuildingCdr = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TechCdr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TechCdr = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cdr", wireType)
			}
			m.Cdr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cdr |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpType", wireType)
			}
			m.ExpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpType |= (GoodsExpEffectType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveBase", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MoveBase = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomPos", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RandomPos = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveTent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MoveTent = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildMoveBase", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GuildMoveBase = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopCdr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WorkshopCdr = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveBaseType", wireType)
			}
			m.MoveBaseType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveBaseType |= (GoodsMoveBaseType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MianDuration", wireType)
			}
			m.MianDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MianDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TroopSpeedUpRate", wireType)
			}
			m.TroopSpeedUpRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TroopSpeedUpRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainDuration", wireType)
			}
			m.TrainDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartsCombineId", wireType)
			}
			m.PartsCombineId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartsCombineId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartsCombineCount", wireType)
			}
			m.PartsCombineCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartsCombineCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddMultiLevelNpcTimes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddMultiLevelNpcTimes = bool(v != 0)
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartsShowPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartsShowPrize = append(m.PartsShowPrize, &PrizeProto{})
			if err := m.PartsShowPrize[len(m.PartsShowPrize)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartsShowType", wireType)
			}
			m.PartsShowType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartsShowType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationType", wireType)
			}
			m.DurationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationType |= (GoodsDurationEffectType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountType", wireType)
			}
			m.AmountType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AmountType |= (GoodsAmountType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddInvaseHeroTimes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddInvaseHeroTimes = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffId", wireType)
			}
			m.BuffId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGoods(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGoods
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipmentDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGoods
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipmentDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipmentDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (EquipmentType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseStat == nil {
				m.BaseStat = &SpriteStatProto{}
			}
			if err := m.BaseStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGoods(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGoods
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipmentQualityProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGoods
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipmentQualityProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipmentQualityProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefinedLevelLimit", wireType)
			}
			m.RefinedLevelLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefinedLevelLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmeltBackCount", wireType)
			}
			m.SmeltBackCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SmeltBackCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsQuality", wireType)
			}
			m.GoodsQuality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoodsQuality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGoods(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGoods
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipmentRefinedProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGoods
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipmentRefinedProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipmentRefinedProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostCount", wireType)
			}
			m.CostCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CostCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCostCount", wireType)
			}
			m.TotalCostCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCostCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroLevelLimit", wireType)
			}
			m.HeroLevelLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroLevelLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGoods(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGoods
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipmentTaozProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGoods
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipmentTaozProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipmentTaozProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefinedLevel", wireType)
			}
			m.RefinedLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefinedLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Morale", wireType)
			}
			m.Morale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Morale |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpriteStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpriteStat == nil {
				m.SpriteStat = &SpriteStatProto{}
			}
			if err := m.SpriteStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGoods(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGoods
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipmentProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGoods
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipmentProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipmentProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataId", wireType)
			}
			m.DataId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefinedLevel", wireType)
			}
			m.RefinedLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefinedLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalStat == nil {
				m.TotalStat = &SpriteStatProto{}
			}
			if err := m.TotalStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LevelStat == nil {
				m.LevelStat = &SpriteStatProto{}
			}
			if err := m.LevelStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentRefinedStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurrentRefinedStat == nil {
				m.CurrentRefinedStat = &SpriteStatProto{}
			}
			if err := m.CurrentRefinedStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeLevelStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpgradeLevelStat == nil {
				m.UpgradeLevelStat = &SpriteStatProto{}
			}
			if err := m.UpgradeLevelStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeLevelCost", wireType)
			}
			m.UpgradeLevelCost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradeLevelCost |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeLevelTotalCost", wireType)
			}
			m.UpgradeLevelTotalCost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradeLevelTotalCost |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefinedStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RefinedStat == nil {
				m.RefinedStat = &SpriteStatProto{}
			}
			if err := m.RefinedStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefinedStatPercent", wireType)
			}
			m.RefinedStatPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefinedStatPercent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGoods(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGoods
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoodsCombineDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGoods
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoodsCombineDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoodsCombineDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &CostProto{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGoods(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGoods
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipCombineDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGoods
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipCombineDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipCombineDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostGoodsId", wireType)
			}
			m.CostGoodsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CostGoodsId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGoods
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CombineEquipId = append(m.CombineEquipId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGoods
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGoods
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGoods
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CombineEquipId = append(m.CombineEquipId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CombineEquipId", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CombineData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CombineData = append(m.CombineData, &GoodsCombineDataProto{})
			if err := m.CombineData[len(m.CombineData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGoods(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGoods
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GemDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGoods
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GemDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GemDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GemType", wireType)
			}
			m.GemType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GemType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (Quality(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseStat == nil {
				m.BaseStat = &SpriteStatProto{}
			}
			if err := m.BaseStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeNeedCount", wireType)
			}
			m.UpgradeNeedCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradeNeedCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevLevel", wireType)
			}
			m.PrevLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextLevel", wireType)
			}
			m.NextLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGoods
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YuanbaoPrice", wireType)
			}
			m.YuanbaoPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YuanbaoPrice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGoods(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGoods
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GemSlotDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGoods
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GemSlotDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GemSlotDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotIdx", wireType)
			}
			m.SlotIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlotIdx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedAbility", wireType)
			}
			m.NeedAbility = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedAbility |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (EquipmentType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGoods(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGoods
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGoods(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGoods
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGoods
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGoods
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGoods
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGoods(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGoods = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGoods   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/shared_proto/goods.proto", fileDescriptorGoods)
}

var fileDescriptorGoods = []byte{
	// 2393 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0x4b, 0x73, 0x1b, 0xc7,
	0x11, 0x26, 0x00, 0x82, 0x00, 0x1a, 0x0f, 0x8e, 0x46, 0x94, 0xb8, 0x92, 0x2d, 0x89, 0x86, 0xf3,
	0x60, 0xb1, 0x14, 0x29, 0x7e, 0xc5, 0x79, 0x54, 0x25, 0x85, 0x17, 0x81, 0xb5, 0x29, 0x00, 0x5e,
	0x00, 0x91, 0xe4, 0xcb, 0xd4, 0x02, 0x3b, 0x04, 0x36, 0x06, 0x76, 0xd7, 0x8b, 0x85, 0x48, 0xfa,
	0x94, 0x7f, 0x90, 0x6b, 0x8e, 0x39, 0xe7, 0x90, 0x63, 0xce, 0x39, 0xa5, 0x72, 0xcc, 0x35, 0x55,
	0xa9, 0x54, 0x4a, 0xf9, 0x23, 0xa9, 0xee, 0x99, 0x05, 0x16, 0xa2, 0x2c, 0xab, 0xca, 0x27, 0x4c,
	0x7f, 0xfd, 0x98, 0xee, 0x9e, 0x9e, 0xee, 0x1d, 0xc0, 0x27, 0x53, 0x37, 0x9a, 0xad, 0xc6, 0x8f,
	0x26, 0xfe, 0xe2, 0xf1, 0xdc, 0x9d, 0xce, 0xa2, 0xc0, 0xbe, 0x78, 0xbc, 0xb0, 0xe7, 0xf2, 0xd3,
	0xc7, 0xc1, 0xf8, 0xf1, 0x72, 0x66, 0x87, 0xd2, 0x11, 0x41, 0xe8, 0x47, 0xfe, 0xe3, 0xa9, 0xef,
	0x3b, 0xcb, 0x47, 0xb4, 0xe6, 0x59, 0xfa, 0xb9, 0xfb, 0xf1, 0xdb, 0x6b, 0x8f, 0xed, 0xa5, 0x54,
	0xca, 0xd5, 0xbf, 0x64, 0xa1, 0xd2, 0x46, 0x63, 0x4d, 0x3b, 0xb2, 0xfb, 0x64, 0xaf, 0x02, 0x69,
	0xd7, 0x31, 0x52, 0x47, 0xa9, 0xe3, 0xac, 0x95, 0x76, 0x1d, 0xce, 0x61, 0xd7, 0xb3, 0x17, 0xd2,
	0x48, 0x1f, 0xa5, 0x8e, 0x0b, 0x16, 0xad, 0x11, 0x73, 0xe4, 0x72, 0x62, 0x64, 0x14, 0x86, 0x6b,
	0x6e, 0x40, 0x6e, 0x62, 0x07, 0x91, 0xed, 0x7a, 0xc6, 0x2e, 0x29, 0xc7, 0x24, 0x7f, 0x08, 0xb9,
	0xaf, 0x57, 0xf6, 0xdc, 0x8d, 0xae, 0x8c, 0xec, 0x51, 0xea, 0xb8, 0xf2, 0x61, 0x45, 0xed, 0xfe,
	0xe8, 0x0b, 0x85, 0xd6, 0xd3, 0x46, 0xca, 0x8a, 0x45, 0xf8, 0xfb, 0x50, 0xbe, 0x5a, 0xd9, 0xde,
	0xd8, 0xf6, 0x45, 0x10, 0xba, 0x13, 0x69, 0xec, 0x91, 0xb5, 0x92, 0x06, 0xfb, 0x88, 0xf1, 0x43,
	0xc8, 0xb9, 0x13, 0xdf, 0x13, 0xae, 0x63, 0xe4, 0xc8, 0x87, 0x3d, 0x24, 0x4d, 0x07, 0xbd, 0x9f,
	0x38, 0x46, 0x5e, 0x79, 0x3f, 0x71, 0xf8, 0x0f, 0xa1, 0xe2, 0xb8, 0xb6, 0xf7, 0xf5, 0xca, 0xf6,
	0xb4, 0xb9, 0x02, 0xf1, 0xca, 0x31, 0xaa, 0xec, 0xbd, 0x0f, 0x65, 0xca, 0xa9, 0x88, 0x1d, 0x05,
	0xb5, 0x29, 0x81, 0xda, 0x4d, 0xb4, 0x75, 0xe5, 0x7a, 0x73, 0xd7, 0xf6, 0xa6, 0xda, 0x56, 0x51,
	0xd9, 0x8a, 0x51, 0x65, 0xeb, 0x01, 0x14, 0xfd, 0x31, 0x06, 0x2e, 0x2e, 0xec, 0xab, 0xa5, 0x51,
	0x3a, 0xca, 0x1c, 0x17, 0x2c, 0x50, 0xd0, 0x53, 0xfb, 0x6a, 0xc9, 0x3f, 0x85, 0xa2, 0x3c, 0x3f,
	0x97, 0x93, 0x48, 0x44, 0x57, 0x81, 0x34, 0x0e, 0x28, 0x27, 0xb7, 0x75, 0x4e, 0xe8, 0x34, 0x5a,
	0xc4, 0x1e, 0x5e, 0x05, 0xd2, 0x02, 0xb9, 0x5e, 0xf3, 0x5f, 0x82, 0x72, 0x48, 0x28, 0xcc, 0xb8,
	0x73, 0x94, 0x3a, 0x2e, 0x7e, 0x78, 0x78, 0x5d, 0x93, 0x4e, 0xd2, 0x2a, 0x4e, 0x37, 0x08, 0xff,
	0x00, 0x0a, 0xcb, 0x40, 0x4e, 0xd4, 0x96, 0x0f, 0x68, 0xcb, 0x83, 0xa4, 0xe2, 0x20, 0x90, 0x13,
	0xda, 0x30, 0xbf, 0xd4, 0x2b, 0xfe, 0x10, 0x0a, 0x33, 0x39, 0x76, 0x95, 0xca, 0x11, 0xa9, 0xec,
	0x6b, 0x95, 0x8e, 0x1c, 0xbb, 0x4a, 0x7a, 0xa6, 0x57, 0xfc, 0x67, 0x50, 0x26, 0xe9, 0xe5, 0x6a,
	0xac, 0x34, 0xde, 0x23, 0x0d, 0x9e, 0xd0, 0x18, 0xac, 0xc6, 0xa4, 0x54, 0x9c, 0x6d, 0x08, 0xfe,
	0x10, 0x78, 0x60, 0x87, 0x91, 0x27, 0x43, 0x41, 0xfa, 0xe4, 0xb4, 0x51, 0xa5, 0xcc, 0x32, 0xcd,
	0x41, 0x65, 0xf2, 0xb2, 0x3a, 0x85, 0x1b, 0xed, 0xc4, 0x99, 0xa8, 0x92, 0x3d, 0x80, 0xec, 0x5c,
	0xbe, 0x90, 0x73, 0x5d, 0xb5, 0x8a, 0x78, 0x6d, 0xe1, 0x1e, 0x6f, 0x4a, 0x31, 0xf3, 0xba, 0x52,
	0x5c, 0x97, 0x61, 0xf5, 0x65, 0x1e, 0xd8, 0xab, 0x19, 0x45, 0x93, 0x53, 0x7f, 0x1e, 0xdf, 0x0e,
	0x5a, 0x23, 0x76, 0xee, 0xfb, 0x0e, 0x6d, 0x93, 0xb5, 0x68, 0x8d, 0xd8, 0x05, 0x62, 0x19, 0x85,
	0xe1, 0x1a, 0x9d, 0x5c, 0x46, 0xbe, 0x27, 0xf5, 0xed, 0x50, 0x04, 0x7f, 0x0f, 0x4a, 0xe3, 0x95,
	0x3b, 0x77, 0x5c, 0x6f, 0x2a, 0x26, 0x4e, 0x48, 0x17, 0x24, 0x6f, 0x15, 0x63, 0xac, 0xe1, 0x84,
	0xfc, 0x0e, 0xe4, 0x23, 0x39, 0x99, 0x11, 0x7b, 0x8f, 0xd8, 0x39, 0xa4, 0x91, 0xc5, 0x20, 0x83,
	0x68, 0x8e, 0x2c, 0xe2, 0x92, 0x7f, 0x0c, 0x79, 0x79, 0x19, 0xa8, 0x03, 0xc8, 0x53, 0x84, 0x77,
	0xb6, 0xca, 0xe3, 0x32, 0x48, 0xd4, 0x56, 0x4e, 0x5e, 0x06, 0x74, 0x06, 0x0c, 0x32, 0xf2, 0x32,
	0xd0, 0x57, 0x03, 0x97, 0xfc, 0x01, 0x14, 0x16, 0xfe, 0x0b, 0x29, 0xb0, 0x57, 0xd0, 0x65, 0xc8,
	0xd3, 0x2d, 0xcd, 0x23, 0x58, 0xb7, 0x97, 0xe8, 0x38, 0x84, 0xb6, 0xe7, 0xf8, 0x0b, 0x11, 0xf8,
	0x4b, 0xba, 0x08, 0x4a, 0xa2, 0xa0, 0xd0, 0xbe, 0xbf, 0x5c, 0xdb, 0x88, 0xa4, 0x17, 0x19, 0xa5,
	0x6d, 0x1b, 0x43, 0xe9, 0x45, 0xfc, 0x04, 0xf6, 0xa7, 0x18, 0xa8, 0xd8, 0x6c, 0x55, 0x5e, 0x8b,
	0x95, 0x89, 0xf5, 0x64, 0xb3, 0x5f, 0xe9, 0xc2, 0x0f, 0xbf, 0x5a, 0xce, 0xfc, 0x80, 0x32, 0x51,
	0x51, 0x89, 0x8a, 0x31, 0xcc, 0xc6, 0xaf, 0xa1, 0xb2, 0x36, 0xa4, 0x32, 0xb0, 0x4f, 0x19, 0x30,
	0x92, 0x19, 0x88, 0x0d, 0x52, 0x02, 0x4a, 0x8b, 0x04, 0x85, 0x4d, 0x60, 0xe1, 0xda, 0x9e, 0x70,
	0x56, 0xa1, 0x1d, 0xb9, 0xbe, 0x67, 0xdc, 0x52, 0x4d, 0x00, 0xc1, 0xa6, 0xc6, 0xf8, 0x4f, 0xe0,
	0x66, 0x14, 0xfa, 0x7e, 0x20, 0x96, 0x81, 0x94, 0x8e, 0x58, 0x05, 0x22, 0xb4, 0x23, 0x69, 0xdc,
	0x56, 0xf5, 0x4a, 0xac, 0x01, 0x72, 0x46, 0x81, 0x65, 0x47, 0x12, 0x7b, 0x46, 0x14, 0x62, 0x2f,
	0x58, 0x1b, 0x3d, 0x54, 0x3d, 0x83, 0xd0, 0xb5, 0xd5, 0x63, 0xa0, 0x52, 0x5f, 0x8a, 0x89, 0xbf,
	0x18, 0xbb, 0x9e, 0xc4, 0xc6, 0x66, 0x90, 0x60, 0x85, 0xf0, 0x86, 0x82, 0x4d, 0x87, 0x3f, 0x82,
	0x9b, 0xdb, 0x92, 0x13, 0x7f, 0xe5, 0xa9, 0x56, 0x90, 0xb5, 0x6e, 0x24, 0x85, 0x1b, 0xc8, 0xe0,
	0x3f, 0x87, 0x3b, 0xb6, 0xe3, 0x88, 0xc5, 0x6a, 0x1e, 0xb9, 0x82, 0x2e, 0x86, 0xf0, 0x82, 0x89,
	0x88, 0xdc, 0x85, 0x5c, 0x1a, 0x77, 0x29, 0x89, 0xb7, 0x6c, 0xc7, 0x79, 0x82, 0xfc, 0x33, 0x64,
	0x77, 0x83, 0xc9, 0x10, 0x99, 0xfc, 0x57, 0xb1, 0x4f, 0xcb, 0x99, 0x7f, 0x81, 0x0d, 0xef, 0x1b,
	0x69, 0xbc, 0x73, 0x94, 0x39, 0x2e, 0x7e, 0x78, 0x43, 0x27, 0xb4, 0x8f, 0x98, 0xea, 0x35, 0xca,
	0xcd, 0xc1, 0xcc, 0xbf, 0x20, 0x90, 0xff, 0x08, 0xf6, 0x13, 0xca, 0x74, 0x18, 0xef, 0xaa, 0xc0,
	0xd7, 0x82, 0x94, 0xf3, 0x06, 0x94, 0xe3, 0xcc, 0x28, 0xa9, 0x7b, 0x74, 0x64, 0xf7, 0x93, 0x47,
	0x16, 0x67, 0x29, 0x51, 0xb9, 0xa5, 0x58, 0x89, 0x8c, 0xdc, 0x85, 0xfc, 0x3a, 0xbd, 0xf7, 0x69,
	0x97, 0x35, 0x8d, 0xcd, 0xd6, 0x5e, 0x60, 0x26, 0x92, 0x9d, 0x6f, 0xab, 0xd9, 0xd6, 0x88, 0xad,
	0x9a, 0xad, 0xbd, 0x5e, 0xf3, 0xdb, 0xb0, 0xa7, 0x28, 0x6a, 0x7d, 0x59, 0x4b, 0x53, 0xfc, 0x03,
	0xc0, 0x7c, 0x09, 0xd7, 0x7b, 0x81, 0x65, 0x36, 0x93, 0xa1, 0xaf, 0x93, 0xf9, 0x1e, 0x25, 0x93,
	0xdb, 0x8e, 0x63, 0x12, 0xaf, 0x23, 0x43, 0x5f, 0x65, 0xf2, 0x10, 0x72, 0xe3, 0xd5, 0xf9, 0x39,
	0x1e, 0xaa, 0xea, 0x6b, 0x7b, 0x48, 0x9a, 0x4e, 0xf5, 0x3f, 0x29, 0xe0, 0xad, 0xaf, 0x57, 0x6e,
	0xb0, 0x90, 0x5e, 0xf4, 0xfd, 0x47, 0xf0, 0x31, 0xec, 0x52, 0x90, 0xd9, 0xad, 0xf6, 0xbe, 0xde,
	0x80, 0x42, 0x24, 0x09, 0xfe, 0x11, 0x14, 0xe8, 0x96, 0x2c, 0x23, 0x3b, 0xa2, 0xa6, 0x52, 0x5c,
	0xe7, 0x64, 0x10, 0x84, 0x6e, 0x24, 0x07, 0x91, 0xad, 0xa7, 0x48, 0x1e, 0x05, 0x91, 0xc4, 0x09,
	0x1f, 0x37, 0x4f, 0xd5, 0x71, 0xd6, 0x33, 0x3b, 0x31, 0x8e, 0xf3, 0xc9, 0x71, 0x5c, 0xfd, 0x5b,
	0x0a, 0x6e, 0xad, 0xf7, 0xdf, 0xea, 0xd9, 0xaf, 0xc6, 0x68, 0xc4, 0x3d, 0x9c, 0xfa, 0x28, 0x75,
	0x00, 0xdd, 0xc7, 0x1f, 0xc1, 0xcd, 0x50, 0x9e, 0xbb, 0x9e, 0x74, 0x74, 0xfd, 0xce, 0xdd, 0x85,
	0x1b, 0xe9, 0xde, 0x7a, 0x43, 0xb3, 0xa8, 0x74, 0xcf, 0x90, 0x81, 0x77, 0x69, 0xb9, 0x90, 0xf3,
	0x48, 0x8c, 0xed, 0xc9, 0x57, 0xfa, 0x7a, 0xa8, 0x9e, 0x5b, 0x21, 0xbc, 0x6e, 0x4f, 0xbe, 0x52,
	0x77, 0xe3, 0xda, 0xd4, 0xcf, 0x5e, 0x9f, 0xfa, 0xd5, 0x3f, 0x25, 0x43, 0xb0, 0xd4, 0x6e, 0x6f,
	0x1a, 0x3b, 0xf7, 0x00, 0x26, 0xfe, 0x32, 0xd2, 0x1b, 0xab, 0xa9, 0x50, 0x40, 0x44, 0xed, 0x79,
	0x0c, 0x2c, 0xf2, 0x23, 0x7b, 0x2e, 0x12, 0x42, 0x2a, 0x94, 0x0a, 0xe1, 0x8d, 0xa4, 0x24, 0x55,
	0x57, 0x32, 0x68, 0x1d, 0x07, 0xe2, 0x9b, 0x88, 0xab, 0x7f, 0x4d, 0x96, 0xd1, 0xd0, 0xf6, 0xbf,
	0x79, 0x93, 0x7f, 0x07, 0x90, 0x4d, 0xba, 0xa6, 0x08, 0x4c, 0xc5, 0x56, 0x92, 0xb5, 0x4f, 0xa5,
	0x64, 0x7a, 0xf1, 0x4a, 0x2c, 0xfc, 0xd0, 0x9e, 0xc7, 0x33, 0x4c, 0x53, 0x78, 0xc7, 0x96, 0x54,
	0x35, 0xaa, 0x9e, 0xb2, 0x6f, 0xac, 0x27, 0x58, 0xae, 0x81, 0xea, 0xdf, 0x77, 0xa1, 0xb2, 0x76,
	0xfc, 0xf5, 0x75, 0x71, 0x08, 0x39, 0xc7, 0x8e, 0x6c, 0x2c, 0x2d, 0xe5, 0xf0, 0x1e, 0x92, 0xa6,
	0xb3, 0x89, 0x2e, 0x93, 0x8c, 0xee, 0x5a, 0x1c, 0xbb, 0xaf, 0x89, 0xe3, 0x13, 0x00, 0x75, 0x06,
	0x6f, 0xe1, 0x6e, 0x81, 0x24, 0xa9, 0xfe, 0x3f, 0x01, 0x50, 0x67, 0xf1, 0x16, 0xb7, 0xa6, 0x40,
	0x92, 0xa4, 0xd6, 0x81, 0x83, 0xc9, 0x2a, 0x0c, 0xa5, 0x17, 0x89, 0xd8, 0x35, 0x32, 0x90, 0x7b,
	0xa3, 0x01, 0xae, 0x75, 0x74, 0xc5, 0x91, 0xa5, 0x26, 0xf0, 0x55, 0x30, 0x0d, 0x6d, 0x47, 0x8a,
	0x84, 0x23, 0xb7, 0xde, 0x68, 0x87, 0x69, 0x8d, 0xb3, 0xb5, 0x3f, 0x0f, 0x5f, 0xb5, 0x82, 0x95,
	0x18, 0x0f, 0xb0, 0xa4, 0x34, 0x96, 0x22, 0xff, 0x14, 0x8c, 0x6d, 0xe9, 0x4d, 0xf5, 0xea, 0x51,
	0x76, 0x2b, 0xa9, 0x33, 0x8c, 0x6b, 0x98, 0xff, 0x02, 0x4a, 0x5b, 0xe1, 0x1a, 0x6f, 0x74, 0xb3,
	0x18, 0x26, 0xe2, 0xfc, 0x29, 0x1c, 0x24, 0x55, 0x45, 0x20, 0xc3, 0x89, 0x5c, 0x0f, 0x39, 0x9e,
	0x10, 0xed, 0x2b, 0x4e, 0xf5, 0x05, 0xdc, 0xa2, 0x5e, 0xae, 0x47, 0xdf, 0xb7, 0xb7, 0xd2, 0x1f,
	0xc0, 0x2e, 0xb9, 0x9e, 0x26, 0x6f, 0x98, 0xf6, 0x06, 0x1d, 0x56, 0x7e, 0x10, 0x97, 0xff, 0x18,
	0xb2, 0x6a, 0xde, 0x65, 0x48, 0xec, 0x35, 0xf3, 0x4e, 0xf1, 0xab, 0xff, 0x8a, 0x9b, 0xc3, 0x77,
	0x6e, 0x7c, 0x0f, 0x60, 0x1a, 0xfa, 0xab, 0x40, 0x24, 0x3a, 0x79, 0x81, 0x90, 0x2e, 0xb6, 0xf3,
	0x2a, 0x94, 0xa9, 0x21, 0xa8, 0x7e, 0xe4, 0xc6, 0x9f, 0x8e, 0x45, 0x04, 0x29, 0x32, 0xd3, 0xe1,
	0x0f, 0x81, 0xc5, 0x43, 0x5f, 0xe2, 0x9e, 0x28, 0xb6, 0x7b, 0x94, 0xc1, 0x6e, 0xc9, 0x76, 0xac,
	0x8a, 0xe6, 0x91, 0x3b, 0xa6, 0xc3, 0x7f, 0x03, 0xa5, 0x58, 0x1a, 0x6f, 0x8c, 0x91, 0xa5, 0xd1,
	0xfd, 0x6e, 0x72, 0xf2, 0xbd, 0xea, 0x34, 0x6e, 0xb7, 0x46, 0xaa, 0xbf, 0xcf, 0x40, 0xa9, 0x2d,
	0x17, 0xdf, 0x7f, 0x2c, 0xdd, 0x81, 0xfc, 0x54, 0x2e, 0xc4, 0x7a, 0x34, 0x65, 0xad, 0xdc, 0x54,
	0x2e, 0x68, 0xc8, 0xae, 0x2f, 0xf1, 0x5e, 0xf2, 0x12, 0x1f, 0x6f, 0x0f, 0x9a, 0x6f, 0xff, 0x4a,
	0xdf, 0x9e, 0x63, 0xf9, 0xb7, 0x9c, 0x63, 0x89, 0x0b, 0xe0, 0xe1, 0x37, 0x9c, 0x6a, 0x87, 0x85,
	0xad, 0x0b, 0xd0, 0x95, 0xd2, 0x51, 0x6d, 0xf8, 0x1e, 0x40, 0x10, 0xca, 0x17, 0xba, 0x9d, 0xa8,
	0x77, 0x61, 0x01, 0x91, 0xb3, 0xb8, 0xdd, 0x7b, 0xf2, 0x32, 0xd2, 0x6c, 0xf5, 0x20, 0x2c, 0x20,
	0xa2, 0xd8, 0x89, 0xc9, 0x58, 0xda, 0x7a, 0xa8, 0x5e, 0x7b, 0xe6, 0x96, 0xaf, 0x3f, 0x73, 0xab,
	0xdf, 0x00, 0x6b, 0xcb, 0xc5, 0x60, 0xee, 0x27, 0x3e, 0x0e, 0xee, 0x40, 0x7e, 0x39, 0xf7, 0x23,
	0xe1, 0x3a, 0x97, 0xfa, 0x2c, 0x72, 0x48, 0x9b, 0xce, 0x25, 0x7e, 0x23, 0x53, 0x40, 0xf6, 0xd8,
	0xa5, 0xe4, 0xa9, 0x86, 0x59, 0x44, 0xac, 0xa6, 0xa0, 0xf5, 0x27, 0x42, 0xe6, 0xbb, 0x3e, 0x11,
	0x4e, 0xfe, 0x90, 0x86, 0xfd, 0x57, 0x1e, 0xa3, 0x1c, 0x60, 0xaf, 0xeb, 0x87, 0x0b, 0x7b, 0xce,
	0x76, 0xf8, 0x4d, 0xd8, 0x6f, 0x9d, 0x9e, 0xb6, 0x1a, 0x43, 0x61, 0xb5, 0x06, 0xbd, 0x91, 0xd5,
	0x68, 0xb1, 0x14, 0xaf, 0x00, 0x68, 0xb0, 0xd1, 0xb4, 0x58, 0x9a, 0x1f, 0x00, 0xd3, 0xf4, 0x93,
	0xde, 0x6f, 0x5b, 0xa2, 0x5e, 0x1b, 0xb4, 0x58, 0x26, 0x21, 0xd5, 0x7a, 0xd6, 0x67, 0xbb, 0x7c,
	0x1f, 0x8a, 0xb1, 0x94, 0x59, 0xeb, 0xb2, 0x6c, 0xc2, 0xf6, 0xa0, 0xdf, 0x6a, 0x35, 0xc5, 0xa8,
	0xcf, 0xf6, 0x12, 0xb6, 0x86, 0x56, 0xcd, 0xec, 0x92, 0x6e, 0x8e, 0x33, 0x28, 0x69, 0xb4, 0x5f,
	0xb3, 0x86, 0x03, 0x96, 0x4f, 0x58, 0x1f, 0x9e, 0x9e, 0xb1, 0x42, 0xc2, 0x58, 0x73, 0x64, 0xd5,
	0x86, 0x66, 0xaf, 0xcb, 0x80, 0xdf, 0x80, 0xb2, 0x06, 0x6b, 0x4f, 0x7a, 0xa3, 0xee, 0x90, 0x15,
	0x13, 0x7a, 0xed, 0xc6, 0x19, 0x2b, 0x25, 0xbc, 0xaa, 0x8f, 0x4e, 0x4f, 0x59, 0xf9, 0xe4, 0xcf,
	0x29, 0xe0, 0xd7, 0x5f, 0x51, 0x68, 0x1f, 0x3f, 0xf8, 0xe6, 0xae, 0x13, 0x33, 0xd9, 0x0e, 0x2f,
	0x41, 0xbe, 0xf5, 0xac, 0x2f, 0x3a, 0x2d, 0xab, 0xc7, 0x52, 0xfc, 0x10, 0x6e, 0x22, 0xd5, 0xa8,
	0xf5, 0x87, 0xe8, 0xb9, 0xd5, 0x3a, 0x35, 0xbb, 0xad, 0x26, 0x4b, 0x5f, 0x67, 0xd4, 0x4d, 0x6b,
	0xd8, 0x61, 0x19, 0xfe, 0x2e, 0x18, 0x49, 0xc6, 0xa0, 0x37, 0x3a, 0x13, 0xa3, 0x7e, 0xdb, 0xaa,
	0x35, 0x5b, 0x6c, 0x97, 0x82, 0x7e, 0xd6, 0x17, 0xed, 0x5e, 0xb7, 0x2d, 0x9e, 0x8d, 0x30, 0x63,
	0xe8, 0xec, 0x46, 0x9e, 0xed, 0x9d, 0x2c, 0xf4, 0x43, 0x39, 0xf9, 0xde, 0xe1, 0x06, 0x1c, 0x24,
	0x5d, 0x8d, 0x79, 0xea, 0x34, 0xd7, 0x27, 0x24, 0xfa, 0x3d, 0xb3, 0x3b, 0x64, 0x29, 0xcc, 0xf8,
	0x06, 0xb4, 0x6a, 0xdd, 0x66, 0xef, 0x09, 0x4b, 0x6f, 0x8b, 0xb6, 0x47, 0xe6, 0x59, 0x93, 0x65,
	0x4e, 0x16, 0xba, 0x58, 0x36, 0x1f, 0xd3, 0x98, 0x62, 0xbd, 0x99, 0x02, 0xd9, 0x0e, 0xa6, 0x58,
	0xad, 0x3b, 0xab, 0xf3, 0x15, 0x4b, 0xa1, 0x29, 0x45, 0x7f, 0x39, 0xb3, 0xbd, 0xdf, 0xb9, 0xb6,
	0x37, 0x65, 0x69, 0x0c, 0x45, 0x5b, 0xf1, 0x2f, 0x64, 0xc8, 0x32, 0x68, 0x48, 0x01, 0x9f, 0xad,
	0xbc, 0xe1, 0xca, 0xf6, 0xd8, 0xee, 0xc9, 0xbf, 0xd3, 0x50, 0xde, 0xfa, 0xdb, 0x82, 0xdf, 0x85,
	0xdb, 0xc9, 0xd0, 0x36, 0x7e, 0xa8, 0xc3, 0x68, 0xd7, 0x86, 0xa2, 0xdd, 0x3b, 0x6b, 0xb2, 0x54,
	0x4c, 0x9d, 0xf6, 0x7a, 0x78, 0x02, 0x9a, 0x7a, 0x8a, 0x54, 0x86, 0x97, 0xa1, 0x80, 0xd4, 0x60,
	0xd8, 0xeb, 0xb6, 0x54, 0x61, 0x22, 0xf9, 0x7c, 0x54, 0xeb, 0xd6, 0x6b, 0x3d, 0x55, 0x98, 0x08,
	0xc4, 0xc7, 0x82, 0x25, 0xb8, 0x87, 0xa7, 0x81, 0x20, 0x9e, 0xb5, 0x2e, 0x4a, 0x0e, 0x15, 0x44,
	0xfa, 0x56, 0x6f, 0xd0, 0x6f, 0x59, 0xe6, 0xf0, 0x39, 0xcb, 0xc7, 0x52, 0x4d, 0xb3, 0xd6, 0xfd,
	0x62, 0x54, 0xeb, 0xb2, 0x02, 0x7f, 0x00, 0xef, 0x90, 0x5b, 0x98, 0x42, 0xd1, 0xe8, 0x75, 0x87,
	0x96, 0x59, 0x1f, 0x61, 0x7d, 0x8a, 0x46, 0xcf, 0xc4, 0x22, 0xbd, 0x0b, 0xb7, 0x5f, 0x2f, 0xc0,
	0x8a, 0xb1, 0xdf, 0x9d, 0x56, 0xdd, 0x64, 0x25, 0x7e, 0x1b, 0x78, 0x4c, 0x89, 0x46, 0xaf, 0xff,
	0x5c, 0x0c, 0x5a, 0x67, 0xa7, 0xac, 0x1c, 0xe3, 0x8d, 0x4e, 0xad, 0xdb, 0x6e, 0x89, 0x06, 0x56,
	0xba, 0xf5, 0x9c, 0x55, 0x30, 0xa5, 0x14, 0x98, 0xd9, 0x15, 0x67, 0x66, 0xad, 0xdb, 0x66, 0xfb,
	0x78, 0xb7, 0x29, 0xf4, 0x3e, 0x63, 0x27, 0xa7, 0x70, 0xf8, 0x2d, 0x2f, 0xaf, 0x57, 0x4b, 0x28,
	0x96, 0x60, 0x3b, 0x68, 0x93, 0xb6, 0x6e, 0xb6, 0x4e, 0x5b, 0xdd, 0x41, 0xcb, 0x62, 0xa9, 0x93,
	0x0e, 0xe4, 0xe3, 0x7f, 0x8a, 0x30, 0x75, 0xb8, 0xd6, 0xca, 0xfa, 0x64, 0x8a, 0x90, 0xeb, 0xc8,
	0xc1, 0xcc, 0xad, 0xbb, 0x2c, 0x45, 0xc4, 0xea, 0xa9, 0xf4, 0xea, 0x2e, 0x4b, 0xe3, 0x49, 0x3c,
	0x5b, 0xc9, 0x53, 0xe9, 0x4d, 0xeb, 0x2e, 0xcb, 0x9c, 0xd4, 0xa1, 0x98, 0xf8, 0x07, 0x09, 0xe3,
	0x4a, 0x18, 0xd3, 0xa8, 0x3a, 0x69, 0xc4, 0xcf, 0xe4, 0x79, 0xc4, 0x52, 0x68, 0x03, 0x29, 0xcb,
	0x9d, 0xce, 0x22, 0x96, 0x3e, 0x99, 0x42, 0x79, 0xab, 0xd1, 0x25, 0x62, 0xd9, 0xc2, 0xd9, 0x0e,
	0x2f, 0x40, 0xf6, 0xe9, 0x48, 0x7c, 0x61, 0x2a, 0xaf, 0x86, 0xbd, 0x91, 0xf8, 0x7c, 0x64, 0xb2,
	0x34, 0x12, 0x9f, 0xd7, 0x4c, 0xf1, 0x99, 0x59, 0x63, 0x19, 0x24, 0x06, 0x1d, 0x53, 0xf4, 0xcd,
	0x2e, 0xdb, 0xc5, 0xf4, 0x75, 0x46, 0x62, 0x38, 0x32, 0x59, 0xb6, 0x7e, 0xf4, 0x8f, 0x97, 0xf7,
	0x53, 0xff, 0x7c, 0x79, 0x3f, 0xf5, 0xdf, 0x97, 0xf7, 0x53, 0x7f, 0xfc, 0xdf, 0xfd, 0x9d, 0x4e,
	0xea, 0xcb, 0x52, 0xf2, 0x2f, 0xd8, 0xf1, 0x1e, 0xfd, 0x7c, 0xf4, 0xff, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x3d, 0xe9, 0x88, 0xcc, 0xf4, 0x15, 0x00, 0x00,
}
