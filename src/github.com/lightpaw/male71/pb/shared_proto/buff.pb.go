// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/shared_proto/buff.proto
// DO NOT EDIT!

package shared_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// buff效果类型
type BuffEffectType int32

const (
	BuffEffectType_Buff_ET_invalid       BuffEffectType = 0
	BuffEffectType_Buff_ET_captain_train BuffEffectType = 1
	BuffEffectType_Buff_ET_farm_harvest  BuffEffectType = 2
	BuffEffectType_Buff_ET_tax           BuffEffectType = 3
	BuffEffectType_Buff_ET_sprite_stat   BuffEffectType = 4
	BuffEffectType_Buff_ET_battle_mian   BuffEffectType = 5
)

var BuffEffectType_name = map[int32]string{
	0: "Buff_ET_invalid",
	1: "Buff_ET_captain_train",
	2: "Buff_ET_farm_harvest",
	3: "Buff_ET_tax",
	4: "Buff_ET_sprite_stat",
	5: "Buff_ET_battle_mian",
}
var BuffEffectType_value = map[string]int32{
	"Buff_ET_invalid":       0,
	"Buff_ET_captain_train": 1,
	"Buff_ET_farm_harvest":  2,
	"Buff_ET_tax":           3,
	"Buff_ET_sprite_stat":   4,
	"Buff_ET_battle_mian":   5,
}

func (x BuffEffectType) String() string {
	return proto.EnumName(BuffEffectType_name, int32(x))
}
func (BuffEffectType) EnumDescriptor() ([]byte, []int) { return fileDescriptorBuff, []int{0} }

// buff 效果
type StatBuffProto struct {
	Attack         *AmountProto `protobuf:"bytes,1,opt,name=Attack" json:"Attack,omitempty"`
	Defense        *AmountProto `protobuf:"bytes,2,opt,name=Defense" json:"Defense,omitempty"`
	Strength       *AmountProto `protobuf:"bytes,3,opt,name=Strength" json:"Strength,omitempty"`
	Dexterity      *AmountProto `protobuf:"bytes,4,opt,name=Dexterity" json:"Dexterity,omitempty"`
	SoldierCapcity *AmountProto `protobuf:"bytes,5,opt,name=SoldierCapcity" json:"SoldierCapcity,omitempty"`
	DamageIncrePer int32        `protobuf:"varint,6,opt,name=DamageIncrePer,proto3" json:"DamageIncrePer,omitempty"`
	DamageDecrePer int32        `protobuf:"varint,7,opt,name=DamageDecrePer,proto3" json:"DamageDecrePer,omitempty"`
}

func (m *StatBuffProto) Reset()                    { *m = StatBuffProto{} }
func (m *StatBuffProto) String() string            { return proto.CompactTextString(m) }
func (*StatBuffProto) ProtoMessage()               {}
func (*StatBuffProto) Descriptor() ([]byte, []int) { return fileDescriptorBuff, []int{0} }

func (m *StatBuffProto) GetAttack() *AmountProto {
	if m != nil {
		return m.Attack
	}
	return nil
}

func (m *StatBuffProto) GetDefense() *AmountProto {
	if m != nil {
		return m.Defense
	}
	return nil
}

func (m *StatBuffProto) GetStrength() *AmountProto {
	if m != nil {
		return m.Strength
	}
	return nil
}

func (m *StatBuffProto) GetDexterity() *AmountProto {
	if m != nil {
		return m.Dexterity
	}
	return nil
}

func (m *StatBuffProto) GetSoldierCapcity() *AmountProto {
	if m != nil {
		return m.SoldierCapcity
	}
	return nil
}

func (m *StatBuffProto) GetDamageIncrePer() int32 {
	if m != nil {
		return m.DamageIncrePer
	}
	return 0
}

func (m *StatBuffProto) GetDamageDecrePer() int32 {
	if m != nil {
		return m.DamageDecrePer
	}
	return 0
}

// 玩家的 buff
type HeroBuffProto struct {
	Buff []*BuffInfoProto `protobuf:"bytes,1,rep,name=buff" json:"buff,omitempty"`
}

func (m *HeroBuffProto) Reset()                    { *m = HeroBuffProto{} }
func (m *HeroBuffProto) String() string            { return proto.CompactTextString(m) }
func (*HeroBuffProto) ProtoMessage()               {}
func (*HeroBuffProto) Descriptor() ([]byte, []int) { return fileDescriptorBuff, []int{1} }

func (m *HeroBuffProto) GetBuff() []*BuffInfoProto {
	if m != nil {
		return m.Buff
	}
	return nil
}

// 每个具体的 buff
type BuffInfoProto struct {
	StartTime    int32  `protobuf:"varint,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime      int32  `protobuf:"varint,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	BuffEffectId int32  `protobuf:"varint,3,opt,name=buff_effect_id,json=buffEffectId,proto3" json:"buff_effect_id,omitempty"`
	OperHeroId   []byte `protobuf:"bytes,4,opt,name=oper_hero_id,json=operHeroId,proto3" json:"oper_hero_id,omitempty"`
}

func (m *BuffInfoProto) Reset()                    { *m = BuffInfoProto{} }
func (m *BuffInfoProto) String() string            { return proto.CompactTextString(m) }
func (*BuffInfoProto) ProtoMessage()               {}
func (*BuffInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorBuff, []int{2} }

func (m *BuffInfoProto) GetStartTime() int32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *BuffInfoProto) GetEndTime() int32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *BuffInfoProto) GetBuffEffectId() int32 {
	if m != nil {
		return m.BuffEffectId
	}
	return 0
}

func (m *BuffInfoProto) GetOperHeroId() []byte {
	if m != nil {
		return m.OperHeroId
	}
	return nil
}

func init() {
	proto.RegisterType((*StatBuffProto)(nil), "proto.StatBuffProto")
	proto.RegisterType((*HeroBuffProto)(nil), "proto.HeroBuffProto")
	proto.RegisterType((*BuffInfoProto)(nil), "proto.BuffInfoProto")
	proto.RegisterEnum("proto.BuffEffectType", BuffEffectType_name, BuffEffectType_value)
}
func (m *StatBuffProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatBuffProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Attack != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBuff(dAtA, i, uint64(m.Attack.Size()))
		n1, err := m.Attack.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Defense != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBuff(dAtA, i, uint64(m.Defense.Size()))
		n2, err := m.Defense.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Strength != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBuff(dAtA, i, uint64(m.Strength.Size()))
		n3, err := m.Strength.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Dexterity != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBuff(dAtA, i, uint64(m.Dexterity.Size()))
		n4, err := m.Dexterity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.SoldierCapcity != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBuff(dAtA, i, uint64(m.SoldierCapcity.Size()))
		n5, err := m.SoldierCapcity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.DamageIncrePer != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBuff(dAtA, i, uint64(m.DamageIncrePer))
	}
	if m.DamageDecrePer != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBuff(dAtA, i, uint64(m.DamageDecrePer))
	}
	return i, nil
}

func (m *HeroBuffProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroBuffProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Buff) > 0 {
		for _, msg := range m.Buff {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBuff(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BuffInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuff(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuff(dAtA, i, uint64(m.EndTime))
	}
	if m.BuffEffectId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBuff(dAtA, i, uint64(m.BuffEffectId))
	}
	if len(m.OperHeroId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBuff(dAtA, i, uint64(len(m.OperHeroId)))
		i += copy(dAtA[i:], m.OperHeroId)
	}
	return i, nil
}

func encodeFixed64Buff(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Buff(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintBuff(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *StatBuffProto) Size() (n int) {
	var l int
	_ = l
	if m.Attack != nil {
		l = m.Attack.Size()
		n += 1 + l + sovBuff(uint64(l))
	}
	if m.Defense != nil {
		l = m.Defense.Size()
		n += 1 + l + sovBuff(uint64(l))
	}
	if m.Strength != nil {
		l = m.Strength.Size()
		n += 1 + l + sovBuff(uint64(l))
	}
	if m.Dexterity != nil {
		l = m.Dexterity.Size()
		n += 1 + l + sovBuff(uint64(l))
	}
	if m.SoldierCapcity != nil {
		l = m.SoldierCapcity.Size()
		n += 1 + l + sovBuff(uint64(l))
	}
	if m.DamageIncrePer != 0 {
		n += 1 + sovBuff(uint64(m.DamageIncrePer))
	}
	if m.DamageDecrePer != 0 {
		n += 1 + sovBuff(uint64(m.DamageDecrePer))
	}
	return n
}

func (m *HeroBuffProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Buff) > 0 {
		for _, e := range m.Buff {
			l = e.Size()
			n += 1 + l + sovBuff(uint64(l))
		}
	}
	return n
}

func (m *BuffInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovBuff(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovBuff(uint64(m.EndTime))
	}
	if m.BuffEffectId != 0 {
		n += 1 + sovBuff(uint64(m.BuffEffectId))
	}
	l = len(m.OperHeroId)
	if l > 0 {
		n += 1 + l + sovBuff(uint64(l))
	}
	return n
}

func sovBuff(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBuff(x uint64) (n int) {
	return sovBuff(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StatBuffProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuff
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatBuffProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatBuffProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBuff
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attack == nil {
				m.Attack = &AmountProto{}
			}
			if err := m.Attack.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defense", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBuff
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Defense == nil {
				m.Defense = &AmountProto{}
			}
			if err := m.Defense.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBuff
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Strength == nil {
				m.Strength = &AmountProto{}
			}
			if err := m.Strength.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dexterity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBuff
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dexterity == nil {
				m.Dexterity = &AmountProto{}
			}
			if err := m.Dexterity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldierCapcity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBuff
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SoldierCapcity == nil {
				m.SoldierCapcity = &AmountProto{}
			}
			if err := m.SoldierCapcity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DamageIncrePer", wireType)
			}
			m.DamageIncrePer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DamageIncrePer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DamageDecrePer", wireType)
			}
			m.DamageDecrePer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DamageDecrePer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuff(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuff
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroBuffProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuff
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroBuffProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroBuffProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBuff
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buff = append(m.Buff, &BuffInfoProto{})
			if err := m.Buff[len(m.Buff)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBuff(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuff
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffInfoProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuff
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffEffectId", wireType)
			}
			m.BuffEffectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffEffectId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperHeroId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBuff
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperHeroId = append(m.OperHeroId[:0], dAtA[iNdEx:postIndex]...)
			if m.OperHeroId == nil {
				m.OperHeroId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBuff(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuff
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBuff(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBuff
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBuff
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBuff
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBuff
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBuff
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBuff(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBuff = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBuff   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/shared_proto/buff.proto", fileDescriptorBuff)
}

var fileDescriptorBuff = []byte{
	// 491 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x92, 0x4f, 0x6b, 0x13, 0x41,
	0x18, 0xc6, 0x3b, 0x69, 0x37, 0x69, 0xdf, 0xfc, 0xe9, 0x32, 0xad, 0xb8, 0x15, 0x0c, 0x21, 0x88,
	0x84, 0x22, 0x89, 0x54, 0x41, 0xf4, 0xd6, 0x98, 0x42, 0x73, 0x2b, 0x49, 0x4e, 0x5e, 0x86, 0xc9,
	0xee, 0xbb, 0xd9, 0xc1, 0xec, 0xec, 0x32, 0xfb, 0xa6, 0xb6, 0x1f, 0xc3, 0x9b, 0x17, 0xbf, 0x8f,
	0x47, 0x6f, 0x5e, 0x25, 0x7e, 0x11, 0xd9, 0x49, 0xb6, 0x89, 0x85, 0x1c, 0x3c, 0xcd, 0xf2, 0x7b,
	0x7e, 0xcf, 0x30, 0xfb, 0xce, 0xc0, 0xdb, 0x99, 0xa2, 0x68, 0x31, 0xed, 0xfa, 0x49, 0xdc, 0x9b,
	0xab, 0x59, 0x44, 0xa9, 0xfc, 0xd2, 0x8b, 0xe5, 0x1c, 0xdf, 0xf5, 0xd2, 0x69, 0x2f, 0x8b, 0xa4,
	0xc1, 0x40, 0xa4, 0x26, 0xa1, 0xa4, 0x37, 0x5d, 0x84, 0x61, 0xd7, 0x7e, 0x72, 0xc7, 0x2e, 0xcf,
	0xfe, 0xa7, 0x2c, 0x33, 0x5c, 0x95, 0xdb, 0xbf, 0x4a, 0x50, 0x1f, 0x93, 0xa4, 0xfe, 0x22, 0x0c,
	0x6f, 0xec, 0x76, 0xe7, 0x50, 0xbe, 0x24, 0x92, 0xfe, 0x67, 0x8f, 0xb5, 0x58, 0xa7, 0x7a, 0xc1,
	0x57, 0x66, 0xf7, 0x32, 0x4e, 0x16, 0x9a, 0xac, 0x33, 0x5a, 0x1b, 0xfc, 0x15, 0x54, 0x06, 0x18,
	0xa2, 0xce, 0xd0, 0x2b, 0xed, 0x94, 0x0b, 0x85, 0x77, 0xe1, 0x70, 0x4c, 0x06, 0xf5, 0x8c, 0x22,
	0x6f, 0x7f, 0xa7, 0xfe, 0xe0, 0xf0, 0xd7, 0x70, 0x34, 0xc0, 0x3b, 0x42, 0xa3, 0xe8, 0xde, 0x3b,
	0xd8, 0x59, 0xd8, 0x48, 0xfc, 0x03, 0x34, 0xc6, 0xc9, 0x3c, 0x50, 0x68, 0x3e, 0xca, 0xd4, 0xcf,
	0x6b, 0xce, 0xce, 0xda, 0x23, 0x93, 0xbf, 0x84, 0xc6, 0x40, 0xc6, 0x72, 0x86, 0x43, 0xed, 0x1b,
	0xbc, 0x41, 0xe3, 0x95, 0x5b, 0xac, 0xe3, 0x8c, 0x1e, 0xd1, 0x8d, 0x37, 0xc0, 0xb5, 0x57, 0xd9,
	0xf6, 0x0a, 0xda, 0x7e, 0x0f, 0xf5, 0x6b, 0x34, 0xc9, 0x66, 0xb0, 0x1d, 0x38, 0xc8, 0x6f, 0xcd,
	0x63, 0xad, 0xfd, 0x4e, 0xf5, 0xe2, 0x74, 0x7d, 0xa4, 0x3c, 0x1f, 0xea, 0x30, 0x59, 0x1d, 0xca,
	0x1a, 0xed, 0xaf, 0x0c, 0xea, 0xff, 0x70, 0xfe, 0x1c, 0x20, 0x23, 0x69, 0x48, 0x90, 0x8a, 0xd1,
	0x5e, 0x8c, 0x33, 0x3a, 0xb2, 0x64, 0xa2, 0x62, 0xe4, 0x67, 0x70, 0x88, 0x3a, 0x58, 0x85, 0x25,
	0x1b, 0x56, 0x50, 0x07, 0x36, 0x7a, 0x01, 0x8d, 0x7c, 0x4f, 0x81, 0x61, 0x88, 0x3e, 0x09, 0x15,
	0xd8, 0xd1, 0x3b, 0xa3, 0x5a, 0x4e, 0xaf, 0x2c, 0x1c, 0x06, 0xbc, 0x05, 0xb5, 0x24, 0x45, 0x23,
	0x22, 0x34, 0x49, 0xee, 0xe4, 0xd3, 0xae, 0x8d, 0x20, 0x67, 0xf9, 0x4f, 0x0c, 0x83, 0xf3, 0xef,
	0x0c, 0x1a, 0xfd, 0x87, 0xca, 0xe4, 0x3e, 0x45, 0x7e, 0x02, 0xc7, 0x39, 0x11, 0x57, 0x13, 0xa1,
	0xf4, 0xad, 0x9c, 0xab, 0xc0, 0xdd, 0xe3, 0x67, 0xf0, 0xa4, 0x80, 0xbe, 0x4c, 0x49, 0x2a, 0x2d,
	0xc8, 0x48, 0xa5, 0x5d, 0xc6, 0x3d, 0x38, 0x2d, 0xa2, 0x50, 0x9a, 0x58, 0x44, 0xd2, 0xdc, 0x62,
	0x46, 0x6e, 0x89, 0x1f, 0x43, 0xb5, 0x48, 0x48, 0xde, 0xb9, 0xfb, 0xfc, 0x29, 0x9c, 0x14, 0x20,
	0x4b, 0x8d, 0x22, 0x14, 0x19, 0x49, 0x72, 0x0f, 0xb6, 0x83, 0xa9, 0x24, 0x9a, 0xa3, 0x88, 0x95,
	0xd4, 0xae, 0xd3, 0x6f, 0xfd, 0x58, 0x36, 0xd9, 0xcf, 0x65, 0x93, 0xfd, 0x5e, 0x36, 0xd9, 0xb7,
	0x3f, 0xcd, 0xbd, 0x6b, 0xf6, 0xa9, 0xb6, 0xfd, 0xea, 0xa7, 0x65, 0xbb, 0xbc, 0xf9, 0x1b, 0x00,
	0x00, 0xff, 0xff, 0x32, 0x71, 0xee, 0xd7, 0x66, 0x03, 0x00, 0x00,
}
