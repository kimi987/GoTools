// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/shared_proto/military.proto
// DO NOT EDIT!

package shared_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// pve队伍类型
type PveTroopType int32

const (
	PveTroopType_InvalidPveTroopType PveTroopType = 0
	PveTroopType_TOWER               PveTroopType = 1
	PveTroopType_SECRET_TOWER        PveTroopType = 2
	PveTroopType_DUNGEON             PveTroopType = 3
	PveTroopType_BAI_ZHAN            PveTroopType = 4
	PveTroopType_PVE_XUAN_YUAN       PveTroopType = 5
	PveTroopType_HE_BI               PveTroopType = 6
	PveTroopType_MINGC_WAR           PveTroopType = 7
)

var PveTroopType_name = map[int32]string{
	0: "InvalidPveTroopType",
	1: "TOWER",
	2: "SECRET_TOWER",
	3: "DUNGEON",
	4: "BAI_ZHAN",
	5: "PVE_XUAN_YUAN",
	6: "HE_BI",
	7: "MINGC_WAR",
}
var PveTroopType_value = map[string]int32{
	"InvalidPveTroopType": 0,
	"TOWER":               1,
	"SECRET_TOWER":        2,
	"DUNGEON":             3,
	"BAI_ZHAN":            4,
	"PVE_XUAN_YUAN":       5,
	"HE_BI":               6,
	"MINGC_WAR":           7,
}

func (x PveTroopType) String() string {
	return proto.EnumName(PveTroopType_name, int32(x))
}
func (PveTroopType) EnumDescriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{0} }

type StrongerDataProto struct {
	Level int32 `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	// 类型
	// 1、达到推荐战力值
	// 2、X个武将强化点数达到Y
	// 3、X个武将穿上Y件Z级装备
	// 4、X个武将穿上Y件Z星装备
	// 5、X个武将穿上Y个Z级宝石
	// 6、X个武将穿上Y级将魂
	// 7、君主升到X级
	// 8、士兵升到X阶
	Type int32 `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	X    int32 `protobuf:"varint,11,opt,name=x,proto3" json:"x,omitempty"`
	Y    int32 `protobuf:"varint,12,opt,name=y,proto3" json:"y,omitempty"`
	Z    int32 `protobuf:"varint,13,opt,name=z,proto3" json:"z,omitempty"`
}

func (m *StrongerDataProto) Reset()                    { *m = StrongerDataProto{} }
func (m *StrongerDataProto) String() string            { return proto.CompactTextString(m) }
func (*StrongerDataProto) ProtoMessage()               {}
func (*StrongerDataProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{0} }

func (m *StrongerDataProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *StrongerDataProto) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *StrongerDataProto) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *StrongerDataProto) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *StrongerDataProto) GetZ() int32 {
	if m != nil {
		return m.Z
	}
	return 0
}

type JiuGuanMiscDataProto struct {
	MaxTimes           int32        `protobuf:"varint,1,opt,name=max_times,json=maxTimes,proto3" json:"max_times,omitempty"`
	RefreshCostYuanBao []int32      `protobuf:"varint,3,rep,name=refresh_cost_yuan_bao,json=refreshCostYuanBao" json:"refresh_cost_yuan_bao,omitempty"`
	RefreshCost        []*CostProto `protobuf:"bytes,5,rep,name=refresh_cost,json=refreshCost" json:"refresh_cost,omitempty"`
	RecoveryDuration   int32        `protobuf:"varint,4,opt,name=recovery_duration,json=recoveryDuration,proto3" json:"recovery_duration,omitempty"`
}

func (m *JiuGuanMiscDataProto) Reset()                    { *m = JiuGuanMiscDataProto{} }
func (m *JiuGuanMiscDataProto) String() string            { return proto.CompactTextString(m) }
func (*JiuGuanMiscDataProto) ProtoMessage()               {}
func (*JiuGuanMiscDataProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{1} }

func (m *JiuGuanMiscDataProto) GetMaxTimes() int32 {
	if m != nil {
		return m.MaxTimes
	}
	return 0
}

func (m *JiuGuanMiscDataProto) GetRefreshCostYuanBao() []int32 {
	if m != nil {
		return m.RefreshCostYuanBao
	}
	return nil
}

func (m *JiuGuanMiscDataProto) GetRefreshCost() []*CostProto {
	if m != nil {
		return m.RefreshCost
	}
	return nil
}

func (m *JiuGuanMiscDataProto) GetRecoveryDuration() int32 {
	if m != nil {
		return m.RecoveryDuration
	}
	return 0
}

type TutorDataProto struct {
	Name           string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Image          string      `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	Prize          *PrizeProto `protobuf:"bytes,3,opt,name=prize" json:"prize,omitempty"`
	ChatContent    string      `protobuf:"bytes,4,opt,name=chat_content,json=chatContent,proto3" json:"chat_content,omitempty"`
	RefreshMaxCost *CostProto  `protobuf:"bytes,5,opt,name=refresh_max_cost,json=refreshMaxCost" json:"refresh_max_cost,omitempty"`
}

func (m *TutorDataProto) Reset()                    { *m = TutorDataProto{} }
func (m *TutorDataProto) String() string            { return proto.CompactTextString(m) }
func (*TutorDataProto) ProtoMessage()               {}
func (*TutorDataProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{2} }

func (m *TutorDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TutorDataProto) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *TutorDataProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

func (m *TutorDataProto) GetChatContent() string {
	if m != nil {
		return m.ChatContent
	}
	return ""
}

func (m *TutorDataProto) GetRefreshMaxCost() *CostProto {
	if m != nil {
		return m.RefreshMaxCost
	}
	return nil
}

type JiuGuanDataProto struct {
	Level            int32             `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	TutorDatas       []*TutorDataProto `protobuf:"bytes,2,rep,name=tutor_datas,json=tutorDatas" json:"tutor_datas,omitempty"`
	BroadcastContent string            `protobuf:"bytes,3,opt,name=broadcast_content,json=broadcastContent,proto3" json:"broadcast_content,omitempty"`
	RecoveryDuration int32             `protobuf:"varint,4,opt,name=recovery_duration,json=recoveryDuration,proto3" json:"recovery_duration,omitempty"`
	MaxTimes         int32             `protobuf:"varint,5,opt,name=max_times,json=maxTimes,proto3" json:"max_times,omitempty"`
}

func (m *JiuGuanDataProto) Reset()                    { *m = JiuGuanDataProto{} }
func (m *JiuGuanDataProto) String() string            { return proto.CompactTextString(m) }
func (*JiuGuanDataProto) ProtoMessage()               {}
func (*JiuGuanDataProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{3} }

func (m *JiuGuanDataProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *JiuGuanDataProto) GetTutorDatas() []*TutorDataProto {
	if m != nil {
		return m.TutorDatas
	}
	return nil
}

func (m *JiuGuanDataProto) GetBroadcastContent() string {
	if m != nil {
		return m.BroadcastContent
	}
	return ""
}

func (m *JiuGuanDataProto) GetRecoveryDuration() int32 {
	if m != nil {
		return m.RecoveryDuration
	}
	return 0
}

func (m *JiuGuanDataProto) GetMaxTimes() int32 {
	if m != nil {
		return m.MaxTimes
	}
	return 0
}

type JunYingLevelDataProto struct {
	Level            int32 `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	MaxTimes         int32 `protobuf:"varint,2,opt,name=max_times,json=maxTimes,proto3" json:"max_times,omitempty"`
	RecoveryDuration int32 `protobuf:"varint,4,opt,name=recovery_duration,json=recoveryDuration,proto3" json:"recovery_duration,omitempty"`
}

func (m *JunYingLevelDataProto) Reset()                    { *m = JunYingLevelDataProto{} }
func (m *JunYingLevelDataProto) String() string            { return proto.CompactTextString(m) }
func (*JunYingLevelDataProto) ProtoMessage()               {}
func (*JunYingLevelDataProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{4} }

func (m *JunYingLevelDataProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *JunYingLevelDataProto) GetMaxTimes() int32 {
	if m != nil {
		return m.MaxTimes
	}
	return 0
}

func (m *JunYingLevelDataProto) GetRecoveryDuration() int32 {
	if m != nil {
		return m.RecoveryDuration
	}
	return 0
}

type JunYingMiscProto struct {
	ForceAddSoldierMaxTimes int32        `protobuf:"varint,2,opt,name=force_add_soldier_max_times,json=forceAddSoldierMaxTimes,proto3" json:"force_add_soldier_max_times,omitempty"`
	ForceAddSoldierCost     []int32      `protobuf:"varint,3,rep,name=force_add_soldier_cost,json=forceAddSoldierCost" json:"force_add_soldier_cost,omitempty"`
	ForceAddSoldierNewCost  []*CostProto `protobuf:"bytes,4,rep,name=force_add_soldier_new_cost,json=forceAddSoldierNewCost" json:"force_add_soldier_new_cost,omitempty"`
}

func (m *JunYingMiscProto) Reset()                    { *m = JunYingMiscProto{} }
func (m *JunYingMiscProto) String() string            { return proto.CompactTextString(m) }
func (*JunYingMiscProto) ProtoMessage()               {}
func (*JunYingMiscProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{5} }

func (m *JunYingMiscProto) GetForceAddSoldierMaxTimes() int32 {
	if m != nil {
		return m.ForceAddSoldierMaxTimes
	}
	return 0
}

func (m *JunYingMiscProto) GetForceAddSoldierCost() []int32 {
	if m != nil {
		return m.ForceAddSoldierCost
	}
	return nil
}

func (m *JunYingMiscProto) GetForceAddSoldierNewCost() []*CostProto {
	if m != nil {
		return m.ForceAddSoldierNewCost
	}
	return nil
}

type TrainingLevelProto struct {
	Level      int32      `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	Name       string     `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Desc       string     `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	ExpOutput  int32      `protobuf:"varint,4,opt,name=exp_output,json=expOutput,proto3" json:"exp_output,omitempty"`
	ExpCapcity int32      `protobuf:"varint,5,opt,name=exp_capcity,json=expCapcity,proto3" json:"exp_capcity,omitempty"`
	Cost       *CostProto `protobuf:"bytes,6,opt,name=cost" json:"cost,omitempty"`
	Coef       int32      `protobuf:"varint,7,opt,name=coef,proto3" json:"coef,omitempty"`
}

func (m *TrainingLevelProto) Reset()                    { *m = TrainingLevelProto{} }
func (m *TrainingLevelProto) String() string            { return proto.CompactTextString(m) }
func (*TrainingLevelProto) ProtoMessage()               {}
func (*TrainingLevelProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{6} }

func (m *TrainingLevelProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *TrainingLevelProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TrainingLevelProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *TrainingLevelProto) GetExpOutput() int32 {
	if m != nil {
		return m.ExpOutput
	}
	return 0
}

func (m *TrainingLevelProto) GetExpCapcity() int32 {
	if m != nil {
		return m.ExpCapcity
	}
	return 0
}

func (m *TrainingLevelProto) GetCost() *CostProto {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *TrainingLevelProto) GetCoef() int32 {
	if m != nil {
		return m.Coef
	}
	return 0
}

type CaptainAbilityProto struct {
	Ability    int32       `protobuf:"varint,1,opt,name=ability,proto3" json:"ability,omitempty"`
	UpgradeExp int32       `protobuf:"varint,2,opt,name=upgrade_exp,json=upgradeExp,proto3" json:"upgrade_exp,omitempty"`
	SellPrice  *PrizeProto `protobuf:"bytes,3,opt,name=sell_price,json=sellPrice" json:"sell_price,omitempty"`
	FirePrice  *PrizeProto `protobuf:"bytes,5,opt,name=fire_price,json=firePrice" json:"fire_price,omitempty"`
	Quality    Quality     `protobuf:"varint,4,opt,name=quality,proto3,enum=proto.Quality" json:"quality,omitempty"`
	Desc       string      `protobuf:"bytes,6,opt,name=desc,proto3" json:"desc,omitempty"`
	Models     []int32     `protobuf:"varint,7,rep,name=models" json:"models,omitempty"`
	// 解锁技能个数
	UnlockSpellCount int32 `protobuf:"varint,8,opt,name=unlock_spell_count,json=unlockSpellCount,proto3" json:"unlock_spell_count,omitempty"`
	// 重生消耗
	ResetCost *CostProto `protobuf:"bytes,9,opt,name=reset_cost,json=resetCost" json:"reset_cost,omitempty"`
}

func (m *CaptainAbilityProto) Reset()                    { *m = CaptainAbilityProto{} }
func (m *CaptainAbilityProto) String() string            { return proto.CompactTextString(m) }
func (*CaptainAbilityProto) ProtoMessage()               {}
func (*CaptainAbilityProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{7} }

func (m *CaptainAbilityProto) GetAbility() int32 {
	if m != nil {
		return m.Ability
	}
	return 0
}

func (m *CaptainAbilityProto) GetUpgradeExp() int32 {
	if m != nil {
		return m.UpgradeExp
	}
	return 0
}

func (m *CaptainAbilityProto) GetSellPrice() *PrizeProto {
	if m != nil {
		return m.SellPrice
	}
	return nil
}

func (m *CaptainAbilityProto) GetFirePrice() *PrizeProto {
	if m != nil {
		return m.FirePrice
	}
	return nil
}

func (m *CaptainAbilityProto) GetQuality() Quality {
	if m != nil {
		return m.Quality
	}
	return Quality_InvalidQuality
}

func (m *CaptainAbilityProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *CaptainAbilityProto) GetModels() []int32 {
	if m != nil {
		return m.Models
	}
	return nil
}

func (m *CaptainAbilityProto) GetUnlockSpellCount() int32 {
	if m != nil {
		return m.UnlockSpellCount
	}
	return 0
}

func (m *CaptainAbilityProto) GetResetCost() *CostProto {
	if m != nil {
		return m.ResetCost
	}
	return nil
}

type CaptainGeneratorProto struct {
	Count         int32 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	NeedHeroLevel int32 `protobuf:"varint,2,opt,name=need_hero_level,json=needHeroLevel,proto3" json:"need_hero_level,omitempty"`
}

func (m *CaptainGeneratorProto) Reset()                    { *m = CaptainGeneratorProto{} }
func (m *CaptainGeneratorProto) String() string            { return proto.CompactTextString(m) }
func (*CaptainGeneratorProto) ProtoMessage()               {}
func (*CaptainGeneratorProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{8} }

func (m *CaptainGeneratorProto) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *CaptainGeneratorProto) GetNeedHeroLevel() int32 {
	if m != nil {
		return m.NeedHeroLevel
	}
	return 0
}

type CaptainLevelProto struct {
	Rebirth       int32 `protobuf:"varint,11,opt,name=rebirth,proto3" json:"rebirth,omitempty"`
	Level         int32 `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	UpgradeExp    int32 `protobuf:"varint,2,opt,name=upgrade_exp,json=upgradeExp,proto3" json:"upgrade_exp,omitempty"`
	GemSlotCount  int32 `protobuf:"varint,22,opt,name=gem_slot_count,json=gemSlotCount,proto3" json:"gem_slot_count,omitempty"`
	HasNewGemSlot bool  `protobuf:"varint,3,opt,name=has_new_gem_slot,json=hasNewGemSlot,proto3" json:"has_new_gem_slot,omitempty"`
	AbilityLimit  int32 `protobuf:"varint,4,opt,name=ability_limit,json=abilityLimit,proto3" json:"ability_limit,omitempty"`
}

func (m *CaptainLevelProto) Reset()                    { *m = CaptainLevelProto{} }
func (m *CaptainLevelProto) String() string            { return proto.CompactTextString(m) }
func (*CaptainLevelProto) ProtoMessage()               {}
func (*CaptainLevelProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{9} }

func (m *CaptainLevelProto) GetRebirth() int32 {
	if m != nil {
		return m.Rebirth
	}
	return 0
}

func (m *CaptainLevelProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *CaptainLevelProto) GetUpgradeExp() int32 {
	if m != nil {
		return m.UpgradeExp
	}
	return 0
}

func (m *CaptainLevelProto) GetGemSlotCount() int32 {
	if m != nil {
		return m.GemSlotCount
	}
	return 0
}

func (m *CaptainLevelProto) GetHasNewGemSlot() bool {
	if m != nil {
		return m.HasNewGemSlot
	}
	return false
}

func (m *CaptainLevelProto) GetAbilityLimit() int32 {
	if m != nil {
		return m.AbilityLimit
	}
	return 0
}

type CaptainRebirthLevelProto struct {
	Level              int32 `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	RebirthUpgradeExp  int32 `protobuf:"varint,2,opt,name=rebirth_upgrade_exp,json=rebirthUpgradeExp,proto3" json:"rebirth_upgrade_exp,omitempty"`
	CaptainLevelLimit  int32 `protobuf:"varint,3,opt,name=captain_level_limit,json=captainLevelLimit,proto3" json:"captain_level_limit,omitempty"`
	Yuanbao            int32 `protobuf:"varint,4,opt,name=yuanbao,proto3" json:"yuanbao,omitempty"`
	SpriteStatPoint    int32 `protobuf:"varint,5,opt,name=sprite_stat_point,json=spriteStatPoint,proto3" json:"sprite_stat_point,omitempty"`
	SoldierCapcity     int32 `protobuf:"varint,6,opt,name=soldier_capcity,json=soldierCapcity,proto3" json:"soldier_capcity,omitempty"`
	AbilityLimit       int32 `protobuf:"varint,7,opt,name=ability_limit,json=abilityLimit,proto3" json:"ability_limit,omitempty"`
	AbilityExp         int32 `protobuf:"varint,8,opt,name=ability_exp,json=abilityExp,proto3" json:"ability_exp,omitempty"`
	Cd                 int32 `protobuf:"varint,9,opt,name=cd,proto3" json:"cd,omitempty"`
	BeforeRebirthLevel int32 `protobuf:"varint,10,opt,name=before_rebirth_level,json=beforeRebirthLevel,proto3" json:"before_rebirth_level,omitempty"`
	HeroLevelLimit     int32 `protobuf:"varint,11,opt,name=hero_level_limit,json=heroLevelLimit,proto3" json:"hero_level_limit,omitempty"`
}

func (m *CaptainRebirthLevelProto) Reset()         { *m = CaptainRebirthLevelProto{} }
func (m *CaptainRebirthLevelProto) String() string { return proto.CompactTextString(m) }
func (*CaptainRebirthLevelProto) ProtoMessage()    {}
func (*CaptainRebirthLevelProto) Descriptor() ([]byte, []int) {
	return fileDescriptorMilitary, []int{10}
}

func (m *CaptainRebirthLevelProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *CaptainRebirthLevelProto) GetRebirthUpgradeExp() int32 {
	if m != nil {
		return m.RebirthUpgradeExp
	}
	return 0
}

func (m *CaptainRebirthLevelProto) GetCaptainLevelLimit() int32 {
	if m != nil {
		return m.CaptainLevelLimit
	}
	return 0
}

func (m *CaptainRebirthLevelProto) GetYuanbao() int32 {
	if m != nil {
		return m.Yuanbao
	}
	return 0
}

func (m *CaptainRebirthLevelProto) GetSpriteStatPoint() int32 {
	if m != nil {
		return m.SpriteStatPoint
	}
	return 0
}

func (m *CaptainRebirthLevelProto) GetSoldierCapcity() int32 {
	if m != nil {
		return m.SoldierCapcity
	}
	return 0
}

func (m *CaptainRebirthLevelProto) GetAbilityLimit() int32 {
	if m != nil {
		return m.AbilityLimit
	}
	return 0
}

func (m *CaptainRebirthLevelProto) GetAbilityExp() int32 {
	if m != nil {
		return m.AbilityExp
	}
	return 0
}

func (m *CaptainRebirthLevelProto) GetCd() int32 {
	if m != nil {
		return m.Cd
	}
	return 0
}

func (m *CaptainRebirthLevelProto) GetBeforeRebirthLevel() int32 {
	if m != nil {
		return m.BeforeRebirthLevel
	}
	return 0
}

func (m *CaptainRebirthLevelProto) GetHeroLevelLimit() int32 {
	if m != nil {
		return m.HeroLevelLimit
	}
	return 0
}

type CaptainSeekerProto struct {
	Index             int32             `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Sequence          int32             `protobuf:"varint,2,opt,name=sequence,proto3" json:"sequence,omitempty"`
	RequiredHeroLevel int32             `protobuf:"varint,3,opt,name=required_hero_level,json=requiredHeroLevel,proto3" json:"required_hero_level,omitempty"`
	FamilyName        string            `protobuf:"bytes,9,opt,name=family_name,json=familyName,proto3" json:"family_name,omitempty"`
	GivenName         string            `protobuf:"bytes,11,opt,name=given_name,json=givenName,proto3" json:"given_name,omitempty"`
	Name              *CaptainNameProto `protobuf:"bytes,10,opt,name=name" json:"name,omitempty"`
	IconId            string            `protobuf:"bytes,4,opt,name=icon_id,json=iconId,proto3" json:"icon_id,omitempty"`
	Male              bool              `protobuf:"varint,5,opt,name=male,proto3" json:"male,omitempty"`
	Race              Race              `protobuf:"varint,6,opt,name=race,proto3,enum=proto.Race" json:"race,omitempty"`
	Quality           Quality           `protobuf:"varint,7,opt,name=quality,proto3,enum=proto.Quality" json:"quality,omitempty"`
	Ability           int32             `protobuf:"varint,8,opt,name=ability,proto3" json:"ability,omitempty"`
}

func (m *CaptainSeekerProto) Reset()                    { *m = CaptainSeekerProto{} }
func (m *CaptainSeekerProto) String() string            { return proto.CompactTextString(m) }
func (*CaptainSeekerProto) ProtoMessage()               {}
func (*CaptainSeekerProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{11} }

func (m *CaptainSeekerProto) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *CaptainSeekerProto) GetSequence() int32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *CaptainSeekerProto) GetRequiredHeroLevel() int32 {
	if m != nil {
		return m.RequiredHeroLevel
	}
	return 0
}

func (m *CaptainSeekerProto) GetFamilyName() string {
	if m != nil {
		return m.FamilyName
	}
	return ""
}

func (m *CaptainSeekerProto) GetGivenName() string {
	if m != nil {
		return m.GivenName
	}
	return ""
}

func (m *CaptainSeekerProto) GetName() *CaptainNameProto {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *CaptainSeekerProto) GetIconId() string {
	if m != nil {
		return m.IconId
	}
	return ""
}

func (m *CaptainSeekerProto) GetMale() bool {
	if m != nil {
		return m.Male
	}
	return false
}

func (m *CaptainSeekerProto) GetRace() Race {
	if m != nil {
		return m.Race
	}
	return Race_InvalidRace
}

func (m *CaptainSeekerProto) GetQuality() Quality {
	if m != nil {
		return m.Quality
	}
	return Quality_InvalidQuality
}

func (m *CaptainSeekerProto) GetAbility() int32 {
	if m != nil {
		return m.Ability
	}
	return 0
}

type SoldierLevelProto struct {
	Level        int32      `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	Load         int32      `protobuf:"varint,2,opt,name=load,proto3" json:"load,omitempty"`
	Desc         string     `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	JunYingLevel int32      `protobuf:"varint,4,opt,name=jun_ying_level,json=junYingLevel,proto3" json:"jun_ying_level,omitempty"`
	RecruitCost  *CostProto `protobuf:"bytes,11,opt,name=recruit_cost,json=recruitCost" json:"recruit_cost,omitempty"`
	WoundedCost  *CostProto `protobuf:"bytes,12,opt,name=wounded_cost,json=woundedCost" json:"wounded_cost,omitempty"`
	// CostProto god_cost = 13; // 高价造兵消耗资源
	UpgradeCost  *CostProto         `protobuf:"bytes,14,opt,name=upgrade_cost,json=upgradeCost" json:"upgrade_cost,omitempty"`
	BaseStat     []*SpriteStatProto `protobuf:"bytes,21,rep,name=base_stat,json=baseStat" json:"base_stat,omitempty"`
	TotalStatSum int32              `protobuf:"varint,22,opt,name=total_stat_sum,json=totalStatSum,proto3" json:"total_stat_sum,omitempty"`
	Models       []int32            `protobuf:"varint,23,rep,name=models" json:"models,omitempty"`
}

func (m *SoldierLevelProto) Reset()                    { *m = SoldierLevelProto{} }
func (m *SoldierLevelProto) String() string            { return proto.CompactTextString(m) }
func (*SoldierLevelProto) ProtoMessage()               {}
func (*SoldierLevelProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{12} }

func (m *SoldierLevelProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *SoldierLevelProto) GetLoad() int32 {
	if m != nil {
		return m.Load
	}
	return 0
}

func (m *SoldierLevelProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *SoldierLevelProto) GetJunYingLevel() int32 {
	if m != nil {
		return m.JunYingLevel
	}
	return 0
}

func (m *SoldierLevelProto) GetRecruitCost() *CostProto {
	if m != nil {
		return m.RecruitCost
	}
	return nil
}

func (m *SoldierLevelProto) GetWoundedCost() *CostProto {
	if m != nil {
		return m.WoundedCost
	}
	return nil
}

func (m *SoldierLevelProto) GetUpgradeCost() *CostProto {
	if m != nil {
		return m.UpgradeCost
	}
	return nil
}

func (m *SoldierLevelProto) GetBaseStat() []*SpriteStatProto {
	if m != nil {
		return m.BaseStat
	}
	return nil
}

func (m *SoldierLevelProto) GetTotalStatSum() int32 {
	if m != nil {
		return m.TotalStatSum
	}
	return 0
}

func (m *SoldierLevelProto) GetModels() []int32 {
	if m != nil {
		return m.Models
	}
	return nil
}

// 武将官职配置
type CaptainOfficialProto struct {
	Id           int32            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	OfficialName string           `protobuf:"bytes,2,opt,name=official_name,json=officialName,proto3" json:"official_name,omitempty"`
	SpriteStat   *SpriteStatProto `protobuf:"bytes,3,opt,name=sprite_stat,json=spriteStat" json:"sprite_stat,omitempty"`
	NeedGongxun  int32            `protobuf:"varint,4,opt,name=need_gongxun,json=needGongxun,proto3" json:"need_gongxun,omitempty"`
	Icon         string           `protobuf:"bytes,5,opt,name=icon,proto3" json:"icon,omitempty"`
	Desc         string           `protobuf:"bytes,6,opt,name=desc,proto3" json:"desc,omitempty"`
}

func (m *CaptainOfficialProto) Reset()                    { *m = CaptainOfficialProto{} }
func (m *CaptainOfficialProto) String() string            { return proto.CompactTextString(m) }
func (*CaptainOfficialProto) ProtoMessage()               {}
func (*CaptainOfficialProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{13} }

func (m *CaptainOfficialProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CaptainOfficialProto) GetOfficialName() string {
	if m != nil {
		return m.OfficialName
	}
	return ""
}

func (m *CaptainOfficialProto) GetSpriteStat() *SpriteStatProto {
	if m != nil {
		return m.SpriteStat
	}
	return nil
}

func (m *CaptainOfficialProto) GetNeedGongxun() int32 {
	if m != nil {
		return m.NeedGongxun
	}
	return 0
}

func (m *CaptainOfficialProto) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *CaptainOfficialProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

// 军情
type MilitaryInfoProto struct {
	RegionId          int32  `protobuf:"varint,102,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	CombineId         []byte `protobuf:"bytes,101,opt,name=combine_id,json=combineId,proto3" json:"combine_id,omitempty"`
	Action            int32  `protobuf:"varint,2,opt,name=action,proto3" json:"action,omitempty"`
	MoveType          int32  `protobuf:"varint,3,opt,name=move_type,json=moveType,proto3" json:"move_type,omitempty"`
	CreateTime        int32  `protobuf:"varint,8,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	MoveStartRate1000 int32  `protobuf:"varint,9,opt,name=move_start_rate1000,json=moveStartRate1000,proto3" json:"move_start_rate1000,omitempty"`
	MoveStartTime     int32  `protobuf:"varint,4,opt,name=move_start_time,json=moveStartTime,proto3" json:"move_start_time,omitempty"`
	MoveArrivedTime   int32  `protobuf:"varint,5,opt,name=move_arrived_time,json=moveArrivedTime,proto3" json:"move_arrived_time,omitempty"`
	RobbingEndTime    int32  `protobuf:"varint,7,opt,name=robbing_end_time,json=robbingEndTime,proto3" json:"robbing_end_time,omitempty"`
	PriorityActionId  int32  `protobuf:"varint,6,opt,name=priority_action_id,json=priorityActionId,proto3" json:"priority_action_id,omitempty"`
	// 发起方
	SelfNpcDataId int32                   `protobuf:"varint,18,opt,name=self_npc_data_id,json=selfNpcDataId,proto3" json:"self_npc_data_id,omitempty"`
	SelfNpcType   int32                   `protobuf:"varint,19,opt,name=self_npc_type,json=selfNpcType,proto3" json:"self_npc_type,omitempty"`
	Self          *HeroBasicSnapshotProto `protobuf:"bytes,21,opt,name=self" json:"self,omitempty"`
	SelfIsTent    bool                    `protobuf:"varint,20,opt,name=self_is_tent,json=selfIsTent,proto3" json:"self_is_tent,omitempty"`
	CaptainIndex  []int32                 `protobuf:"varint,15,rep,name=captain_index,json=captainIndex" json:"captain_index,omitempty"`
	Captains      []*CaptainInfoProto     `protobuf:"bytes,16,rep,name=captains" json:"captains,omitempty"`
	// 目标
	TargetNpcDataId int32                   `protobuf:"varint,26,opt,name=target_npc_data_id,json=targetNpcDataId,proto3" json:"target_npc_data_id,omitempty"`
	TargetNpcType   int32                   `protobuf:"varint,27,opt,name=target_npc_type,json=targetNpcType,proto3" json:"target_npc_type,omitempty"`
	Target          *HeroBasicSnapshotProto `protobuf:"bytes,22,opt,name=target" json:"target,omitempty"`
	TargetBaseX     int32                   `protobuf:"varint,23,opt,name=target_base_x,json=targetBaseX,proto3" json:"target_base_x,omitempty"`
	TargetBaseY     int32                   `protobuf:"varint,24,opt,name=target_base_y,json=targetBaseY,proto3" json:"target_base_y,omitempty"`
	TargetIsTent    bool                    `protobuf:"varint,25,opt,name=target_is_tent,json=targetIsTent,proto3" json:"target_is_tent,omitempty"`
	// 援助击退
	KillEnemy []string `protobuf:"bytes,30,rep,name=kill_enemy,json=killEnemy" json:"kill_enemy,omitempty"`
	// 当行为是入侵时，下面字段有效
	// 待删除，使用PrizeProto代替 TODO
	Gold          int32       `protobuf:"varint,51,opt,name=gold,proto3" json:"gold,omitempty"`
	Food          int32       `protobuf:"varint,52,opt,name=food,proto3" json:"food,omitempty"`
	Wood          int32       `protobuf:"varint,53,opt,name=wood,proto3" json:"wood,omitempty"`
	Stone         int32       `protobuf:"varint,54,opt,name=stone,proto3" json:"stone,omitempty"`
	JadeOre       int32       `protobuf:"varint,55,opt,name=jade_ore,json=jadeOre,proto3" json:"jade_ore,omitempty"`
	AccumRobPrize *PrizeProto `protobuf:"bytes,56,opt,name=accum_rob_prize,json=accumRobPrize" json:"accum_rob_prize,omitempty"`
	// 集结信息
	AssemblyCount          int32  `protobuf:"varint,61,opt,name=assembly_count,json=assemblyCount,proto3" json:"assembly_count,omitempty"`
	AssemblyTotalCount     int32  `protobuf:"varint,62,opt,name=assembly_total_count,json=assemblyTotalCount,proto3" json:"assembly_total_count,omitempty"`
	AssemblyId             []byte `protobuf:"bytes,63,opt,name=assembly_id,json=assemblyId,proto3" json:"assembly_id,omitempty"`
	AssemblyTargetNpcType  int32  `protobuf:"varint,64,opt,name=assembly_target_npc_type,json=assemblyTargetNpcType,proto3" json:"assembly_target_npc_type,omitempty"`
	MultiLevelMonsterCount int32  `protobuf:"varint,65,opt,name=multi_level_monster_count,json=multiLevelMonsterCount,proto3" json:"multi_level_monster_count,omitempty"`
}

func (m *MilitaryInfoProto) Reset()                    { *m = MilitaryInfoProto{} }
func (m *MilitaryInfoProto) String() string            { return proto.CompactTextString(m) }
func (*MilitaryInfoProto) ProtoMessage()               {}
func (*MilitaryInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{14} }

func (m *MilitaryInfoProto) GetRegionId() int32 {
	if m != nil {
		return m.RegionId
	}
	return 0
}

func (m *MilitaryInfoProto) GetCombineId() []byte {
	if m != nil {
		return m.CombineId
	}
	return nil
}

func (m *MilitaryInfoProto) GetAction() int32 {
	if m != nil {
		return m.Action
	}
	return 0
}

func (m *MilitaryInfoProto) GetMoveType() int32 {
	if m != nil {
		return m.MoveType
	}
	return 0
}

func (m *MilitaryInfoProto) GetCreateTime() int32 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *MilitaryInfoProto) GetMoveStartRate1000() int32 {
	if m != nil {
		return m.MoveStartRate1000
	}
	return 0
}

func (m *MilitaryInfoProto) GetMoveStartTime() int32 {
	if m != nil {
		return m.MoveStartTime
	}
	return 0
}

func (m *MilitaryInfoProto) GetMoveArrivedTime() int32 {
	if m != nil {
		return m.MoveArrivedTime
	}
	return 0
}

func (m *MilitaryInfoProto) GetRobbingEndTime() int32 {
	if m != nil {
		return m.RobbingEndTime
	}
	return 0
}

func (m *MilitaryInfoProto) GetPriorityActionId() int32 {
	if m != nil {
		return m.PriorityActionId
	}
	return 0
}

func (m *MilitaryInfoProto) GetSelfNpcDataId() int32 {
	if m != nil {
		return m.SelfNpcDataId
	}
	return 0
}

func (m *MilitaryInfoProto) GetSelfNpcType() int32 {
	if m != nil {
		return m.SelfNpcType
	}
	return 0
}

func (m *MilitaryInfoProto) GetSelf() *HeroBasicSnapshotProto {
	if m != nil {
		return m.Self
	}
	return nil
}

func (m *MilitaryInfoProto) GetSelfIsTent() bool {
	if m != nil {
		return m.SelfIsTent
	}
	return false
}

func (m *MilitaryInfoProto) GetCaptainIndex() []int32 {
	if m != nil {
		return m.CaptainIndex
	}
	return nil
}

func (m *MilitaryInfoProto) GetCaptains() []*CaptainInfoProto {
	if m != nil {
		return m.Captains
	}
	return nil
}

func (m *MilitaryInfoProto) GetTargetNpcDataId() int32 {
	if m != nil {
		return m.TargetNpcDataId
	}
	return 0
}

func (m *MilitaryInfoProto) GetTargetNpcType() int32 {
	if m != nil {
		return m.TargetNpcType
	}
	return 0
}

func (m *MilitaryInfoProto) GetTarget() *HeroBasicSnapshotProto {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *MilitaryInfoProto) GetTargetBaseX() int32 {
	if m != nil {
		return m.TargetBaseX
	}
	return 0
}

func (m *MilitaryInfoProto) GetTargetBaseY() int32 {
	if m != nil {
		return m.TargetBaseY
	}
	return 0
}

func (m *MilitaryInfoProto) GetTargetIsTent() bool {
	if m != nil {
		return m.TargetIsTent
	}
	return false
}

func (m *MilitaryInfoProto) GetKillEnemy() []string {
	if m != nil {
		return m.KillEnemy
	}
	return nil
}

func (m *MilitaryInfoProto) GetGold() int32 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *MilitaryInfoProto) GetFood() int32 {
	if m != nil {
		return m.Food
	}
	return 0
}

func (m *MilitaryInfoProto) GetWood() int32 {
	if m != nil {
		return m.Wood
	}
	return 0
}

func (m *MilitaryInfoProto) GetStone() int32 {
	if m != nil {
		return m.Stone
	}
	return 0
}

func (m *MilitaryInfoProto) GetJadeOre() int32 {
	if m != nil {
		return m.JadeOre
	}
	return 0
}

func (m *MilitaryInfoProto) GetAccumRobPrize() *PrizeProto {
	if m != nil {
		return m.AccumRobPrize
	}
	return nil
}

func (m *MilitaryInfoProto) GetAssemblyCount() int32 {
	if m != nil {
		return m.AssemblyCount
	}
	return 0
}

func (m *MilitaryInfoProto) GetAssemblyTotalCount() int32 {
	if m != nil {
		return m.AssemblyTotalCount
	}
	return 0
}

func (m *MilitaryInfoProto) GetAssemblyId() []byte {
	if m != nil {
		return m.AssemblyId
	}
	return nil
}

func (m *MilitaryInfoProto) GetAssemblyTargetNpcType() int32 {
	if m != nil {
		return m.AssemblyTargetNpcType
	}
	return 0
}

func (m *MilitaryInfoProto) GetMultiLevelMonsterCount() int32 {
	if m != nil {
		return m.MultiLevelMonsterCount
	}
	return 0
}

type AssemblyInfoProto struct {
	// 集结状态，直接使用State，1-集结出征 3-集结返回 4-等待集结状态 5-集结持续掠夺
	// 0-集结出征
	//   MoveStartTime() time.Time 出征开始时间
	//   MoveArriveTime() time.Time 出征到达时间
	//
	// 1-集结持续掠夺
	//   RobbingEndTime() time.Time 集结持续掠夺结束时间
	//
	// 2-集结返回
	//   MoveStartTime() time.Time 返回开始时间
	//   MoveArriveTime() time.Time 返回到达时间
	//
	// 3-等待集结状态
	//   MoveStartTime() time.Time 集结出发时间
	//
	MoveType        int32 `protobuf:"varint,3,opt,name=move_type,json=moveType,proto3" json:"move_type,omitempty"`
	MoveStartTime   int32 `protobuf:"varint,4,opt,name=move_start_time,json=moveStartTime,proto3" json:"move_start_time,omitempty"`
	MoveArrivedTime int32 `protobuf:"varint,5,opt,name=move_arrived_time,json=moveArrivedTime,proto3" json:"move_arrived_time,omitempty"`
	RobbingEndTime  int32 `protobuf:"varint,6,opt,name=robbing_end_time,json=robbingEndTime,proto3" json:"robbing_end_time,omitempty"`
	// 集结发起者
	Self            *HeroBasicSnapshotProto `protobuf:"bytes,11,opt,name=self" json:"self,omitempty"`
	SelfFightAmount int32                   `protobuf:"varint,12,opt,name=self_fight_amount,json=selfFightAmount,proto3" json:"self_fight_amount,omitempty"`
	// 集结目标
	TargetNpcDataId  int32                   `protobuf:"varint,26,opt,name=target_npc_data_id,json=targetNpcDataId,proto3" json:"target_npc_data_id,omitempty"`
	TargetNpcType    int32                   `protobuf:"varint,27,opt,name=target_npc_type,json=targetNpcType,proto3" json:"target_npc_type,omitempty"`
	Target           *HeroBasicSnapshotProto `protobuf:"bytes,22,opt,name=target" json:"target,omitempty"`
	TargetBaseX      int32                   `protobuf:"varint,23,opt,name=target_base_x,json=targetBaseX,proto3" json:"target_base_x,omitempty"`
	TargetBaseY      int32                   `protobuf:"varint,24,opt,name=target_base_y,json=targetBaseY,proto3" json:"target_base_y,omitempty"`
	TargetMorale     int32                   `protobuf:"varint,25,opt,name=target_morale,json=targetMorale,proto3" json:"target_morale,omitempty"`
	TargetTroop      int32                   `protobuf:"varint,28,opt,name=target_troop,json=targetTroop,proto3" json:"target_troop,omitempty"`
	TargetTotalTroop int32                   `protobuf:"varint,29,opt,name=target_total_troop,json=targetTotalTroop,proto3" json:"target_total_troop,omitempty"`
	// 集结成员
	Member     []*AssemblyMemberProto `protobuf:"bytes,30,rep,name=member" json:"member,omitempty"`
	TotalCount int32                  `protobuf:"varint,31,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	AddedStat  *SpriteStatProto       `protobuf:"bytes,32,opt,name=added_stat,json=addedStat" json:"added_stat,omitempty"`
}

func (m *AssemblyInfoProto) Reset()                    { *m = AssemblyInfoProto{} }
func (m *AssemblyInfoProto) String() string            { return proto.CompactTextString(m) }
func (*AssemblyInfoProto) ProtoMessage()               {}
func (*AssemblyInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{15} }

func (m *AssemblyInfoProto) GetMoveType() int32 {
	if m != nil {
		return m.MoveType
	}
	return 0
}

func (m *AssemblyInfoProto) GetMoveStartTime() int32 {
	if m != nil {
		return m.MoveStartTime
	}
	return 0
}

func (m *AssemblyInfoProto) GetMoveArrivedTime() int32 {
	if m != nil {
		return m.MoveArrivedTime
	}
	return 0
}

func (m *AssemblyInfoProto) GetRobbingEndTime() int32 {
	if m != nil {
		return m.RobbingEndTime
	}
	return 0
}

func (m *AssemblyInfoProto) GetSelf() *HeroBasicSnapshotProto {
	if m != nil {
		return m.Self
	}
	return nil
}

func (m *AssemblyInfoProto) GetSelfFightAmount() int32 {
	if m != nil {
		return m.SelfFightAmount
	}
	return 0
}

func (m *AssemblyInfoProto) GetTargetNpcDataId() int32 {
	if m != nil {
		return m.TargetNpcDataId
	}
	return 0
}

func (m *AssemblyInfoProto) GetTargetNpcType() int32 {
	if m != nil {
		return m.TargetNpcType
	}
	return 0
}

func (m *AssemblyInfoProto) GetTarget() *HeroBasicSnapshotProto {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *AssemblyInfoProto) GetTargetBaseX() int32 {
	if m != nil {
		return m.TargetBaseX
	}
	return 0
}

func (m *AssemblyInfoProto) GetTargetBaseY() int32 {
	if m != nil {
		return m.TargetBaseY
	}
	return 0
}

func (m *AssemblyInfoProto) GetTargetMorale() int32 {
	if m != nil {
		return m.TargetMorale
	}
	return 0
}

func (m *AssemblyInfoProto) GetTargetTroop() int32 {
	if m != nil {
		return m.TargetTroop
	}
	return 0
}

func (m *AssemblyInfoProto) GetTargetTotalTroop() int32 {
	if m != nil {
		return m.TargetTotalTroop
	}
	return 0
}

func (m *AssemblyInfoProto) GetMember() []*AssemblyMemberProto {
	if m != nil {
		return m.Member
	}
	return nil
}

func (m *AssemblyInfoProto) GetTotalCount() int32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *AssemblyInfoProto) GetAddedStat() *SpriteStatProto {
	if m != nil {
		return m.AddedStat
	}
	return nil
}

// 集结成员
type AssemblyMemberProto struct {
	TroopId         []byte                  `protobuf:"bytes,5,opt,name=troop_id,json=troopId,proto3" json:"troop_id,omitempty"`
	Hero            *HeroBasicSnapshotProto `protobuf:"bytes,1,opt,name=hero" json:"hero,omitempty"`
	FightAmount     int32                   `protobuf:"varint,2,opt,name=fight_amount,json=fightAmount,proto3" json:"fight_amount,omitempty"`
	MoveStartTime   int32                   `protobuf:"varint,3,opt,name=move_start_time,json=moveStartTime,proto3" json:"move_start_time,omitempty"`
	MoveArrivedTime int32                   `protobuf:"varint,4,opt,name=move_arrived_time,json=moveArrivedTime,proto3" json:"move_arrived_time,omitempty"`
}

func (m *AssemblyMemberProto) Reset()                    { *m = AssemblyMemberProto{} }
func (m *AssemblyMemberProto) String() string            { return proto.CompactTextString(m) }
func (*AssemblyMemberProto) ProtoMessage()               {}
func (*AssemblyMemberProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{16} }

func (m *AssemblyMemberProto) GetTroopId() []byte {
	if m != nil {
		return m.TroopId
	}
	return nil
}

func (m *AssemblyMemberProto) GetHero() *HeroBasicSnapshotProto {
	if m != nil {
		return m.Hero
	}
	return nil
}

func (m *AssemblyMemberProto) GetFightAmount() int32 {
	if m != nil {
		return m.FightAmount
	}
	return 0
}

func (m *AssemblyMemberProto) GetMoveStartTime() int32 {
	if m != nil {
		return m.MoveStartTime
	}
	return 0
}

func (m *AssemblyMemberProto) GetMoveArrivedTime() int32 {
	if m != nil {
		return m.MoveArrivedTime
	}
	return 0
}

// 基地驻守部队
type BaseDefenserProto struct {
	CaptainIndex []int32             `protobuf:"varint,15,rep,name=captain_index,json=captainIndex" json:"captain_index,omitempty"`
	Captains     []*CaptainInfoProto `protobuf:"bytes,16,rep,name=captains" json:"captains,omitempty"`
}

func (m *BaseDefenserProto) Reset()                    { *m = BaseDefenserProto{} }
func (m *BaseDefenserProto) String() string            { return proto.CompactTextString(m) }
func (*BaseDefenserProto) ProtoMessage()               {}
func (*BaseDefenserProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{17} }

func (m *BaseDefenserProto) GetCaptainIndex() []int32 {
	if m != nil {
		return m.CaptainIndex
	}
	return nil
}

func (m *BaseDefenserProto) GetCaptains() []*CaptainInfoProto {
	if m != nil {
		return m.Captains
	}
	return nil
}

type CaptainInfoProto struct {
	Id                       int32             `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                     *CaptainNameProto `protobuf:"bytes,14,opt,name=name" json:"name,omitempty"`
	IconId                   string            `protobuf:"bytes,20,opt,name=icon_id,json=iconId,proto3" json:"icon_id,omitempty"`
	Male                     bool              `protobuf:"varint,12,opt,name=male,proto3" json:"male,omitempty"`
	Race                     Race              `protobuf:"varint,4,opt,name=race,proto3,enum=proto.Race" json:"race,omitempty"`
	Quality                  Quality           `protobuf:"varint,5,opt,name=quality,proto3,enum=proto.Quality" json:"quality,omitempty"`
	Soldier                  int32             `protobuf:"varint,6,opt,name=soldier,proto3" json:"soldier,omitempty"`
	TotalSoldier             int32             `protobuf:"varint,7,opt,name=total_soldier,json=totalSoldier,proto3" json:"total_soldier,omitempty"`
	FightAmount              int32             `protobuf:"varint,8,opt,name=fight_amount,json=fightAmount,proto3" json:"fight_amount,omitempty"`
	FullFightAmount          int32             `protobuf:"varint,35,opt,name=full_fight_amount,json=fullFightAmount,proto3" json:"full_fight_amount,omitempty"`
	SpellFightAmountCoef     int32             `protobuf:"varint,41,opt,name=spell_fight_amount_coef,json=spellFightAmountCoef,proto3" json:"spell_fight_amount_coef,omitempty"`
	Morale                   int32             `protobuf:"varint,9,opt,name=morale,proto3" json:"morale,omitempty"`
	Level                    int32             `protobuf:"varint,10,opt,name=level,proto3" json:"level,omitempty"`
	SoldierLevel             int32             `protobuf:"varint,11,opt,name=soldier_level,json=soldierLevel,proto3" json:"soldier_level,omitempty"`
	CanTriggerRestraintSpell bool              `protobuf:"varint,13,opt,name=can_trigger_restraint_spell,json=canTriggerRestraintSpell,proto3" json:"can_trigger_restraint_spell,omitempty"`
	Outside                  bool              `protobuf:"varint,21,opt,name=outside,proto3" json:"outside,omitempty"`
	TotalStat                *SpriteStatProto  `protobuf:"bytes,22,opt,name=total_stat,json=totalStat" json:"total_stat,omitempty"`
	LifePerSoldier           int32             `protobuf:"varint,23,opt,name=life_per_soldier,json=lifePerSoldier,proto3" json:"life_per_soldier,omitempty"`
	LoadPerSoldier           int32             `protobuf:"varint,24,opt,name=load_per_soldier,json=loadPerSoldier,proto3" json:"load_per_soldier,omitempty"`
	Model                    int32             `protobuf:"varint,25,opt,name=model,proto3" json:"model,omitempty"`
	CaptainSoul              int32             `protobuf:"varint,31,opt,name=captain_soul,json=captainSoul,proto3" json:"captain_soul,omitempty"`
	CaptainSoulLevel         int32             `protobuf:"varint,32,opt,name=captain_soul_level,json=captainSoulLevel,proto3" json:"captain_soul_level,omitempty"`
	RebirthLevel             int32             `protobuf:"varint,33,opt,name=rebirth_level,json=rebirthLevel,proto3" json:"rebirth_level,omitempty"`
	YuanJun                  bool              `protobuf:"varint,34,opt,name=yuan_jun,json=yuanJun,proto3" json:"yuan_jun,omitempty"`
	XIndex                   int32             `protobuf:"varint,36,opt,name=x_index,json=xIndex,proto3" json:"x_index,omitempty"`
	CaptainId                int32             `protobuf:"varint,37,opt,name=captain_id,json=captainId,proto3" json:"captain_id,omitempty"`
	IsNameless               bool              `protobuf:"varint,38,opt,name=is_nameless,json=isNameless,proto3" json:"is_nameless,omitempty"`
	Star                     int32             `protobuf:"varint,39,opt,name=star,proto3" json:"star,omitempty"`
	UnlockSpellCount         int32             `protobuf:"varint,40,opt,name=unlock_spell_count,json=unlockSpellCount,proto3" json:"unlock_spell_count,omitempty"`
}

func (m *CaptainInfoProto) Reset()                    { *m = CaptainInfoProto{} }
func (m *CaptainInfoProto) String() string            { return proto.CompactTextString(m) }
func (*CaptainInfoProto) ProtoMessage()               {}
func (*CaptainInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{18} }

func (m *CaptainInfoProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CaptainInfoProto) GetName() *CaptainNameProto {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *CaptainInfoProto) GetIconId() string {
	if m != nil {
		return m.IconId
	}
	return ""
}

func (m *CaptainInfoProto) GetMale() bool {
	if m != nil {
		return m.Male
	}
	return false
}

func (m *CaptainInfoProto) GetRace() Race {
	if m != nil {
		return m.Race
	}
	return Race_InvalidRace
}

func (m *CaptainInfoProto) GetQuality() Quality {
	if m != nil {
		return m.Quality
	}
	return Quality_InvalidQuality
}

func (m *CaptainInfoProto) GetSoldier() int32 {
	if m != nil {
		return m.Soldier
	}
	return 0
}

func (m *CaptainInfoProto) GetTotalSoldier() int32 {
	if m != nil {
		return m.TotalSoldier
	}
	return 0
}

func (m *CaptainInfoProto) GetFightAmount() int32 {
	if m != nil {
		return m.FightAmount
	}
	return 0
}

func (m *CaptainInfoProto) GetFullFightAmount() int32 {
	if m != nil {
		return m.FullFightAmount
	}
	return 0
}

func (m *CaptainInfoProto) GetSpellFightAmountCoef() int32 {
	if m != nil {
		return m.SpellFightAmountCoef
	}
	return 0
}

func (m *CaptainInfoProto) GetMorale() int32 {
	if m != nil {
		return m.Morale
	}
	return 0
}

func (m *CaptainInfoProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *CaptainInfoProto) GetSoldierLevel() int32 {
	if m != nil {
		return m.SoldierLevel
	}
	return 0
}

func (m *CaptainInfoProto) GetCanTriggerRestraintSpell() bool {
	if m != nil {
		return m.CanTriggerRestraintSpell
	}
	return false
}

func (m *CaptainInfoProto) GetOutside() bool {
	if m != nil {
		return m.Outside
	}
	return false
}

func (m *CaptainInfoProto) GetTotalStat() *SpriteStatProto {
	if m != nil {
		return m.TotalStat
	}
	return nil
}

func (m *CaptainInfoProto) GetLifePerSoldier() int32 {
	if m != nil {
		return m.LifePerSoldier
	}
	return 0
}

func (m *CaptainInfoProto) GetLoadPerSoldier() int32 {
	if m != nil {
		return m.LoadPerSoldier
	}
	return 0
}

func (m *CaptainInfoProto) GetModel() int32 {
	if m != nil {
		return m.Model
	}
	return 0
}

func (m *CaptainInfoProto) GetCaptainSoul() int32 {
	if m != nil {
		return m.CaptainSoul
	}
	return 0
}

func (m *CaptainInfoProto) GetCaptainSoulLevel() int32 {
	if m != nil {
		return m.CaptainSoulLevel
	}
	return 0
}

func (m *CaptainInfoProto) GetRebirthLevel() int32 {
	if m != nil {
		return m.RebirthLevel
	}
	return 0
}

func (m *CaptainInfoProto) GetYuanJun() bool {
	if m != nil {
		return m.YuanJun
	}
	return false
}

func (m *CaptainInfoProto) GetXIndex() int32 {
	if m != nil {
		return m.XIndex
	}
	return 0
}

func (m *CaptainInfoProto) GetCaptainId() int32 {
	if m != nil {
		return m.CaptainId
	}
	return 0
}

func (m *CaptainInfoProto) GetIsNameless() bool {
	if m != nil {
		return m.IsNameless
	}
	return false
}

func (m *CaptainInfoProto) GetStar() int32 {
	if m != nil {
		return m.Star
	}
	return 0
}

func (m *CaptainInfoProto) GetUnlockSpellCount() int32 {
	if m != nil {
		return m.UnlockSpellCount
	}
	return 0
}

type HeroMilitaryProto struct {
	CaptainFriendship            []int32                     `protobuf:"varint,5,rep,name=captain_friendship,json=captainFriendship" json:"captain_friendship,omitempty"`
	Captain                      []*CaptainProto             `protobuf:"bytes,11,rep,name=captain" json:"captain,omitempty"`
	Captains                     []*HeroCaptainProto         `protobuf:"bytes,1,rep,name=captains" json:"captains,omitempty"`
	OfficialCount                []*HeroCaptainOfficialCount `protobuf:"bytes,4,rep,name=official_count,json=officialCount" json:"official_count,omitempty"`
	OfficialView                 []*Int32PairInt32ArrayProto `protobuf:"bytes,9,rep,name=official_view,json=officialView" json:"official_view,omitempty"`
	Troops                       []*HeroTroopProto           `protobuf:"bytes,6,rep,name=troops" json:"troops,omitempty"`
	InvestigateTroop             *HeroTroopProto             `protobuf:"bytes,61,opt,name=investigate_troop,json=investigateTroop" json:"investigate_troop,omitempty"`
	PveTroop                     []*HeroPveTroopProto        `protobuf:"bytes,8,rep,name=pve_troop,json=pveTroop" json:"pve_troop,omitempty"`
	PveTroops                    []*HeroPveTroopProto        `protobuf:"bytes,7,rep,name=pve_troops,json=pveTroops" json:"pve_troops,omitempty"`
	SoldierLevel                 int32                       `protobuf:"varint,30,opt,name=soldier_level,json=soldierLevel,proto3" json:"soldier_level,omitempty"`
	SoldierCapcity               int32                       `protobuf:"varint,31,opt,name=soldier_capcity,json=soldierCapcity,proto3" json:"soldier_capcity,omitempty"`
	FreeSoldier                  int32                       `protobuf:"varint,32,opt,name=free_soldier,json=freeSoldier,proto3" json:"free_soldier,omitempty"`
	WoundedSoldier               int32                       `protobuf:"varint,33,opt,name=wounded_soldier,json=woundedSoldier,proto3" json:"wounded_soldier,omitempty"`
	WoundedSoldierCapcity        int32                       `protobuf:"varint,34,opt,name=wounded_soldier_capcity,json=woundedSoldierCapcity,proto3" json:"wounded_soldier_capcity,omitempty"`
	FreeSoldierStartRecoveryTime int32                       `protobuf:"varint,56,opt,name=free_soldier_start_recovery_time,json=freeSoldierStartRecoveryTime,proto3" json:"free_soldier_start_recovery_time,omitempty"`
	FreeSoldierCapcity           int32                       `protobuf:"varint,57,opt,name=free_soldier_capcity,json=freeSoldierCapcity,proto3" json:"free_soldier_capcity,omitempty"`
	FreeSoldierOutput            int32                       `protobuf:"varint,58,opt,name=free_soldier_output,json=freeSoldierOutput,proto3" json:"free_soldier_output,omitempty"`
	OverflowFreeSoldier          int32                       `protobuf:"varint,59,opt,name=overflow_free_soldier,json=overflowFreeSoldier,proto3" json:"overflow_free_soldier,omitempty"`
	ForceAddSoldierTimes         int32                       `protobuf:"varint,60,opt,name=force_add_soldier_times,json=forceAddSoldierTimes,proto3" json:"force_add_soldier_times,omitempty"`
	NewSoldier                   int32                       `protobuf:"varint,35,opt,name=new_soldier,json=newSoldier,proto3" json:"new_soldier,omitempty"`
	NewSoldierCapcity            int32                       `protobuf:"varint,36,opt,name=new_soldier_capcity,json=newSoldierCapcity,proto3" json:"new_soldier_capcity,omitempty"`
	NewSoldierOutput             int32                       `protobuf:"varint,37,opt,name=new_soldier_output,json=newSoldierOutput,proto3" json:"new_soldier_output,omitempty"`
	NewSoldierRecruitCount       int32                       `protobuf:"varint,38,opt,name=new_soldier_recruit_count,json=newSoldierRecruitCount,proto3" json:"new_soldier_recruit_count,omitempty"`
	// 计算酒馆请教次数
	// 当前时间 ctime，次数 = min((ctime - jiu_guan_start_recovey_time) / JiuGuanMiscDataProto.recovery_duration, JiuGuanMiscDataProto.max_times)
	// 剩余恢复时间：
	// if 次数 >= JiuGuanMiscDataProto.max_times 显示已满，不需要恢复时间了
	// else 剩余恢复时间 = （次数+1）* JiuGuanMiscDataProto.recovery_duration + jiu_guan_start_recovey_time - ctime
	//    int32 jiu_guan_start_recovey_time = 45; // 酒馆恢复时间
	JiuGuanRefreshTimes int32 `protobuf:"varint,46,opt,name=jiu_guan_refresh_times,json=jiuGuanRefreshTimes,proto3" json:"jiu_guan_refresh_times,omitempty"`
	JiuGuanTutorIndex   int32 `protobuf:"varint,47,opt,name=jiu_guan_tutor_index,json=jiuGuanTutorIndex,proto3" json:"jiu_guan_tutor_index,omitempty"`
	JiuGuanTimes        int32 `protobuf:"varint,48,opt,name=jiu_guan_times,json=jiuGuanTimes,proto3" json:"jiu_guan_times,omitempty"`
	JiuGuanNextTime     int32 `protobuf:"varint,49,opt,name=jiu_guan_next_time,json=jiuGuanNextTime,proto3" json:"jiu_guan_next_time,omitempty"`
	// JunYingLevelDataProto 通过军营等级去取 BuildingType = JUN_YING
	// 当前时间 ctime，次数 = min((ctime - start_recovey_time) / JunYingLevelDataProto.recovery_duration, JunYingLevelDataProto.max_times)
	// 剩余恢复时间：
	// if 次数 >= JunYingLevelDataProto.max_times 显示已满，不需要恢复时间了
	// else 剩余恢复时间 = （次数+1）* JunYingLevelDataProto.recovery_duration + start_recovey_time - ctime
	JunYingRecruitStartRecoveyTime int32 `protobuf:"varint,50,opt,name=jun_ying_recruit_start_recovey_time,json=junYingRecruitStartRecoveyTime,proto3" json:"jun_ying_recruit_start_recovey_time,omitempty"`
	NextExpelTime                  int32 `protobuf:"varint,51,opt,name=next_expel_time,json=nextExpelTime,proto3" json:"next_expel_time,omitempty"`
	GlobalTrainStartTime           int32 `protobuf:"varint,53,opt,name=global_train_start_time,json=globalTrainStartTime,proto3" json:"global_train_start_time,omitempty"`
	CaptainTrainStartTime          int32 `protobuf:"varint,54,opt,name=captain_train_start_time,json=captainTrainStartTime,proto3" json:"captain_train_start_time,omitempty"`
	TrainCoef                      int32 `protobuf:"varint,55,opt,name=train_coef,json=trainCoef,proto3" json:"train_coef,omitempty"`
}

func (m *HeroMilitaryProto) Reset()                    { *m = HeroMilitaryProto{} }
func (m *HeroMilitaryProto) String() string            { return proto.CompactTextString(m) }
func (*HeroMilitaryProto) ProtoMessage()               {}
func (*HeroMilitaryProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{19} }

func (m *HeroMilitaryProto) GetCaptainFriendship() []int32 {
	if m != nil {
		return m.CaptainFriendship
	}
	return nil
}

func (m *HeroMilitaryProto) GetCaptain() []*CaptainProto {
	if m != nil {
		return m.Captain
	}
	return nil
}

func (m *HeroMilitaryProto) GetCaptains() []*HeroCaptainProto {
	if m != nil {
		return m.Captains
	}
	return nil
}

func (m *HeroMilitaryProto) GetOfficialCount() []*HeroCaptainOfficialCount {
	if m != nil {
		return m.OfficialCount
	}
	return nil
}

func (m *HeroMilitaryProto) GetOfficialView() []*Int32PairInt32ArrayProto {
	if m != nil {
		return m.OfficialView
	}
	return nil
}

func (m *HeroMilitaryProto) GetTroops() []*HeroTroopProto {
	if m != nil {
		return m.Troops
	}
	return nil
}

func (m *HeroMilitaryProto) GetInvestigateTroop() *HeroTroopProto {
	if m != nil {
		return m.InvestigateTroop
	}
	return nil
}

func (m *HeroMilitaryProto) GetPveTroop() []*HeroPveTroopProto {
	if m != nil {
		return m.PveTroop
	}
	return nil
}

func (m *HeroMilitaryProto) GetPveTroops() []*HeroPveTroopProto {
	if m != nil {
		return m.PveTroops
	}
	return nil
}

func (m *HeroMilitaryProto) GetSoldierLevel() int32 {
	if m != nil {
		return m.SoldierLevel
	}
	return 0
}

func (m *HeroMilitaryProto) GetSoldierCapcity() int32 {
	if m != nil {
		return m.SoldierCapcity
	}
	return 0
}

func (m *HeroMilitaryProto) GetFreeSoldier() int32 {
	if m != nil {
		return m.FreeSoldier
	}
	return 0
}

func (m *HeroMilitaryProto) GetWoundedSoldier() int32 {
	if m != nil {
		return m.WoundedSoldier
	}
	return 0
}

func (m *HeroMilitaryProto) GetWoundedSoldierCapcity() int32 {
	if m != nil {
		return m.WoundedSoldierCapcity
	}
	return 0
}

func (m *HeroMilitaryProto) GetFreeSoldierStartRecoveryTime() int32 {
	if m != nil {
		return m.FreeSoldierStartRecoveryTime
	}
	return 0
}

func (m *HeroMilitaryProto) GetFreeSoldierCapcity() int32 {
	if m != nil {
		return m.FreeSoldierCapcity
	}
	return 0
}

func (m *HeroMilitaryProto) GetFreeSoldierOutput() int32 {
	if m != nil {
		return m.FreeSoldierOutput
	}
	return 0
}

func (m *HeroMilitaryProto) GetOverflowFreeSoldier() int32 {
	if m != nil {
		return m.OverflowFreeSoldier
	}
	return 0
}

func (m *HeroMilitaryProto) GetForceAddSoldierTimes() int32 {
	if m != nil {
		return m.ForceAddSoldierTimes
	}
	return 0
}

func (m *HeroMilitaryProto) GetNewSoldier() int32 {
	if m != nil {
		return m.NewSoldier
	}
	return 0
}

func (m *HeroMilitaryProto) GetNewSoldierCapcity() int32 {
	if m != nil {
		return m.NewSoldierCapcity
	}
	return 0
}

func (m *HeroMilitaryProto) GetNewSoldierOutput() int32 {
	if m != nil {
		return m.NewSoldierOutput
	}
	return 0
}

func (m *HeroMilitaryProto) GetNewSoldierRecruitCount() int32 {
	if m != nil {
		return m.NewSoldierRecruitCount
	}
	return 0
}

func (m *HeroMilitaryProto) GetJiuGuanRefreshTimes() int32 {
	if m != nil {
		return m.JiuGuanRefreshTimes
	}
	return 0
}

func (m *HeroMilitaryProto) GetJiuGuanTutorIndex() int32 {
	if m != nil {
		return m.JiuGuanTutorIndex
	}
	return 0
}

func (m *HeroMilitaryProto) GetJiuGuanTimes() int32 {
	if m != nil {
		return m.JiuGuanTimes
	}
	return 0
}

func (m *HeroMilitaryProto) GetJiuGuanNextTime() int32 {
	if m != nil {
		return m.JiuGuanNextTime
	}
	return 0
}

func (m *HeroMilitaryProto) GetJunYingRecruitStartRecoveyTime() int32 {
	if m != nil {
		return m.JunYingRecruitStartRecoveyTime
	}
	return 0
}

func (m *HeroMilitaryProto) GetNextExpelTime() int32 {
	if m != nil {
		return m.NextExpelTime
	}
	return 0
}

func (m *HeroMilitaryProto) GetGlobalTrainStartTime() int32 {
	if m != nil {
		return m.GlobalTrainStartTime
	}
	return 0
}

func (m *HeroMilitaryProto) GetCaptainTrainStartTime() int32 {
	if m != nil {
		return m.CaptainTrainStartTime
	}
	return 0
}

func (m *HeroMilitaryProto) GetTrainCoef() int32 {
	if m != nil {
		return m.TrainCoef
	}
	return 0
}

// 官职册封计数器
type HeroCaptainOfficialCount struct {
	OfficialId int32 `protobuf:"varint,1,opt,name=official_id,json=officialId,proto3" json:"official_id,omitempty"`
	Count      int32 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *HeroCaptainOfficialCount) Reset()         { *m = HeroCaptainOfficialCount{} }
func (m *HeroCaptainOfficialCount) String() string { return proto.CompactTextString(m) }
func (*HeroCaptainOfficialCount) ProtoMessage()    {}
func (*HeroCaptainOfficialCount) Descriptor() ([]byte, []int) {
	return fileDescriptorMilitary, []int{20}
}

func (m *HeroCaptainOfficialCount) GetOfficialId() int32 {
	if m != nil {
		return m.OfficialId
	}
	return 0
}

func (m *HeroCaptainOfficialCount) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type PveTroopDataProto struct {
	PveTroopType    PveTroopType `protobuf:"varint,1,opt,name=pve_troop_type,json=pveTroopType,proto3,enum=proto.PveTroopType" json:"pve_troop_type,omitempty"`
	Capacity        int32        `protobuf:"varint,2,opt,name=capacity,proto3" json:"capacity,omitempty"`
	MinCaptainCount int32        `protobuf:"varint,3,opt,name=min_captain_count,json=minCaptainCount,proto3" json:"min_captain_count,omitempty"`
}

func (m *PveTroopDataProto) Reset()                    { *m = PveTroopDataProto{} }
func (m *PveTroopDataProto) String() string            { return proto.CompactTextString(m) }
func (*PveTroopDataProto) ProtoMessage()               {}
func (*PveTroopDataProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{21} }

func (m *PveTroopDataProto) GetPveTroopType() PveTroopType {
	if m != nil {
		return m.PveTroopType
	}
	return PveTroopType_InvalidPveTroopType
}

func (m *PveTroopDataProto) GetCapacity() int32 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *PveTroopDataProto) GetMinCaptainCount() int32 {
	if m != nil {
		return m.MinCaptainCount
	}
	return 0
}

type HeroTroopProto struct {
	Sequence  int32   `protobuf:"varint,1,opt,name=sequence,proto3" json:"sequence,omitempty"`
	Captains  []int32 `protobuf:"varint,2,rep,name=captains" json:"captains,omitempty"`
	Captains2 []int32 `protobuf:"varint,4,rep,name=captains2" json:"captains2,omitempty"`
	XIndex    []int32 `protobuf:"varint,5,rep,name=x_index,json=xIndex" json:"x_index,omitempty"`
	IsOutside bool    `protobuf:"varint,3,opt,name=is_outside,json=isOutside,proto3" json:"is_outside,omitempty"`
}

func (m *HeroTroopProto) Reset()                    { *m = HeroTroopProto{} }
func (m *HeroTroopProto) String() string            { return proto.CompactTextString(m) }
func (*HeroTroopProto) ProtoMessage()               {}
func (*HeroTroopProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{22} }

func (m *HeroTroopProto) GetSequence() int32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *HeroTroopProto) GetCaptains() []int32 {
	if m != nil {
		return m.Captains
	}
	return nil
}

func (m *HeroTroopProto) GetCaptains2() []int32 {
	if m != nil {
		return m.Captains2
	}
	return nil
}

func (m *HeroTroopProto) GetXIndex() []int32 {
	if m != nil {
		return m.XIndex
	}
	return nil
}

func (m *HeroTroopProto) GetIsOutside() bool {
	if m != nil {
		return m.IsOutside
	}
	return false
}

type HeroPveTroopProto struct {
	Type      PveTroopType `protobuf:"varint,1,opt,name=type,proto3,enum=proto.PveTroopType" json:"type,omitempty"`
	Captains  []int32      `protobuf:"varint,2,rep,name=captains" json:"captains,omitempty"`
	Captains2 []int32      `protobuf:"varint,4,rep,name=captains2" json:"captains2,omitempty"`
	XIndex    []int32      `protobuf:"varint,5,rep,name=x_index,json=xIndex" json:"x_index,omitempty"`
}

func (m *HeroPveTroopProto) Reset()                    { *m = HeroPveTroopProto{} }
func (m *HeroPveTroopProto) String() string            { return proto.CompactTextString(m) }
func (*HeroPveTroopProto) ProtoMessage()               {}
func (*HeroPveTroopProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{23} }

func (m *HeroPveTroopProto) GetType() PveTroopType {
	if m != nil {
		return m.Type
	}
	return PveTroopType_InvalidPveTroopType
}

func (m *HeroPveTroopProto) GetCaptains() []int32 {
	if m != nil {
		return m.Captains
	}
	return nil
}

func (m *HeroPveTroopProto) GetCaptains2() []int32 {
	if m != nil {
		return m.Captains2
	}
	return nil
}

func (m *HeroPveTroopProto) GetXIndex() []int32 {
	if m != nil {
		return m.XIndex
	}
	return nil
}

type CaptainProto struct {
	Id           int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	IconId       string `protobuf:"bytes,20,opt,name=icon_id,json=iconId,proto3" json:"icon_id,omitempty"`
	Star         int32  `protobuf:"varint,7,opt,name=star,proto3" json:"star,omitempty"`
	Ability      int32  `protobuf:"varint,8,opt,name=ability,proto3" json:"ability,omitempty"`
	AbilityExp   int32  `protobuf:"varint,15,opt,name=ability_exp,json=abilityExp,proto3" json:"ability_exp,omitempty"`
	AbilityLimit int32  `protobuf:"varint,19,opt,name=ability_limit,json=abilityLimit,proto3" json:"ability_limit,omitempty"`
	// int32 rebirth_exp = 23 [deprecated = true]; // 转生经验
	Rebirth                int32            `protobuf:"varint,24,opt,name=rebirth,proto3" json:"rebirth,omitempty"`
	RebirthCdEndTime       int32            `protobuf:"varint,26,opt,name=rebirth_cd_end_time,json=rebirthCdEndTime,proto3" json:"rebirth_cd_end_time,omitempty"`
	Exp                    int32            `protobuf:"varint,9,opt,name=exp,proto3" json:"exp,omitempty"`
	Level                  int32            `protobuf:"varint,10,opt,name=level,proto3" json:"level,omitempty"`
	Soldier                int32            `protobuf:"varint,11,opt,name=soldier,proto3" json:"soldier,omitempty"`
	FightAmount            int32            `protobuf:"varint,13,opt,name=fight_amount,json=fightAmount,proto3" json:"fight_amount,omitempty"`
	FullSoldierFightAmount int32            `protobuf:"varint,18,opt,name=full_soldier_fight_amount,json=fullSoldierFightAmount,proto3" json:"full_soldier_fight_amount,omitempty"`
	TotalStat              *SpriteStatProto `protobuf:"bytes,14,opt,name=total_stat,json=totalStat" json:"total_stat,omitempty"`
	Taoz                   int32            `protobuf:"varint,17,opt,name=taoz,proto3" json:"taoz,omitempty"`
	// 装备
	Equipment []*EquipmentProto `protobuf:"bytes,31,rep,name=equipment" json:"equipment,omitempty"`
	// 宝石
	Gems        []*HeroCaptainGemProto `protobuf:"bytes,34,rep,name=gems" json:"gems,omitempty"`
	Gongxun     int32                  `protobuf:"varint,37,opt,name=gongxun,proto3" json:"gongxun,omitempty"`
	Official    int32                  `protobuf:"varint,38,opt,name=official,proto3" json:"official,omitempty"`
	OfficialIdx int32                  `protobuf:"varint,39,opt,name=official_idx,json=officialIdx,proto3" json:"official_idx,omitempty"`
	Viewed      bool                   `protobuf:"varint,40,opt,name=viewed,proto3" json:"viewed,omitempty"`
}

func (m *CaptainProto) Reset()                    { *m = CaptainProto{} }
func (m *CaptainProto) String() string            { return proto.CompactTextString(m) }
func (*CaptainProto) ProtoMessage()               {}
func (*CaptainProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{24} }

func (m *CaptainProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CaptainProto) GetIconId() string {
	if m != nil {
		return m.IconId
	}
	return ""
}

func (m *CaptainProto) GetStar() int32 {
	if m != nil {
		return m.Star
	}
	return 0
}

func (m *CaptainProto) GetAbility() int32 {
	if m != nil {
		return m.Ability
	}
	return 0
}

func (m *CaptainProto) GetAbilityExp() int32 {
	if m != nil {
		return m.AbilityExp
	}
	return 0
}

func (m *CaptainProto) GetAbilityLimit() int32 {
	if m != nil {
		return m.AbilityLimit
	}
	return 0
}

func (m *CaptainProto) GetRebirth() int32 {
	if m != nil {
		return m.Rebirth
	}
	return 0
}

func (m *CaptainProto) GetRebirthCdEndTime() int32 {
	if m != nil {
		return m.RebirthCdEndTime
	}
	return 0
}

func (m *CaptainProto) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *CaptainProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *CaptainProto) GetSoldier() int32 {
	if m != nil {
		return m.Soldier
	}
	return 0
}

func (m *CaptainProto) GetFightAmount() int32 {
	if m != nil {
		return m.FightAmount
	}
	return 0
}

func (m *CaptainProto) GetFullSoldierFightAmount() int32 {
	if m != nil {
		return m.FullSoldierFightAmount
	}
	return 0
}

func (m *CaptainProto) GetTotalStat() *SpriteStatProto {
	if m != nil {
		return m.TotalStat
	}
	return nil
}

func (m *CaptainProto) GetTaoz() int32 {
	if m != nil {
		return m.Taoz
	}
	return 0
}

func (m *CaptainProto) GetEquipment() []*EquipmentProto {
	if m != nil {
		return m.Equipment
	}
	return nil
}

func (m *CaptainProto) GetGems() []*HeroCaptainGemProto {
	if m != nil {
		return m.Gems
	}
	return nil
}

func (m *CaptainProto) GetGongxun() int32 {
	if m != nil {
		return m.Gongxun
	}
	return 0
}

func (m *CaptainProto) GetOfficial() int32 {
	if m != nil {
		return m.Official
	}
	return 0
}

func (m *CaptainProto) GetOfficialIdx() int32 {
	if m != nil {
		return m.OfficialIdx
	}
	return 0
}

func (m *CaptainProto) GetViewed() bool {
	if m != nil {
		return m.Viewed
	}
	return false
}

type HeroCaptainProto struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// string family_name = 2; // 系统随机的姓氏，玩家改名后会清空
	Name                   *CaptainNameProto `protobuf:"bytes,25,opt,name=name" json:"name,omitempty"`
	IconId                 string            `protobuf:"bytes,20,opt,name=icon_id,json=iconId,proto3" json:"icon_id,omitempty"`
	Male                   bool              `protobuf:"varint,5,opt,name=male,proto3" json:"male,omitempty"`
	Race                   Race              `protobuf:"varint,6,opt,name=race,proto3,enum=proto.Race" json:"race,omitempty"`
	Quality                Quality           `protobuf:"varint,7,opt,name=quality,proto3,enum=proto.Quality" json:"quality,omitempty"`
	Ability                int32             `protobuf:"varint,8,opt,name=ability,proto3" json:"ability,omitempty"`
	AbilityExp             int32             `protobuf:"varint,15,opt,name=ability_exp,json=abilityExp,proto3" json:"ability_exp,omitempty"`
	AbilityLimit           int32             `protobuf:"varint,19,opt,name=ability_limit,json=abilityLimit,proto3" json:"ability_limit,omitempty"`
	RebirthExp             int32             `protobuf:"varint,23,opt,name=rebirth_exp,json=rebirthExp,proto3" json:"rebirth_exp,omitempty"`
	Rebirth                int32             `protobuf:"varint,24,opt,name=rebirth,proto3" json:"rebirth,omitempty"`
	RebirthCdEndTime       int32             `protobuf:"varint,26,opt,name=rebirth_cd_end_time,json=rebirthCdEndTime,proto3" json:"rebirth_cd_end_time,omitempty"`
	Exp                    int32             `protobuf:"varint,9,opt,name=exp,proto3" json:"exp,omitempty"`
	Level                  int32             `protobuf:"varint,10,opt,name=level,proto3" json:"level,omitempty"`
	Soldier                int32             `protobuf:"varint,11,opt,name=soldier,proto3" json:"soldier,omitempty"`
	FightAmount            int32             `protobuf:"varint,13,opt,name=fight_amount,json=fightAmount,proto3" json:"fight_amount,omitempty"`
	FullSoldierFightAmount int32             `protobuf:"varint,18,opt,name=full_soldier_fight_amount,json=fullSoldierFightAmount,proto3" json:"full_soldier_fight_amount,omitempty"`
	TotalStat              *SpriteStatProto  `protobuf:"bytes,14,opt,name=total_stat,json=totalStat" json:"total_stat,omitempty"`
	Morale                 int32             `protobuf:"varint,16,opt,name=morale,proto3" json:"morale,omitempty"`
	Taoz                   int32             `protobuf:"varint,17,opt,name=taoz,proto3" json:"taoz,omitempty"`
	RaceCdEndTime          int32             `protobuf:"varint,22,opt,name=race_cd_end_time,json=raceCdEndTime,proto3" json:"race_cd_end_time,omitempty"`
	// 装备
	Equipment []*EquipmentProto `protobuf:"bytes,31,rep,name=equipment" json:"equipment,omitempty"`
	// 宝石
	Gems []*HeroCaptainGemProto `protobuf:"bytes,34,rep,name=gems" json:"gems,omitempty"`
	// 附身的将魂id，0表示没有附身的将魂
	FuShenCaptainSoulId int32 `protobuf:"varint,35,opt,name=fu_shen_captain_soul_id,json=fuShenCaptainSoulId,proto3" json:"fu_shen_captain_soul_id,omitempty"`
	// 克制技被解锁了
	RestraintSpellUnlocked bool  `protobuf:"varint,36,opt,name=restraint_spell_unlocked,json=restraintSpellUnlocked,proto3" json:"restraint_spell_unlocked,omitempty"`
	Gongxun                int32 `protobuf:"varint,37,opt,name=gongxun,proto3" json:"gongxun,omitempty"`
	Official               int32 `protobuf:"varint,38,opt,name=official,proto3" json:"official,omitempty"`
}

func (m *HeroCaptainProto) Reset()                    { *m = HeroCaptainProto{} }
func (m *HeroCaptainProto) String() string            { return proto.CompactTextString(m) }
func (*HeroCaptainProto) ProtoMessage()               {}
func (*HeroCaptainProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{25} }

func (m *HeroCaptainProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *HeroCaptainProto) GetName() *CaptainNameProto {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *HeroCaptainProto) GetIconId() string {
	if m != nil {
		return m.IconId
	}
	return ""
}

func (m *HeroCaptainProto) GetMale() bool {
	if m != nil {
		return m.Male
	}
	return false
}

func (m *HeroCaptainProto) GetRace() Race {
	if m != nil {
		return m.Race
	}
	return Race_InvalidRace
}

func (m *HeroCaptainProto) GetQuality() Quality {
	if m != nil {
		return m.Quality
	}
	return Quality_InvalidQuality
}

func (m *HeroCaptainProto) GetAbility() int32 {
	if m != nil {
		return m.Ability
	}
	return 0
}

func (m *HeroCaptainProto) GetAbilityExp() int32 {
	if m != nil {
		return m.AbilityExp
	}
	return 0
}

func (m *HeroCaptainProto) GetAbilityLimit() int32 {
	if m != nil {
		return m.AbilityLimit
	}
	return 0
}

func (m *HeroCaptainProto) GetRebirthExp() int32 {
	if m != nil {
		return m.RebirthExp
	}
	return 0
}

func (m *HeroCaptainProto) GetRebirth() int32 {
	if m != nil {
		return m.Rebirth
	}
	return 0
}

func (m *HeroCaptainProto) GetRebirthCdEndTime() int32 {
	if m != nil {
		return m.RebirthCdEndTime
	}
	return 0
}

func (m *HeroCaptainProto) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *HeroCaptainProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *HeroCaptainProto) GetSoldier() int32 {
	if m != nil {
		return m.Soldier
	}
	return 0
}

func (m *HeroCaptainProto) GetFightAmount() int32 {
	if m != nil {
		return m.FightAmount
	}
	return 0
}

func (m *HeroCaptainProto) GetFullSoldierFightAmount() int32 {
	if m != nil {
		return m.FullSoldierFightAmount
	}
	return 0
}

func (m *HeroCaptainProto) GetTotalStat() *SpriteStatProto {
	if m != nil {
		return m.TotalStat
	}
	return nil
}

func (m *HeroCaptainProto) GetMorale() int32 {
	if m != nil {
		return m.Morale
	}
	return 0
}

func (m *HeroCaptainProto) GetTaoz() int32 {
	if m != nil {
		return m.Taoz
	}
	return 0
}

func (m *HeroCaptainProto) GetRaceCdEndTime() int32 {
	if m != nil {
		return m.RaceCdEndTime
	}
	return 0
}

func (m *HeroCaptainProto) GetEquipment() []*EquipmentProto {
	if m != nil {
		return m.Equipment
	}
	return nil
}

func (m *HeroCaptainProto) GetGems() []*HeroCaptainGemProto {
	if m != nil {
		return m.Gems
	}
	return nil
}

func (m *HeroCaptainProto) GetFuShenCaptainSoulId() int32 {
	if m != nil {
		return m.FuShenCaptainSoulId
	}
	return 0
}

func (m *HeroCaptainProto) GetRestraintSpellUnlocked() bool {
	if m != nil {
		return m.RestraintSpellUnlocked
	}
	return false
}

func (m *HeroCaptainProto) GetGongxun() int32 {
	if m != nil {
		return m.Gongxun
	}
	return 0
}

func (m *HeroCaptainProto) GetOfficial() int32 {
	if m != nil {
		return m.Official
	}
	return 0
}

type HeroCaptainGemProto struct {
	Gem     int32 `protobuf:"varint,1,opt,name=gem,proto3" json:"gem,omitempty"`
	SlotIdx int32 `protobuf:"varint,2,opt,name=slot_idx,json=slotIdx,proto3" json:"slot_idx,omitempty"`
}

func (m *HeroCaptainGemProto) Reset()                    { *m = HeroCaptainGemProto{} }
func (m *HeroCaptainGemProto) String() string            { return proto.CompactTextString(m) }
func (*HeroCaptainGemProto) ProtoMessage()               {}
func (*HeroCaptainGemProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{26} }

func (m *HeroCaptainGemProto) GetGem() int32 {
	if m != nil {
		return m.Gem
	}
	return 0
}

func (m *HeroCaptainGemProto) GetSlotIdx() int32 {
	if m != nil {
		return m.SlotIdx
	}
	return 0
}

type CaptainSkillProto struct {
	Id    int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Level int32 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
}

func (m *CaptainSkillProto) Reset()                    { *m = CaptainSkillProto{} }
func (m *CaptainSkillProto) String() string            { return proto.CompactTextString(m) }
func (*CaptainSkillProto) ProtoMessage()               {}
func (*CaptainSkillProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{27} }

func (m *CaptainSkillProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CaptainSkillProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

type HeroCaptainOtherProto struct {
	Id                     int32             `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                   *CaptainNameProto `protobuf:"bytes,25,opt,name=name" json:"name,omitempty"`
	IconId                 string            `protobuf:"bytes,20,opt,name=icon_id,json=iconId,proto3" json:"icon_id,omitempty"`
	Male                   bool              `protobuf:"varint,5,opt,name=male,proto3" json:"male,omitempty"`
	Race                   Race              `protobuf:"varint,6,opt,name=race,proto3,enum=proto.Race" json:"race,omitempty"`
	Quality                Quality           `protobuf:"varint,7,opt,name=quality,proto3,enum=proto.Quality" json:"quality,omitempty"`
	Ability                int32             `protobuf:"varint,8,opt,name=ability,proto3" json:"ability,omitempty"`
	Rebirth                int32             `protobuf:"varint,24,opt,name=rebirth,proto3" json:"rebirth,omitempty"`
	Level                  int32             `protobuf:"varint,10,opt,name=level,proto3" json:"level,omitempty"`
	SoldierLevel           int32             `protobuf:"varint,11,opt,name=soldier_level,json=soldierLevel,proto3" json:"soldier_level,omitempty"`
	FullSoldierFightAmount int32             `protobuf:"varint,18,opt,name=full_soldier_fight_amount,json=fullSoldierFightAmount,proto3" json:"full_soldier_fight_amount,omitempty"`
	TotalStat              *SpriteStatProto  `protobuf:"bytes,14,opt,name=total_stat,json=totalStat" json:"total_stat,omitempty"`
	// 装备
	Equipment []*EquipmentProto `protobuf:"bytes,31,rep,name=equipment" json:"equipment,omitempty"`
	// 宝石
	Gems             []*HeroCaptainGemProto `protobuf:"bytes,34,rep,name=gems" json:"gems,omitempty"`
	CaptainSoul      int32                  `protobuf:"varint,35,opt,name=captain_soul,json=captainSoul,proto3" json:"captain_soul,omitempty"`
	CaptainSoulLevel int32                  `protobuf:"varint,36,opt,name=captain_soul_level,json=captainSoulLevel,proto3" json:"captain_soul_level,omitempty"`
	Official         int32                  `protobuf:"varint,38,opt,name=official,proto3" json:"official,omitempty"`
	Star             int32                  `protobuf:"varint,2,opt,name=star,proto3" json:"star,omitempty"`
}

func (m *HeroCaptainOtherProto) Reset()                    { *m = HeroCaptainOtherProto{} }
func (m *HeroCaptainOtherProto) String() string            { return proto.CompactTextString(m) }
func (*HeroCaptainOtherProto) ProtoMessage()               {}
func (*HeroCaptainOtherProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{28} }

func (m *HeroCaptainOtherProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *HeroCaptainOtherProto) GetName() *CaptainNameProto {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *HeroCaptainOtherProto) GetIconId() string {
	if m != nil {
		return m.IconId
	}
	return ""
}

func (m *HeroCaptainOtherProto) GetMale() bool {
	if m != nil {
		return m.Male
	}
	return false
}

func (m *HeroCaptainOtherProto) GetRace() Race {
	if m != nil {
		return m.Race
	}
	return Race_InvalidRace
}

func (m *HeroCaptainOtherProto) GetQuality() Quality {
	if m != nil {
		return m.Quality
	}
	return Quality_InvalidQuality
}

func (m *HeroCaptainOtherProto) GetAbility() int32 {
	if m != nil {
		return m.Ability
	}
	return 0
}

func (m *HeroCaptainOtherProto) GetRebirth() int32 {
	if m != nil {
		return m.Rebirth
	}
	return 0
}

func (m *HeroCaptainOtherProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *HeroCaptainOtherProto) GetSoldierLevel() int32 {
	if m != nil {
		return m.SoldierLevel
	}
	return 0
}

func (m *HeroCaptainOtherProto) GetFullSoldierFightAmount() int32 {
	if m != nil {
		return m.FullSoldierFightAmount
	}
	return 0
}

func (m *HeroCaptainOtherProto) GetTotalStat() *SpriteStatProto {
	if m != nil {
		return m.TotalStat
	}
	return nil
}

func (m *HeroCaptainOtherProto) GetEquipment() []*EquipmentProto {
	if m != nil {
		return m.Equipment
	}
	return nil
}

func (m *HeroCaptainOtherProto) GetGems() []*HeroCaptainGemProto {
	if m != nil {
		return m.Gems
	}
	return nil
}

func (m *HeroCaptainOtherProto) GetCaptainSoul() int32 {
	if m != nil {
		return m.CaptainSoul
	}
	return 0
}

func (m *HeroCaptainOtherProto) GetCaptainSoulLevel() int32 {
	if m != nil {
		return m.CaptainSoulLevel
	}
	return 0
}

func (m *HeroCaptainOtherProto) GetOfficial() int32 {
	if m != nil {
		return m.Official
	}
	return 0
}

func (m *HeroCaptainOtherProto) GetStar() int32 {
	if m != nil {
		return m.Star
	}
	return 0
}

func init() {
	proto.RegisterType((*StrongerDataProto)(nil), "proto.StrongerDataProto")
	proto.RegisterType((*JiuGuanMiscDataProto)(nil), "proto.JiuGuanMiscDataProto")
	proto.RegisterType((*TutorDataProto)(nil), "proto.TutorDataProto")
	proto.RegisterType((*JiuGuanDataProto)(nil), "proto.JiuGuanDataProto")
	proto.RegisterType((*JunYingLevelDataProto)(nil), "proto.JunYingLevelDataProto")
	proto.RegisterType((*JunYingMiscProto)(nil), "proto.JunYingMiscProto")
	proto.RegisterType((*TrainingLevelProto)(nil), "proto.TrainingLevelProto")
	proto.RegisterType((*CaptainAbilityProto)(nil), "proto.CaptainAbilityProto")
	proto.RegisterType((*CaptainGeneratorProto)(nil), "proto.CaptainGeneratorProto")
	proto.RegisterType((*CaptainLevelProto)(nil), "proto.CaptainLevelProto")
	proto.RegisterType((*CaptainRebirthLevelProto)(nil), "proto.CaptainRebirthLevelProto")
	proto.RegisterType((*CaptainSeekerProto)(nil), "proto.CaptainSeekerProto")
	proto.RegisterType((*SoldierLevelProto)(nil), "proto.SoldierLevelProto")
	proto.RegisterType((*CaptainOfficialProto)(nil), "proto.CaptainOfficialProto")
	proto.RegisterType((*MilitaryInfoProto)(nil), "proto.MilitaryInfoProto")
	proto.RegisterType((*AssemblyInfoProto)(nil), "proto.AssemblyInfoProto")
	proto.RegisterType((*AssemblyMemberProto)(nil), "proto.AssemblyMemberProto")
	proto.RegisterType((*BaseDefenserProto)(nil), "proto.BaseDefenserProto")
	proto.RegisterType((*CaptainInfoProto)(nil), "proto.CaptainInfoProto")
	proto.RegisterType((*HeroMilitaryProto)(nil), "proto.HeroMilitaryProto")
	proto.RegisterType((*HeroCaptainOfficialCount)(nil), "proto.HeroCaptainOfficialCount")
	proto.RegisterType((*PveTroopDataProto)(nil), "proto.PveTroopDataProto")
	proto.RegisterType((*HeroTroopProto)(nil), "proto.HeroTroopProto")
	proto.RegisterType((*HeroPveTroopProto)(nil), "proto.HeroPveTroopProto")
	proto.RegisterType((*CaptainProto)(nil), "proto.CaptainProto")
	proto.RegisterType((*HeroCaptainProto)(nil), "proto.HeroCaptainProto")
	proto.RegisterType((*HeroCaptainGemProto)(nil), "proto.HeroCaptainGemProto")
	proto.RegisterType((*CaptainSkillProto)(nil), "proto.CaptainSkillProto")
	proto.RegisterType((*HeroCaptainOtherProto)(nil), "proto.HeroCaptainOtherProto")
	proto.RegisterEnum("proto.PveTroopType", PveTroopType_name, PveTroopType_value)
}
func (m *StrongerDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StrongerDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Level))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Type))
	}
	if m.X != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Y))
	}
	if m.Z != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Z))
	}
	return i, nil
}

func (m *JiuGuanMiscDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JiuGuanMiscDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxTimes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.MaxTimes))
	}
	if len(m.RefreshCostYuanBao) > 0 {
		for _, num := range m.RefreshCostYuanBao {
			dAtA[i] = 0x18
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(num))
		}
	}
	if m.RecoveryDuration != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.RecoveryDuration))
	}
	if len(m.RefreshCost) > 0 {
		for _, msg := range m.RefreshCost {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TutorDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TutorDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if m.Prize != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Prize.Size()))
		n1, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.ChatContent) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.ChatContent)))
		i += copy(dAtA[i:], m.ChatContent)
	}
	if m.RefreshMaxCost != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.RefreshMaxCost.Size()))
		n2, err := m.RefreshMaxCost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *JiuGuanDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JiuGuanDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Level))
	}
	if len(m.TutorDatas) > 0 {
		for _, msg := range m.TutorDatas {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BroadcastContent) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.BroadcastContent)))
		i += copy(dAtA[i:], m.BroadcastContent)
	}
	if m.RecoveryDuration != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.RecoveryDuration))
	}
	if m.MaxTimes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.MaxTimes))
	}
	return i, nil
}

func (m *JunYingLevelDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JunYingLevelDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Level))
	}
	if m.MaxTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.MaxTimes))
	}
	if m.RecoveryDuration != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.RecoveryDuration))
	}
	return i, nil
}

func (m *JunYingMiscProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JunYingMiscProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ForceAddSoldierMaxTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.ForceAddSoldierMaxTimes))
	}
	if len(m.ForceAddSoldierCost) > 0 {
		for _, num := range m.ForceAddSoldierCost {
			dAtA[i] = 0x18
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(num))
		}
	}
	if len(m.ForceAddSoldierNewCost) > 0 {
		for _, msg := range m.ForceAddSoldierNewCost {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrainingLevelProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrainingLevelProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Level))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.ExpOutput != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.ExpOutput))
	}
	if m.ExpCapcity != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.ExpCapcity))
	}
	if m.Cost != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Cost.Size()))
		n3, err := m.Cost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Coef != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Coef))
	}
	return i, nil
}

func (m *CaptainAbilityProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptainAbilityProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ability != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Ability))
	}
	if m.UpgradeExp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.UpgradeExp))
	}
	if m.SellPrice != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.SellPrice.Size()))
		n4, err := m.SellPrice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Quality != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Quality))
	}
	if m.FirePrice != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.FirePrice.Size()))
		n5, err := m.FirePrice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.Models) > 0 {
		for _, num := range m.Models {
			dAtA[i] = 0x38
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(num))
		}
	}
	if m.UnlockSpellCount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.UnlockSpellCount))
	}
	if m.ResetCost != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.ResetCost.Size()))
		n6, err := m.ResetCost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *CaptainGeneratorProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptainGeneratorProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Count))
	}
	if m.NeedHeroLevel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.NeedHeroLevel))
	}
	return i, nil
}

func (m *CaptainLevelProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptainLevelProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Level))
	}
	if m.UpgradeExp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.UpgradeExp))
	}
	if m.HasNewGemSlot {
		dAtA[i] = 0x18
		i++
		if m.HasNewGemSlot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AbilityLimit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.AbilityLimit))
	}
	if m.Rebirth != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Rebirth))
	}
	if m.GemSlotCount != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.GemSlotCount))
	}
	return i, nil
}

func (m *CaptainRebirthLevelProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptainRebirthLevelProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Level))
	}
	if m.RebirthUpgradeExp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.RebirthUpgradeExp))
	}
	if m.CaptainLevelLimit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.CaptainLevelLimit))
	}
	if m.Yuanbao != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Yuanbao))
	}
	if m.SpriteStatPoint != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.SpriteStatPoint))
	}
	if m.SoldierCapcity != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.SoldierCapcity))
	}
	if m.AbilityLimit != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.AbilityLimit))
	}
	if m.AbilityExp != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.AbilityExp))
	}
	if m.Cd != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Cd))
	}
	if m.BeforeRebirthLevel != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.BeforeRebirthLevel))
	}
	if m.HeroLevelLimit != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.HeroLevelLimit))
	}
	return i, nil
}

func (m *CaptainSeekerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptainSeekerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Index))
	}
	if m.Sequence != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Sequence))
	}
	if m.RequiredHeroLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.RequiredHeroLevel))
	}
	if len(m.IconId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.IconId)))
		i += copy(dAtA[i:], m.IconId)
	}
	if m.Male {
		dAtA[i] = 0x28
		i++
		if m.Male {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Race != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Race))
	}
	if m.Quality != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Quality))
	}
	if m.Ability != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Ability))
	}
	if len(m.FamilyName) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.FamilyName)))
		i += copy(dAtA[i:], m.FamilyName)
	}
	if m.Name != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Name.Size()))
		n7, err := m.Name.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.GivenName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.GivenName)))
		i += copy(dAtA[i:], m.GivenName)
	}
	return i, nil
}

func (m *SoldierLevelProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SoldierLevelProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Level))
	}
	if m.Load != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Load))
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.JunYingLevel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.JunYingLevel))
	}
	if m.RecruitCost != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.RecruitCost.Size()))
		n8, err := m.RecruitCost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.WoundedCost != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.WoundedCost.Size()))
		n9, err := m.WoundedCost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.UpgradeCost != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.UpgradeCost.Size()))
		n10, err := m.UpgradeCost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.BaseStat) > 0 {
		for _, msg := range m.BaseStat {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TotalStatSum != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TotalStatSum))
	}
	if len(m.Models) > 0 {
		for _, num := range m.Models {
			dAtA[i] = 0xb8
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *CaptainOfficialProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptainOfficialProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Id))
	}
	if len(m.OfficialName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.OfficialName)))
		i += copy(dAtA[i:], m.OfficialName)
	}
	if m.SpriteStat != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.SpriteStat.Size()))
		n11, err := m.SpriteStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.NeedGongxun != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.NeedGongxun))
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	return i, nil
}

func (m *MilitaryInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MilitaryInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Action))
	}
	if m.MoveType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.MoveType))
	}
	if m.MoveStartTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.MoveStartTime))
	}
	if m.MoveArrivedTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.MoveArrivedTime))
	}
	if m.PriorityActionId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.PriorityActionId))
	}
	if m.RobbingEndTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.RobbingEndTime))
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.CreateTime))
	}
	if m.MoveStartRate1000 != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.MoveStartRate1000))
	}
	if len(m.CaptainIndex) > 0 {
		for _, num := range m.CaptainIndex {
			dAtA[i] = 0x78
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(num))
		}
	}
	if len(m.Captains) > 0 {
		for _, msg := range m.Captains {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SelfNpcDataId != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.SelfNpcDataId))
	}
	if m.SelfNpcType != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.SelfNpcType))
	}
	if m.SelfIsTent {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.SelfIsTent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Self != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Self.Size()))
		n12, err := m.Self.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Target != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Target.Size()))
		n13, err := m.Target.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.TargetBaseX != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TargetBaseX))
	}
	if m.TargetBaseY != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TargetBaseY))
	}
	if m.TargetIsTent {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		if m.TargetIsTent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TargetNpcDataId != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TargetNpcDataId))
	}
	if m.TargetNpcType != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TargetNpcType))
	}
	if len(m.KillEnemy) > 0 {
		for _, s := range m.KillEnemy {
			dAtA[i] = 0xf2
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Gold != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Gold))
	}
	if m.Food != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Food))
	}
	if m.Wood != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Wood))
	}
	if m.Stone != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Stone))
	}
	if m.JadeOre != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.JadeOre))
	}
	if m.AccumRobPrize != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.AccumRobPrize.Size()))
		n14, err := m.AccumRobPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.AssemblyCount != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.AssemblyCount))
	}
	if m.AssemblyTotalCount != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.AssemblyTotalCount))
	}
	if len(m.AssemblyId) > 0 {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.AssemblyId)))
		i += copy(dAtA[i:], m.AssemblyId)
	}
	if m.AssemblyTargetNpcType != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.AssemblyTargetNpcType))
	}
	if m.MultiLevelMonsterCount != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.MultiLevelMonsterCount))
	}
	if len(m.CombineId) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.CombineId)))
		i += copy(dAtA[i:], m.CombineId)
	}
	if m.RegionId != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.RegionId))
	}
	return i, nil
}

func (m *AssemblyInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssemblyInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MoveType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.MoveType))
	}
	if m.MoveStartTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.MoveStartTime))
	}
	if m.MoveArrivedTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.MoveArrivedTime))
	}
	if m.RobbingEndTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.RobbingEndTime))
	}
	if m.Self != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Self.Size()))
		n15, err := m.Self.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.SelfFightAmount != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.SelfFightAmount))
	}
	if m.Target != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Target.Size()))
		n16, err := m.Target.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.TargetBaseX != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TargetBaseX))
	}
	if m.TargetBaseY != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TargetBaseY))
	}
	if m.TargetMorale != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TargetMorale))
	}
	if m.TargetNpcDataId != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TargetNpcDataId))
	}
	if m.TargetNpcType != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TargetNpcType))
	}
	if m.TargetTroop != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TargetTroop))
	}
	if m.TargetTotalTroop != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TargetTotalTroop))
	}
	if len(m.Member) > 0 {
		for _, msg := range m.Member {
			dAtA[i] = 0xf2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TotalCount != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TotalCount))
	}
	if m.AddedStat != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.AddedStat.Size()))
		n17, err := m.AddedStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *AssemblyMemberProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssemblyMemberProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hero != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Hero.Size()))
		n18, err := m.Hero.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.FightAmount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.FightAmount))
	}
	if m.MoveStartTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.MoveStartTime))
	}
	if m.MoveArrivedTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.MoveArrivedTime))
	}
	if len(m.TroopId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.TroopId)))
		i += copy(dAtA[i:], m.TroopId)
	}
	return i, nil
}

func (m *BaseDefenserProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseDefenserProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CaptainIndex) > 0 {
		for _, num := range m.CaptainIndex {
			dAtA[i] = 0x78
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(num))
		}
	}
	if len(m.Captains) > 0 {
		for _, msg := range m.Captains {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CaptainInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptainInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Id))
	}
	if m.Race != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Race))
	}
	if m.Quality != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Quality))
	}
	if m.Soldier != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Soldier))
	}
	if m.TotalSoldier != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TotalSoldier))
	}
	if m.FightAmount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.FightAmount))
	}
	if m.Morale != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Morale))
	}
	if m.Level != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Level))
	}
	if m.SoldierLevel != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.SoldierLevel))
	}
	if m.Male {
		dAtA[i] = 0x60
		i++
		if m.Male {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanTriggerRestraintSpell {
		dAtA[i] = 0x68
		i++
		if m.CanTriggerRestraintSpell {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Name != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Name.Size()))
		n19, err := m.Name.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.IconId) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.IconId)))
		i += copy(dAtA[i:], m.IconId)
	}
	if m.Outside {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		if m.Outside {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TotalStat != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TotalStat.Size()))
		n20, err := m.TotalStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.LifePerSoldier != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.LifePerSoldier))
	}
	if m.LoadPerSoldier != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.LoadPerSoldier))
	}
	if m.Model != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Model))
	}
	if m.CaptainSoul != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.CaptainSoul))
	}
	if m.CaptainSoulLevel != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.CaptainSoulLevel))
	}
	if m.RebirthLevel != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.RebirthLevel))
	}
	if m.YuanJun {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		if m.YuanJun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FullFightAmount != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.FullFightAmount))
	}
	if m.XIndex != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.XIndex))
	}
	if m.CaptainId != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.CaptainId))
	}
	if m.IsNameless {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		if m.IsNameless {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Star != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Star))
	}
	if m.UnlockSpellCount != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.UnlockSpellCount))
	}
	if m.SpellFightAmountCoef != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.SpellFightAmountCoef))
	}
	return i, nil
}

func (m *HeroMilitaryProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroMilitaryProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Captains) > 0 {
		for _, msg := range m.Captains {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OfficialCount) > 0 {
		for _, msg := range m.OfficialCount {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CaptainFriendship) > 0 {
		for _, num := range m.CaptainFriendship {
			dAtA[i] = 0x28
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(num))
		}
	}
	if len(m.Troops) > 0 {
		for _, msg := range m.Troops {
			dAtA[i] = 0x32
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PveTroops) > 0 {
		for _, msg := range m.PveTroops {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PveTroop) > 0 {
		for _, msg := range m.PveTroop {
			dAtA[i] = 0x42
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OfficialView) > 0 {
		for _, msg := range m.OfficialView {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Captain) > 0 {
		for _, msg := range m.Captain {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SoldierLevel != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.SoldierLevel))
	}
	if m.SoldierCapcity != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.SoldierCapcity))
	}
	if m.FreeSoldier != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.FreeSoldier))
	}
	if m.WoundedSoldier != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.WoundedSoldier))
	}
	if m.WoundedSoldierCapcity != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.WoundedSoldierCapcity))
	}
	if m.NewSoldier != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.NewSoldier))
	}
	if m.NewSoldierCapcity != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.NewSoldierCapcity))
	}
	if m.NewSoldierOutput != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.NewSoldierOutput))
	}
	if m.NewSoldierRecruitCount != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.NewSoldierRecruitCount))
	}
	if m.JiuGuanRefreshTimes != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.JiuGuanRefreshTimes))
	}
	if m.JiuGuanTutorIndex != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.JiuGuanTutorIndex))
	}
	if m.JiuGuanTimes != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.JiuGuanTimes))
	}
	if m.JiuGuanNextTime != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.JiuGuanNextTime))
	}
	if m.JunYingRecruitStartRecoveyTime != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.JunYingRecruitStartRecoveyTime))
	}
	if m.NextExpelTime != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.NextExpelTime))
	}
	if m.GlobalTrainStartTime != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.GlobalTrainStartTime))
	}
	if m.CaptainTrainStartTime != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.CaptainTrainStartTime))
	}
	if m.TrainCoef != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TrainCoef))
	}
	if m.FreeSoldierStartRecoveryTime != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.FreeSoldierStartRecoveryTime))
	}
	if m.FreeSoldierCapcity != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.FreeSoldierCapcity))
	}
	if m.FreeSoldierOutput != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.FreeSoldierOutput))
	}
	if m.OverflowFreeSoldier != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.OverflowFreeSoldier))
	}
	if m.ForceAddSoldierTimes != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.ForceAddSoldierTimes))
	}
	if m.InvestigateTroop != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.InvestigateTroop.Size()))
		n21, err := m.InvestigateTroop.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *HeroCaptainOfficialCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroCaptainOfficialCount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OfficialId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.OfficialId))
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *PveTroopDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PveTroopDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PveTroopType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.PveTroopType))
	}
	if m.Capacity != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Capacity))
	}
	if m.MinCaptainCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.MinCaptainCount))
	}
	return i, nil
}

func (m *HeroTroopProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroTroopProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sequence != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Sequence))
	}
	if len(m.Captains) > 0 {
		for _, num := range m.Captains {
			dAtA[i] = 0x10
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(num))
		}
	}
	if m.IsOutside {
		dAtA[i] = 0x18
		i++
		if m.IsOutside {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Captains2) > 0 {
		for _, num := range m.Captains2 {
			dAtA[i] = 0x20
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(num))
		}
	}
	if len(m.XIndex) > 0 {
		for _, num := range m.XIndex {
			dAtA[i] = 0x28
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *HeroPveTroopProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroPveTroopProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Type))
	}
	if len(m.Captains) > 0 {
		for _, num := range m.Captains {
			dAtA[i] = 0x10
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(num))
		}
	}
	if len(m.Captains2) > 0 {
		for _, num := range m.Captains2 {
			dAtA[i] = 0x20
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(num))
		}
	}
	if len(m.XIndex) > 0 {
		for _, num := range m.XIndex {
			dAtA[i] = 0x28
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *CaptainProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptainProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Id))
	}
	if m.Star != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Star))
	}
	if m.Ability != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Ability))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Exp))
	}
	if m.Level != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Level))
	}
	if m.Soldier != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Soldier))
	}
	if m.FightAmount != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.FightAmount))
	}
	if m.TotalStat != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TotalStat.Size()))
		n22, err := m.TotalStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.AbilityExp != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.AbilityExp))
	}
	if m.Taoz != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Taoz))
	}
	if m.FullSoldierFightAmount != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.FullSoldierFightAmount))
	}
	if m.AbilityLimit != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.AbilityLimit))
	}
	if len(m.IconId) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.IconId)))
		i += copy(dAtA[i:], m.IconId)
	}
	if m.Rebirth != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Rebirth))
	}
	if m.RebirthCdEndTime != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.RebirthCdEndTime))
	}
	if len(m.Equipment) > 0 {
		for _, msg := range m.Equipment {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Gems) > 0 {
		for _, msg := range m.Gems {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Gongxun != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Gongxun))
	}
	if m.Official != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Official))
	}
	if m.OfficialIdx != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.OfficialIdx))
	}
	if m.Viewed {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		if m.Viewed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *HeroCaptainProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroCaptainProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Id))
	}
	if m.Male {
		dAtA[i] = 0x28
		i++
		if m.Male {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Race != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Race))
	}
	if m.Quality != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Quality))
	}
	if m.Ability != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Ability))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Exp))
	}
	if m.Level != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Level))
	}
	if m.Soldier != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Soldier))
	}
	if m.FightAmount != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.FightAmount))
	}
	if m.TotalStat != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TotalStat.Size()))
		n23, err := m.TotalStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.AbilityExp != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.AbilityExp))
	}
	if m.Morale != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Morale))
	}
	if m.Taoz != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Taoz))
	}
	if m.FullSoldierFightAmount != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.FullSoldierFightAmount))
	}
	if m.AbilityLimit != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.AbilityLimit))
	}
	if len(m.IconId) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.IconId)))
		i += copy(dAtA[i:], m.IconId)
	}
	if m.RaceCdEndTime != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.RaceCdEndTime))
	}
	if m.RebirthExp != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.RebirthExp))
	}
	if m.Rebirth != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Rebirth))
	}
	if m.Name != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Name.Size()))
		n24, err := m.Name.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.RebirthCdEndTime != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.RebirthCdEndTime))
	}
	if len(m.Equipment) > 0 {
		for _, msg := range m.Equipment {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Gems) > 0 {
		for _, msg := range m.Gems {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FuShenCaptainSoulId != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.FuShenCaptainSoulId))
	}
	if m.RestraintSpellUnlocked {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		if m.RestraintSpellUnlocked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Gongxun != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Gongxun))
	}
	if m.Official != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Official))
	}
	return i, nil
}

func (m *HeroCaptainGemProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroCaptainGemProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gem != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Gem))
	}
	if m.SlotIdx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.SlotIdx))
	}
	return i, nil
}

func (m *CaptainSkillProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptainSkillProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Id))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Level))
	}
	return i, nil
}

func (m *HeroCaptainOtherProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroCaptainOtherProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Id))
	}
	if m.Star != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Star))
	}
	if m.Male {
		dAtA[i] = 0x28
		i++
		if m.Male {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Race != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Race))
	}
	if m.Quality != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Quality))
	}
	if m.Ability != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Ability))
	}
	if m.Level != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Level))
	}
	if m.SoldierLevel != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.SoldierLevel))
	}
	if m.TotalStat != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TotalStat.Size()))
		n25, err := m.TotalStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.FullSoldierFightAmount != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.FullSoldierFightAmount))
	}
	if len(m.IconId) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(len(m.IconId)))
		i += copy(dAtA[i:], m.IconId)
	}
	if m.Rebirth != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Rebirth))
	}
	if m.Name != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Name.Size()))
		n26, err := m.Name.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if len(m.Equipment) > 0 {
		for _, msg := range m.Equipment {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Gems) > 0 {
		for _, msg := range m.Gems {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CaptainSoul != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.CaptainSoul))
	}
	if m.CaptainSoulLevel != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.CaptainSoulLevel))
	}
	if m.Official != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Official))
	}
	return i, nil
}

func encodeFixed64Military(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Military(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMilitary(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *StrongerDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovMilitary(uint64(m.Level))
	}
	if m.Type != 0 {
		n += 1 + sovMilitary(uint64(m.Type))
	}
	if m.X != 0 {
		n += 1 + sovMilitary(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovMilitary(uint64(m.Y))
	}
	if m.Z != 0 {
		n += 1 + sovMilitary(uint64(m.Z))
	}
	return n
}

func (m *JiuGuanMiscDataProto) Size() (n int) {
	var l int
	_ = l
	if m.MaxTimes != 0 {
		n += 1 + sovMilitary(uint64(m.MaxTimes))
	}
	if len(m.RefreshCostYuanBao) > 0 {
		for _, e := range m.RefreshCostYuanBao {
			n += 1 + sovMilitary(uint64(e))
		}
	}
	if m.RecoveryDuration != 0 {
		n += 1 + sovMilitary(uint64(m.RecoveryDuration))
	}
	if len(m.RefreshCost) > 0 {
		for _, e := range m.RefreshCost {
			l = e.Size()
			n += 1 + l + sovMilitary(uint64(l))
		}
	}
	return n
}

func (m *TutorDataProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMilitary(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovMilitary(uint64(l))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovMilitary(uint64(l))
	}
	l = len(m.ChatContent)
	if l > 0 {
		n += 1 + l + sovMilitary(uint64(l))
	}
	if m.RefreshMaxCost != nil {
		l = m.RefreshMaxCost.Size()
		n += 1 + l + sovMilitary(uint64(l))
	}
	return n
}

func (m *JiuGuanDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovMilitary(uint64(m.Level))
	}
	if len(m.TutorDatas) > 0 {
		for _, e := range m.TutorDatas {
			l = e.Size()
			n += 1 + l + sovMilitary(uint64(l))
		}
	}
	l = len(m.BroadcastContent)
	if l > 0 {
		n += 1 + l + sovMilitary(uint64(l))
	}
	if m.RecoveryDuration != 0 {
		n += 1 + sovMilitary(uint64(m.RecoveryDuration))
	}
	if m.MaxTimes != 0 {
		n += 1 + sovMilitary(uint64(m.MaxTimes))
	}
	return n
}

func (m *JunYingLevelDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovMilitary(uint64(m.Level))
	}
	if m.MaxTimes != 0 {
		n += 1 + sovMilitary(uint64(m.MaxTimes))
	}
	if m.RecoveryDuration != 0 {
		n += 1 + sovMilitary(uint64(m.RecoveryDuration))
	}
	return n
}

func (m *JunYingMiscProto) Size() (n int) {
	var l int
	_ = l
	if m.ForceAddSoldierMaxTimes != 0 {
		n += 1 + sovMilitary(uint64(m.ForceAddSoldierMaxTimes))
	}
	if len(m.ForceAddSoldierCost) > 0 {
		for _, e := range m.ForceAddSoldierCost {
			n += 1 + sovMilitary(uint64(e))
		}
	}
	if len(m.ForceAddSoldierNewCost) > 0 {
		for _, e := range m.ForceAddSoldierNewCost {
			l = e.Size()
			n += 1 + l + sovMilitary(uint64(l))
		}
	}
	return n
}

func (m *TrainingLevelProto) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovMilitary(uint64(m.Level))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMilitary(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovMilitary(uint64(l))
	}
	if m.ExpOutput != 0 {
		n += 1 + sovMilitary(uint64(m.ExpOutput))
	}
	if m.ExpCapcity != 0 {
		n += 1 + sovMilitary(uint64(m.ExpCapcity))
	}
	if m.Cost != nil {
		l = m.Cost.Size()
		n += 1 + l + sovMilitary(uint64(l))
	}
	if m.Coef != 0 {
		n += 1 + sovMilitary(uint64(m.Coef))
	}
	return n
}

func (m *CaptainAbilityProto) Size() (n int) {
	var l int
	_ = l
	if m.Ability != 0 {
		n += 1 + sovMilitary(uint64(m.Ability))
	}
	if m.UpgradeExp != 0 {
		n += 1 + sovMilitary(uint64(m.UpgradeExp))
	}
	if m.SellPrice != nil {
		l = m.SellPrice.Size()
		n += 1 + l + sovMilitary(uint64(l))
	}
	if m.Quality != 0 {
		n += 1 + sovMilitary(uint64(m.Quality))
	}
	if m.FirePrice != nil {
		l = m.FirePrice.Size()
		n += 1 + l + sovMilitary(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovMilitary(uint64(l))
	}
	if len(m.Models) > 0 {
		for _, e := range m.Models {
			n += 1 + sovMilitary(uint64(e))
		}
	}
	if m.UnlockSpellCount != 0 {
		n += 1 + sovMilitary(uint64(m.UnlockSpellCount))
	}
	if m.ResetCost != nil {
		l = m.ResetCost.Size()
		n += 1 + l + sovMilitary(uint64(l))
	}
	return n
}

func (m *CaptainGeneratorProto) Size() (n int) {
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovMilitary(uint64(m.Count))
	}
	if m.NeedHeroLevel != 0 {
		n += 1 + sovMilitary(uint64(m.NeedHeroLevel))
	}
	return n
}

func (m *CaptainLevelProto) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovMilitary(uint64(m.Level))
	}
	if m.UpgradeExp != 0 {
		n += 1 + sovMilitary(uint64(m.UpgradeExp))
	}
	if m.HasNewGemSlot {
		n += 2
	}
	if m.AbilityLimit != 0 {
		n += 1 + sovMilitary(uint64(m.AbilityLimit))
	}
	if m.Rebirth != 0 {
		n += 1 + sovMilitary(uint64(m.Rebirth))
	}
	if m.GemSlotCount != 0 {
		n += 2 + sovMilitary(uint64(m.GemSlotCount))
	}
	return n
}

func (m *CaptainRebirthLevelProto) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovMilitary(uint64(m.Level))
	}
	if m.RebirthUpgradeExp != 0 {
		n += 1 + sovMilitary(uint64(m.RebirthUpgradeExp))
	}
	if m.CaptainLevelLimit != 0 {
		n += 1 + sovMilitary(uint64(m.CaptainLevelLimit))
	}
	if m.Yuanbao != 0 {
		n += 1 + sovMilitary(uint64(m.Yuanbao))
	}
	if m.SpriteStatPoint != 0 {
		n += 1 + sovMilitary(uint64(m.SpriteStatPoint))
	}
	if m.SoldierCapcity != 0 {
		n += 1 + sovMilitary(uint64(m.SoldierCapcity))
	}
	if m.AbilityLimit != 0 {
		n += 1 + sovMilitary(uint64(m.AbilityLimit))
	}
	if m.AbilityExp != 0 {
		n += 1 + sovMilitary(uint64(m.AbilityExp))
	}
	if m.Cd != 0 {
		n += 1 + sovMilitary(uint64(m.Cd))
	}
	if m.BeforeRebirthLevel != 0 {
		n += 1 + sovMilitary(uint64(m.BeforeRebirthLevel))
	}
	if m.HeroLevelLimit != 0 {
		n += 1 + sovMilitary(uint64(m.HeroLevelLimit))
	}
	return n
}

func (m *CaptainSeekerProto) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovMilitary(uint64(m.Index))
	}
	if m.Sequence != 0 {
		n += 1 + sovMilitary(uint64(m.Sequence))
	}
	if m.RequiredHeroLevel != 0 {
		n += 1 + sovMilitary(uint64(m.RequiredHeroLevel))
	}
	l = len(m.IconId)
	if l > 0 {
		n += 1 + l + sovMilitary(uint64(l))
	}
	if m.Male {
		n += 2
	}
	if m.Race != 0 {
		n += 1 + sovMilitary(uint64(m.Race))
	}
	if m.Quality != 0 {
		n += 1 + sovMilitary(uint64(m.Quality))
	}
	if m.Ability != 0 {
		n += 1 + sovMilitary(uint64(m.Ability))
	}
	l = len(m.FamilyName)
	if l > 0 {
		n += 1 + l + sovMilitary(uint64(l))
	}
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovMilitary(uint64(l))
	}
	l = len(m.GivenName)
	if l > 0 {
		n += 1 + l + sovMilitary(uint64(l))
	}
	return n
}

func (m *SoldierLevelProto) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovMilitary(uint64(m.Level))
	}
	if m.Load != 0 {
		n += 1 + sovMilitary(uint64(m.Load))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovMilitary(uint64(l))
	}
	if m.JunYingLevel != 0 {
		n += 1 + sovMilitary(uint64(m.JunYingLevel))
	}
	if m.RecruitCost != nil {
		l = m.RecruitCost.Size()
		n += 1 + l + sovMilitary(uint64(l))
	}
	if m.WoundedCost != nil {
		l = m.WoundedCost.Size()
		n += 1 + l + sovMilitary(uint64(l))
	}
	if m.UpgradeCost != nil {
		l = m.UpgradeCost.Size()
		n += 1 + l + sovMilitary(uint64(l))
	}
	if len(m.BaseStat) > 0 {
		for _, e := range m.BaseStat {
			l = e.Size()
			n += 2 + l + sovMilitary(uint64(l))
		}
	}
	if m.TotalStatSum != 0 {
		n += 2 + sovMilitary(uint64(m.TotalStatSum))
	}
	if len(m.Models) > 0 {
		for _, e := range m.Models {
			n += 2 + sovMilitary(uint64(e))
		}
	}
	return n
}

func (m *CaptainOfficialProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMilitary(uint64(m.Id))
	}
	l = len(m.OfficialName)
	if l > 0 {
		n += 1 + l + sovMilitary(uint64(l))
	}
	if m.SpriteStat != nil {
		l = m.SpriteStat.Size()
		n += 1 + l + sovMilitary(uint64(l))
	}
	if m.NeedGongxun != 0 {
		n += 1 + sovMilitary(uint64(m.NeedGongxun))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovMilitary(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovMilitary(uint64(l))
	}
	return n
}

func (m *MilitaryInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovMilitary(uint64(m.Action))
	}
	if m.MoveType != 0 {
		n += 1 + sovMilitary(uint64(m.MoveType))
	}
	if m.MoveStartTime != 0 {
		n += 1 + sovMilitary(uint64(m.MoveStartTime))
	}
	if m.MoveArrivedTime != 0 {
		n += 1 + sovMilitary(uint64(m.MoveArrivedTime))
	}
	if m.PriorityActionId != 0 {
		n += 1 + sovMilitary(uint64(m.PriorityActionId))
	}
	if m.RobbingEndTime != 0 {
		n += 1 + sovMilitary(uint64(m.RobbingEndTime))
	}
	if m.CreateTime != 0 {
		n += 1 + sovMilitary(uint64(m.CreateTime))
	}
	if m.MoveStartRate1000 != 0 {
		n += 1 + sovMilitary(uint64(m.MoveStartRate1000))
	}
	if len(m.CaptainIndex) > 0 {
		for _, e := range m.CaptainIndex {
			n += 1 + sovMilitary(uint64(e))
		}
	}
	if len(m.Captains) > 0 {
		for _, e := range m.Captains {
			l = e.Size()
			n += 2 + l + sovMilitary(uint64(l))
		}
	}
	if m.SelfNpcDataId != 0 {
		n += 2 + sovMilitary(uint64(m.SelfNpcDataId))
	}
	if m.SelfNpcType != 0 {
		n += 2 + sovMilitary(uint64(m.SelfNpcType))
	}
	if m.SelfIsTent {
		n += 3
	}
	if m.Self != nil {
		l = m.Self.Size()
		n += 2 + l + sovMilitary(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 2 + l + sovMilitary(uint64(l))
	}
	if m.TargetBaseX != 0 {
		n += 2 + sovMilitary(uint64(m.TargetBaseX))
	}
	if m.TargetBaseY != 0 {
		n += 2 + sovMilitary(uint64(m.TargetBaseY))
	}
	if m.TargetIsTent {
		n += 3
	}
	if m.TargetNpcDataId != 0 {
		n += 2 + sovMilitary(uint64(m.TargetNpcDataId))
	}
	if m.TargetNpcType != 0 {
		n += 2 + sovMilitary(uint64(m.TargetNpcType))
	}
	if len(m.KillEnemy) > 0 {
		for _, s := range m.KillEnemy {
			l = len(s)
			n += 2 + l + sovMilitary(uint64(l))
		}
	}
	if m.Gold != 0 {
		n += 2 + sovMilitary(uint64(m.Gold))
	}
	if m.Food != 0 {
		n += 2 + sovMilitary(uint64(m.Food))
	}
	if m.Wood != 0 {
		n += 2 + sovMilitary(uint64(m.Wood))
	}
	if m.Stone != 0 {
		n += 2 + sovMilitary(uint64(m.Stone))
	}
	if m.JadeOre != 0 {
		n += 2 + sovMilitary(uint64(m.JadeOre))
	}
	if m.AccumRobPrize != nil {
		l = m.AccumRobPrize.Size()
		n += 2 + l + sovMilitary(uint64(l))
	}
	if m.AssemblyCount != 0 {
		n += 2 + sovMilitary(uint64(m.AssemblyCount))
	}
	if m.AssemblyTotalCount != 0 {
		n += 2 + sovMilitary(uint64(m.AssemblyTotalCount))
	}
	l = len(m.AssemblyId)
	if l > 0 {
		n += 2 + l + sovMilitary(uint64(l))
	}
	if m.AssemblyTargetNpcType != 0 {
		n += 2 + sovMilitary(uint64(m.AssemblyTargetNpcType))
	}
	if m.MultiLevelMonsterCount != 0 {
		n += 2 + sovMilitary(uint64(m.MultiLevelMonsterCount))
	}
	l = len(m.CombineId)
	if l > 0 {
		n += 2 + l + sovMilitary(uint64(l))
	}
	if m.RegionId != 0 {
		n += 2 + sovMilitary(uint64(m.RegionId))
	}
	return n
}

func (m *AssemblyInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.MoveType != 0 {
		n += 1 + sovMilitary(uint64(m.MoveType))
	}
	if m.MoveStartTime != 0 {
		n += 1 + sovMilitary(uint64(m.MoveStartTime))
	}
	if m.MoveArrivedTime != 0 {
		n += 1 + sovMilitary(uint64(m.MoveArrivedTime))
	}
	if m.RobbingEndTime != 0 {
		n += 1 + sovMilitary(uint64(m.RobbingEndTime))
	}
	if m.Self != nil {
		l = m.Self.Size()
		n += 1 + l + sovMilitary(uint64(l))
	}
	if m.SelfFightAmount != 0 {
		n += 1 + sovMilitary(uint64(m.SelfFightAmount))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 2 + l + sovMilitary(uint64(l))
	}
	if m.TargetBaseX != 0 {
		n += 2 + sovMilitary(uint64(m.TargetBaseX))
	}
	if m.TargetBaseY != 0 {
		n += 2 + sovMilitary(uint64(m.TargetBaseY))
	}
	if m.TargetMorale != 0 {
		n += 2 + sovMilitary(uint64(m.TargetMorale))
	}
	if m.TargetNpcDataId != 0 {
		n += 2 + sovMilitary(uint64(m.TargetNpcDataId))
	}
	if m.TargetNpcType != 0 {
		n += 2 + sovMilitary(uint64(m.TargetNpcType))
	}
	if m.TargetTroop != 0 {
		n += 2 + sovMilitary(uint64(m.TargetTroop))
	}
	if m.TargetTotalTroop != 0 {
		n += 2 + sovMilitary(uint64(m.TargetTotalTroop))
	}
	if len(m.Member) > 0 {
		for _, e := range m.Member {
			l = e.Size()
			n += 2 + l + sovMilitary(uint64(l))
		}
	}
	if m.TotalCount != 0 {
		n += 2 + sovMilitary(uint64(m.TotalCount))
	}
	if m.AddedStat != nil {
		l = m.AddedStat.Size()
		n += 2 + l + sovMilitary(uint64(l))
	}
	return n
}

func (m *AssemblyMemberProto) Size() (n int) {
	var l int
	_ = l
	if m.Hero != nil {
		l = m.Hero.Size()
		n += 1 + l + sovMilitary(uint64(l))
	}
	if m.FightAmount != 0 {
		n += 1 + sovMilitary(uint64(m.FightAmount))
	}
	if m.MoveStartTime != 0 {
		n += 1 + sovMilitary(uint64(m.MoveStartTime))
	}
	if m.MoveArrivedTime != 0 {
		n += 1 + sovMilitary(uint64(m.MoveArrivedTime))
	}
	l = len(m.TroopId)
	if l > 0 {
		n += 1 + l + sovMilitary(uint64(l))
	}
	return n
}

func (m *BaseDefenserProto) Size() (n int) {
	var l int
	_ = l
	if len(m.CaptainIndex) > 0 {
		for _, e := range m.CaptainIndex {
			n += 1 + sovMilitary(uint64(e))
		}
	}
	if len(m.Captains) > 0 {
		for _, e := range m.Captains {
			l = e.Size()
			n += 2 + l + sovMilitary(uint64(l))
		}
	}
	return n
}

func (m *CaptainInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMilitary(uint64(m.Id))
	}
	if m.Race != 0 {
		n += 1 + sovMilitary(uint64(m.Race))
	}
	if m.Quality != 0 {
		n += 1 + sovMilitary(uint64(m.Quality))
	}
	if m.Soldier != 0 {
		n += 1 + sovMilitary(uint64(m.Soldier))
	}
	if m.TotalSoldier != 0 {
		n += 1 + sovMilitary(uint64(m.TotalSoldier))
	}
	if m.FightAmount != 0 {
		n += 1 + sovMilitary(uint64(m.FightAmount))
	}
	if m.Morale != 0 {
		n += 1 + sovMilitary(uint64(m.Morale))
	}
	if m.Level != 0 {
		n += 1 + sovMilitary(uint64(m.Level))
	}
	if m.SoldierLevel != 0 {
		n += 1 + sovMilitary(uint64(m.SoldierLevel))
	}
	if m.Male {
		n += 2
	}
	if m.CanTriggerRestraintSpell {
		n += 2
	}
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovMilitary(uint64(l))
	}
	l = len(m.IconId)
	if l > 0 {
		n += 2 + l + sovMilitary(uint64(l))
	}
	if m.Outside {
		n += 3
	}
	if m.TotalStat != nil {
		l = m.TotalStat.Size()
		n += 2 + l + sovMilitary(uint64(l))
	}
	if m.LifePerSoldier != 0 {
		n += 2 + sovMilitary(uint64(m.LifePerSoldier))
	}
	if m.LoadPerSoldier != 0 {
		n += 2 + sovMilitary(uint64(m.LoadPerSoldier))
	}
	if m.Model != 0 {
		n += 2 + sovMilitary(uint64(m.Model))
	}
	if m.CaptainSoul != 0 {
		n += 2 + sovMilitary(uint64(m.CaptainSoul))
	}
	if m.CaptainSoulLevel != 0 {
		n += 2 + sovMilitary(uint64(m.CaptainSoulLevel))
	}
	if m.RebirthLevel != 0 {
		n += 2 + sovMilitary(uint64(m.RebirthLevel))
	}
	if m.YuanJun {
		n += 3
	}
	if m.FullFightAmount != 0 {
		n += 2 + sovMilitary(uint64(m.FullFightAmount))
	}
	if m.XIndex != 0 {
		n += 2 + sovMilitary(uint64(m.XIndex))
	}
	if m.CaptainId != 0 {
		n += 2 + sovMilitary(uint64(m.CaptainId))
	}
	if m.IsNameless {
		n += 3
	}
	if m.Star != 0 {
		n += 2 + sovMilitary(uint64(m.Star))
	}
	if m.UnlockSpellCount != 0 {
		n += 2 + sovMilitary(uint64(m.UnlockSpellCount))
	}
	if m.SpellFightAmountCoef != 0 {
		n += 2 + sovMilitary(uint64(m.SpellFightAmountCoef))
	}
	return n
}

func (m *HeroMilitaryProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Captains) > 0 {
		for _, e := range m.Captains {
			l = e.Size()
			n += 1 + l + sovMilitary(uint64(l))
		}
	}
	if len(m.OfficialCount) > 0 {
		for _, e := range m.OfficialCount {
			l = e.Size()
			n += 1 + l + sovMilitary(uint64(l))
		}
	}
	if len(m.CaptainFriendship) > 0 {
		for _, e := range m.CaptainFriendship {
			n += 1 + sovMilitary(uint64(e))
		}
	}
	if len(m.Troops) > 0 {
		for _, e := range m.Troops {
			l = e.Size()
			n += 1 + l + sovMilitary(uint64(l))
		}
	}
	if len(m.PveTroops) > 0 {
		for _, e := range m.PveTroops {
			l = e.Size()
			n += 1 + l + sovMilitary(uint64(l))
		}
	}
	if len(m.PveTroop) > 0 {
		for _, e := range m.PveTroop {
			l = e.Size()
			n += 1 + l + sovMilitary(uint64(l))
		}
	}
	if len(m.OfficialView) > 0 {
		for _, e := range m.OfficialView {
			l = e.Size()
			n += 1 + l + sovMilitary(uint64(l))
		}
	}
	if len(m.Captain) > 0 {
		for _, e := range m.Captain {
			l = e.Size()
			n += 1 + l + sovMilitary(uint64(l))
		}
	}
	if m.SoldierLevel != 0 {
		n += 2 + sovMilitary(uint64(m.SoldierLevel))
	}
	if m.SoldierCapcity != 0 {
		n += 2 + sovMilitary(uint64(m.SoldierCapcity))
	}
	if m.FreeSoldier != 0 {
		n += 2 + sovMilitary(uint64(m.FreeSoldier))
	}
	if m.WoundedSoldier != 0 {
		n += 2 + sovMilitary(uint64(m.WoundedSoldier))
	}
	if m.WoundedSoldierCapcity != 0 {
		n += 2 + sovMilitary(uint64(m.WoundedSoldierCapcity))
	}
	if m.NewSoldier != 0 {
		n += 2 + sovMilitary(uint64(m.NewSoldier))
	}
	if m.NewSoldierCapcity != 0 {
		n += 2 + sovMilitary(uint64(m.NewSoldierCapcity))
	}
	if m.NewSoldierOutput != 0 {
		n += 2 + sovMilitary(uint64(m.NewSoldierOutput))
	}
	if m.NewSoldierRecruitCount != 0 {
		n += 2 + sovMilitary(uint64(m.NewSoldierRecruitCount))
	}
	if m.JiuGuanRefreshTimes != 0 {
		n += 2 + sovMilitary(uint64(m.JiuGuanRefreshTimes))
	}
	if m.JiuGuanTutorIndex != 0 {
		n += 2 + sovMilitary(uint64(m.JiuGuanTutorIndex))
	}
	if m.JiuGuanTimes != 0 {
		n += 2 + sovMilitary(uint64(m.JiuGuanTimes))
	}
	if m.JiuGuanNextTime != 0 {
		n += 2 + sovMilitary(uint64(m.JiuGuanNextTime))
	}
	if m.JunYingRecruitStartRecoveyTime != 0 {
		n += 2 + sovMilitary(uint64(m.JunYingRecruitStartRecoveyTime))
	}
	if m.NextExpelTime != 0 {
		n += 2 + sovMilitary(uint64(m.NextExpelTime))
	}
	if m.GlobalTrainStartTime != 0 {
		n += 2 + sovMilitary(uint64(m.GlobalTrainStartTime))
	}
	if m.CaptainTrainStartTime != 0 {
		n += 2 + sovMilitary(uint64(m.CaptainTrainStartTime))
	}
	if m.TrainCoef != 0 {
		n += 2 + sovMilitary(uint64(m.TrainCoef))
	}
	if m.FreeSoldierStartRecoveryTime != 0 {
		n += 2 + sovMilitary(uint64(m.FreeSoldierStartRecoveryTime))
	}
	if m.FreeSoldierCapcity != 0 {
		n += 2 + sovMilitary(uint64(m.FreeSoldierCapcity))
	}
	if m.FreeSoldierOutput != 0 {
		n += 2 + sovMilitary(uint64(m.FreeSoldierOutput))
	}
	if m.OverflowFreeSoldier != 0 {
		n += 2 + sovMilitary(uint64(m.OverflowFreeSoldier))
	}
	if m.ForceAddSoldierTimes != 0 {
		n += 2 + sovMilitary(uint64(m.ForceAddSoldierTimes))
	}
	if m.InvestigateTroop != nil {
		l = m.InvestigateTroop.Size()
		n += 2 + l + sovMilitary(uint64(l))
	}
	return n
}

func (m *HeroCaptainOfficialCount) Size() (n int) {
	var l int
	_ = l
	if m.OfficialId != 0 {
		n += 1 + sovMilitary(uint64(m.OfficialId))
	}
	if m.Count != 0 {
		n += 1 + sovMilitary(uint64(m.Count))
	}
	return n
}

func (m *PveTroopDataProto) Size() (n int) {
	var l int
	_ = l
	if m.PveTroopType != 0 {
		n += 1 + sovMilitary(uint64(m.PveTroopType))
	}
	if m.Capacity != 0 {
		n += 1 + sovMilitary(uint64(m.Capacity))
	}
	if m.MinCaptainCount != 0 {
		n += 1 + sovMilitary(uint64(m.MinCaptainCount))
	}
	return n
}

func (m *HeroTroopProto) Size() (n int) {
	var l int
	_ = l
	if m.Sequence != 0 {
		n += 1 + sovMilitary(uint64(m.Sequence))
	}
	if len(m.Captains) > 0 {
		for _, e := range m.Captains {
			n += 1 + sovMilitary(uint64(e))
		}
	}
	if m.IsOutside {
		n += 2
	}
	if len(m.Captains2) > 0 {
		for _, e := range m.Captains2 {
			n += 1 + sovMilitary(uint64(e))
		}
	}
	if len(m.XIndex) > 0 {
		for _, e := range m.XIndex {
			n += 1 + sovMilitary(uint64(e))
		}
	}
	return n
}

func (m *HeroPveTroopProto) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMilitary(uint64(m.Type))
	}
	if len(m.Captains) > 0 {
		for _, e := range m.Captains {
			n += 1 + sovMilitary(uint64(e))
		}
	}
	if len(m.Captains2) > 0 {
		for _, e := range m.Captains2 {
			n += 1 + sovMilitary(uint64(e))
		}
	}
	if len(m.XIndex) > 0 {
		for _, e := range m.XIndex {
			n += 1 + sovMilitary(uint64(e))
		}
	}
	return n
}

func (m *CaptainProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMilitary(uint64(m.Id))
	}
	if m.Star != 0 {
		n += 1 + sovMilitary(uint64(m.Star))
	}
	if m.Ability != 0 {
		n += 1 + sovMilitary(uint64(m.Ability))
	}
	if m.Exp != 0 {
		n += 1 + sovMilitary(uint64(m.Exp))
	}
	if m.Level != 0 {
		n += 1 + sovMilitary(uint64(m.Level))
	}
	if m.Soldier != 0 {
		n += 1 + sovMilitary(uint64(m.Soldier))
	}
	if m.FightAmount != 0 {
		n += 1 + sovMilitary(uint64(m.FightAmount))
	}
	if m.TotalStat != nil {
		l = m.TotalStat.Size()
		n += 1 + l + sovMilitary(uint64(l))
	}
	if m.AbilityExp != 0 {
		n += 1 + sovMilitary(uint64(m.AbilityExp))
	}
	if m.Taoz != 0 {
		n += 2 + sovMilitary(uint64(m.Taoz))
	}
	if m.FullSoldierFightAmount != 0 {
		n += 2 + sovMilitary(uint64(m.FullSoldierFightAmount))
	}
	if m.AbilityLimit != 0 {
		n += 2 + sovMilitary(uint64(m.AbilityLimit))
	}
	l = len(m.IconId)
	if l > 0 {
		n += 2 + l + sovMilitary(uint64(l))
	}
	if m.Rebirth != 0 {
		n += 2 + sovMilitary(uint64(m.Rebirth))
	}
	if m.RebirthCdEndTime != 0 {
		n += 2 + sovMilitary(uint64(m.RebirthCdEndTime))
	}
	if len(m.Equipment) > 0 {
		for _, e := range m.Equipment {
			l = e.Size()
			n += 2 + l + sovMilitary(uint64(l))
		}
	}
	if len(m.Gems) > 0 {
		for _, e := range m.Gems {
			l = e.Size()
			n += 2 + l + sovMilitary(uint64(l))
		}
	}
	if m.Gongxun != 0 {
		n += 2 + sovMilitary(uint64(m.Gongxun))
	}
	if m.Official != 0 {
		n += 2 + sovMilitary(uint64(m.Official))
	}
	if m.OfficialIdx != 0 {
		n += 2 + sovMilitary(uint64(m.OfficialIdx))
	}
	if m.Viewed {
		n += 3
	}
	return n
}

func (m *HeroCaptainProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMilitary(uint64(m.Id))
	}
	if m.Male {
		n += 2
	}
	if m.Race != 0 {
		n += 1 + sovMilitary(uint64(m.Race))
	}
	if m.Quality != 0 {
		n += 1 + sovMilitary(uint64(m.Quality))
	}
	if m.Ability != 0 {
		n += 1 + sovMilitary(uint64(m.Ability))
	}
	if m.Exp != 0 {
		n += 1 + sovMilitary(uint64(m.Exp))
	}
	if m.Level != 0 {
		n += 1 + sovMilitary(uint64(m.Level))
	}
	if m.Soldier != 0 {
		n += 1 + sovMilitary(uint64(m.Soldier))
	}
	if m.FightAmount != 0 {
		n += 1 + sovMilitary(uint64(m.FightAmount))
	}
	if m.TotalStat != nil {
		l = m.TotalStat.Size()
		n += 1 + l + sovMilitary(uint64(l))
	}
	if m.AbilityExp != 0 {
		n += 1 + sovMilitary(uint64(m.AbilityExp))
	}
	if m.Morale != 0 {
		n += 2 + sovMilitary(uint64(m.Morale))
	}
	if m.Taoz != 0 {
		n += 2 + sovMilitary(uint64(m.Taoz))
	}
	if m.FullSoldierFightAmount != 0 {
		n += 2 + sovMilitary(uint64(m.FullSoldierFightAmount))
	}
	if m.AbilityLimit != 0 {
		n += 2 + sovMilitary(uint64(m.AbilityLimit))
	}
	l = len(m.IconId)
	if l > 0 {
		n += 2 + l + sovMilitary(uint64(l))
	}
	if m.RaceCdEndTime != 0 {
		n += 2 + sovMilitary(uint64(m.RaceCdEndTime))
	}
	if m.RebirthExp != 0 {
		n += 2 + sovMilitary(uint64(m.RebirthExp))
	}
	if m.Rebirth != 0 {
		n += 2 + sovMilitary(uint64(m.Rebirth))
	}
	if m.Name != nil {
		l = m.Name.Size()
		n += 2 + l + sovMilitary(uint64(l))
	}
	if m.RebirthCdEndTime != 0 {
		n += 2 + sovMilitary(uint64(m.RebirthCdEndTime))
	}
	if len(m.Equipment) > 0 {
		for _, e := range m.Equipment {
			l = e.Size()
			n += 2 + l + sovMilitary(uint64(l))
		}
	}
	if len(m.Gems) > 0 {
		for _, e := range m.Gems {
			l = e.Size()
			n += 2 + l + sovMilitary(uint64(l))
		}
	}
	if m.FuShenCaptainSoulId != 0 {
		n += 2 + sovMilitary(uint64(m.FuShenCaptainSoulId))
	}
	if m.RestraintSpellUnlocked {
		n += 3
	}
	if m.Gongxun != 0 {
		n += 2 + sovMilitary(uint64(m.Gongxun))
	}
	if m.Official != 0 {
		n += 2 + sovMilitary(uint64(m.Official))
	}
	return n
}

func (m *HeroCaptainGemProto) Size() (n int) {
	var l int
	_ = l
	if m.Gem != 0 {
		n += 1 + sovMilitary(uint64(m.Gem))
	}
	if m.SlotIdx != 0 {
		n += 1 + sovMilitary(uint64(m.SlotIdx))
	}
	return n
}

func (m *CaptainSkillProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMilitary(uint64(m.Id))
	}
	if m.Level != 0 {
		n += 1 + sovMilitary(uint64(m.Level))
	}
	return n
}

func (m *HeroCaptainOtherProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMilitary(uint64(m.Id))
	}
	if m.Star != 0 {
		n += 1 + sovMilitary(uint64(m.Star))
	}
	if m.Male {
		n += 2
	}
	if m.Race != 0 {
		n += 1 + sovMilitary(uint64(m.Race))
	}
	if m.Quality != 0 {
		n += 1 + sovMilitary(uint64(m.Quality))
	}
	if m.Ability != 0 {
		n += 1 + sovMilitary(uint64(m.Ability))
	}
	if m.Level != 0 {
		n += 1 + sovMilitary(uint64(m.Level))
	}
	if m.SoldierLevel != 0 {
		n += 1 + sovMilitary(uint64(m.SoldierLevel))
	}
	if m.TotalStat != nil {
		l = m.TotalStat.Size()
		n += 1 + l + sovMilitary(uint64(l))
	}
	if m.FullSoldierFightAmount != 0 {
		n += 2 + sovMilitary(uint64(m.FullSoldierFightAmount))
	}
	l = len(m.IconId)
	if l > 0 {
		n += 2 + l + sovMilitary(uint64(l))
	}
	if m.Rebirth != 0 {
		n += 2 + sovMilitary(uint64(m.Rebirth))
	}
	if m.Name != nil {
		l = m.Name.Size()
		n += 2 + l + sovMilitary(uint64(l))
	}
	if len(m.Equipment) > 0 {
		for _, e := range m.Equipment {
			l = e.Size()
			n += 2 + l + sovMilitary(uint64(l))
		}
	}
	if len(m.Gems) > 0 {
		for _, e := range m.Gems {
			l = e.Size()
			n += 2 + l + sovMilitary(uint64(l))
		}
	}
	if m.CaptainSoul != 0 {
		n += 2 + sovMilitary(uint64(m.CaptainSoul))
	}
	if m.CaptainSoulLevel != 0 {
		n += 2 + sovMilitary(uint64(m.CaptainSoulLevel))
	}
	if m.Official != 0 {
		n += 2 + sovMilitary(uint64(m.Official))
	}
	return n
}

func sovMilitary(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMilitary(x uint64) (n int) {
	return sovMilitary(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StrongerDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StrongerDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StrongerDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			m.Z = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Z |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JiuGuanMiscDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JiuGuanMiscDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JiuGuanMiscDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimes", wireType)
			}
			m.MaxTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RefreshCostYuanBao = append(m.RefreshCostYuanBao, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMilitary
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMilitary
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RefreshCostYuanBao = append(m.RefreshCostYuanBao, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshCostYuanBao", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryDuration", wireType)
			}
			m.RecoveryDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecoveryDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshCost = append(m.RefreshCost, &CostProto{})
			if err := m.RefreshCost[len(m.RefreshCost)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TutorDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TutorDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TutorDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatContent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatContent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshMaxCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RefreshMaxCost == nil {
				m.RefreshMaxCost = &CostProto{}
			}
			if err := m.RefreshMaxCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JiuGuanDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JiuGuanDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JiuGuanDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TutorDatas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TutorDatas = append(m.TutorDatas, &TutorDataProto{})
			if err := m.TutorDatas[len(m.TutorDatas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BroadcastContent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BroadcastContent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryDuration", wireType)
			}
			m.RecoveryDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecoveryDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimes", wireType)
			}
			m.MaxTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JunYingLevelDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JunYingLevelDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JunYingLevelDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimes", wireType)
			}
			m.MaxTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryDuration", wireType)
			}
			m.RecoveryDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecoveryDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JunYingMiscProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JunYingMiscProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JunYingMiscProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceAddSoldierMaxTimes", wireType)
			}
			m.ForceAddSoldierMaxTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceAddSoldierMaxTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ForceAddSoldierCost = append(m.ForceAddSoldierCost, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMilitary
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMilitary
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ForceAddSoldierCost = append(m.ForceAddSoldierCost, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceAddSoldierCost", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceAddSoldierNewCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForceAddSoldierNewCost = append(m.ForceAddSoldierNewCost, &CostProto{})
			if err := m.ForceAddSoldierNewCost[len(m.ForceAddSoldierNewCost)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrainingLevelProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrainingLevelProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrainingLevelProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpOutput", wireType)
			}
			m.ExpOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpCapcity", wireType)
			}
			m.ExpCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &CostProto{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coef", wireType)
			}
			m.Coef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptainAbilityProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptainAbilityProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptainAbilityProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ability", wireType)
			}
			m.Ability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ability |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeExp", wireType)
			}
			m.UpgradeExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradeExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SellPrice == nil {
				m.SellPrice = &PrizeProto{}
			}
			if err := m.SellPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (Quality(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirePrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FirePrice == nil {
				m.FirePrice = &PrizeProto{}
			}
			if err := m.FirePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Models = append(m.Models, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMilitary
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMilitary
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Models = append(m.Models, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Models", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockSpellCount", wireType)
			}
			m.UnlockSpellCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnlockSpellCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResetCost == nil {
				m.ResetCost = &CostProto{}
			}
			if err := m.ResetCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptainGeneratorProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptainGeneratorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptainGeneratorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedHeroLevel", wireType)
			}
			m.NeedHeroLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedHeroLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptainLevelProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptainLevelProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptainLevelProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeExp", wireType)
			}
			m.UpgradeExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradeExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasNewGemSlot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasNewGemSlot = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbilityLimit", wireType)
			}
			m.AbilityLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbilityLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rebirth", wireType)
			}
			m.Rebirth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rebirth |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GemSlotCount", wireType)
			}
			m.GemSlotCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GemSlotCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptainRebirthLevelProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptainRebirthLevelProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptainRebirthLevelProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RebirthUpgradeExp", wireType)
			}
			m.RebirthUpgradeExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RebirthUpgradeExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainLevelLimit", wireType)
			}
			m.CaptainLevelLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainLevelLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yuanbao", wireType)
			}
			m.Yuanbao = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Yuanbao |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpriteStatPoint", wireType)
			}
			m.SpriteStatPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpriteStatPoint |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldierCapcity", wireType)
			}
			m.SoldierCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoldierCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbilityLimit", wireType)
			}
			m.AbilityLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbilityLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbilityExp", wireType)
			}
			m.AbilityExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbilityExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cd", wireType)
			}
			m.Cd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeforeRebirthLevel", wireType)
			}
			m.BeforeRebirthLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeforeRebirthLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroLevelLimit", wireType)
			}
			m.HeroLevelLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroLevelLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptainSeekerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptainSeekerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptainSeekerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredHeroLevel", wireType)
			}
			m.RequiredHeroLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredHeroLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Male", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Male = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Race", wireType)
			}
			m.Race = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Race |= (Race(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (Quality(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ability", wireType)
			}
			m.Ability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ability |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FamilyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &CaptainNameProto{}
			}
			if err := m.Name.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GivenName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GivenName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SoldierLevelProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SoldierLevelProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SoldierLevelProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load", wireType)
			}
			m.Load = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Load |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JunYingLevel", wireType)
			}
			m.JunYingLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JunYingLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecruitCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecruitCost == nil {
				m.RecruitCost = &CostProto{}
			}
			if err := m.RecruitCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WoundedCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WoundedCost == nil {
				m.WoundedCost = &CostProto{}
			}
			if err := m.WoundedCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpgradeCost == nil {
				m.UpgradeCost = &CostProto{}
			}
			if err := m.UpgradeCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseStat = append(m.BaseStat, &SpriteStatProto{})
			if err := m.BaseStat[len(m.BaseStat)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStatSum", wireType)
			}
			m.TotalStatSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalStatSum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Models = append(m.Models, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMilitary
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMilitary
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Models = append(m.Models, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Models", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptainOfficialProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptainOfficialProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptainOfficialProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfficialName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OfficialName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpriteStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpriteStat == nil {
				m.SpriteStat = &SpriteStatProto{}
			}
			if err := m.SpriteStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedGongxun", wireType)
			}
			m.NeedGongxun = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedGongxun |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MilitaryInfoProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MilitaryInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MilitaryInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveType", wireType)
			}
			m.MoveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveStartTime", wireType)
			}
			m.MoveStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveStartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveArrivedTime", wireType)
			}
			m.MoveArrivedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveArrivedTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityActionId", wireType)
			}
			m.PriorityActionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriorityActionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobbingEndTime", wireType)
			}
			m.RobbingEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobbingEndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveStartRate1000", wireType)
			}
			m.MoveStartRate1000 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveStartRate1000 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainIndex = append(m.CaptainIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMilitary
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMilitary
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainIndex = append(m.CaptainIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainIndex", wireType)
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Captains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Captains = append(m.Captains, &CaptainInfoProto{})
			if err := m.Captains[len(m.Captains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfNpcDataId", wireType)
			}
			m.SelfNpcDataId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfNpcDataId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfNpcType", wireType)
			}
			m.SelfNpcType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfNpcType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfIsTent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SelfIsTent = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Self", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Self == nil {
				m.Self = &HeroBasicSnapshotProto{}
			}
			if err := m.Self.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &HeroBasicSnapshotProto{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBaseX", wireType)
			}
			m.TargetBaseX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetBaseX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBaseY", wireType)
			}
			m.TargetBaseY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetBaseY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetIsTent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TargetIsTent = bool(v != 0)
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetNpcDataId", wireType)
			}
			m.TargetNpcDataId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetNpcDataId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetNpcType", wireType)
			}
			m.TargetNpcType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetNpcType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillEnemy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KillEnemy = append(m.KillEnemy, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Food", wireType)
			}
			m.Food = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Food |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wood", wireType)
			}
			m.Wood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Wood |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stone", wireType)
			}
			m.Stone = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stone |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JadeOre", wireType)
			}
			m.JadeOre = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JadeOre |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccumRobPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccumRobPrize == nil {
				m.AccumRobPrize = &PrizeProto{}
			}
			if err := m.AccumRobPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 61:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssemblyCount", wireType)
			}
			m.AssemblyCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssemblyCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 62:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssemblyTotalCount", wireType)
			}
			m.AssemblyTotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssemblyTotalCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 63:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssemblyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssemblyId = append(m.AssemblyId[:0], dAtA[iNdEx:postIndex]...)
			if m.AssemblyId == nil {
				m.AssemblyId = []byte{}
			}
			iNdEx = postIndex
		case 64:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssemblyTargetNpcType", wireType)
			}
			m.AssemblyTargetNpcType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssemblyTargetNpcType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 65:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiLevelMonsterCount", wireType)
			}
			m.MultiLevelMonsterCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MultiLevelMonsterCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CombineId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CombineId = append(m.CombineId[:0], dAtA[iNdEx:postIndex]...)
			if m.CombineId == nil {
				m.CombineId = []byte{}
			}
			iNdEx = postIndex
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			m.RegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssemblyInfoProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssemblyInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssemblyInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveType", wireType)
			}
			m.MoveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveStartTime", wireType)
			}
			m.MoveStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveStartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveArrivedTime", wireType)
			}
			m.MoveArrivedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveArrivedTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobbingEndTime", wireType)
			}
			m.RobbingEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobbingEndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Self", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Self == nil {
				m.Self = &HeroBasicSnapshotProto{}
			}
			if err := m.Self.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfFightAmount", wireType)
			}
			m.SelfFightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfFightAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &HeroBasicSnapshotProto{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBaseX", wireType)
			}
			m.TargetBaseX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetBaseX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBaseY", wireType)
			}
			m.TargetBaseY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetBaseY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetMorale", wireType)
			}
			m.TargetMorale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetMorale |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetNpcDataId", wireType)
			}
			m.TargetNpcDataId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetNpcDataId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetNpcType", wireType)
			}
			m.TargetNpcType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetNpcType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetTroop", wireType)
			}
			m.TargetTroop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetTroop |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetTotalTroop", wireType)
			}
			m.TargetTotalTroop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetTotalTroop |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Member = append(m.Member, &AssemblyMemberProto{})
			if err := m.Member[len(m.Member)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddedStat == nil {
				m.AddedStat = &SpriteStatProto{}
			}
			if err := m.AddedStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssemblyMemberProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssemblyMemberProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssemblyMemberProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hero", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hero == nil {
				m.Hero = &HeroBasicSnapshotProto{}
			}
			if err := m.Hero.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightAmount", wireType)
			}
			m.FightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveStartTime", wireType)
			}
			m.MoveStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveStartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveArrivedTime", wireType)
			}
			m.MoveArrivedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveArrivedTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TroopId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TroopId = append(m.TroopId[:0], dAtA[iNdEx:postIndex]...)
			if m.TroopId == nil {
				m.TroopId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseDefenserProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseDefenserProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseDefenserProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 15:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainIndex = append(m.CaptainIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMilitary
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMilitary
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainIndex = append(m.CaptainIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainIndex", wireType)
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Captains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Captains = append(m.Captains, &CaptainInfoProto{})
			if err := m.Captains[len(m.Captains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptainInfoProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptainInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptainInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Race", wireType)
			}
			m.Race = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Race |= (Race(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (Quality(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Soldier", wireType)
			}
			m.Soldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Soldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSoldier", wireType)
			}
			m.TotalSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightAmount", wireType)
			}
			m.FightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Morale", wireType)
			}
			m.Morale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Morale |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldierLevel", wireType)
			}
			m.SoldierLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoldierLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Male", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Male = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanTriggerRestraintSpell", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanTriggerRestraintSpell = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &CaptainNameProto{}
			}
			if err := m.Name.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outside", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Outside = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalStat == nil {
				m.TotalStat = &SpriteStatProto{}
			}
			if err := m.TotalStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LifePerSoldier", wireType)
			}
			m.LifePerSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LifePerSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadPerSoldier", wireType)
			}
			m.LoadPerSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadPerSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			m.Model = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Model |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainSoul", wireType)
			}
			m.CaptainSoul = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainSoul |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainSoulLevel", wireType)
			}
			m.CaptainSoulLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainSoulLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RebirthLevel", wireType)
			}
			m.RebirthLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RebirthLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YuanJun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.YuanJun = bool(v != 0)
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullFightAmount", wireType)
			}
			m.FullFightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FullFightAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XIndex", wireType)
			}
			m.XIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainId", wireType)
			}
			m.CaptainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNameless", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNameless = bool(v != 0)
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockSpellCount", wireType)
			}
			m.UnlockSpellCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnlockSpellCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpellFightAmountCoef", wireType)
			}
			m.SpellFightAmountCoef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpellFightAmountCoef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroMilitaryProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroMilitaryProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroMilitaryProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Captains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Captains = append(m.Captains, &HeroCaptainProto{})
			if err := m.Captains[len(m.Captains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfficialCount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OfficialCount = append(m.OfficialCount, &HeroCaptainOfficialCount{})
			if err := m.OfficialCount[len(m.OfficialCount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainFriendship = append(m.CaptainFriendship, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMilitary
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMilitary
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainFriendship = append(m.CaptainFriendship, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainFriendship", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Troops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Troops = append(m.Troops, &HeroTroopProto{})
			if err := m.Troops[len(m.Troops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PveTroops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PveTroops = append(m.PveTroops, &HeroPveTroopProto{})
			if err := m.PveTroops[len(m.PveTroops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PveTroop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PveTroop = append(m.PveTroop, &HeroPveTroopProto{})
			if err := m.PveTroop[len(m.PveTroop)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfficialView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OfficialView = append(m.OfficialView, &Int32PairInt32ArrayProto{})
			if err := m.OfficialView[len(m.OfficialView)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Captain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Captain = append(m.Captain, &CaptainProto{})
			if err := m.Captain[len(m.Captain)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldierLevel", wireType)
			}
			m.SoldierLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoldierLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldierCapcity", wireType)
			}
			m.SoldierCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoldierCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeSoldier", wireType)
			}
			m.FreeSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WoundedSoldier", wireType)
			}
			m.WoundedSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WoundedSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WoundedSoldierCapcity", wireType)
			}
			m.WoundedSoldierCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WoundedSoldierCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSoldier", wireType)
			}
			m.NewSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSoldierCapcity", wireType)
			}
			m.NewSoldierCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewSoldierCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSoldierOutput", wireType)
			}
			m.NewSoldierOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewSoldierOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSoldierRecruitCount", wireType)
			}
			m.NewSoldierRecruitCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewSoldierRecruitCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JiuGuanRefreshTimes", wireType)
			}
			m.JiuGuanRefreshTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JiuGuanRefreshTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JiuGuanTutorIndex", wireType)
			}
			m.JiuGuanTutorIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JiuGuanTutorIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JiuGuanTimes", wireType)
			}
			m.JiuGuanTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JiuGuanTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JiuGuanNextTime", wireType)
			}
			m.JiuGuanNextTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JiuGuanNextTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JunYingRecruitStartRecoveyTime", wireType)
			}
			m.JunYingRecruitStartRecoveyTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JunYingRecruitStartRecoveyTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextExpelTime", wireType)
			}
			m.NextExpelTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextExpelTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalTrainStartTime", wireType)
			}
			m.GlobalTrainStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalTrainStartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainTrainStartTime", wireType)
			}
			m.CaptainTrainStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainTrainStartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainCoef", wireType)
			}
			m.TrainCoef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainCoef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeSoldierStartRecoveryTime", wireType)
			}
			m.FreeSoldierStartRecoveryTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeSoldierStartRecoveryTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 57:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeSoldierCapcity", wireType)
			}
			m.FreeSoldierCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeSoldierCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeSoldierOutput", wireType)
			}
			m.FreeSoldierOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeSoldierOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverflowFreeSoldier", wireType)
			}
			m.OverflowFreeSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverflowFreeSoldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceAddSoldierTimes", wireType)
			}
			m.ForceAddSoldierTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceAddSoldierTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvestigateTroop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InvestigateTroop == nil {
				m.InvestigateTroop = &HeroTroopProto{}
			}
			if err := m.InvestigateTroop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroCaptainOfficialCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroCaptainOfficialCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroCaptainOfficialCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfficialId", wireType)
			}
			m.OfficialId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OfficialId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PveTroopDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PveTroopDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PveTroopDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PveTroopType", wireType)
			}
			m.PveTroopType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PveTroopType |= (PveTroopType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			m.Capacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Capacity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCaptainCount", wireType)
			}
			m.MinCaptainCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCaptainCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroTroopProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroTroopProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroTroopProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Captains = append(m.Captains, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMilitary
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMilitary
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Captains = append(m.Captains, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Captains", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOutside", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOutside = bool(v != 0)
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Captains2 = append(m.Captains2, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMilitary
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMilitary
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Captains2 = append(m.Captains2, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Captains2", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XIndex = append(m.XIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMilitary
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMilitary
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XIndex = append(m.XIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XIndex", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroPveTroopProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroPveTroopProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroPveTroopProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (PveTroopType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Captains = append(m.Captains, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMilitary
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMilitary
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Captains = append(m.Captains, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Captains", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Captains2 = append(m.Captains2, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMilitary
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMilitary
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Captains2 = append(m.Captains2, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Captains2", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XIndex = append(m.XIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMilitary
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMilitary
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XIndex = append(m.XIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XIndex", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptainProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptainProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptainProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ability", wireType)
			}
			m.Ability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ability |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Soldier", wireType)
			}
			m.Soldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Soldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightAmount", wireType)
			}
			m.FightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalStat == nil {
				m.TotalStat = &SpriteStatProto{}
			}
			if err := m.TotalStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbilityExp", wireType)
			}
			m.AbilityExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbilityExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Taoz", wireType)
			}
			m.Taoz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Taoz |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullSoldierFightAmount", wireType)
			}
			m.FullSoldierFightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FullSoldierFightAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbilityLimit", wireType)
			}
			m.AbilityLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbilityLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rebirth", wireType)
			}
			m.Rebirth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rebirth |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RebirthCdEndTime", wireType)
			}
			m.RebirthCdEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RebirthCdEndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equipment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Equipment = append(m.Equipment, &EquipmentProto{})
			if err := m.Equipment[len(m.Equipment)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gems = append(m.Gems, &HeroCaptainGemProto{})
			if err := m.Gems[len(m.Gems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gongxun", wireType)
			}
			m.Gongxun = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gongxun |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Official", wireType)
			}
			m.Official = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Official |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfficialIdx", wireType)
			}
			m.OfficialIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OfficialIdx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Viewed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Viewed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroCaptainProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroCaptainProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroCaptainProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Male", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Male = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Race", wireType)
			}
			m.Race = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Race |= (Race(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (Quality(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ability", wireType)
			}
			m.Ability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ability |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Soldier", wireType)
			}
			m.Soldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Soldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightAmount", wireType)
			}
			m.FightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalStat == nil {
				m.TotalStat = &SpriteStatProto{}
			}
			if err := m.TotalStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbilityExp", wireType)
			}
			m.AbilityExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbilityExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Morale", wireType)
			}
			m.Morale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Morale |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Taoz", wireType)
			}
			m.Taoz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Taoz |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullSoldierFightAmount", wireType)
			}
			m.FullSoldierFightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FullSoldierFightAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbilityLimit", wireType)
			}
			m.AbilityLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbilityLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaceCdEndTime", wireType)
			}
			m.RaceCdEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaceCdEndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RebirthExp", wireType)
			}
			m.RebirthExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RebirthExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rebirth", wireType)
			}
			m.Rebirth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rebirth |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &CaptainNameProto{}
			}
			if err := m.Name.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RebirthCdEndTime", wireType)
			}
			m.RebirthCdEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RebirthCdEndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equipment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Equipment = append(m.Equipment, &EquipmentProto{})
			if err := m.Equipment[len(m.Equipment)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gems = append(m.Gems, &HeroCaptainGemProto{})
			if err := m.Gems[len(m.Gems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuShenCaptainSoulId", wireType)
			}
			m.FuShenCaptainSoulId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FuShenCaptainSoulId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestraintSpellUnlocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RestraintSpellUnlocked = bool(v != 0)
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gongxun", wireType)
			}
			m.Gongxun = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gongxun |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Official", wireType)
			}
			m.Official = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Official |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroCaptainGemProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroCaptainGemProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroCaptainGemProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gem", wireType)
			}
			m.Gem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gem |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotIdx", wireType)
			}
			m.SlotIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlotIdx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptainSkillProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptainSkillProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptainSkillProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroCaptainOtherProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroCaptainOtherProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroCaptainOtherProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Male", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Male = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Race", wireType)
			}
			m.Race = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Race |= (Race(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (Quality(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ability", wireType)
			}
			m.Ability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ability |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldierLevel", wireType)
			}
			m.SoldierLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoldierLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalStat == nil {
				m.TotalStat = &SpriteStatProto{}
			}
			if err := m.TotalStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullSoldierFightAmount", wireType)
			}
			m.FullSoldierFightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FullSoldierFightAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rebirth", wireType)
			}
			m.Rebirth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rebirth |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &CaptainNameProto{}
			}
			if err := m.Name.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equipment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Equipment = append(m.Equipment, &EquipmentProto{})
			if err := m.Equipment[len(m.Equipment)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gems = append(m.Gems, &HeroCaptainGemProto{})
			if err := m.Gems[len(m.Gems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainSoul", wireType)
			}
			m.CaptainSoul = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainSoul |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainSoulLevel", wireType)
			}
			m.CaptainSoulLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainSoulLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Official", wireType)
			}
			m.Official = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Official |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMilitary(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMilitary
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMilitary(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMilitary = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMilitary   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/shared_proto/military.proto", fileDescriptorMilitary)
}

var fileDescriptorMilitary = []byte{
	// 3946 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x5a, 0xcd, 0x77, 0x1b, 0x47,
	0x72, 0x37, 0xc0, 0x0f, 0x00, 0x05, 0x10, 0x04, 0x86, 0x5f, 0x43, 0xca, 0x92, 0x68, 0x48, 0x96,
	0x94, 0x5d, 0x9b, 0x94, 0x49, 0xcb, 0xb2, 0x36, 0xeb, 0x24, 0x24, 0x45, 0xc9, 0x74, 0x2c, 0x4a,
	0x0b, 0x52, 0xbb, 0xeb, 0xbd, 0xcc, 0x1b, 0x62, 0x1a, 0xe0, 0xc8, 0x83, 0x19, 0x68, 0x3e, 0x48,
	0x50, 0x7f, 0x43, 0x72, 0xcc, 0xc7, 0x7b, 0xf9, 0x0f, 0x72, 0xca, 0x25, 0x87, 0x5c, 0x73, 0xca,
	0x21, 0x2f, 0xd9, 0x5b, 0x92, 0x4b, 0x5e, 0x9e, 0xf7, 0x9c, 0x3f, 0x60, 0x6f, 0x79, 0xf5, 0xd1,
	0x83, 0x01, 0x48, 0x88, 0xb4, 0xfd, 0x76, 0xbd, 0x39, 0x11, 0x5d, 0x5d, 0xd5, 0xd3, 0x55, 0x5d,
	0xf5, 0xab, 0xaa, 0x6e, 0xc2, 0xa7, 0x1d, 0x37, 0x3e, 0x4e, 0x8e, 0xd6, 0x5a, 0x41, 0x77, 0xdd,
	0x73, 0x3b, 0xc7, 0x71, 0xcf, 0x3e, 0x5d, 0xef, 0xda, 0x9e, 0x7a, 0xb8, 0xde, 0x3b, 0x5a, 0x8f,
	0x8e, 0xed, 0x50, 0x39, 0x56, 0x2f, 0x0c, 0xe2, 0x60, 0xbd, 0xeb, 0x7a, 0x6e, 0x6c, 0x87, 0x67,
	0x6b, 0x34, 0x34, 0xa6, 0xe8, 0xcf, 0xca, 0xc7, 0x57, 0x5f, 0xe0, 0xc8, 0x8e, 0x14, 0x0b, 0xaf,
	0x3c, 0xb8, 0xba, 0x54, 0x27, 0x08, 0x9c, 0x48, 0xc4, 0xbe, 0xc5, 0x6e, 0x23, 0xdf, 0xee, 0x45,
	0xc7, 0x41, 0xcc, 0x92, 0x8d, 0x0e, 0xd4, 0x0f, 0xe2, 0x30, 0xf0, 0x3b, 0x2a, 0x7c, 0x6c, 0xc7,
	0xf6, 0x0b, 0x52, 0x61, 0x1e, 0xa6, 0x3c, 0x75, 0xa2, 0x3c, 0x33, 0xb7, 0x9a, 0xbb, 0x37, 0xd5,
	0xe4, 0x81, 0x61, 0xc0, 0x64, 0x7c, 0xd6, 0x53, 0x66, 0x9e, 0x88, 0xf4, 0xdb, 0xa8, 0x40, 0xae,
	0x6f, 0x96, 0x89, 0x90, 0xeb, 0xe3, 0xe8, 0xcc, 0xac, 0xf0, 0xe8, 0x0c, 0x47, 0x6f, 0xcc, 0x19,
	0x1e, 0xbd, 0x69, 0xfc, 0x5b, 0x0e, 0xe6, 0xbf, 0x70, 0x93, 0xa7, 0x89, 0xed, 0x3f, 0x73, 0xa3,
	0xd6, 0xe0, 0x63, 0xd7, 0xa0, 0xd4, 0xb5, 0xfb, 0x56, 0xec, 0x76, 0x55, 0x24, 0x1f, 0x2c, 0x76,
	0xed, 0xfe, 0x21, 0x8e, 0x8d, 0x87, 0xb0, 0x10, 0xaa, 0x76, 0xa8, 0xa2, 0x63, 0xab, 0x15, 0x44,
	0xb1, 0x75, 0x96, 0xd8, 0xbe, 0x75, 0x64, 0x07, 0xe6, 0xc4, 0xea, 0xc4, 0xbd, 0xa9, 0xed, 0xc9,
	0xda, 0x3b, 0x66, 0xae, 0x69, 0x08, 0xcb, 0x4e, 0x10, 0xc5, 0x5f, 0x25, 0xb6, 0xbf, 0x6d, 0x07,
	0xc6, 0x8f, 0xa1, 0x1e, 0xaa, 0x56, 0x70, 0xa2, 0xc2, 0x33, 0xcb, 0x49, 0x42, 0x3b, 0x76, 0x03,
	0xdf, 0x9c, 0xa4, 0xd5, 0x6b, 0x7a, 0xe2, 0xb1, 0xd0, 0x8d, 0x4d, 0xa8, 0x64, 0xbf, 0x62, 0x4e,
	0xad, 0x4e, 0xdc, 0x2b, 0x6f, 0xd4, 0xd8, 0x44, 0x6b, 0xb8, 0x2c, 0x6d, 0xb5, 0x59, 0xce, 0x7c,
	0xa8, 0xf1, 0xcf, 0x39, 0xa8, 0x1e, 0x26, 0x71, 0x90, 0xb1, 0x9b, 0x01, 0x93, 0xbe, 0xdd, 0x55,
	0xa4, 0x45, 0xa9, 0x49, 0xbf, 0xd1, 0x96, 0x6e, 0xd7, 0xee, 0xb0, 0xd9, 0x4a, 0x4d, 0x1e, 0x18,
	0x77, 0x61, 0xaa, 0x17, 0xba, 0x6f, 0x94, 0x39, 0xb1, 0x9a, 0xbb, 0x57, 0xde, 0xa8, 0xcb, 0xa7,
	0x5e, 0x20, 0x8d, 0xbf, 0xc5, 0xf3, 0xc6, 0x7b, 0x50, 0x69, 0x1d, 0xdb, 0xb1, 0xd5, 0x0a, 0xfc,
	0x58, 0xf9, 0x31, 0xa9, 0x50, 0x6a, 0x96, 0x91, 0xb6, 0xc3, 0x24, 0xe3, 0x27, 0x50, 0xd3, 0xbb,
	0x47, 0x43, 0x8a, 0x06, 0xb9, 0x0b, 0x35, 0xa8, 0x0a, 0xe7, 0x33, 0xbb, 0x4f, 0x4a, 0xfc, 0x47,
	0x0e, 0x6a, 0x72, 0x2a, 0x97, 0x1d, 0xff, 0x27, 0x50, 0x8e, 0x51, 0x5d, 0xcb, 0xb1, 0x63, 0x3b,
	0x32, 0xf3, 0x64, 0xa3, 0x05, 0xf9, 0xc2, 0xb0, 0x21, 0x9a, 0x10, 0xeb, 0x71, 0x84, 0x27, 0x71,
	0x14, 0x06, 0xb6, 0xd3, 0xb2, 0xa3, 0x81, 0x1a, 0x13, 0xa4, 0x46, 0x2d, 0x9d, 0xd0, 0xba, 0x7c,
	0xab, 0x63, 0x1b, 0xf2, 0x9c, 0xa9, 0x61, 0xcf, 0x69, 0x9c, 0xc2, 0xc2, 0x17, 0x89, 0xff, 0x95,
	0xeb, 0x77, 0xbe, 0xc4, 0xed, 0x5f, 0xa6, 0xdd, 0xd0, 0x5a, 0xf9, 0x11, 0x2f, 0xfc, 0x36, 0xbb,
	0x6a, 0xfc, 0x17, 0x9a, 0x94, 0xbf, 0x8c, 0x8e, 0xce, 0x1f, 0xfd, 0x29, 0x5c, 0x6b, 0x07, 0x61,
	0x4b, 0x59, 0xb6, 0xe3, 0x58, 0x51, 0xe0, 0x39, 0xae, 0x0a, 0xad, 0xd1, 0x0f, 0x2e, 0x11, 0xcb,
	0x96, 0xe3, 0x1c, 0x30, 0xc3, 0x33, 0xfd, 0xfd, 0x47, 0xb0, 0x78, 0x5e, 0x9a, 0xce, 0x39, 0x1b,
	0x06, 0x73, 0x23, 0xe2, 0x78, 0xc0, 0xc6, 0x97, 0xb0, 0x72, 0x5e, 0xd4, 0x57, 0xa7, 0x2c, 0x3e,
	0x39, 0xc6, 0xd1, 0x17, 0x47, 0x96, 0xda, 0x57, 0xa7, 0xe4, 0x2e, 0xff, 0x9a, 0x03, 0xe3, 0x30,
	0xb4, 0x5d, 0x5f, 0x9b, 0xf5, 0x12, 0xbc, 0xa0, 0x68, 0xc8, 0x67, 0xa2, 0xc1, 0x80, 0x49, 0x47,
	0x45, 0x2d, 0x39, 0x7f, 0xfa, 0x6d, 0x5c, 0x07, 0x50, 0xfd, 0x9e, 0x15, 0x24, 0x71, 0x2f, 0x89,
	0xc5, 0xac, 0x25, 0xd5, 0xef, 0x3d, 0x27, 0x82, 0x71, 0x13, 0xca, 0x38, 0xdd, 0xb2, 0x7b, 0x2d,
	0x37, 0x3e, 0x93, 0x73, 0x46, 0x89, 0x1d, 0xa6, 0x18, 0xb7, 0x61, 0x92, 0x94, 0x99, 0x1e, 0xe3,
	0xf3, 0x34, 0x8b, 0x5f, 0x6e, 0x05, 0xaa, 0x6d, 0x16, 0x18, 0xbd, 0xf0, 0x77, 0xe3, 0x7f, 0xf3,
	0x30, 0xb7, 0x63, 0xf7, 0x62, 0xdb, 0xf5, 0xb7, 0x8e, 0x10, 0xc5, 0xcf, 0x58, 0x1f, 0x13, 0x0a,
	0x36, 0x8f, 0x45, 0x23, 0x3d, 0xc4, 0xcd, 0x24, 0xbd, 0x4e, 0x68, 0x3b, 0xca, 0x52, 0xfd, 0x9e,
	0x9c, 0x1b, 0x08, 0x69, 0xb7, 0xdf, 0x33, 0xee, 0x03, 0x44, 0xca, 0xf3, 0xac, 0x5e, 0xe8, 0xb6,
	0xde, 0x12, 0xdd, 0x25, 0x64, 0x7a, 0x81, 0x3c, 0xc6, 0x3d, 0x28, 0xbc, 0x4e, 0x6c, 0xfa, 0x18,
	0xea, 0x5e, 0xdd, 0xa8, 0x0a, 0xfb, 0xcf, 0x98, 0xda, 0xd4, 0xd3, 0xb8, 0x76, 0xdb, 0x0d, 0x95,
	0xac, 0x3d, 0x35, 0x76, 0x6d, 0x64, 0xe2, 0xb5, 0xb5, 0xb9, 0xa7, 0x33, 0xe6, 0x5e, 0x81, 0xe9,
	0x6e, 0xe0, 0x28, 0x2f, 0x32, 0x0b, 0xe4, 0x3c, 0xf9, 0xda, 0x3b, 0x4d, 0xa1, 0x18, 0x1f, 0x80,
	0x91, 0xf8, 0x5e, 0xd0, 0xfa, 0xda, 0x8a, 0x7a, 0xa8, 0x45, 0x2b, 0x48, 0xfc, 0xd8, 0x2c, 0xb2,
	0xa7, 0xf3, 0xcc, 0x01, 0x4e, 0xec, 0x20, 0xdd, 0x58, 0x07, 0x08, 0x55, 0xa4, 0x62, 0xf6, 0xa5,
	0xd2, 0x18, 0xf3, 0x97, 0x88, 0x87, 0xdc, 0xe7, 0x25, 0x2c, 0x88, 0xb9, 0x9f, 0x2a, 0x5f, 0x85,
	0x76, 0x1c, 0x84, 0xa9, 0x03, 0xf1, 0xa7, 0xc4, 0x81, 0x68, 0x60, 0xdc, 0x81, 0x59, 0x5f, 0x29,
	0xc7, 0x3a, 0x56, 0x61, 0x60, 0xb1, 0x83, 0xb1, 0xc1, 0x67, 0x90, 0xfc, 0xb9, 0x0a, 0x03, 0xf2,
	0xc1, 0xc6, 0x7f, 0xe6, 0xa0, 0x2e, 0xeb, 0x5e, 0xea, 0x94, 0x97, 0x1e, 0xe0, 0x5d, 0xa8, 0x1d,
	0xdb, 0x11, 0x85, 0x48, 0x47, 0x75, 0xad, 0xc8, 0x0b, 0x18, 0xad, 0x8a, 0xcd, 0x99, 0x63, 0x3b,
	0xda, 0x57, 0xa7, 0x4f, 0x55, 0xf7, 0xc0, 0x0b, 0x62, 0xe3, 0x16, 0xcc, 0x88, 0x57, 0x58, 0x9e,
	0xdb, 0x75, 0xb5, 0xe7, 0x56, 0x84, 0xf8, 0x25, 0xd2, 0xd0, 0x93, 0x42, 0x75, 0xe4, 0x86, 0xf1,
	0xb1, 0x64, 0x49, 0x3d, 0x34, 0x6e, 0x43, 0x55, 0xaf, 0x2f, 0x66, 0x5e, 0x64, 0xf9, 0x0e, 0xaf,
	0x4f, 0x26, 0x6e, 0xfc, 0xd3, 0x04, 0x98, 0xa2, 0x5a, 0x93, 0x05, 0x2f, 0xd5, 0x70, 0x03, 0xe6,
	0xe4, 0x1b, 0xd6, 0x39, 0x4d, 0xb7, 0xf3, 0x66, 0xae, 0x59, 0x97, 0xe9, 0x97, 0x03, 0xa5, 0xd7,
	0x60, 0xae, 0xc5, 0x5f, 0x61, 0x3b, 0x8b, 0x46, 0x13, 0xb4, 0x6e, 0xbd, 0x95, 0xb1, 0x2d, 0xab,
	0xf5, 0x2e, 0x14, 0x30, 0x13, 0x63, 0x22, 0x9e, 0x4c, 0xd7, 0xd5, 0x24, 0xe3, 0x47, 0x50, 0x8f,
	0x7a, 0xa1, 0x1b, 0x2b, 0x2b, 0x8a, 0xed, 0xd8, 0xea, 0x05, 0xae, 0x1f, 0x4b, 0xdc, 0xce, 0xf2,
	0xc4, 0x41, 0x6c, 0xc7, 0x2f, 0x90, 0x6c, 0xdc, 0x85, 0xd9, 0x14, 0xd0, 0x24, 0xc2, 0xa7, 0x89,
	0xb3, 0x2a, 0x64, 0x1d, 0xe5, 0xe7, 0xcc, 0x5d, 0xb8, 0xc0, 0xdc, 0x37, 0xa1, 0xac, 0x99, 0x50,
	0x67, 0x76, 0x5c, 0x10, 0x12, 0x2a, 0x5a, 0x85, 0x7c, 0xcb, 0x21, 0x57, 0x9d, 0x6a, 0xe6, 0x5b,
	0x8e, 0x71, 0x1f, 0xe6, 0x8f, 0x54, 0x3b, 0x08, 0x95, 0xa5, 0x6d, 0xc6, 0x16, 0x05, 0xe2, 0x30,
	0x78, 0x2e, 0x6b, 0x79, 0xe3, 0x1e, 0xd4, 0x06, 0xfe, 0x28, 0x5b, 0xe1, 0xa3, 0xad, 0x1e, 0x6b,
	0x8f, 0xa4, 0xcd, 0x34, 0x7e, 0x9b, 0x07, 0x43, 0xce, 0xee, 0x40, 0xa9, 0xaf, 0xd5, 0xc0, 0xd7,
	0x5d, 0xdf, 0x51, 0x7d, 0x7d, 0x6a, 0x34, 0x30, 0x56, 0xa0, 0x18, 0xa9, 0xd7, 0x89, 0xf2, 0x5b,
	0xba, 0xc0, 0x4a, 0xc7, 0x78, 0x3a, 0xa1, 0x7a, 0x9d, 0xb8, 0xe1, 0x70, 0x2c, 0xc8, 0xe9, 0xe8,
	0xa9, 0x34, 0x1e, 0x8c, 0x25, 0x28, 0xb8, 0xad, 0xc0, 0xb7, 0x5c, 0x47, 0xca, 0x85, 0x69, 0x1c,
	0xee, 0x39, 0x08, 0x07, 0x58, 0x14, 0xd2, 0x59, 0x14, 0x9b, 0xf4, 0xdb, 0xb8, 0x09, 0x93, 0xa1,
	0xdd, 0x52, 0x64, 0xf5, 0xea, 0x46, 0x59, 0xc2, 0xb7, 0x69, 0xb7, 0x54, 0x93, 0x26, 0xb2, 0xf8,
	0x54, 0x78, 0x3b, 0x3e, 0x65, 0x60, 0xb3, 0x78, 0x0e, 0x36, 0xdb, 0x76, 0xd7, 0xf5, 0xce, 0x2c,
	0xca, 0x08, 0x25, 0xda, 0x15, 0x30, 0x69, 0x1f, 0xf3, 0xc2, 0xba, 0xe4, 0x0a, 0x20, 0x10, 0x59,
	0xd2, 0x20, 0xc2, 0xd6, 0x43, 0x0e, 0xb2, 0x1d, 0xb9, 0x19, 0x27, 0x92, 0xeb, 0x00, 0x1d, 0xf7,
	0x44, 0xf9, 0xbc, 0x60, 0x99, 0x16, 0x2c, 0x11, 0x05, 0xb9, 0x1b, 0x7f, 0x39, 0x01, 0x75, 0xc9,
	0x5d, 0x57, 0xc9, 0x53, 0x5e, 0x60, 0x3b, 0xba, 0xae, 0xc5, 0xdf, 0x17, 0xe6, 0xa9, 0xdb, 0x50,
	0x7d, 0x95, 0xf8, 0xd6, 0x99, 0xeb, 0x77, 0xe4, 0x04, 0x24, 0xe2, 0x5f, 0x65, 0xea, 0x0c, 0xae,
	0x25, 0x5b, 0x61, 0xe2, 0x0a, 0x2c, 0x96, 0xc7, 0xc0, 0x62, 0x59, 0xb8, 0x28, 0x4b, 0x6f, 0x42,
	0xe5, 0x34, 0x48, 0x7c, 0x47, 0x39, 0x2c, 0x54, 0x19, 0x27, 0x24, 0x5c, 0x5a, 0x48, 0x07, 0x38,
	0x09, 0x55, 0xc7, 0x09, 0x09, 0x97, 0x08, 0x95, 0xb0, 0xdd, 0xa0, 0xc8, 0x34, 0x17, 0x28, 0xfd,
	0x2f, 0x8a, 0xc4, 0xc1, 0x20, 0x34, 0x49, 0xae, 0x88, 0x8c, 0x38, 0x44, 0xcd, 0xe3, 0x20, 0xb6,
	0x3d, 0x8e, 0xe7, 0x28, 0xe9, 0x6a, 0xac, 0x22, 0x2a, 0xb2, 0x1c, 0x24, 0xdd, 0x4c, 0x62, 0x59,
	0x1a, 0x4d, 0x2c, 0x8d, 0x7f, 0xcf, 0xc1, 0xbc, 0x9c, 0xe6, 0xf3, 0x76, 0xdb, 0x6d, 0xb9, 0xb6,
	0x1c, 0x49, 0x15, 0xf2, 0xae, 0x23, 0xe7, 0x91, 0x77, 0x1d, 0x0c, 0xf3, 0x40, 0x18, 0xac, 0x4c,
	0xf5, 0x50, 0xd1, 0x44, 0xf2, 0x96, 0x87, 0x50, 0xce, 0x00, 0x8c, 0x64, 0xd9, 0x71, 0x6a, 0xc0,
	0x00, 0x72, 0xb0, 0x9a, 0xa6, 0x8c, 0xd2, 0x09, 0xfc, 0x4e, 0x3f, 0xd1, 0x35, 0x5c, 0x19, 0x69,
	0x4f, 0x99, 0x84, 0x27, 0x8f, 0xd1, 0x42, 0x31, 0x52, 0x6a, 0xd2, 0xef, 0x8b, 0xd2, 0x68, 0xe3,
	0x1f, 0x00, 0xea, 0xcf, 0xa4, 0xf3, 0xdb, 0xf3, 0xdb, 0x01, 0xab, 0xb3, 0x08, 0xd3, 0x76, 0x8b,
	0xca, 0x43, 0xf6, 0x26, 0x19, 0x51, 0x79, 0x19, 0x9c, 0x28, 0x8b, 0x1a, 0xa8, 0x09, 0x29, 0x2f,
	0x83, 0x13, 0x75, 0x88, 0x4d, 0xd4, 0x1d, 0x98, 0xa5, 0xc9, 0x28, 0xb6, 0xc3, 0x98, 0x2a, 0x42,
	0xd9, 0xd8, 0x0c, 0x92, 0x0f, 0x90, 0x8a, 0x75, 0x20, 0xe2, 0x2a, 0xf1, 0xd9, 0x61, 0xe8, 0x9e,
	0x28, 0x87, 0x39, 0x05, 0x57, 0x71, 0x62, 0x8b, 0xe9, 0xc4, 0xfb, 0x01, 0x18, 0xbd, 0xd0, 0x0d,
	0x42, 0x84, 0x42, 0xde, 0x03, 0xc2, 0x01, 0x43, 0x6b, 0x4d, 0xcf, 0x6c, 0xd1, 0xc4, 0x9e, 0x83,
	0xa0, 0x16, 0x06, 0x47, 0x47, 0xe8, 0xd9, 0xca, 0x97, 0x85, 0x19, 0x5f, 0xab, 0x42, 0xdf, 0xf5,
	0x79, 0xdd, 0x9b, 0x50, 0x6e, 0x85, 0xca, 0x8e, 0x15, 0x33, 0x09, 0xc2, 0x32, 0x89, 0x18, 0xd6,
	0x60, 0x2e, 0xa3, 0x4c, 0x68, 0xc7, 0xea, 0xa3, 0xfb, 0xf7, 0xef, 0x0b, 0xe4, 0xd6, 0x53, 0x85,
	0x9a, 0x32, 0x61, 0xdc, 0x85, 0x19, 0x9d, 0x7a, 0x18, 0x16, 0x67, 0x53, 0xe7, 0xa9, 0xc8, 0xc4,
	0x1e, 0x21, 0xe4, 0x26, 0x14, 0x65, 0x1c, 0x99, 0x35, 0x72, 0xdc, 0x11, 0x98, 0x48, 0x4f, 0xa1,
	0x99, 0x32, 0x62, 0x36, 0x8f, 0x94, 0xd7, 0xb6, 0xfc, 0x5e, 0x8b, 0xfa, 0x16, 0x34, 0x82, 0xc1,
	0xb6, 0x45, 0xfa, 0x7e, 0x8f, 0x1a, 0xd1, 0x3d, 0xc7, 0x68, 0xc0, 0x4c, 0xca, 0x48, 0x87, 0x34,
	0xc7, 0xae, 0x21, 0x5c, 0x74, 0x4e, 0xab, 0x50, 0x21, 0x1e, 0x37, 0xb2, 0xa8, 0x89, 0x99, 0x27,
	0x18, 0xc5, 0x7a, 0xaf, 0xbd, 0x17, 0x1d, 0x62, 0xfb, 0xf2, 0x11, 0x4c, 0xe2, 0xc8, 0x5c, 0x20,
	0x8f, 0xbc, 0x2e, 0xfb, 0x43, 0x64, 0xde, 0xb6, 0x23, 0xb7, 0x75, 0x20, 0xbd, 0xb7, 0xd4, 0xa5,
	0xc8, 0x6a, 0x3c, 0x80, 0xe9, 0xd8, 0x0e, 0x3b, 0x8a, 0xf3, 0xff, 0xa5, 0x42, 0xc2, 0x8c, 0xfb,
	0xe5, 0x5f, 0x16, 0x85, 0x73, 0xdf, 0x5c, 0xe2, 0xfd, 0x32, 0x71, 0xdb, 0x8e, 0xd4, 0x2f, 0x47,
	0x79, 0xce, 0x4c, 0x73, 0x94, 0xe7, 0x2b, 0x0a, 0x6d, 0xe6, 0xd1, 0x5a, 0x2d, 0x93, 0x56, 0x15,
	0xa6, 0x8a, 0x5e, 0x3f, 0x06, 0x43, 0xb8, 0xb2, 0x86, 0x5c, 0x61, 0xd7, 0xe3, 0x99, 0x81, 0x29,
	0xef, 0xc0, 0x6c, 0x86, 0x99, 0x8c, 0x79, 0x8d, 0x4d, 0x9e, 0x72, 0x92, 0x39, 0xaf, 0x03, 0x7c,
	0xed, 0x7a, 0x9e, 0xa5, 0x7c, 0xd5, 0x3d, 0x33, 0x6f, 0xac, 0x4e, 0x20, 0x84, 0x23, 0x65, 0x17,
	0x09, 0x18, 0x74, 0x9d, 0xc0, 0x73, 0xcc, 0x4d, 0x86, 0x65, 0xfc, 0x8d, 0xb4, 0x76, 0x10, 0x38,
	0xe6, 0xc7, 0x4c, 0xc3, 0xdf, 0x48, 0x3b, 0x45, 0xda, 0x03, 0xa6, 0xe1, 0x6f, 0x04, 0xfa, 0x28,
	0x0e, 0x7c, 0x65, 0x7e, 0xc2, 0x40, 0x4f, 0x03, 0x63, 0x19, 0x8a, 0xaf, 0x10, 0x2d, 0x83, 0x50,
	0x99, 0x0f, 0x39, 0x41, 0xe1, 0xf8, 0x79, 0xa8, 0x8c, 0x47, 0x30, 0x6b, 0xb7, 0x5a, 0x49, 0xd7,
	0x0a, 0x83, 0x23, 0x8b, 0x3b, 0xf3, 0x4f, 0xc7, 0xd5, 0xd7, 0x33, 0xc4, 0xd9, 0x0c, 0x8e, 0x88,
	0x66, 0xbc, 0x0f, 0x55, 0x3b, 0x8a, 0x54, 0xf7, 0xc8, 0x3b, 0x93, 0x42, 0xee, 0x33, 0xd6, 0x56,
	0x53, 0xb9, 0x58, 0xbe, 0x0f, 0xf3, 0x29, 0x1b, 0x83, 0x29, 0x33, 0xff, 0x09, 0x57, 0x1a, 0x7a,
	0xee, 0x10, 0xa7, 0x58, 0x02, 0x8b, 0x19, 0x2d, 0xe1, 0x3a, 0xe6, 0x9f, 0xae, 0xe6, 0xee, 0x55,
	0x9a, 0xa0, 0x49, 0x7b, 0x8e, 0xf1, 0x10, 0xcc, 0xc1, 0x92, 0x23, 0x16, 0xff, 0x33, 0x5a, 0x76,
	0x21, 0x5d, 0x76, 0xc8, 0xf2, 0x8f, 0x60, 0xb9, 0x9b, 0x78, 0xb1, 0x2b, 0x45, 0x4c, 0x37, 0xf0,
	0xa3, 0x98, 0x3a, 0x4a, 0xdc, 0xd0, 0x16, 0x49, 0x2e, 0x12, 0x03, 0xa5, 0xb4, 0x67, 0x3c, 0xcd,
	0x9b, 0xba, 0x0e, 0xd0, 0x0a, 0xba, 0x47, 0xae, 0xaf, 0x70, 0x4f, 0x8a, 0xf6, 0x54, 0x12, 0xca,
	0x9e, 0x83, 0x38, 0x17, 0xaa, 0x8e, 0xa0, 0x4d, 0x9b, 0x71, 0x8e, 0x09, 0x7b, 0x4e, 0xe3, 0x37,
	0x53, 0x50, 0xdf, 0xd2, 0xdb, 0x4f, 0x21, 0xf3, 0xf7, 0x0e, 0x8d, 0x17, 0x81, 0xdd, 0xf4, 0x85,
	0x60, 0xa7, 0xc3, 0xb9, 0x7c, 0xf5, 0x70, 0xc6, 0xda, 0x17, 0x31, 0xa2, 0xed, 0x76, 0x8e, 0x63,
	0xcb, 0xee, 0x92, 0x49, 0x2b, 0x52, 0xfb, 0x2a, 0xaf, 0xfd, 0x04, 0xe9, 0x5b, 0x44, 0xfe, 0xa1,
	0x43, 0xff, 0x56, 0xca, 0xd3, 0x0d, 0x42, 0x2c, 0x0b, 0x97, 0x25, 0xa9, 0x13, 0xf1, 0x19, 0xd1,
	0x7e, 0x37, 0x91, 0xff, 0x1e, 0xc8, 0x47, 0xac, 0x38, 0x0c, 0x82, 0x9e, 0xf9, 0x6e, 0x76, 0x73,
	0x87, 0x48, 0xc2, 0xfc, 0xa5, 0x59, 0x28, 0x58, 0x98, 0xf1, 0x3a, 0xe7, 0x2f, 0x61, 0xc4, 0x09,
	0xe6, 0xde, 0x80, 0xe9, 0xae, 0xea, 0x1e, 0xa9, 0x90, 0x60, 0xa4, 0xbc, 0xb1, 0x22, 0x96, 0xd4,
	0xde, 0xf6, 0x8c, 0x26, 0xc5, 0x8c, 0xcc, 0x89, 0xe1, 0x95, 0x8d, 0xc3, 0x9b, 0x9c, 0xc9, 0xe2,
	0x41, 0xfc, 0x3d, 0x00, 0xb0, 0x1d, 0x2c, 0xc9, 0xa8, 0xc8, 0x58, 0x7d, 0x6b, 0x91, 0x51, 0x22,
	0x4e, 0x1c, 0x37, 0xfe, 0x3b, 0x07, 0x73, 0x17, 0x7c, 0x17, 0x9d, 0x09, 0x8b, 0x77, 0xaa, 0x75,
	0x2e, 0x77, 0x26, 0x64, 0x35, 0xde, 0x87, 0xca, 0x90, 0x1f, 0x49, 0x0f, 0x57, 0x7b, 0xa7, 0x59,
	0x6e, 0x67, 0xfc, 0xe8, 0x82, 0x20, 0x99, 0xb8, 0x72, 0x90, 0x4c, 0x5e, 0x1c, 0x24, 0xcb, 0x50,
	0x24, 0x93, 0xe3, 0x69, 0x4f, 0x51, 0x94, 0x17, 0x68, 0xbc, 0xe7, 0x34, 0x5e, 0x43, 0x1d, 0x1d,
	0xe8, 0xb1, 0x6a, 0x2b, 0x3f, 0xd2, 0xda, 0xfd, 0x4e, 0xd3, 0x78, 0xe3, 0xaf, 0x8a, 0x50, 0x1b,
	0x9d, 0xbe, 0xa0, 0x74, 0xe4, 0x4e, 0x66, 0xf2, 0x5c, 0x27, 0xc3, 0x7d, 0xc3, 0x68, 0x37, 0x33,
	0x75, 0x69, 0x37, 0x23, 0x2d, 0xa8, 0xa0, 0x83, 0x1e, 0x52, 0xe0, 0x70, 0x39, 0x2c, 0xf3, 0x85,
	0x6c, 0x35, 0x2c, 0x4c, 0xef, 0x8d, 0x9c, 0x1d, 0x57, 0x4a, 0x43, 0xe7, 0xb6, 0x88, 0x05, 0x33,
	0x45, 0x1e, 0x57, 0x47, 0x32, 0x1a, 0xb4, 0x29, 0x90, 0x6d, 0x53, 0x6e, 0xc1, 0x8c, 0xee, 0x94,
	0x79, 0x96, 0xbb, 0xce, 0x4a, 0x94, 0x69, 0x73, 0x8c, 0x45, 0xe9, 0xf0, 0x10, 0x71, 0x8a, 0xac,
	0x36, 0x75, 0x79, 0x9f, 0xc1, 0xb5, 0x96, 0xed, 0x5b, 0x71, 0xe8, 0x76, 0x3a, 0x2a, 0xb4, 0x42,
	0x15, 0xc5, 0xa1, 0xed, 0xfa, 0x31, 0xdf, 0xf3, 0xd0, 0x2d, 0x7d, 0xb1, 0x69, 0xb6, 0x6c, 0xff,
	0x90, 0x39, 0x9a, 0x9a, 0x81, 0xae, 0x7b, 0xd2, 0xf6, 0xac, 0x7a, 0xd5, 0xf6, 0xec, 0xda, 0xa0,
	0x05, 0xc5, 0x2a, 0xa9, 0x44, 0x53, 0xba, 0x0d, 0x35, 0xa1, 0x10, 0x24, 0x71, 0xe4, 0x3a, 0x8a,
	0x0a, 0xa5, 0x62, 0x53, 0x0f, 0x31, 0xe4, 0x06, 0x8d, 0x86, 0xa0, 0xe2, 0xd8, 0x90, 0x4b, 0x9b,
	0x0f, 0x44, 0x74, 0xcf, 0x6d, 0x2b, 0xab, 0xa7, 0xc2, 0xf4, 0x4c, 0x18, 0x14, 0xab, 0x48, 0x7f,
	0xa1, 0x42, 0x7d, 0x2a, 0xc8, 0x19, 0xd8, 0xce, 0x10, 0xa7, 0x29, 0x9c, 0x81, 0xed, 0x64, 0x38,
	0xe7, 0x61, 0x8a, 0x7a, 0x17, 0x41, 0x45, 0x1e, 0xd0, 0x75, 0xbc, 0xb8, 0x79, 0x14, 0x24, 0x9e,
	0xa0, 0x46, 0x59, 0x68, 0x07, 0x41, 0xe2, 0x21, 0x72, 0x65, 0x59, 0xe4, 0xb0, 0x56, 0x19, 0xb9,
	0x32, 0x8c, 0x5f, 0xea, 0x53, 0x1d, 0xbe, 0x79, 0x78, 0x8f, 0x4f, 0x35, 0xcc, 0xde, 0x39, 0x2c,
	0x43, 0x91, 0x1e, 0x3e, 0x5e, 0x25, 0xbe, 0xd9, 0x60, 0x8b, 0xe1, 0xf8, 0x8b, 0xc4, 0xc7, 0x98,
	0x6e, 0x27, 0x9e, 0x37, 0x9c, 0x6f, 0x6e, 0x71, 0x4c, 0xe3, 0x44, 0x36, 0xdf, 0x2c, 0x41, 0xa1,
	0x2f, 0xd1, 0x79, 0x9b, 0x1d, 0xae, 0xcf, 0x31, 0x89, 0x49, 0x5d, 0x07, 0xaf, 0x63, 0xbe, 0xcf,
	0x37, 0xb0, 0x3a, 0x6a, 0x1d, 0x44, 0x4a, 0x37, 0xa2, 0x6e, 0xcc, 0x53, 0x51, 0x64, 0xde, 0xe1,
	0xb2, 0xd7, 0x8d, 0xf6, 0x85, 0x82, 0x25, 0x18, 0x62, 0x8f, 0x79, 0x97, 0x4b, 0x30, 0xfc, 0x3d,
	0xe6, 0x2a, 0xf1, 0xde, 0x98, 0xab, 0xc4, 0x07, 0xb0, 0xc4, 0x6c, 0x59, 0x3d, 0x2c, 0xba, 0xb0,
	0xfd, 0x23, 0x12, 0x99, 0xa7, 0xe9, 0x8c, 0x36, 0x3b, 0x81, 0x6a, 0x37, 0x7e, 0x5b, 0x81, 0x3a,
	0x22, 0xa8, 0x6e, 0xc4, 0x18, 0x18, 0xb2, 0x10, 0x93, 0x1b, 0x82, 0x18, 0xe4, 0x15, 0xaf, 0x1d,
	0xed, 0x14, 0x9e, 0x40, 0x35, 0x6d, 0x3c, 0x79, 0xaf, 0x7c, 0x39, 0x7e, 0xf3, 0xbc, 0xa8, 0xee,
	0x60, 0x69, 0xeb, 0xcd, 0xb4, 0x5f, 0x65, 0x4d, 0x3e, 0x1a, 0x1c, 0x7f, 0x3b, 0x74, 0x95, 0xef,
	0x44, 0xc7, 0x6e, 0x8f, 0x5e, 0x94, 0x18, 0x0d, 0xf5, 0x6d, 0xda, 0x93, 0x74, 0xd2, 0xf8, 0x10,
	0xa6, 0x09, 0x5b, 0x23, 0x73, 0x7a, 0xe8, 0x51, 0x05, 0x3f, 0x49, 0xf9, 0x4d, 0xe7, 0x7f, 0x62,
	0x32, 0x1e, 0x02, 0xf4, 0xb0, 0x5e, 0x62, 0x91, 0x02, 0x89, 0x98, 0x19, 0x91, 0x17, 0x27, 0x2a,
	0x23, 0x55, 0xea, 0xc9, 0x30, 0x32, 0x1e, 0x40, 0x29, 0x15, 0x34, 0x8b, 0x97, 0xc8, 0x15, 0xb5,
	0x9c, 0xf1, 0x38, 0xd3, 0x92, 0x9f, 0xb8, 0xea, 0xd4, 0x2c, 0x0d, 0x19, 0x66, 0xcf, 0x8f, 0x37,
	0x37, 0x5e, 0xd8, 0x6e, 0x48, 0x3f, 0xb6, 0xc2, 0xd0, 0xe6, 0x63, 0x18, 0xf4, 0xec, 0x3f, 0x77,
	0xd5, 0xa9, 0xf1, 0x21, 0x14, 0x44, 0x73, 0xb3, 0x4c, 0xf2, 0x73, 0xc3, 0x28, 0xc2, 0x32, 0x9a,
	0xe7, 0x3c, 0xda, 0xdd, 0xb8, 0x00, 0xed, 0x2e, 0xb8, 0x3c, 0xbc, 0x79, 0xe1, 0xe5, 0x21, 0x82,
	0x71, 0xa8, 0x54, 0x1a, 0xf2, 0xab, 0x02, 0xc6, 0xa1, 0x52, 0x3a, 0xde, 0xef, 0xc2, 0xac, 0xbe,
	0x82, 0xd1, 0x5c, 0x1c, 0x8a, 0x55, 0x21, 0x6b, 0xc6, 0x4f, 0x60, 0x69, 0x84, 0x31, 0xfd, 0x78,
	0x83, 0x8b, 0xee, 0x61, 0x01, 0xbd, 0x87, 0x9b, 0x50, 0xf6, 0xd5, 0x69, 0xba, 0x38, 0xc7, 0x28,
	0xf8, 0xea, 0x54, 0x2f, 0xbc, 0x06, 0x73, 0x19, 0x86, 0x74, 0x51, 0x0e, 0xd5, 0xfa, 0x80, 0x51,
	0x2f, 0xf8, 0x01, 0x18, 0x59, 0x7e, 0x79, 0x3f, 0xe1, 0xe8, 0xad, 0x0d, 0xd8, 0xe5, 0x19, 0xe5,
	0x11, 0x2c, 0x67, 0xb9, 0x07, 0x77, 0x54, 0xe8, 0xea, 0x77, 0xb8, 0xe6, 0x1f, 0x08, 0x35, 0xf5,
	0xe5, 0x14, 0xba, 0xf4, 0x26, 0x2c, 0xbe, 0x72, 0x13, 0xab, 0x83, 0x10, 0xa4, 0x5f, 0x1a, 0xf9,
	0xdd, 0x6a, 0x8d, 0xe4, 0xe6, 0x5e, 0xf1, 0x0b, 0x62, 0x93, 0xe7, 0xf8, 0xcd, 0x6a, 0x1d, 0xe6,
	0x53, 0x21, 0x7e, 0x37, 0x64, 0xe4, 0x59, 0x67, 0x75, 0x44, 0x84, 0xde, 0x0d, 0x19, 0x84, 0x6e,
	0x43, 0x75, 0x20, 0x40, 0xab, 0xdf, 0x97, 0xeb, 0x35, 0x61, 0x95, 0xa7, 0x38, 0x23, 0xe5, 0xf2,
	0x55, 0x5f, 0xca, 0x9d, 0x8f, 0x18, 0xf0, 0x84, 0x73, 0x5f, 0xf5, 0xb9, 0xe0, 0xf9, 0x73, 0xb8,
	0x95, 0xde, 0xd8, 0x69, 0x85, 0xe5, 0x5e, 0x82, 0x5e, 0xed, 0xce, 0x58, 0x7a, 0x83, 0xa4, 0x6f,
	0xc8, 0x35, 0x9e, 0xa8, 0xce, 0xb7, 0x14, 0xcc, 0x46, 0x8b, 0xd1, 0x6b, 0x44, 0x3f, 0xb6, 0x54,
	0xbf, 0xa7, 0x3c, 0x16, 0xdc, 0xd4, 0xaf, 0x11, 0xfd, 0x78, 0x17, 0xa9, 0xc4, 0xf7, 0x00, 0x96,
	0x3a, 0x5e, 0x70, 0x44, 0x35, 0x2b, 0x25, 0x81, 0x41, 0x55, 0xc6, 0x2d, 0xea, 0x3c, 0x4f, 0xd3,
	0x3b, 0xda, 0xa0, 0x38, 0x7b, 0x08, 0xa6, 0xc6, 0x8d, 0x73, 0x72, 0xdc, 0xc5, 0x2e, 0xc8, 0xfc,
	0x88, 0xe0, 0x75, 0x00, 0x16, 0x20, 0xb4, 0xe4, 0xbe, 0xb6, 0x44, 0x14, 0x84, 0x48, 0xe3, 0x09,
	0xac, 0x66, 0x5d, 0x7f, 0x48, 0xff, 0x50, 0x0c, 0xf0, 0x29, 0x09, 0xbd, 0x9b, 0x09, 0x87, 0x8c,
	0xf6, 0x21, 0xab, 0x7f, 0x1f, 0xe6, 0x87, 0xd6, 0xd1, 0xee, 0xf9, 0x88, 0xfb, 0xd7, 0x8c, 0xac,
	0xf6, 0xcf, 0x35, 0x98, 0x1b, 0x92, 0x10, 0x07, 0xfd, 0x09, 0x3b, 0x40, 0x46, 0x40, 0x3c, 0x74,
	0x03, 0x16, 0xf0, 0x73, 0x6d, 0x2f, 0x38, 0xb5, 0x86, 0xa2, 0xf5, 0x8f, 0xd9, 0xcb, 0xf4, 0xe4,
	0x93, 0x4c, 0xd4, 0x3e, 0x80, 0xa5, 0xf3, 0xcf, 0x9b, 0xec, 0x3d, 0x3f, 0x65, 0x63, 0x8f, 0xbc,
	0x64, 0xb2, 0x17, 0x6d, 0x43, 0xdd, 0xf5, 0x4f, 0x54, 0x14, 0xbb, 0x1d, 0xba, 0xca, 0x22, 0x44,
	0xfc, 0x8c, 0xca, 0x8d, 0x31, 0xe0, 0x5b, 0xcb, 0xf0, 0x13, 0xb9, 0xf1, 0x33, 0x30, 0xc7, 0xe5,
	0x04, 0x8c, 0xf5, 0x14, 0x32, 0xd3, 0x1a, 0x15, 0x34, 0x69, 0xcf, 0x19, 0x3c, 0x78, 0xe5, 0x33,
	0x0f, 0x5e, 0x8d, 0xbf, 0xce, 0x41, 0x5d, 0xa3, 0xf0, 0xe0, 0xc1, 0xfa, 0x11, 0x54, 0x53, 0xd8,
	0xe6, 0xa6, 0x2a, 0x47, 0x95, 0xab, 0x06, 0x50, 0x2d, 0x81, 0xad, 0x55, 0xb3, 0xd2, 0xcb, 0x8c,
	0x8c, 0x15, 0xca, 0x84, 0x36, 0x1d, 0x94, 0xbc, 0x2a, 0xe8, 0x31, 0x75, 0x03, 0xe8, 0x35, 0xe2,
	0x74, 0xbc, 0x9d, 0x09, 0xe9, 0x06, 0x5c, 0x5f, 0xf4, 0xe2, 0x67, 0xa8, 0xbf, 0xcf, 0x41, 0x75,
	0xd8, 0x20, 0x43, 0x0f, 0x16, 0xb9, 0x91, 0x07, 0x8b, 0x1b, 0x99, 0x04, 0x9c, 0x4f, 0x33, 0xdf,
	0x20, 0xd7, 0x5e, 0x07, 0x70, 0x23, 0x4b, 0xd7, 0x80, 0xfc, 0xba, 0x56, 0x72, 0xa3, 0xe7, 0x52,
	0x05, 0xae, 0x82, 0x2e, 0x3e, 0xa2, 0x0d, 0xca, 0xc2, 0x2c, 0x3f, 0x20, 0x62, 0x79, 0xa9, 0x2b,
	0x99, 0x41, 0x66, 0x95, 0x6a, 0xa6, 0xf1, 0x77, 0x39, 0x2e, 0x0a, 0x86, 0xf2, 0x99, 0x71, 0x57,
	0xfe, 0x7b, 0xe5, 0x2d, 0xb6, 0xe3, 0x7f, 0x69, 0xb9, 0x6c, 0xf3, 0xdf, 0x73, 0x77, 0xff, 0x38,
	0x05, 0x95, 0x6c, 0xca, 0x3b, 0xd7, 0xc6, 0xe8, 0x62, 0xaa, 0x90, 0x29, 0xa6, 0xc6, 0xbf, 0xac,
	0xd4, 0x60, 0x42, 0xf5, 0x7b, 0xd2, 0x40, 0xe0, 0xcf, 0x31, 0xdd, 0x43, 0xa6, 0x9b, 0x29, 0x0f,
	0x77, 0x33, 0xa3, 0x8d, 0xca, 0xcc, 0xf9, 0x46, 0x65, 0xb8, 0x2c, 0xaf, 0x5e, 0xb5, 0x2c, 0x1f,
	0x79, 0x8d, 0x9b, 0x3d, 0xf7, 0x1a, 0x67, 0xc0, 0x64, 0x6c, 0x07, 0x6f, 0xcc, 0xba, 0xfc, 0x47,
	0x91, 0x1d, 0xbc, 0xc1, 0x3c, 0x45, 0x05, 0xad, 0x0e, 0xe6, 0xa1, 0xbd, 0xf1, 0xd5, 0xed, 0x22,
	0x32, 0x48, 0x3c, 0x67, 0xeb, 0xdb, 0x73, 0x4f, 0x84, 0x73, 0x17, 0x3c, 0x11, 0x2e, 0x8d, 0x74,
	0x26, 0xd9, 0xae, 0x44, 0x3f, 0xd5, 0x9a, 0xc3, 0x4f, 0xb5, 0x1f, 0x0e, 0x5e, 0x54, 0x5b, 0xce,
	0xe0, 0xce, 0x68, 0x45, 0xff, 0x03, 0x08, 0x4d, 0xed, 0x38, 0xfa, 0xd6, 0x68, 0x13, 0x4a, 0xea,
	0x75, 0xe2, 0xf6, 0xba, 0x8a, 0xae, 0x15, 0xb2, 0x15, 0xdd, 0xae, 0xa6, 0x8b, 0xad, 0x52, 0x3e,
	0x63, 0x0d, 0x26, 0x3b, 0xaa, 0x1b, 0x99, 0x8d, 0xa1, 0xfb, 0x8b, 0x0c, 0xc0, 0x3c, 0x55, 0x5d,
	0xb9, 0x1a, 0x40, 0x3e, 0xdc, 0xad, 0x7e, 0xc4, 0xe0, 0x8c, 0xaf, 0x87, 0x18, 0x98, 0x1a, 0x68,
	0x24, 0xaf, 0xa7, 0x63, 0x3c, 0xeb, 0x0c, 0x2e, 0xf5, 0xa5, 0x60, 0x2f, 0x0f, 0x80, 0xa9, 0x8f,
	0x4d, 0x29, 0x16, 0x79, 0xca, 0xa1, 0x5a, 0xbd, 0xd8, 0x94, 0x51, 0xe3, 0xd7, 0x05, 0xa8, 0x8d,
	0x96, 0xcf, 0x17, 0xf9, 0xee, 0x0f, 0xf3, 0xc0, 0xf8, 0xff, 0x3a, 0x0c, 0x06, 0xf7, 0x00, 0xb5,
	0xa1, 0x7b, 0x80, 0x3f, 0xa8, 0xf0, 0xb8, 0x0b, 0x35, 0x3c, 0xad, 0xa1, 0x08, 0xe0, 0x57, 0xc0,
	0x19, 0xa4, 0x0f, 0xdc, 0xff, 0x16, 0x94, 0x75, 0xb4, 0xa0, 0xba, 0x4b, 0xe9, 0xff, 0x07, 0x80,
	0x90, 0x51, 0xe5, 0xf1, 0xc1, 0xa6, 0xaf, 0x1a, 0x96, 0xaf, 0x7a, 0xd5, 0xf0, 0x87, 0x18, 0x9d,
	0x1f, 0xc3, 0x52, 0x3b, 0xb1, 0xa2, 0x63, 0x35, 0xc8, 0xaf, 0x74, 0x17, 0xe0, 0x3a, 0x52, 0xf7,
	0xcf, 0xb5, 0x93, 0x83, 0x63, 0xa5, 0x93, 0xec, 0x41, 0x90, 0x60, 0x51, 0xf0, 0x29, 0x98, 0x23,
	0x17, 0x33, 0x16, 0x37, 0xca, 0xca, 0xa1, 0x2e, 0xa0, 0xd8, 0x5c, 0x0c, 0x87, 0xee, 0x65, 0x5e,
	0xca, 0xec, 0x77, 0x43, 0x83, 0xc6, 0x36, 0xcc, 0x5d, 0xa0, 0x02, 0xc6, 0x52, 0x47, 0x75, 0x25,
	0xaa, 0xf1, 0xa7, 0xb1, 0x0c, 0x45, 0xfa, 0x3f, 0x15, 0x84, 0x8c, 0xbc, 0x84, 0x8d, 0x17, 0xc4,
	0x7b, 0x4e, 0xbf, 0xf1, 0x28, 0xfd, 0xd7, 0x9b, 0x83, 0xaf, 0x5d, 0x6f, 0xcc, 0xa3, 0x6e, 0x1a,
	0x8b, 0xf9, 0x4c, 0x2c, 0x36, 0xfe, 0x66, 0x0a, 0x16, 0xb2, 0x15, 0x54, 0x7c, 0xac, 0x2f, 0x13,
	0xc7, 0xa5, 0xc4, 0x7c, 0x26, 0x25, 0xfe, 0x60, 0x50, 0xf3, 0x3d, 0x6e, 0xe7, 0xbe, 0x23, 0x80,
	0x7c, 0x8f, 0x98, 0xff, 0x0e, 0xd9, 0xee, 0x5b, 0x07, 0xe0, 0xef, 0x25, 0xa2, 0x46, 0x2f, 0xde,
	0x6e, 0x5d, 0xf5, 0xe2, 0xed, 0xf6, 0x98, 0x8b, 0xb7, 0xb7, 0x04, 0xc6, 0x8f, 0xfe, 0x22, 0x07,
	0x95, 0x6c, 0x65, 0x68, 0x2c, 0xc1, 0xdc, 0x9e, 0x7f, 0x62, 0x7b, 0xae, 0x93, 0x25, 0xd7, 0xde,
	0x31, 0x4a, 0x30, 0x75, 0xf8, 0xfc, 0x17, 0xbb, 0xcd, 0x5a, 0xce, 0xa8, 0x41, 0xe5, 0x60, 0x77,
	0xa7, 0xb9, 0x7b, 0x68, 0x31, 0x25, 0x6f, 0x94, 0xa1, 0xf0, 0xf8, 0xe5, 0xfe, 0xd3, 0xdd, 0xe7,
	0xfb, 0xb5, 0x09, 0xa3, 0x02, 0xc5, 0xed, 0xad, 0x3d, 0xeb, 0x57, 0x9f, 0x6f, 0xed, 0xd7, 0x26,
	0x8d, 0x3a, 0xcc, 0xbc, 0xf8, 0xf9, 0xae, 0xf5, 0xcb, 0x97, 0x5b, 0xfb, 0xd6, 0x57, 0x2f, 0xb7,
	0xf6, 0x6b, 0x53, 0xb8, 0xd4, 0xe7, 0xbb, 0xd6, 0xf6, 0x5e, 0x6d, 0xda, 0x98, 0x81, 0xd2, 0xb3,
	0xbd, 0xfd, 0xa7, 0x3b, 0xd6, 0x2f, 0xb6, 0x9a, 0xb5, 0xc2, 0xf6, 0xea, 0xbf, 0x7c, 0x73, 0x23,
	0xf7, 0xeb, 0x6f, 0x6e, 0xe4, 0xfe, 0xe7, 0x9b, 0x1b, 0xb9, 0xbf, 0xfd, 0xcd, 0x8d, 0x77, 0x3e,
	0xcf, 0xfd, 0xaa, 0x92, 0xfd, 0xa7, 0xee, 0xa3, 0x69, 0xfa, 0xb3, 0xf9, 0x7f, 0x01, 0x00, 0x00,
	0xff, 0xff, 0xe6, 0x53, 0x14, 0x03, 0xb6, 0x2e, 0x00, 0x00,
}
