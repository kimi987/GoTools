// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/shared_proto/combatx.proto
// DO NOT EDIT!

package shared_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type CombatTroopsInitProto struct {
	Index   int32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	X       int32 `protobuf:"varint,2,opt,name=x,proto3" json:"x,omitempty"`
	Y       int32 `protobuf:"varint,3,opt,name=y,proto3" json:"y,omitempty"`
	Rage    int32 `protobuf:"varint,4,opt,name=rage,proto3" json:"rage,omitempty"`
	Recover int32 `protobuf:"varint,5,opt,name=recover,proto3" json:"recover,omitempty"`
}

func (m *CombatTroopsInitProto) Reset()                    { *m = CombatTroopsInitProto{} }
func (m *CombatTroopsInitProto) String() string            { return proto.CompactTextString(m) }
func (*CombatTroopsInitProto) ProtoMessage()               {}
func (*CombatTroopsInitProto) Descriptor() ([]byte, []int) { return fileDescriptorCombatx, []int{0} }

func (m *CombatTroopsInitProto) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *CombatTroopsInitProto) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *CombatTroopsInitProto) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *CombatTroopsInitProto) GetRage() int32 {
	if m != nil {
		return m.Rage
	}
	return 0
}

func (m *CombatTroopsInitProto) GetRecover() int32 {
	if m != nil {
		return m.Recover
	}
	return 0
}

type CombatXProto struct {
	// 初始数据 进攻方 防守方
	Attacker          *CombatPlayerProto       `protobuf:"bytes,1,opt,name=attacker" json:"attacker,omitempty"`
	AttackerTroopData []*CombatTroopsInitProto `protobuf:"bytes,7,rep,name=attacker_troop_data,json=attackerTroopData" json:"attacker_troop_data,omitempty"`
	Defenser          *CombatPlayerProto       `protobuf:"bytes,2,opt,name=defenser" json:"defenser,omitempty"`
	DefenserTroopData []*CombatTroopsInitProto `protobuf:"bytes,8,rep,name=defenser_troop_data,json=defenserTroopData" json:"defenser_troop_data,omitempty"`
	MapRes            string                   `protobuf:"bytes,3,opt,name=map_res,json=mapRes,proto3" json:"map_res,omitempty"`
	MapXLen           int32                    `protobuf:"varint,4,opt,name=map_x_len,json=mapXLen,proto3" json:"map_x_len,omitempty"`
	MapYLen           int32                    `protobuf:"varint,5,opt,name=map_y_len,json=mapYLen,proto3" json:"map_y_len,omitempty"`
	// 战斗过程
	Frame    []*CombatFrameProto `protobuf:"bytes,6,rep,name=frame" json:"frame,omitempty"`
	MaxFrame int32               `protobuf:"varint,9,opt,name=max_frame,json=maxFrame,proto3" json:"max_frame,omitempty"`
	// 胜利方 true表示进攻方胜利了
	AttackerWin bool `protobuf:"varint,11,opt,name=attacker_win,json=attackerWin,proto3" json:"attacker_win,omitempty"`
	// 对战双方出战的士兵数量，Key是战斗index，Value是士兵数
	CombatSolider []*Int32Pair `protobuf:"bytes,14,rep,name=combat_solider,json=combatSolider" json:"combat_solider,omitempty"`
	// 存活的士兵，Key是战斗index，Value是士兵数
	AliveSolider []*Int32Pair `protobuf:"bytes,12,rep,name=alive_solider,json=aliveSolider" json:"alive_solider,omitempty"`
	// 击杀的士兵，Key是战斗index，Value是士兵数
	KillSolider []*Int32Pair `protobuf:"bytes,18,rep,name=kill_solider,json=killSolider" json:"kill_solider,omitempty"`
	// 评分，0-险胜 1-小胜 2-大胜 3-完胜
	Score int32 `protobuf:"varint,13,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *CombatXProto) Reset()                    { *m = CombatXProto{} }
func (m *CombatXProto) String() string            { return proto.CompactTextString(m) }
func (*CombatXProto) ProtoMessage()               {}
func (*CombatXProto) Descriptor() ([]byte, []int) { return fileDescriptorCombatx, []int{1} }

func (m *CombatXProto) GetAttacker() *CombatPlayerProto {
	if m != nil {
		return m.Attacker
	}
	return nil
}

func (m *CombatXProto) GetAttackerTroopData() []*CombatTroopsInitProto {
	if m != nil {
		return m.AttackerTroopData
	}
	return nil
}

func (m *CombatXProto) GetDefenser() *CombatPlayerProto {
	if m != nil {
		return m.Defenser
	}
	return nil
}

func (m *CombatXProto) GetDefenserTroopData() []*CombatTroopsInitProto {
	if m != nil {
		return m.DefenserTroopData
	}
	return nil
}

func (m *CombatXProto) GetMapRes() string {
	if m != nil {
		return m.MapRes
	}
	return ""
}

func (m *CombatXProto) GetMapXLen() int32 {
	if m != nil {
		return m.MapXLen
	}
	return 0
}

func (m *CombatXProto) GetMapYLen() int32 {
	if m != nil {
		return m.MapYLen
	}
	return 0
}

func (m *CombatXProto) GetFrame() []*CombatFrameProto {
	if m != nil {
		return m.Frame
	}
	return nil
}

func (m *CombatXProto) GetMaxFrame() int32 {
	if m != nil {
		return m.MaxFrame
	}
	return 0
}

func (m *CombatXProto) GetAttackerWin() bool {
	if m != nil {
		return m.AttackerWin
	}
	return false
}

func (m *CombatXProto) GetCombatSolider() []*Int32Pair {
	if m != nil {
		return m.CombatSolider
	}
	return nil
}

func (m *CombatXProto) GetAliveSolider() []*Int32Pair {
	if m != nil {
		return m.AliveSolider
	}
	return nil
}

func (m *CombatXProto) GetKillSolider() []*Int32Pair {
	if m != nil {
		return m.KillSolider
	}
	return nil
}

func (m *CombatXProto) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

type CombatFrameProto struct {
	Frame  int32               `protobuf:"varint,1,opt,name=frame,proto3" json:"frame,omitempty"`
	Action []*TroopActionProto `protobuf:"bytes,2,rep,name=action" json:"action,omitempty"`
}

func (m *CombatFrameProto) Reset()                    { *m = CombatFrameProto{} }
func (m *CombatFrameProto) String() string            { return proto.CompactTextString(m) }
func (*CombatFrameProto) ProtoMessage()               {}
func (*CombatFrameProto) Descriptor() ([]byte, []int) { return fileDescriptorCombatx, []int{2} }

func (m *CombatFrameProto) GetFrame() int32 {
	if m != nil {
		return m.Frame
	}
	return 0
}

func (m *CombatFrameProto) GetAction() []*TroopActionProto {
	if m != nil {
		return m.Action
	}
	return nil
}

type TroopActionProto struct {
	Index int32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// 行动类型，1-移动 2-放技能 3-技能生效 4-buff生效 5-触发被动 6-短跑
	ActionType int32 `protobuf:"varint,2,opt,name=action_type,json=actionType,proto3" json:"action_type,omitempty"`
	// 移动
	Move *TroopMoveActionProto `protobuf:"bytes,3,opt,name=move" json:"move,omitempty"`
	// 放技能
	ReleaseSpell *TroopReleaseSpellActionProto `protobuf:"bytes,4,opt,name=release_spell,json=releaseSpell" json:"release_spell,omitempty"`
	// 技能生效（延时技能生效）
	SpellEffect *TroopTickEffectProto `protobuf:"bytes,5,opt,name=spell_effect,json=spellEffect" json:"spell_effect,omitempty"`
	// buff生效
	StateEffect *TroopTickEffectProto `protobuf:"bytes,6,opt,name=state_effect,json=stateEffect" json:"state_effect,omitempty"`
	// 触发被动技能
	TriggerPassiveSpell *TroopTriggerPassiveSpellActionProto `protobuf:"bytes,7,opt,name=trigger_passive_spell,json=triggerPassiveSpell" json:"trigger_passive_spell,omitempty"`
}

func (m *TroopActionProto) Reset()                    { *m = TroopActionProto{} }
func (m *TroopActionProto) String() string            { return proto.CompactTextString(m) }
func (*TroopActionProto) ProtoMessage()               {}
func (*TroopActionProto) Descriptor() ([]byte, []int) { return fileDescriptorCombatx, []int{3} }

func (m *TroopActionProto) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *TroopActionProto) GetActionType() int32 {
	if m != nil {
		return m.ActionType
	}
	return 0
}

func (m *TroopActionProto) GetMove() *TroopMoveActionProto {
	if m != nil {
		return m.Move
	}
	return nil
}

func (m *TroopActionProto) GetReleaseSpell() *TroopReleaseSpellActionProto {
	if m != nil {
		return m.ReleaseSpell
	}
	return nil
}

func (m *TroopActionProto) GetSpellEffect() *TroopTickEffectProto {
	if m != nil {
		return m.SpellEffect
	}
	return nil
}

func (m *TroopActionProto) GetStateEffect() *TroopTickEffectProto {
	if m != nil {
		return m.StateEffect
	}
	return nil
}

func (m *TroopActionProto) GetTriggerPassiveSpell() *TroopTriggerPassiveSpellActionProto {
	if m != nil {
		return m.TriggerPassiveSpell
	}
	return nil
}

// 触发被动技能
type TroopTriggerPassiveSpellActionProto struct {
	// 被动技能id
	PassiveSpellId int32 `protobuf:"varint,1,opt,name=passive_spell_id,json=passiveSpellId,proto3" json:"passive_spell_id,omitempty"`
	// 谁的被动技能
	SelfIndex int32 `protobuf:"varint,2,opt,name=self_index,json=selfIndex,proto3" json:"self_index,omitempty"`
	// 给自己加状态
	SelfAddState         []int32 `protobuf:"varint,3,rep,name=self_add_state,json=selfAddState" json:"self_add_state,omitempty"`
	SelfAddStateEndFrame []int32 `protobuf:"varint,4,rep,name=self_add_state_end_frame,json=selfAddStateEndFrame" json:"self_add_state_end_frame,omitempty"`
	// 触发目标
	TargetIndex int32 `protobuf:"varint,21,opt,name=target_index,json=targetIndex,proto3" json:"target_index,omitempty"`
	// 给别人加状态
	TargetAddState         []int32 `protobuf:"varint,22,rep,name=target_add_state,json=targetAddState" json:"target_add_state,omitempty"`
	TargetAddStateEndFrame []int32 `protobuf:"varint,23,rep,name=target_add_state_end_frame,json=targetAddStateEndFrame" json:"target_add_state_end_frame,omitempty"`
	// 持续效果立即生效
	TargetStateEffect []*TroopTickEffectProto `protobuf:"bytes,24,rep,name=target_state_effect,json=targetStateEffect" json:"target_state_effect,omitempty"`
}

func (m *TroopTriggerPassiveSpellActionProto) Reset()         { *m = TroopTriggerPassiveSpellActionProto{} }
func (m *TroopTriggerPassiveSpellActionProto) String() string { return proto.CompactTextString(m) }
func (*TroopTriggerPassiveSpellActionProto) ProtoMessage()    {}
func (*TroopTriggerPassiveSpellActionProto) Descriptor() ([]byte, []int) {
	return fileDescriptorCombatx, []int{4}
}

func (m *TroopTriggerPassiveSpellActionProto) GetPassiveSpellId() int32 {
	if m != nil {
		return m.PassiveSpellId
	}
	return 0
}

func (m *TroopTriggerPassiveSpellActionProto) GetSelfIndex() int32 {
	if m != nil {
		return m.SelfIndex
	}
	return 0
}

func (m *TroopTriggerPassiveSpellActionProto) GetSelfAddState() []int32 {
	if m != nil {
		return m.SelfAddState
	}
	return nil
}

func (m *TroopTriggerPassiveSpellActionProto) GetSelfAddStateEndFrame() []int32 {
	if m != nil {
		return m.SelfAddStateEndFrame
	}
	return nil
}

func (m *TroopTriggerPassiveSpellActionProto) GetTargetIndex() int32 {
	if m != nil {
		return m.TargetIndex
	}
	return 0
}

func (m *TroopTriggerPassiveSpellActionProto) GetTargetAddState() []int32 {
	if m != nil {
		return m.TargetAddState
	}
	return nil
}

func (m *TroopTriggerPassiveSpellActionProto) GetTargetAddStateEndFrame() []int32 {
	if m != nil {
		return m.TargetAddStateEndFrame
	}
	return nil
}

func (m *TroopTriggerPassiveSpellActionProto) GetTargetStateEffect() []*TroopTickEffectProto {
	if m != nil {
		return m.TargetStateEffect
	}
	return nil
}

// 移动
type TroopMoveActionProto struct {
	MoveStartX   int32 `protobuf:"varint,1,opt,name=move_start_x,json=moveStartX,proto3" json:"move_start_x,omitempty"`
	MoveStartY   int32 `protobuf:"varint,2,opt,name=move_start_y,json=moveStartY,proto3" json:"move_start_y,omitempty"`
	MoveEndX     int32 `protobuf:"varint,3,opt,name=move_end_x,json=moveEndX,proto3" json:"move_end_x,omitempty"`
	MoveEndY     int32 `protobuf:"varint,4,opt,name=move_end_y,json=moveEndY,proto3" json:"move_end_y,omitempty"`
	MoveEndFrame int32 `protobuf:"varint,5,opt,name=move_end_frame,json=moveEndFrame,proto3" json:"move_end_frame,omitempty"`
}

func (m *TroopMoveActionProto) Reset()                    { *m = TroopMoveActionProto{} }
func (m *TroopMoveActionProto) String() string            { return proto.CompactTextString(m) }
func (*TroopMoveActionProto) ProtoMessage()               {}
func (*TroopMoveActionProto) Descriptor() ([]byte, []int) { return fileDescriptorCombatx, []int{5} }

func (m *TroopMoveActionProto) GetMoveStartX() int32 {
	if m != nil {
		return m.MoveStartX
	}
	return 0
}

func (m *TroopMoveActionProto) GetMoveStartY() int32 {
	if m != nil {
		return m.MoveStartY
	}
	return 0
}

func (m *TroopMoveActionProto) GetMoveEndX() int32 {
	if m != nil {
		return m.MoveEndX
	}
	return 0
}

func (m *TroopMoveActionProto) GetMoveEndY() int32 {
	if m != nil {
		return m.MoveEndY
	}
	return 0
}

func (m *TroopMoveActionProto) GetMoveEndFrame() int32 {
	if m != nil {
		return m.MoveEndFrame
	}
	return 0
}

// 释放技能
type TroopReleaseSpellActionProto struct {
	ReleaseType int32                           `protobuf:"varint,1,opt,name=release_type,json=releaseType,proto3" json:"release_type,omitempty"`
	SpellId     int32                           `protobuf:"varint,2,opt,name=spell_id,json=spellId,proto3" json:"spell_id,omitempty"`
	EndFrame    int32                           `protobuf:"varint,3,opt,name=end_frame,json=endFrame,proto3" json:"end_frame,omitempty"`
	SpellTarget int32                           `protobuf:"varint,4,opt,name=spell_target,json=spellTarget,proto3" json:"spell_target,omitempty"`
	SpellX      int32                           `protobuf:"varint,5,opt,name=spell_x,json=spellX,proto3" json:"spell_x,omitempty"`
	SpellY      int32                           `protobuf:"varint,6,opt,name=spell_y,json=spellY,proto3" json:"spell_y,omitempty"`
	ClearRage   bool                            `protobuf:"varint,7,opt,name=clear_rage,json=clearRage,proto3" json:"clear_rage,omitempty"`
	Target      []*TroopReleaseSpellEffectProto `protobuf:"bytes,11,rep,name=target" json:"target,omitempty"`
}

func (m *TroopReleaseSpellActionProto) Reset()         { *m = TroopReleaseSpellActionProto{} }
func (m *TroopReleaseSpellActionProto) String() string { return proto.CompactTextString(m) }
func (*TroopReleaseSpellActionProto) ProtoMessage()    {}
func (*TroopReleaseSpellActionProto) Descriptor() ([]byte, []int) {
	return fileDescriptorCombatx, []int{6}
}

func (m *TroopReleaseSpellActionProto) GetReleaseType() int32 {
	if m != nil {
		return m.ReleaseType
	}
	return 0
}

func (m *TroopReleaseSpellActionProto) GetSpellId() int32 {
	if m != nil {
		return m.SpellId
	}
	return 0
}

func (m *TroopReleaseSpellActionProto) GetEndFrame() int32 {
	if m != nil {
		return m.EndFrame
	}
	return 0
}

func (m *TroopReleaseSpellActionProto) GetSpellTarget() int32 {
	if m != nil {
		return m.SpellTarget
	}
	return 0
}

func (m *TroopReleaseSpellActionProto) GetSpellX() int32 {
	if m != nil {
		return m.SpellX
	}
	return 0
}

func (m *TroopReleaseSpellActionProto) GetSpellY() int32 {
	if m != nil {
		return m.SpellY
	}
	return 0
}

func (m *TroopReleaseSpellActionProto) GetClearRage() bool {
	if m != nil {
		return m.ClearRage
	}
	return false
}

func (m *TroopReleaseSpellActionProto) GetTarget() []*TroopReleaseSpellEffectProto {
	if m != nil {
		return m.Target
	}
	return nil
}

type TroopReleaseSpellEffectProto struct {
	TargetIndex int32                 `protobuf:"varint,1,opt,name=target_index,json=targetIndex,proto3" json:"target_index,omitempty"`
	TargetX     int32                 `protobuf:"varint,2,opt,name=target_x,json=targetX,proto3" json:"target_x,omitempty"`
	TargetY     int32                 `protobuf:"varint,3,opt,name=target_y,json=targetY,proto3" json:"target_y,omitempty"`
	EffectFrame int32                 `protobuf:"varint,18,opt,name=effect_frame,json=effectFrame,proto3" json:"effect_frame,omitempty"`
	IsTarget    bool                  `protobuf:"varint,19,opt,name=is_target,json=isTarget,proto3" json:"is_target,omitempty"`
	Rage        *TroopRageUpdateProto `protobuf:"bytes,4,opt,name=rage" json:"rage,omitempty"`
	// 效果
	HurtType         HurtType `protobuf:"varint,10,opt,name=hurt_type,json=hurtType,proto3,enum=proto.HurtType" json:"hurt_type,omitempty"`
	ChangeShield     int32    `protobuf:"zigzag32,11,opt,name=change_shield,json=changeShield,proto3" json:"change_shield,omitempty"`
	ChangeSoldier    int32    `protobuf:"zigzag32,13,opt,name=change_soldier,json=changeSoldier,proto3" json:"change_soldier,omitempty"`
	Soldier          int32    `protobuf:"varint,14,opt,name=soldier,proto3" json:"soldier,omitempty"`
	AddState         []int32  `protobuf:"varint,15,rep,name=add_state,json=addState" json:"add_state,omitempty"`
	AddStateEndFrame []int32  `protobuf:"varint,16,rep,name=add_state_end_frame,json=addStateEndFrame" json:"add_state_end_frame,omitempty"`
	RemoveState      []int32  `protobuf:"varint,17,rep,name=remove_state,json=removeState" json:"remove_state,omitempty"`
}

func (m *TroopReleaseSpellEffectProto) Reset()         { *m = TroopReleaseSpellEffectProto{} }
func (m *TroopReleaseSpellEffectProto) String() string { return proto.CompactTextString(m) }
func (*TroopReleaseSpellEffectProto) ProtoMessage()    {}
func (*TroopReleaseSpellEffectProto) Descriptor() ([]byte, []int) {
	return fileDescriptorCombatx, []int{7}
}

func (m *TroopReleaseSpellEffectProto) GetTargetIndex() int32 {
	if m != nil {
		return m.TargetIndex
	}
	return 0
}

func (m *TroopReleaseSpellEffectProto) GetTargetX() int32 {
	if m != nil {
		return m.TargetX
	}
	return 0
}

func (m *TroopReleaseSpellEffectProto) GetTargetY() int32 {
	if m != nil {
		return m.TargetY
	}
	return 0
}

func (m *TroopReleaseSpellEffectProto) GetEffectFrame() int32 {
	if m != nil {
		return m.EffectFrame
	}
	return 0
}

func (m *TroopReleaseSpellEffectProto) GetIsTarget() bool {
	if m != nil {
		return m.IsTarget
	}
	return false
}

func (m *TroopReleaseSpellEffectProto) GetRage() *TroopRageUpdateProto {
	if m != nil {
		return m.Rage
	}
	return nil
}

func (m *TroopReleaseSpellEffectProto) GetHurtType() HurtType {
	if m != nil {
		return m.HurtType
	}
	return HurtType_InvalidHurtType
}

func (m *TroopReleaseSpellEffectProto) GetChangeShield() int32 {
	if m != nil {
		return m.ChangeShield
	}
	return 0
}

func (m *TroopReleaseSpellEffectProto) GetChangeSoldier() int32 {
	if m != nil {
		return m.ChangeSoldier
	}
	return 0
}

func (m *TroopReleaseSpellEffectProto) GetSoldier() int32 {
	if m != nil {
		return m.Soldier
	}
	return 0
}

func (m *TroopReleaseSpellEffectProto) GetAddState() []int32 {
	if m != nil {
		return m.AddState
	}
	return nil
}

func (m *TroopReleaseSpellEffectProto) GetAddStateEndFrame() []int32 {
	if m != nil {
		return m.AddStateEndFrame
	}
	return nil
}

func (m *TroopReleaseSpellEffectProto) GetRemoveState() []int32 {
	if m != nil {
		return m.RemoveState
	}
	return nil
}

// 怒气变化
type TroopRageUpdateProto struct {
	Rage    int32 `protobuf:"varint,1,opt,name=rage,proto3" json:"rage,omitempty"`
	Recover int32 `protobuf:"varint,2,opt,name=recover,proto3" json:"recover,omitempty"`
}

func (m *TroopRageUpdateProto) Reset()                    { *m = TroopRageUpdateProto{} }
func (m *TroopRageUpdateProto) String() string            { return proto.CompactTextString(m) }
func (*TroopRageUpdateProto) ProtoMessage()               {}
func (*TroopRageUpdateProto) Descriptor() ([]byte, []int) { return fileDescriptorCombatx, []int{8} }

func (m *TroopRageUpdateProto) GetRage() int32 {
	if m != nil {
		return m.Rage
	}
	return 0
}

func (m *TroopRageUpdateProto) GetRecover() int32 {
	if m != nil {
		return m.Recover
	}
	return 0
}

// 技能/状态 生效
type TroopTickEffectProto struct {
	Id   int32                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Rage *TroopRageUpdateProto `protobuf:"bytes,4,opt,name=rage" json:"rage,omitempty"`
	// 效果
	ChangeShield  int32   `protobuf:"zigzag32,11,opt,name=change_shield,json=changeShield,proto3" json:"change_shield,omitempty"`
	ChangeSoldier int32   `protobuf:"zigzag32,13,opt,name=change_soldier,json=changeSoldier,proto3" json:"change_soldier,omitempty"`
	Soldier       int32   `protobuf:"varint,14,opt,name=soldier,proto3" json:"soldier,omitempty"`
	RemoveState   []int32 `protobuf:"varint,17,rep,name=remove_state,json=removeState" json:"remove_state,omitempty"`
}

func (m *TroopTickEffectProto) Reset()                    { *m = TroopTickEffectProto{} }
func (m *TroopTickEffectProto) String() string            { return proto.CompactTextString(m) }
func (*TroopTickEffectProto) ProtoMessage()               {}
func (*TroopTickEffectProto) Descriptor() ([]byte, []int) { return fileDescriptorCombatx, []int{9} }

func (m *TroopTickEffectProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TroopTickEffectProto) GetRage() *TroopRageUpdateProto {
	if m != nil {
		return m.Rage
	}
	return nil
}

func (m *TroopTickEffectProto) GetChangeShield() int32 {
	if m != nil {
		return m.ChangeShield
	}
	return 0
}

func (m *TroopTickEffectProto) GetChangeSoldier() int32 {
	if m != nil {
		return m.ChangeSoldier
	}
	return 0
}

func (m *TroopTickEffectProto) GetSoldier() int32 {
	if m != nil {
		return m.Soldier
	}
	return 0
}

func (m *TroopTickEffectProto) GetRemoveState() []int32 {
	if m != nil {
		return m.RemoveState
	}
	return nil
}

func init() {
	proto.RegisterType((*CombatTroopsInitProto)(nil), "proto.CombatTroopsInitProto")
	proto.RegisterType((*CombatXProto)(nil), "proto.CombatXProto")
	proto.RegisterType((*CombatFrameProto)(nil), "proto.CombatFrameProto")
	proto.RegisterType((*TroopActionProto)(nil), "proto.TroopActionProto")
	proto.RegisterType((*TroopTriggerPassiveSpellActionProto)(nil), "proto.TroopTriggerPassiveSpellActionProto")
	proto.RegisterType((*TroopMoveActionProto)(nil), "proto.TroopMoveActionProto")
	proto.RegisterType((*TroopReleaseSpellActionProto)(nil), "proto.TroopReleaseSpellActionProto")
	proto.RegisterType((*TroopReleaseSpellEffectProto)(nil), "proto.TroopReleaseSpellEffectProto")
	proto.RegisterType((*TroopRageUpdateProto)(nil), "proto.TroopRageUpdateProto")
	proto.RegisterType((*TroopTickEffectProto)(nil), "proto.TroopTickEffectProto")
}
func (m *CombatTroopsInitProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombatTroopsInitProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.Index))
	}
	if m.X != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.Y))
	}
	if m.Rage != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.Rage))
	}
	if m.Recover != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.Recover))
	}
	return i, nil
}

func (m *CombatXProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombatXProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Attacker != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.Attacker.Size()))
		n1, err := m.Attacker.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Defenser != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.Defenser.Size()))
		n2, err := m.Defenser.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.MapRes) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(len(m.MapRes)))
		i += copy(dAtA[i:], m.MapRes)
	}
	if m.MapXLen != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.MapXLen))
	}
	if m.MapYLen != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.MapYLen))
	}
	if len(m.Frame) > 0 {
		for _, msg := range m.Frame {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCombatx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AttackerTroopData) > 0 {
		for _, msg := range m.AttackerTroopData {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintCombatx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DefenserTroopData) > 0 {
		for _, msg := range m.DefenserTroopData {
			dAtA[i] = 0x42
			i++
			i = encodeVarintCombatx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MaxFrame != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.MaxFrame))
	}
	if m.AttackerWin {
		dAtA[i] = 0x58
		i++
		if m.AttackerWin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AliveSolider) > 0 {
		for _, msg := range m.AliveSolider {
			dAtA[i] = 0x62
			i++
			i = encodeVarintCombatx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Score != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.Score))
	}
	if len(m.CombatSolider) > 0 {
		for _, msg := range m.CombatSolider {
			dAtA[i] = 0x72
			i++
			i = encodeVarintCombatx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.KillSolider) > 0 {
		for _, msg := range m.KillSolider {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCombatx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CombatFrameProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombatFrameProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Frame != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.Frame))
	}
	if len(m.Action) > 0 {
		for _, msg := range m.Action {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCombatx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TroopActionProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TroopActionProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.Index))
	}
	if m.ActionType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.ActionType))
	}
	if m.Move != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.Move.Size()))
		n3, err := m.Move.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ReleaseSpell != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.ReleaseSpell.Size()))
		n4, err := m.ReleaseSpell.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.SpellEffect != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.SpellEffect.Size()))
		n5, err := m.SpellEffect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.StateEffect != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.StateEffect.Size()))
		n6, err := m.StateEffect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.TriggerPassiveSpell != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.TriggerPassiveSpell.Size()))
		n7, err := m.TriggerPassiveSpell.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *TroopTriggerPassiveSpellActionProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TroopTriggerPassiveSpellActionProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PassiveSpellId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.PassiveSpellId))
	}
	if m.SelfIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.SelfIndex))
	}
	if len(m.SelfAddState) > 0 {
		for _, num := range m.SelfAddState {
			dAtA[i] = 0x18
			i++
			i = encodeVarintCombatx(dAtA, i, uint64(num))
		}
	}
	if len(m.SelfAddStateEndFrame) > 0 {
		for _, num := range m.SelfAddStateEndFrame {
			dAtA[i] = 0x20
			i++
			i = encodeVarintCombatx(dAtA, i, uint64(num))
		}
	}
	if m.TargetIndex != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.TargetIndex))
	}
	if len(m.TargetAddState) > 0 {
		for _, num := range m.TargetAddState {
			dAtA[i] = 0xb0
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCombatx(dAtA, i, uint64(num))
		}
	}
	if len(m.TargetAddStateEndFrame) > 0 {
		for _, num := range m.TargetAddStateEndFrame {
			dAtA[i] = 0xb8
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCombatx(dAtA, i, uint64(num))
		}
	}
	if len(m.TargetStateEffect) > 0 {
		for _, msg := range m.TargetStateEffect {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCombatx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TroopMoveActionProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TroopMoveActionProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MoveStartX != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.MoveStartX))
	}
	if m.MoveStartY != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.MoveStartY))
	}
	if m.MoveEndX != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.MoveEndX))
	}
	if m.MoveEndY != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.MoveEndY))
	}
	if m.MoveEndFrame != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.MoveEndFrame))
	}
	return i, nil
}

func (m *TroopReleaseSpellActionProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TroopReleaseSpellActionProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReleaseType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.ReleaseType))
	}
	if m.SpellId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.SpellId))
	}
	if m.EndFrame != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.EndFrame))
	}
	if m.SpellTarget != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.SpellTarget))
	}
	if m.SpellX != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.SpellX))
	}
	if m.SpellY != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.SpellY))
	}
	if m.ClearRage {
		dAtA[i] = 0x38
		i++
		if m.ClearRage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Target) > 0 {
		for _, msg := range m.Target {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintCombatx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TroopReleaseSpellEffectProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TroopReleaseSpellEffectProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TargetIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.TargetIndex))
	}
	if m.TargetX != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.TargetX))
	}
	if m.TargetY != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.TargetY))
	}
	if m.Rage != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.Rage.Size()))
		n8, err := m.Rage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.HurtType != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.HurtType))
	}
	if m.ChangeShield != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCombatx(dAtA, i, uint64((uint32(m.ChangeShield)<<1)^uint32((m.ChangeShield>>31))))
	}
	if m.ChangeSoldier != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCombatx(dAtA, i, uint64((uint32(m.ChangeSoldier)<<1)^uint32((m.ChangeSoldier>>31))))
	}
	if m.Soldier != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.Soldier))
	}
	if len(m.AddState) > 0 {
		for _, num := range m.AddState {
			dAtA[i] = 0x78
			i++
			i = encodeVarintCombatx(dAtA, i, uint64(num))
		}
	}
	if len(m.AddStateEndFrame) > 0 {
		for _, num := range m.AddStateEndFrame {
			dAtA[i] = 0x80
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCombatx(dAtA, i, uint64(num))
		}
	}
	if len(m.RemoveState) > 0 {
		for _, num := range m.RemoveState {
			dAtA[i] = 0x88
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCombatx(dAtA, i, uint64(num))
		}
	}
	if m.EffectFrame != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.EffectFrame))
	}
	if m.IsTarget {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.IsTarget {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *TroopRageUpdateProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TroopRageUpdateProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rage != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.Rage))
	}
	if m.Recover != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.Recover))
	}
	return i, nil
}

func (m *TroopTickEffectProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TroopTickEffectProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.Id))
	}
	if m.Rage != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.Rage.Size()))
		n9, err := m.Rage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.ChangeShield != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCombatx(dAtA, i, uint64((uint32(m.ChangeShield)<<1)^uint32((m.ChangeShield>>31))))
	}
	if m.ChangeSoldier != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCombatx(dAtA, i, uint64((uint32(m.ChangeSoldier)<<1)^uint32((m.ChangeSoldier>>31))))
	}
	if m.Soldier != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCombatx(dAtA, i, uint64(m.Soldier))
	}
	if len(m.RemoveState) > 0 {
		for _, num := range m.RemoveState {
			dAtA[i] = 0x88
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCombatx(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func encodeFixed64Combatx(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Combatx(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintCombatx(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CombatTroopsInitProto) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovCombatx(uint64(m.Index))
	}
	if m.X != 0 {
		n += 1 + sovCombatx(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovCombatx(uint64(m.Y))
	}
	if m.Rage != 0 {
		n += 1 + sovCombatx(uint64(m.Rage))
	}
	if m.Recover != 0 {
		n += 1 + sovCombatx(uint64(m.Recover))
	}
	return n
}

func (m *CombatXProto) Size() (n int) {
	var l int
	_ = l
	if m.Attacker != nil {
		l = m.Attacker.Size()
		n += 1 + l + sovCombatx(uint64(l))
	}
	if m.Defenser != nil {
		l = m.Defenser.Size()
		n += 1 + l + sovCombatx(uint64(l))
	}
	l = len(m.MapRes)
	if l > 0 {
		n += 1 + l + sovCombatx(uint64(l))
	}
	if m.MapXLen != 0 {
		n += 1 + sovCombatx(uint64(m.MapXLen))
	}
	if m.MapYLen != 0 {
		n += 1 + sovCombatx(uint64(m.MapYLen))
	}
	if len(m.Frame) > 0 {
		for _, e := range m.Frame {
			l = e.Size()
			n += 1 + l + sovCombatx(uint64(l))
		}
	}
	if len(m.AttackerTroopData) > 0 {
		for _, e := range m.AttackerTroopData {
			l = e.Size()
			n += 1 + l + sovCombatx(uint64(l))
		}
	}
	if len(m.DefenserTroopData) > 0 {
		for _, e := range m.DefenserTroopData {
			l = e.Size()
			n += 1 + l + sovCombatx(uint64(l))
		}
	}
	if m.MaxFrame != 0 {
		n += 1 + sovCombatx(uint64(m.MaxFrame))
	}
	if m.AttackerWin {
		n += 2
	}
	if len(m.AliveSolider) > 0 {
		for _, e := range m.AliveSolider {
			l = e.Size()
			n += 1 + l + sovCombatx(uint64(l))
		}
	}
	if m.Score != 0 {
		n += 1 + sovCombatx(uint64(m.Score))
	}
	if len(m.CombatSolider) > 0 {
		for _, e := range m.CombatSolider {
			l = e.Size()
			n += 1 + l + sovCombatx(uint64(l))
		}
	}
	if len(m.KillSolider) > 0 {
		for _, e := range m.KillSolider {
			l = e.Size()
			n += 2 + l + sovCombatx(uint64(l))
		}
	}
	return n
}

func (m *CombatFrameProto) Size() (n int) {
	var l int
	_ = l
	if m.Frame != 0 {
		n += 1 + sovCombatx(uint64(m.Frame))
	}
	if len(m.Action) > 0 {
		for _, e := range m.Action {
			l = e.Size()
			n += 1 + l + sovCombatx(uint64(l))
		}
	}
	return n
}

func (m *TroopActionProto) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovCombatx(uint64(m.Index))
	}
	if m.ActionType != 0 {
		n += 1 + sovCombatx(uint64(m.ActionType))
	}
	if m.Move != nil {
		l = m.Move.Size()
		n += 1 + l + sovCombatx(uint64(l))
	}
	if m.ReleaseSpell != nil {
		l = m.ReleaseSpell.Size()
		n += 1 + l + sovCombatx(uint64(l))
	}
	if m.SpellEffect != nil {
		l = m.SpellEffect.Size()
		n += 1 + l + sovCombatx(uint64(l))
	}
	if m.StateEffect != nil {
		l = m.StateEffect.Size()
		n += 1 + l + sovCombatx(uint64(l))
	}
	if m.TriggerPassiveSpell != nil {
		l = m.TriggerPassiveSpell.Size()
		n += 1 + l + sovCombatx(uint64(l))
	}
	return n
}

func (m *TroopTriggerPassiveSpellActionProto) Size() (n int) {
	var l int
	_ = l
	if m.PassiveSpellId != 0 {
		n += 1 + sovCombatx(uint64(m.PassiveSpellId))
	}
	if m.SelfIndex != 0 {
		n += 1 + sovCombatx(uint64(m.SelfIndex))
	}
	if len(m.SelfAddState) > 0 {
		for _, e := range m.SelfAddState {
			n += 1 + sovCombatx(uint64(e))
		}
	}
	if len(m.SelfAddStateEndFrame) > 0 {
		for _, e := range m.SelfAddStateEndFrame {
			n += 1 + sovCombatx(uint64(e))
		}
	}
	if m.TargetIndex != 0 {
		n += 2 + sovCombatx(uint64(m.TargetIndex))
	}
	if len(m.TargetAddState) > 0 {
		for _, e := range m.TargetAddState {
			n += 2 + sovCombatx(uint64(e))
		}
	}
	if len(m.TargetAddStateEndFrame) > 0 {
		for _, e := range m.TargetAddStateEndFrame {
			n += 2 + sovCombatx(uint64(e))
		}
	}
	if len(m.TargetStateEffect) > 0 {
		for _, e := range m.TargetStateEffect {
			l = e.Size()
			n += 2 + l + sovCombatx(uint64(l))
		}
	}
	return n
}

func (m *TroopMoveActionProto) Size() (n int) {
	var l int
	_ = l
	if m.MoveStartX != 0 {
		n += 1 + sovCombatx(uint64(m.MoveStartX))
	}
	if m.MoveStartY != 0 {
		n += 1 + sovCombatx(uint64(m.MoveStartY))
	}
	if m.MoveEndX != 0 {
		n += 1 + sovCombatx(uint64(m.MoveEndX))
	}
	if m.MoveEndY != 0 {
		n += 1 + sovCombatx(uint64(m.MoveEndY))
	}
	if m.MoveEndFrame != 0 {
		n += 1 + sovCombatx(uint64(m.MoveEndFrame))
	}
	return n
}

func (m *TroopReleaseSpellActionProto) Size() (n int) {
	var l int
	_ = l
	if m.ReleaseType != 0 {
		n += 1 + sovCombatx(uint64(m.ReleaseType))
	}
	if m.SpellId != 0 {
		n += 1 + sovCombatx(uint64(m.SpellId))
	}
	if m.EndFrame != 0 {
		n += 1 + sovCombatx(uint64(m.EndFrame))
	}
	if m.SpellTarget != 0 {
		n += 1 + sovCombatx(uint64(m.SpellTarget))
	}
	if m.SpellX != 0 {
		n += 1 + sovCombatx(uint64(m.SpellX))
	}
	if m.SpellY != 0 {
		n += 1 + sovCombatx(uint64(m.SpellY))
	}
	if m.ClearRage {
		n += 2
	}
	if len(m.Target) > 0 {
		for _, e := range m.Target {
			l = e.Size()
			n += 1 + l + sovCombatx(uint64(l))
		}
	}
	return n
}

func (m *TroopReleaseSpellEffectProto) Size() (n int) {
	var l int
	_ = l
	if m.TargetIndex != 0 {
		n += 1 + sovCombatx(uint64(m.TargetIndex))
	}
	if m.TargetX != 0 {
		n += 1 + sovCombatx(uint64(m.TargetX))
	}
	if m.TargetY != 0 {
		n += 1 + sovCombatx(uint64(m.TargetY))
	}
	if m.Rage != nil {
		l = m.Rage.Size()
		n += 1 + l + sovCombatx(uint64(l))
	}
	if m.HurtType != 0 {
		n += 1 + sovCombatx(uint64(m.HurtType))
	}
	if m.ChangeShield != 0 {
		n += 1 + sozCombatx(uint64(m.ChangeShield))
	}
	if m.ChangeSoldier != 0 {
		n += 1 + sozCombatx(uint64(m.ChangeSoldier))
	}
	if m.Soldier != 0 {
		n += 1 + sovCombatx(uint64(m.Soldier))
	}
	if len(m.AddState) > 0 {
		for _, e := range m.AddState {
			n += 1 + sovCombatx(uint64(e))
		}
	}
	if len(m.AddStateEndFrame) > 0 {
		for _, e := range m.AddStateEndFrame {
			n += 2 + sovCombatx(uint64(e))
		}
	}
	if len(m.RemoveState) > 0 {
		for _, e := range m.RemoveState {
			n += 2 + sovCombatx(uint64(e))
		}
	}
	if m.EffectFrame != 0 {
		n += 2 + sovCombatx(uint64(m.EffectFrame))
	}
	if m.IsTarget {
		n += 3
	}
	return n
}

func (m *TroopRageUpdateProto) Size() (n int) {
	var l int
	_ = l
	if m.Rage != 0 {
		n += 1 + sovCombatx(uint64(m.Rage))
	}
	if m.Recover != 0 {
		n += 1 + sovCombatx(uint64(m.Recover))
	}
	return n
}

func (m *TroopTickEffectProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCombatx(uint64(m.Id))
	}
	if m.Rage != nil {
		l = m.Rage.Size()
		n += 1 + l + sovCombatx(uint64(l))
	}
	if m.ChangeShield != 0 {
		n += 1 + sozCombatx(uint64(m.ChangeShield))
	}
	if m.ChangeSoldier != 0 {
		n += 1 + sozCombatx(uint64(m.ChangeSoldier))
	}
	if m.Soldier != 0 {
		n += 1 + sovCombatx(uint64(m.Soldier))
	}
	if len(m.RemoveState) > 0 {
		for _, e := range m.RemoveState {
			n += 2 + sovCombatx(uint64(e))
		}
	}
	return n
}

func sovCombatx(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCombatx(x uint64) (n int) {
	return sovCombatx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CombatTroopsInitProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombatx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombatTroopsInitProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombatTroopsInitProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rage", wireType)
			}
			m.Rage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recover", wireType)
			}
			m.Recover = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Recover |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCombatx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombatx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombatXProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombatx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombatXProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombatXProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attacker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attacker == nil {
				m.Attacker = &CombatPlayerProto{}
			}
			if err := m.Attacker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defenser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Defenser == nil {
				m.Defenser = &CombatPlayerProto{}
			}
			if err := m.Defenser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapRes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapRes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapXLen", wireType)
			}
			m.MapXLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapXLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapYLen", wireType)
			}
			m.MapYLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapYLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frame", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Frame = append(m.Frame, &CombatFrameProto{})
			if err := m.Frame[len(m.Frame)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerTroopData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttackerTroopData = append(m.AttackerTroopData, &CombatTroopsInitProto{})
			if err := m.AttackerTroopData[len(m.AttackerTroopData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserTroopData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefenserTroopData = append(m.DefenserTroopData, &CombatTroopsInitProto{})
			if err := m.DefenserTroopData[len(m.DefenserTroopData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFrame", wireType)
			}
			m.MaxFrame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFrame |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerWin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttackerWin = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliveSolider", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliveSolider = append(m.AliveSolider, &Int32Pair{})
			if err := m.AliveSolider[len(m.AliveSolider)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CombatSolider", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CombatSolider = append(m.CombatSolider, &Int32Pair{})
			if err := m.CombatSolider[len(m.CombatSolider)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillSolider", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KillSolider = append(m.KillSolider, &Int32Pair{})
			if err := m.KillSolider[len(m.KillSolider)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCombatx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombatx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombatFrameProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombatx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombatFrameProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombatFrameProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frame", wireType)
			}
			m.Frame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frame |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = append(m.Action, &TroopActionProto{})
			if err := m.Action[len(m.Action)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCombatx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombatx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TroopActionProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombatx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TroopActionProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TroopActionProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionType", wireType)
			}
			m.ActionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Move", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Move == nil {
				m.Move = &TroopMoveActionProto{}
			}
			if err := m.Move.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseSpell", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReleaseSpell == nil {
				m.ReleaseSpell = &TroopReleaseSpellActionProto{}
			}
			if err := m.ReleaseSpell.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpellEffect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpellEffect == nil {
				m.SpellEffect = &TroopTickEffectProto{}
			}
			if err := m.SpellEffect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateEffect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StateEffect == nil {
				m.StateEffect = &TroopTickEffectProto{}
			}
			if err := m.StateEffect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerPassiveSpell", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TriggerPassiveSpell == nil {
				m.TriggerPassiveSpell = &TroopTriggerPassiveSpellActionProto{}
			}
			if err := m.TriggerPassiveSpell.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCombatx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombatx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TroopTriggerPassiveSpellActionProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombatx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TroopTriggerPassiveSpellActionProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TroopTriggerPassiveSpellActionProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassiveSpellId", wireType)
			}
			m.PassiveSpellId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PassiveSpellId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfIndex", wireType)
			}
			m.SelfIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombatx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SelfAddState = append(m.SelfAddState, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombatx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCombatx
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCombatx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SelfAddState = append(m.SelfAddState, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfAddState", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombatx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SelfAddStateEndFrame = append(m.SelfAddStateEndFrame, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombatx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCombatx
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCombatx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SelfAddStateEndFrame = append(m.SelfAddStateEndFrame, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfAddStateEndFrame", wireType)
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetIndex", wireType)
			}
			m.TargetIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombatx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TargetAddState = append(m.TargetAddState, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombatx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCombatx
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCombatx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TargetAddState = append(m.TargetAddState, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAddState", wireType)
			}
		case 23:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombatx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TargetAddStateEndFrame = append(m.TargetAddStateEndFrame, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombatx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCombatx
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCombatx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TargetAddStateEndFrame = append(m.TargetAddStateEndFrame, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAddStateEndFrame", wireType)
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetStateEffect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetStateEffect = append(m.TargetStateEffect, &TroopTickEffectProto{})
			if err := m.TargetStateEffect[len(m.TargetStateEffect)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCombatx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombatx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TroopMoveActionProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombatx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TroopMoveActionProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TroopMoveActionProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveStartX", wireType)
			}
			m.MoveStartX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveStartX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveStartY", wireType)
			}
			m.MoveStartY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveStartY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveEndX", wireType)
			}
			m.MoveEndX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveEndX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveEndY", wireType)
			}
			m.MoveEndY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveEndY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveEndFrame", wireType)
			}
			m.MoveEndFrame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveEndFrame |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCombatx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombatx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TroopReleaseSpellActionProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombatx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TroopReleaseSpellActionProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TroopReleaseSpellActionProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseType", wireType)
			}
			m.ReleaseType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReleaseType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpellId", wireType)
			}
			m.SpellId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpellId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndFrame", wireType)
			}
			m.EndFrame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndFrame |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpellTarget", wireType)
			}
			m.SpellTarget = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpellTarget |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpellX", wireType)
			}
			m.SpellX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpellX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpellY", wireType)
			}
			m.SpellY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpellY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearRage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClearRage = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target, &TroopReleaseSpellEffectProto{})
			if err := m.Target[len(m.Target)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCombatx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombatx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TroopReleaseSpellEffectProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombatx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TroopReleaseSpellEffectProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TroopReleaseSpellEffectProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetIndex", wireType)
			}
			m.TargetIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetX", wireType)
			}
			m.TargetX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetY", wireType)
			}
			m.TargetY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rage == nil {
				m.Rage = &TroopRageUpdateProto{}
			}
			if err := m.Rage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtType", wireType)
			}
			m.HurtType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HurtType |= (HurtType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeShield", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ChangeShield = v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeSoldier", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ChangeSoldier = v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Soldier", wireType)
			}
			m.Soldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Soldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombatx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AddState = append(m.AddState, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombatx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCombatx
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCombatx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AddState = append(m.AddState, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AddState", wireType)
			}
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombatx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AddStateEndFrame = append(m.AddStateEndFrame, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombatx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCombatx
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCombatx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AddStateEndFrame = append(m.AddStateEndFrame, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AddStateEndFrame", wireType)
			}
		case 17:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombatx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RemoveState = append(m.RemoveState, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombatx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCombatx
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCombatx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RemoveState = append(m.RemoveState, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveState", wireType)
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectFrame", wireType)
			}
			m.EffectFrame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectFrame |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTarget", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTarget = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCombatx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombatx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TroopRageUpdateProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombatx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TroopRageUpdateProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TroopRageUpdateProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rage", wireType)
			}
			m.Rage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recover", wireType)
			}
			m.Recover = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Recover |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCombatx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombatx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TroopTickEffectProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombatx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TroopTickEffectProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TroopTickEffectProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombatx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rage == nil {
				m.Rage = &TroopRageUpdateProto{}
			}
			if err := m.Rage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeShield", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ChangeShield = v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeSoldier", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ChangeSoldier = v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Soldier", wireType)
			}
			m.Soldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Soldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombatx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RemoveState = append(m.RemoveState, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombatx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCombatx
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCombatx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RemoveState = append(m.RemoveState, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveState", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCombatx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombatx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCombatx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCombatx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCombatx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCombatx
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCombatx
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCombatx(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCombatx = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCombatx   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/shared_proto/combatx.proto", fileDescriptorCombatx)
}

var fileDescriptorCombatx = []byte{
	// 1229 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0xcd, 0x6e, 0xdb, 0xc6,
	0x13, 0x0f, 0x25, 0xeb, 0x6b, 0x48, 0x2b, 0xf2, 0x3a, 0x1f, 0x8c, 0x9d, 0xbf, 0xa3, 0x28, 0xff,
	0x00, 0x42, 0x91, 0xc6, 0xa8, 0x93, 0x36, 0x40, 0x0b, 0x04, 0x48, 0x9a, 0x14, 0x31, 0x90, 0xa2,
	0x06, 0xe5, 0xa2, 0x76, 0x0f, 0x25, 0xd6, 0xe2, 0x5a, 0x22, 0x42, 0x91, 0xc4, 0x72, 0xe3, 0x48,
	0x8f, 0xd1, 0x5b, 0x1f, 0xa0, 0xa7, 0x3e, 0x40, 0x4f, 0x7d, 0x80, 0x1e, 0xfb, 0x08, 0x45, 0xda,
	0x77, 0xe8, 0xb5, 0xd8, 0x99, 0x25, 0x45, 0xc9, 0x1f, 0x70, 0x2e, 0x3d, 0x59, 0x3b, 0xbf, 0xdf,
	0x6f, 0x76, 0x66, 0x67, 0x86, 0xbb, 0x86, 0x27, 0xa3, 0x50, 0x8d, 0xdf, 0x1e, 0x3d, 0x1c, 0x26,
	0x93, 0xed, 0x28, 0x1c, 0x8d, 0x55, 0xca, 0xdf, 0x6d, 0x4f, 0x78, 0x24, 0x9e, 0x6c, 0xa7, 0x47,
	0xdb, 0xd9, 0x98, 0x4b, 0x11, 0xf8, 0xa9, 0x4c, 0x54, 0xb2, 0x3d, 0x4c, 0x26, 0x47, 0x5c, 0x4d,
	0x1f, 0xe2, 0x8a, 0xd5, 0xf0, 0xcf, 0xc6, 0xe3, 0xcb, 0xeb, 0x8f, 0x78, 0x26, 0x48, 0xbc, 0xf1,
	0xd9, 0x87, 0xee, 0x4a, 0xba, 0xde, 0x3b, 0xb8, 0xfe, 0x25, 0xae, 0xf7, 0x65, 0x92, 0xa4, 0xd9,
	0x6e, 0x1c, 0xaa, 0x3d, 0x8c, 0xe6, 0x1a, 0xd4, 0xc2, 0x38, 0x10, 0x53, 0xd7, 0xea, 0x5a, 0xfd,
	0x9a, 0x47, 0x0b, 0xe6, 0x80, 0x35, 0x75, 0x2b, 0x68, 0xb1, 0x70, 0x35, 0x73, 0xab, 0xb4, 0x9a,
	0x31, 0x06, 0x2b, 0x92, 0x8f, 0x84, 0xbb, 0x82, 0x06, 0xfc, 0xcd, 0x5c, 0x68, 0x48, 0x31, 0x4c,
	0x4e, 0x84, 0x74, 0x6b, 0x68, 0xce, 0x97, 0xbd, 0x1f, 0x6b, 0xe0, 0xd0, 0xce, 0x07, 0xb4, 0xe1,
	0x63, 0x68, 0x72, 0xa5, 0xf8, 0xf0, 0x8d, 0x90, 0xb8, 0xa7, 0xbd, 0xe3, 0x52, 0x8c, 0x0f, 0x89,
	0xb6, 0x17, 0xf1, 0x99, 0x90, 0xc8, 0xf5, 0x0a, 0xa6, 0x56, 0x05, 0xe2, 0x58, 0xc4, 0x99, 0x90,
	0x18, 0xd7, 0x85, 0xaa, 0x9c, 0xc9, 0x6e, 0x42, 0x63, 0xc2, 0x53, 0x5f, 0x8a, 0x0c, 0xc3, 0x6f,
	0x79, 0xf5, 0x09, 0x4f, 0x3d, 0x91, 0xb1, 0x0d, 0x68, 0x69, 0x60, 0xea, 0x47, 0x22, 0x36, 0x89,
	0x68, 0xe6, 0xc1, 0x6b, 0x11, 0xe7, 0xd8, 0x0c, 0xb1, 0x5a, 0x81, 0x1d, 0x6a, 0xec, 0x63, 0xa8,
	0x1d, 0x4b, 0x3e, 0x11, 0x6e, 0xbd, 0x5b, 0xed, 0xdb, 0x3b, 0x37, 0x17, 0x62, 0xf8, 0x4a, 0x23,
	0x14, 0x02, 0xb1, 0xd8, 0x6b, 0x58, 0xcf, 0x33, 0xf0, 0x95, 0x3e, 0x78, 0x3f, 0xe0, 0x8a, 0xbb,
	0x0d, 0x14, 0xdf, 0x5e, 0x10, 0x2f, 0xd5, 0xc5, 0x5b, 0xcb, 0x85, 0x08, 0xbc, 0xe0, 0x8a, 0x6b,
	0x6f, 0x79, 0x66, 0x65, 0x6f, 0xcd, 0xcb, 0x78, 0xcb, 0x85, 0x73, 0x6f, 0x9b, 0x3a, 0xcd, 0xa9,
	0x4f, 0xe9, 0xb4, 0x30, 0xcd, 0xe6, 0x84, 0x4f, 0x31, 0x09, 0x76, 0x17, 0x9c, 0x22, 0xf0, 0x77,
	0x61, 0xec, 0xda, 0x5d, 0xab, 0xdf, 0xf4, 0xec, 0xdc, 0xf6, 0x5d, 0x18, 0xb3, 0x4f, 0x61, 0x95,
	0x47, 0xe1, 0x89, 0xf0, 0xb3, 0x24, 0x0a, 0x03, 0x21, 0x5d, 0x07, 0xe3, 0xe8, 0x98, 0x38, 0x76,
	0x63, 0xf5, 0x68, 0x67, 0x8f, 0x87, 0xd2, 0x73, 0x90, 0x36, 0x20, 0x96, 0xee, 0xb7, 0x6c, 0x98,
	0x48, 0xe1, 0xae, 0x52, 0xbf, 0xe1, 0x82, 0x3d, 0x81, 0x36, 0xb5, 0x6b, 0xe1, 0xad, 0x7d, 0x8e,
	0xb7, 0x55, 0xe2, 0xe5, 0xee, 0x1e, 0x81, 0xf3, 0x26, 0x8c, 0xa2, 0x42, 0xc6, 0xce, 0x91, 0xd9,
	0x9a, 0x65, 0x44, 0xbd, 0x43, 0xe8, 0x2c, 0x57, 0x4c, 0xc7, 0x45, 0x47, 0x61, 0xe6, 0x80, 0x0a,
	0xb8, 0x0d, 0x75, 0x3e, 0x54, 0x61, 0x12, 0xbb, 0x95, 0x85, 0x82, 0xe3, 0x31, 0x3e, 0x43, 0x84,
	0x0e, 0xd8, 0xd0, 0x7a, 0x3f, 0x57, 0xa1, 0xb3, 0x0c, 0x9e, 0x33, 0x63, 0x77, 0xc0, 0x26, 0x91,
	0xaf, 0x66, 0xa9, 0x30, 0xd3, 0x06, 0x64, 0xda, 0x9f, 0xa5, 0x7a, 0xf3, 0x95, 0x49, 0x72, 0x22,
	0xb0, 0x75, 0xed, 0x9d, 0xcd, 0xf2, 0xd6, 0x5f, 0x27, 0x27, 0xa2, 0xbc, 0x3d, 0x12, 0xd9, 0x2b,
	0x58, 0x95, 0x22, 0x12, 0x3c, 0x13, 0x7e, 0x96, 0x8a, 0x28, 0xc2, 0xce, 0xb6, 0x77, 0xee, 0x95,
	0x95, 0x1e, 0x11, 0x06, 0x1a, 0x2f, 0x7b, 0x70, 0x64, 0x09, 0x60, 0x4f, 0xc1, 0x41, 0x0f, 0xbe,
	0x38, 0x3e, 0x16, 0x43, 0x85, 0x63, 0xb0, 0x14, 0xc2, 0x7e, 0x38, 0x7c, 0xf3, 0x12, 0x51, 0x72,
	0x60, 0xa3, 0x80, 0x2c, 0xa8, 0x57, 0x5c, 0x89, 0x5c, 0x5f, 0xbf, 0x8c, 0x5e, 0x0b, 0x8c, 0xfe,
	0x07, 0xb8, 0xae, 0x64, 0x38, 0x1a, 0x09, 0xe9, 0xa7, 0x3c, 0xcb, 0xb0, 0xcd, 0x30, 0xa3, 0x06,
	0x3a, 0xfa, 0x68, 0xc1, 0x11, 0x11, 0xf7, 0x88, 0x77, 0x2a, 0xb1, 0x75, 0x75, 0x1a, 0xef, 0xfd,
	0x5a, 0x85, 0x7b, 0x97, 0x10, 0xb3, 0x3e, 0x74, 0x16, 0xf6, 0xf7, 0xc3, 0xc0, 0x14, 0xb1, 0x9d,
	0x96, 0x24, 0xbb, 0x01, 0xfb, 0x1f, 0x40, 0x26, 0xa2, 0x63, 0x9f, 0x0a, 0x4d, 0xc5, 0x6c, 0x69,
	0xcb, 0x2e, 0x16, 0xbb, 0x0f, 0x6d, 0x84, 0x79, 0x10, 0xf8, 0x98, 0xa8, 0x5b, 0xed, 0x56, 0xfb,
	0xb5, 0xe7, 0x95, 0xce, 0x15, 0xcf, 0xd1, 0xc8, 0xb3, 0x20, 0x18, 0x68, 0x3b, 0xfb, 0x1c, 0xdc,
	0x45, 0xa6, 0x2f, 0xe2, 0xc0, 0x8c, 0xe9, 0x4a, 0xa1, 0xb9, 0x56, 0xd6, 0xbc, 0x8c, 0x83, 0x62,
	0x6c, 0x15, 0x97, 0x23, 0xa1, 0x4c, 0x18, 0xd7, 0x31, 0x0c, 0x9b, 0x6c, 0x14, 0xc8, 0x03, 0xe8,
	0x18, 0xca, 0x3c, 0x94, 0x1b, 0x85, 0xdb, 0x36, 0x61, 0x45, 0x30, 0x4f, 0x61, 0x63, 0x99, 0x5d,
	0x0a, 0xe7, 0x66, 0xa1, 0xbb, 0xb1, 0xa8, 0x2b, 0x02, 0xfa, 0x06, 0xd6, 0x8d, 0x7e, 0xa1, 0x1d,
	0x5c, 0x1c, 0xa6, 0x8b, 0xda, 0x01, 0xbd, 0xae, 0x91, 0x76, 0x30, 0x6f, 0x8c, 0xde, 0x6f, 0x16,
	0x5c, 0x3b, 0x6b, 0x02, 0x58, 0x17, 0x1c, 0x3d, 0x03, 0x7a, 0x1f, 0xa9, 0xfc, 0x7c, 0xd4, 0x40,
	0xdb, 0x06, 0xda, 0x74, 0xb0, 0xc4, 0x98, 0xe5, 0x03, 0x57, 0x30, 0x0e, 0xd9, 0x6d, 0xc0, 0x15,
	0x66, 0x38, 0x35, 0x17, 0x5e, 0x53, 0x5b, 0x5e, 0xc6, 0xc1, 0xc1, 0x02, 0x3a, 0x33, 0x97, 0x46,
	0x8e, 0x1e, 0xb2, 0xff, 0x43, 0xbb, 0x40, 0xe9, 0x74, 0xe8, 0xea, 0x70, 0x0c, 0x03, 0xcf, 0xa3,
	0xf7, 0x4b, 0x05, 0x6e, 0x5f, 0x34, 0x86, 0xba, 0x82, 0xf9, 0x08, 0xe3, 0x57, 0x81, 0xd2, 0xb0,
	0x8d, 0x0d, 0x3f, 0x0b, 0xb7, 0xa0, 0x59, 0xf4, 0x22, 0xe5, 0xd0, 0xc8, 0x4c, 0x13, 0x6e, 0x42,
	0x6b, 0xbe, 0xbf, 0x89, 0x5f, 0x94, 0x9a, 0x83, 0x74, 0x74, 0xaa, 0x26, 0x03, 0x1a, 0xdb, 0x7d,
	0x34, 0xe9, 0xfb, 0x92, 0x28, 0x53, 0x13, 0x7d, 0x1d, 0x97, 0x07, 0x73, 0x60, 0x86, 0xa3, 0x9c,
	0x03, 0x87, 0xba, 0xed, 0x87, 0x91, 0xe0, 0xd2, 0xc7, 0x27, 0x41, 0x03, 0xaf, 0x89, 0x16, 0x5a,
	0x3c, 0xfd, 0x2e, 0xf8, 0x02, 0xea, 0x66, 0x37, 0x1b, 0x4b, 0x7e, 0xee, 0xa7, 0xa8, 0xfc, 0x25,
	0x30, 0x92, 0xde, 0x3f, 0xd5, 0x33, 0x0e, 0xab, 0x44, 0x3c, 0xd5, 0xee, 0xd6, 0xe9, 0x76, 0xbf,
	0x05, 0x4d, 0x43, 0xc9, 0x87, 0xb2, 0x41, 0xeb, 0x83, 0x12, 0x94, 0x3f, 0x6e, 0x0c, 0x74, 0xa8,
	0xbf, 0xbc, 0xc5, 0x13, 0x67, 0xa9, 0x4f, 0x75, 0x5a, 0xdf, 0xa6, 0x01, 0x57, 0xe6, 0xa6, 0xa7,
	0xf7, 0xcf, 0x03, 0x68, 0x8d, 0xdf, 0x4a, 0x45, 0x35, 0x83, 0xae, 0xd5, 0x6f, 0xef, 0x5c, 0x35,
	0xaa, 0x57, 0x6f, 0xa5, 0xd2, 0x75, 0xf3, 0x9a, 0x63, 0xf3, 0x8b, 0xdd, 0x83, 0xd5, 0xe1, 0x98,
	0xc7, 0x23, 0xe1, 0x67, 0xe3, 0x50, 0x44, 0x01, 0x5e, 0xaf, 0x6b, 0x9e, 0x43, 0xc6, 0x01, 0xda,
	0xd8, 0x7d, 0x68, 0xe7, 0xa4, 0x24, 0x0a, 0x42, 0x21, 0xf1, 0xc6, 0x5c, 0xf3, 0x8c, 0x74, 0x40,
	0x46, 0xfd, 0xf2, 0xca, 0xf1, 0xb6, 0x69, 0x06, 0x83, 0xdc, 0x81, 0xd6, 0x7c, 0xc4, 0xaf, 0x16,
	0xa3, 0xda, 0xe4, 0xf9, 0x70, 0x7f, 0x02, 0xeb, 0x67, 0x4d, 0x75, 0xa7, 0xa0, 0x76, 0xf8, 0xf2,
	0x3c, 0xdf, 0xd7, 0xed, 0x99, 0x4f, 0x91, 0x12, 0xee, 0x5a, 0xc1, 0xb5, 0xc9, 0x4e, 0x9e, 0xef,
	0x82, 0x43, 0x93, 0x6e, 0x5c, 0x32, 0x2a, 0x0c, 0xd9, 0xc8, 0xd3, 0x26, 0xb4, 0xc2, 0x2c, 0x6f,
	0xc5, 0x75, 0xec, 0x9b, 0x66, 0x98, 0x51, 0x1f, 0xf6, 0x5e, 0x98, 0x21, 0x5f, 0x3a, 0xec, 0xe2,
	0xe9, 0x69, 0x9d, 0xfd, 0xf4, 0xac, 0x2c, 0x3e, 0x3d, 0xff, 0xce, 0xbf, 0x15, 0x4b, 0xdf, 0x16,
	0xd6, 0x86, 0x4a, 0xf1, 0x1d, 0xaf, 0x84, 0xc1, 0x87, 0x97, 0xfb, 0xbf, 0x29, 0xe0, 0xe5, 0x0e,
	0xfb, 0x79, 0xf7, 0xf7, 0xf7, 0x5b, 0xd6, 0x1f, 0xef, 0xb7, 0xac, 0x3f, 0xdf, 0x6f, 0x59, 0x3f,
	0xfd, 0xb5, 0x75, 0xe5, 0x95, 0xf5, 0xbd, 0x53, 0xfe, 0x4f, 0xe0, 0xa8, 0x8e, 0x7f, 0x1e, 0xfd,
	0x1b, 0x00, 0x00, 0xff, 0xff, 0x3c, 0xe0, 0x10, 0xd4, 0xb3, 0x0c, 0x00, 0x00,
}
