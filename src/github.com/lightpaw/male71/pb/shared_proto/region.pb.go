// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/shared_proto/region.proto
// DO NOT EDIT!

package shared_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type BaseTargetType int32

const (
	BaseTargetType_NpcHome              BaseTargetType = 0
	BaseTargetType_NpcMultiLevelMonster BaseTargetType = 1
	BaseTargetType_NpcMonster           BaseTargetType = 2
	BaseTargetType_NpcGuild             BaseTargetType = 3
	BaseTargetType_NpcXiongNu           BaseTargetType = 4
	BaseTargetType_NpcBaoZang           BaseTargetType = 5
	BaseTargetType_NpcMingCheng         BaseTargetType = 6
	BaseTargetType_NpcJunTuan           BaseTargetType = 7
	BaseTargetType_Hero                 BaseTargetType = 32
)

var BaseTargetType_name = map[int32]string{
	0:  "NpcHome",
	1:  "NpcMultiLevelMonster",
	2:  "NpcMonster",
	3:  "NpcGuild",
	4:  "NpcXiongNu",
	5:  "NpcBaoZang",
	6:  "NpcMingCheng",
	7:  "NpcJunTuan",
	32: "Hero",
}
var BaseTargetType_value = map[string]int32{
	"NpcHome":              0,
	"NpcMultiLevelMonster": 1,
	"NpcMonster":           2,
	"NpcGuild":             3,
	"NpcXiongNu":           4,
	"NpcBaoZang":           5,
	"NpcMingCheng":         6,
	"NpcJunTuan":           7,
	"Hero":                 32,
}

func (x BaseTargetType) String() string {
	return proto.EnumName(BaseTargetType_name, int32(x))
}
func (BaseTargetType) EnumDescriptor() ([]byte, []int) { return fileDescriptorRegion, []int{0} }

type TroopType int32

const (
	TroopType_TT_HERO        TroopType = 0
	TroopType_TT_NORMAL_NPC  TroopType = 1
	TroopType_TT_MULTI_LEVEL TroopType = 2
	TroopType_TT_XIONG_NU    TroopType = 3
	TroopType_TT_BAO_ZANG    TroopType = 4
	TroopType_TT_ASSEMBLY    TroopType = 5
)

var TroopType_name = map[int32]string{
	0: "TT_HERO",
	1: "TT_NORMAL_NPC",
	2: "TT_MULTI_LEVEL",
	3: "TT_XIONG_NU",
	4: "TT_BAO_ZANG",
	5: "TT_ASSEMBLY",
}
var TroopType_value = map[string]int32{
	"TT_HERO":        0,
	"TT_NORMAL_NPC":  1,
	"TT_MULTI_LEVEL": 2,
	"TT_XIONG_NU":    3,
	"TT_BAO_ZANG":    4,
	"TT_ASSEMBLY":    5,
}

func (x TroopType) String() string {
	return proto.EnumName(TroopType_name, int32(x))
}
func (TroopType) EnumDescriptor() ([]byte, []int) { return fileDescriptorRegion, []int{1} }

type TroopOperate int32

const (
	TroopOperate_ToNone          TroopOperate = 0
	TroopOperate_ToInvasion      TroopOperate = 1
	TroopOperate_ToAssist        TroopOperate = 2
	TroopOperate_ToAssembly      TroopOperate = 3
	TroopOperate_ToWorkshopBuild TroopOperate = 4
	TroopOperate_ToWorkshopProd  TroopOperate = 5
	TroopOperate_ToWorkshopPrize TroopOperate = 6
	TroopOperate_ToInvestigate   TroopOperate = 7
)

var TroopOperate_name = map[int32]string{
	0: "ToNone",
	1: "ToInvasion",
	2: "ToAssist",
	3: "ToAssembly",
	4: "ToWorkshopBuild",
	5: "ToWorkshopProd",
	6: "ToWorkshopPrize",
	7: "ToInvestigate",
}
var TroopOperate_value = map[string]int32{
	"ToNone":          0,
	"ToInvasion":      1,
	"ToAssist":        2,
	"ToAssembly":      3,
	"ToWorkshopBuild": 4,
	"ToWorkshopProd":  5,
	"ToWorkshopPrize": 6,
	"ToInvestigate":   7,
}

func (x TroopOperate) String() string {
	return proto.EnumName(TroopOperate_name, int32(x))
}
func (TroopOperate) EnumDescriptor() ([]byte, []int) { return fileDescriptorRegion, []int{2} }

type RegionType int32

const (
	RegionType_InvalidRegionType RegionType = 0
	RegionType_HOME              RegionType = 1
	RegionType_GUILD             RegionType = 2
	RegionType_MONSTER           RegionType = 3
)

var RegionType_name = map[int32]string{
	0: "InvalidRegionType",
	1: "HOME",
	2: "GUILD",
	3: "MONSTER",
}
var RegionType_value = map[string]int32{
	"InvalidRegionType": 0,
	"HOME":              1,
	"GUILD":             2,
	"MONSTER":           3,
}

func (x RegionType) String() string {
	return proto.EnumName(RegionType_name, int32(x))
}
func (RegionType) EnumDescriptor() ([]byte, []int) { return fileDescriptorRegion, []int{3} }

type MultiLevelNpcType int32

const (
	MultiLevelNpcType_InvalidMultiLevelNpcType MultiLevelNpcType = 0
	MultiLevelNpcType_LIU_KOU                  MultiLevelNpcType = 1
	MultiLevelNpcType_PAN_JUN                  MultiLevelNpcType = 2
	MultiLevelNpcType_HAI_DAO                  MultiLevelNpcType = 3
	MultiLevelNpcType_JIE_FEI                  MultiLevelNpcType = 4
)

var MultiLevelNpcType_name = map[int32]string{
	0: "InvalidMultiLevelNpcType",
	1: "LIU_KOU",
	2: "PAN_JUN",
	3: "HAI_DAO",
	4: "JIE_FEI",
}
var MultiLevelNpcType_value = map[string]int32{
	"InvalidMultiLevelNpcType": 0,
	"LIU_KOU":                  1,
	"PAN_JUN":                  2,
	"HAI_DAO":                  3,
	"JIE_FEI":                  4,
}

func (x MultiLevelNpcType) String() string {
	return proto.EnumName(MultiLevelNpcType_name, int32(x))
}
func (MultiLevelNpcType) EnumDescriptor() ([]byte, []int) { return fileDescriptorRegion, []int{4} }

// 阻挡区域
type BlockInfoProto struct {
	Name string  `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	X    []int32 `protobuf:"varint,1,rep,name=x" json:"x,omitempty"`
	Y    []int32 `protobuf:"varint,2,rep,name=y" json:"y,omitempty"`
	Type []int32 `protobuf:"varint,3,rep,name=type" json:"type,omitempty"`
	H    []int32 `protobuf:"varint,5,rep,name=h" json:"h,omitempty"`
}

func (m *BlockInfoProto) Reset()                    { *m = BlockInfoProto{} }
func (m *BlockInfoProto) String() string            { return proto.CompactTextString(m) }
func (*BlockInfoProto) ProtoMessage()               {}
func (*BlockInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorRegion, []int{0} }

func (m *BlockInfoProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BlockInfoProto) GetX() []int32 {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *BlockInfoProto) GetY() []int32 {
	if m != nil {
		return m.Y
	}
	return nil
}

func (m *BlockInfoProto) GetType() []int32 {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *BlockInfoProto) GetH() []int32 {
	if m != nil {
		return m.H
	}
	return nil
}

type BlockLayoutProto struct {
	XLenPerBlock int32    `protobuf:"varint,1,opt,name=x_len_per_block,json=xLenPerBlock,proto3" json:"x_len_per_block,omitempty"`
	YLenPerBlock int32    `protobuf:"varint,2,opt,name=y_len_per_block,json=yLenPerBlock,proto3" json:"y_len_per_block,omitempty"`
	BlockLen     int32    `protobuf:"varint,3,opt,name=block_len,json=blockLen,proto3" json:"block_len,omitempty"`
	BlockName    []string `protobuf:"bytes,4,rep,name=block_name,json=blockName" json:"block_name,omitempty"`
}

func (m *BlockLayoutProto) Reset()                    { *m = BlockLayoutProto{} }
func (m *BlockLayoutProto) String() string            { return proto.CompactTextString(m) }
func (*BlockLayoutProto) ProtoMessage()               {}
func (*BlockLayoutProto) Descriptor() ([]byte, []int) { return fileDescriptorRegion, []int{1} }

func (m *BlockLayoutProto) GetXLenPerBlock() int32 {
	if m != nil {
		return m.XLenPerBlock
	}
	return 0
}

func (m *BlockLayoutProto) GetYLenPerBlock() int32 {
	if m != nil {
		return m.YLenPerBlock
	}
	return 0
}

func (m *BlockLayoutProto) GetBlockLen() int32 {
	if m != nil {
		return m.BlockLen
	}
	return 0
}

func (m *BlockLayoutProto) GetBlockName() []string {
	if m != nil {
		return m.BlockName
	}
	return nil
}

// 主城单位
type BaseUnitProto struct {
	HeroId                 []byte `protobuf:"bytes,1,opt,name=hero_id,json=heroId,proto3" json:"hero_id,omitempty"`
	HeroName               string `protobuf:"bytes,2,opt,name=hero_name,json=heroName,proto3" json:"hero_name,omitempty"`
	GuildId                int32  `protobuf:"varint,3,opt,name=guild_id,json=guildId,proto3" json:"guild_id,omitempty"`
	GuildFlagName          string `protobuf:"bytes,5,opt,name=guild_flag_name,json=guildFlagName,proto3" json:"guild_flag_name,omitempty"`
	CountryId              int32  `protobuf:"varint,17,opt,name=country_id,json=countryId,proto3" json:"country_id,omitempty"`
	Level                  int32  `protobuf:"varint,6,opt,name=level,proto3" json:"level,omitempty"`
	BaseX                  int32  `protobuf:"varint,7,opt,name=base_x,json=baseX,proto3" json:"base_x,omitempty"`
	BaseY                  int32  `protobuf:"varint,8,opt,name=base_y,json=baseY,proto3" json:"base_y,omitempty"`
	MianDisappearTime      int32  `protobuf:"varint,9,opt,name=mian_disappear_time,json=mianDisappearTime,proto3" json:"mian_disappear_time,omitempty"`
	WhiteFlagGuildId       int32  `protobuf:"varint,10,opt,name=white_flag_guild_id,json=whiteFlagGuildId,proto3" json:"white_flag_guild_id,omitempty"`
	WhiteFlagGuildFlagName string `protobuf:"bytes,11,opt,name=white_flag_guild_flag_name,json=whiteFlagGuildFlagName,proto3" json:"white_flag_guild_flag_name,omitempty"`
	WhiteFlagDisappearTime int32  `protobuf:"varint,12,opt,name=white_flag_disappear_time,json=whiteFlagDisappearTime,proto3" json:"white_flag_disappear_time,omitempty"`
	OuterCityUnlockBit     int32  `protobuf:"varint,13,opt,name=outer_city_unlock_bit,json=outerCityUnlockBit,proto3" json:"outer_city_unlock_bit,omitempty"`
	Sign                   string `protobuf:"bytes,14,opt,name=sign,proto3" json:"sign,omitempty"`
	Prosperty              int32  `protobuf:"varint,15,opt,name=prosperty,proto3" json:"prosperty,omitempty"`
	StopLostProsperity     bool   `protobuf:"varint,16,opt,name=stop_lost_prosperity,json=stopLostProsperity,proto3" json:"stop_lost_prosperity,omitempty"`
	Title                  int32  `protobuf:"varint,18,opt,name=title,proto3" json:"title,omitempty"`
	VipLevel               int32  `protobuf:"varint,19,opt,name=vip_level,json=vipLevel,proto3" json:"vip_level,omitempty"`
}

func (m *BaseUnitProto) Reset()                    { *m = BaseUnitProto{} }
func (m *BaseUnitProto) String() string            { return proto.CompactTextString(m) }
func (*BaseUnitProto) ProtoMessage()               {}
func (*BaseUnitProto) Descriptor() ([]byte, []int) { return fileDescriptorRegion, []int{2} }

func (m *BaseUnitProto) GetHeroId() []byte {
	if m != nil {
		return m.HeroId
	}
	return nil
}

func (m *BaseUnitProto) GetHeroName() string {
	if m != nil {
		return m.HeroName
	}
	return ""
}

func (m *BaseUnitProto) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *BaseUnitProto) GetGuildFlagName() string {
	if m != nil {
		return m.GuildFlagName
	}
	return ""
}

func (m *BaseUnitProto) GetCountryId() int32 {
	if m != nil {
		return m.CountryId
	}
	return 0
}

func (m *BaseUnitProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *BaseUnitProto) GetBaseX() int32 {
	if m != nil {
		return m.BaseX
	}
	return 0
}

func (m *BaseUnitProto) GetBaseY() int32 {
	if m != nil {
		return m.BaseY
	}
	return 0
}

func (m *BaseUnitProto) GetMianDisappearTime() int32 {
	if m != nil {
		return m.MianDisappearTime
	}
	return 0
}

func (m *BaseUnitProto) GetWhiteFlagGuildId() int32 {
	if m != nil {
		return m.WhiteFlagGuildId
	}
	return 0
}

func (m *BaseUnitProto) GetWhiteFlagGuildFlagName() string {
	if m != nil {
		return m.WhiteFlagGuildFlagName
	}
	return ""
}

func (m *BaseUnitProto) GetWhiteFlagDisappearTime() int32 {
	if m != nil {
		return m.WhiteFlagDisappearTime
	}
	return 0
}

func (m *BaseUnitProto) GetOuterCityUnlockBit() int32 {
	if m != nil {
		return m.OuterCityUnlockBit
	}
	return 0
}

func (m *BaseUnitProto) GetSign() string {
	if m != nil {
		return m.Sign
	}
	return ""
}

func (m *BaseUnitProto) GetProsperty() int32 {
	if m != nil {
		return m.Prosperty
	}
	return 0
}

func (m *BaseUnitProto) GetStopLostProsperity() bool {
	if m != nil {
		return m.StopLostProsperity
	}
	return false
}

func (m *BaseUnitProto) GetTitle() int32 {
	if m != nil {
		return m.Title
	}
	return 0
}

func (m *BaseUnitProto) GetVipLevel() int32 {
	if m != nil {
		return m.VipLevel
	}
	return 0
}

// 部队单位
type TroopUnitProto struct {
	TroopId           []byte    `protobuf:"bytes,101,opt,name=troop_id,json=troopId,proto3" json:"troop_id,omitempty"`
	Action            int32     `protobuf:"varint,2,opt,name=action,proto3" json:"action,omitempty"`
	MoveType          int32     `protobuf:"varint,3,opt,name=move_type,json=moveType,proto3" json:"move_type,omitempty"`
	MoveStartTime     int32     `protobuf:"varint,4,opt,name=move_start_time,json=moveStartTime,proto3" json:"move_start_time,omitempty"`
	MoveArrivedTime   int32     `protobuf:"varint,5,opt,name=move_arrived_time,json=moveArrivedTime,proto3" json:"move_arrived_time,omitempty"`
	StartBaseId       []byte    `protobuf:"bytes,11,opt,name=start_base_id,json=startBaseId,proto3" json:"start_base_id,omitempty"`
	StartBaseX        int32     `protobuf:"varint,12,opt,name=start_base_x,json=startBaseX,proto3" json:"start_base_x,omitempty"`
	StartBaseY        int32     `protobuf:"varint,13,opt,name=start_base_y,json=startBaseY,proto3" json:"start_base_y,omitempty"`
	StartBaseGuildId  int32     `protobuf:"varint,14,opt,name=start_base_guild_id,json=startBaseGuildId,proto3" json:"start_base_guild_id,omitempty"`
	TargetBaseId      []byte    `protobuf:"bytes,21,opt,name=target_base_id,json=targetBaseId,proto3" json:"target_base_id,omitempty"`
	TargetBaseX       int32     `protobuf:"varint,22,opt,name=target_base_x,json=targetBaseX,proto3" json:"target_base_x,omitempty"`
	TargetBaseY       int32     `protobuf:"varint,23,opt,name=target_base_y,json=targetBaseY,proto3" json:"target_base_y,omitempty"`
	TargetBaseGuildId int32     `protobuf:"varint,24,opt,name=target_base_guild_id,json=targetBaseGuildId,proto3" json:"target_base_guild_id,omitempty"`
	Type              TroopType `protobuf:"varint,25,opt,name=type,proto3,enum=proto.TroopType" json:"type,omitempty"`
	Dialogue          int32     `protobuf:"varint,26,opt,name=dialogue,proto3" json:"dialogue,omitempty"`
}

func (m *TroopUnitProto) Reset()                    { *m = TroopUnitProto{} }
func (m *TroopUnitProto) String() string            { return proto.CompactTextString(m) }
func (*TroopUnitProto) ProtoMessage()               {}
func (*TroopUnitProto) Descriptor() ([]byte, []int) { return fileDescriptorRegion, []int{3} }

func (m *TroopUnitProto) GetTroopId() []byte {
	if m != nil {
		return m.TroopId
	}
	return nil
}

func (m *TroopUnitProto) GetAction() int32 {
	if m != nil {
		return m.Action
	}
	return 0
}

func (m *TroopUnitProto) GetMoveType() int32 {
	if m != nil {
		return m.MoveType
	}
	return 0
}

func (m *TroopUnitProto) GetMoveStartTime() int32 {
	if m != nil {
		return m.MoveStartTime
	}
	return 0
}

func (m *TroopUnitProto) GetMoveArrivedTime() int32 {
	if m != nil {
		return m.MoveArrivedTime
	}
	return 0
}

func (m *TroopUnitProto) GetStartBaseId() []byte {
	if m != nil {
		return m.StartBaseId
	}
	return nil
}

func (m *TroopUnitProto) GetStartBaseX() int32 {
	if m != nil {
		return m.StartBaseX
	}
	return 0
}

func (m *TroopUnitProto) GetStartBaseY() int32 {
	if m != nil {
		return m.StartBaseY
	}
	return 0
}

func (m *TroopUnitProto) GetStartBaseGuildId() int32 {
	if m != nil {
		return m.StartBaseGuildId
	}
	return 0
}

func (m *TroopUnitProto) GetTargetBaseId() []byte {
	if m != nil {
		return m.TargetBaseId
	}
	return nil
}

func (m *TroopUnitProto) GetTargetBaseX() int32 {
	if m != nil {
		return m.TargetBaseX
	}
	return 0
}

func (m *TroopUnitProto) GetTargetBaseY() int32 {
	if m != nil {
		return m.TargetBaseY
	}
	return 0
}

func (m *TroopUnitProto) GetTargetBaseGuildId() int32 {
	if m != nil {
		return m.TargetBaseGuildId
	}
	return 0
}

func (m *TroopUnitProto) GetType() TroopType {
	if m != nil {
		return m.Type
	}
	return TroopType_TT_HERO
}

func (m *TroopUnitProto) GetDialogue() int32 {
	if m != nil {
		return m.Dialogue
	}
	return 0
}

type RegionDataProto struct {
	Id                         int32      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	RegionType                 RegionType `protobuf:"varint,2,opt,name=region_type,json=regionType,proto3,enum=proto.RegionType" json:"region_type,omitempty"`
	Level                      int32      `protobuf:"varint,3,opt,name=level,proto3" json:"level,omitempty"`
	BasicOutput                int32      `protobuf:"varint,4,opt,name=basic_output,json=basicOutput,proto3" json:"basic_output,omitempty"`
	IsVeryMuchJadeOreThreshold int32      `protobuf:"varint,5,opt,name=is_very_much_jade_ore_threshold,json=isVeryMuchJadeOreThreshold,proto3" json:"is_very_much_jade_ore_threshold,omitempty"`
	IsMuchJadeOreThreshold     int32      `protobuf:"varint,6,opt,name=is_much_jade_ore_threshold,json=isMuchJadeOreThreshold,proto3" json:"is_much_jade_ore_threshold,omitempty"`
	// 拥挤度主城数分界线，假设3个状态，空闲，拥挤，爆满
	// 此时这个数组会提供2个数作为分界线
	// 地区人数<=第一个值，说明是空闲
	// 第一个值<地区人数<=第二个值，说明拥挤
	// 第二个值<地区人数，说明爆满
	CrowdedBaseCount       []int32 `protobuf:"varint,11,rep,name=crowded_base_count,json=crowdedBaseCount" json:"crowded_base_count,omitempty"`
	SubBlockXLen           int32   `protobuf:"varint,12,opt,name=sub_block_x_len,json=subBlockXLen,proto3" json:"sub_block_x_len,omitempty"`
	SubBlockYLen           int32   `protobuf:"varint,13,opt,name=sub_block_y_len,json=subBlockYLen,proto3" json:"sub_block_y_len,omitempty"`
	GuildMoveBaseMinRadius int32   `protobuf:"varint,14,opt,name=guild_move_base_min_radius,json=guildMoveBaseMinRadius,proto3" json:"guild_move_base_min_radius,omitempty"`
	GuildMoveBaseMaxRadius int32   `protobuf:"varint,15,opt,name=guild_move_base_max_radius,json=guildMoveBaseMaxRadius,proto3" json:"guild_move_base_max_radius,omitempty"`
}

func (m *RegionDataProto) Reset()                    { *m = RegionDataProto{} }
func (m *RegionDataProto) String() string            { return proto.CompactTextString(m) }
func (*RegionDataProto) ProtoMessage()               {}
func (*RegionDataProto) Descriptor() ([]byte, []int) { return fileDescriptorRegion, []int{4} }

func (m *RegionDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RegionDataProto) GetRegionType() RegionType {
	if m != nil {
		return m.RegionType
	}
	return RegionType_InvalidRegionType
}

func (m *RegionDataProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *RegionDataProto) GetBasicOutput() int32 {
	if m != nil {
		return m.BasicOutput
	}
	return 0
}

func (m *RegionDataProto) GetIsVeryMuchJadeOreThreshold() int32 {
	if m != nil {
		return m.IsVeryMuchJadeOreThreshold
	}
	return 0
}

func (m *RegionDataProto) GetIsMuchJadeOreThreshold() int32 {
	if m != nil {
		return m.IsMuchJadeOreThreshold
	}
	return 0
}

func (m *RegionDataProto) GetCrowdedBaseCount() []int32 {
	if m != nil {
		return m.CrowdedBaseCount
	}
	return nil
}

func (m *RegionDataProto) GetSubBlockXLen() int32 {
	if m != nil {
		return m.SubBlockXLen
	}
	return 0
}

func (m *RegionDataProto) GetSubBlockYLen() int32 {
	if m != nil {
		return m.SubBlockYLen
	}
	return 0
}

func (m *RegionDataProto) GetGuildMoveBaseMinRadius() int32 {
	if m != nil {
		return m.GuildMoveBaseMinRadius
	}
	return 0
}

func (m *RegionDataProto) GetGuildMoveBaseMaxRadius() int32 {
	if m != nil {
		return m.GuildMoveBaseMaxRadius
	}
	return 0
}

type RegionMultiLevelNpcTypeProto struct {
	Type      MultiLevelNpcType `protobuf:"varint,2,opt,name=type,proto3,enum=proto.MultiLevelNpcType" json:"type,omitempty"`
	Name      string            `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	MaxHate   int32             `protobuf:"varint,3,opt,name=max_hate,json=maxHate,proto3" json:"max_hate,omitempty"`
	FightHate int32             `protobuf:"varint,4,opt,name=fight_hate,json=fightHate,proto3" json:"fight_hate,omitempty"`
}

func (m *RegionMultiLevelNpcTypeProto) Reset()         { *m = RegionMultiLevelNpcTypeProto{} }
func (m *RegionMultiLevelNpcTypeProto) String() string { return proto.CompactTextString(m) }
func (*RegionMultiLevelNpcTypeProto) ProtoMessage()    {}
func (*RegionMultiLevelNpcTypeProto) Descriptor() ([]byte, []int) {
	return fileDescriptorRegion, []int{5}
}

func (m *RegionMultiLevelNpcTypeProto) GetType() MultiLevelNpcType {
	if m != nil {
		return m.Type
	}
	return MultiLevelNpcType_InvalidMultiLevelNpcType
}

func (m *RegionMultiLevelNpcTypeProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RegionMultiLevelNpcTypeProto) GetMaxHate() int32 {
	if m != nil {
		return m.MaxHate
	}
	return 0
}

func (m *RegionMultiLevelNpcTypeProto) GetFightHate() int32 {
	if m != nil {
		return m.FightHate
	}
	return 0
}

type RegionMultiLevelNpcDataProto struct {
	Id          int32             `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type        MultiLevelNpcType `protobuf:"varint,2,opt,name=type,proto3,enum=proto.MultiLevelNpcType" json:"type,omitempty"`
	LevelBaseId []int32           `protobuf:"varint,3,rep,name=level_base_id,json=levelBaseId" json:"level_base_id,omitempty"`
	OffsetBaseX int32             `protobuf:"varint,4,opt,name=offset_base_x,json=offsetBaseX,proto3" json:"offset_base_x,omitempty"`
	OffsetBaseY int32             `protobuf:"varint,5,opt,name=offset_base_y,json=offsetBaseY,proto3" json:"offset_base_y,omitempty"`
}

func (m *RegionMultiLevelNpcDataProto) Reset()         { *m = RegionMultiLevelNpcDataProto{} }
func (m *RegionMultiLevelNpcDataProto) String() string { return proto.CompactTextString(m) }
func (*RegionMultiLevelNpcDataProto) ProtoMessage()    {}
func (*RegionMultiLevelNpcDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorRegion, []int{6}
}

func (m *RegionMultiLevelNpcDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RegionMultiLevelNpcDataProto) GetType() MultiLevelNpcType {
	if m != nil {
		return m.Type
	}
	return MultiLevelNpcType_InvalidMultiLevelNpcType
}

func (m *RegionMultiLevelNpcDataProto) GetLevelBaseId() []int32 {
	if m != nil {
		return m.LevelBaseId
	}
	return nil
}

func (m *RegionMultiLevelNpcDataProto) GetOffsetBaseX() int32 {
	if m != nil {
		return m.OffsetBaseX
	}
	return 0
}

func (m *RegionMultiLevelNpcDataProto) GetOffsetBaseY() int32 {
	if m != nil {
		return m.OffsetBaseY
	}
	return 0
}

type DiaoKeDataProto struct {
	CostJadeOre int32 `protobuf:"varint,1,opt,name=cost_jade_ore,json=costJadeOre,proto3" json:"cost_jade_ore,omitempty"`
	JadePrize   int32 `protobuf:"varint,2,opt,name=jade_prize,json=jadePrize,proto3" json:"jade_prize,omitempty"`
}

func (m *DiaoKeDataProto) Reset()                    { *m = DiaoKeDataProto{} }
func (m *DiaoKeDataProto) String() string            { return proto.CompactTextString(m) }
func (*DiaoKeDataProto) ProtoMessage()               {}
func (*DiaoKeDataProto) Descriptor() ([]byte, []int) { return fileDescriptorRegion, []int{7} }

func (m *DiaoKeDataProto) GetCostJadeOre() int32 {
	if m != nil {
		return m.CostJadeOre
	}
	return 0
}

func (m *DiaoKeDataProto) GetJadePrize() int32 {
	if m != nil {
		return m.JadePrize
	}
	return 0
}

type DiaoKeMiscDataProto struct {
	TimeCost                   []int32          `protobuf:"varint,1,rep,name=time_cost,json=timeCost" json:"time_cost,omitempty"`
	OneYuanBaoExchangeDuration int32            `protobuf:"varint,2,opt,name=one_yuan_bao_exchange_duration,json=oneYuanBaoExchangeDuration,proto3" json:"one_yuan_bao_exchange_duration,omitempty"`
	DefaultDiaoKeData          *DiaoKeDataProto `protobuf:"bytes,3,opt,name=default_diao_ke_data,json=defaultDiaoKeData" json:"default_diao_ke_data,omitempty"`
}

func (m *DiaoKeMiscDataProto) Reset()                    { *m = DiaoKeMiscDataProto{} }
func (m *DiaoKeMiscDataProto) String() string            { return proto.CompactTextString(m) }
func (*DiaoKeMiscDataProto) ProtoMessage()               {}
func (*DiaoKeMiscDataProto) Descriptor() ([]byte, []int) { return fileDescriptorRegion, []int{8} }

func (m *DiaoKeMiscDataProto) GetTimeCost() []int32 {
	if m != nil {
		return m.TimeCost
	}
	return nil
}

func (m *DiaoKeMiscDataProto) GetOneYuanBaoExchangeDuration() int32 {
	if m != nil {
		return m.OneYuanBaoExchangeDuration
	}
	return 0
}

func (m *DiaoKeMiscDataProto) GetDefaultDiaoKeData() *DiaoKeDataProto {
	if m != nil {
		return m.DefaultDiaoKeData
	}
	return nil
}

// 盟友驻扎恢复繁荣度日志
type AstDefendLogProto struct {
	LogTime           int32  `protobuf:"varint,1,opt,name=log_time,json=logTime,proto3" json:"log_time,omitempty"`
	HeroName          string `protobuf:"bytes,2,opt,name=hero_name,json=heroName,proto3" json:"hero_name,omitempty"`
	DefendingDuration int32  `protobuf:"varint,3,opt,name=defending_duration,json=defendingDuration,proto3" json:"defending_duration,omitempty"`
	AddProsperity     int32  `protobuf:"varint,4,opt,name=add_prosperity,json=addProsperity,proto3" json:"add_prosperity,omitempty"`
}

func (m *AstDefendLogProto) Reset()                    { *m = AstDefendLogProto{} }
func (m *AstDefendLogProto) String() string            { return proto.CompactTextString(m) }
func (*AstDefendLogProto) ProtoMessage()               {}
func (*AstDefendLogProto) Descriptor() ([]byte, []int) { return fileDescriptorRegion, []int{9} }

func (m *AstDefendLogProto) GetLogTime() int32 {
	if m != nil {
		return m.LogTime
	}
	return 0
}

func (m *AstDefendLogProto) GetHeroName() string {
	if m != nil {
		return m.HeroName
	}
	return ""
}

func (m *AstDefendLogProto) GetDefendingDuration() int32 {
	if m != nil {
		return m.DefendingDuration
	}
	return 0
}

func (m *AstDefendLogProto) GetAddProsperity() int32 {
	if m != nil {
		return m.AddProsperity
	}
	return 0
}

func init() {
	proto.RegisterType((*BlockInfoProto)(nil), "proto.BlockInfoProto")
	proto.RegisterType((*BlockLayoutProto)(nil), "proto.BlockLayoutProto")
	proto.RegisterType((*BaseUnitProto)(nil), "proto.BaseUnitProto")
	proto.RegisterType((*TroopUnitProto)(nil), "proto.TroopUnitProto")
	proto.RegisterType((*RegionDataProto)(nil), "proto.RegionDataProto")
	proto.RegisterType((*RegionMultiLevelNpcTypeProto)(nil), "proto.RegionMultiLevelNpcTypeProto")
	proto.RegisterType((*RegionMultiLevelNpcDataProto)(nil), "proto.RegionMultiLevelNpcDataProto")
	proto.RegisterType((*DiaoKeDataProto)(nil), "proto.DiaoKeDataProto")
	proto.RegisterType((*DiaoKeMiscDataProto)(nil), "proto.DiaoKeMiscDataProto")
	proto.RegisterType((*AstDefendLogProto)(nil), "proto.AstDefendLogProto")
	proto.RegisterEnum("proto.BaseTargetType", BaseTargetType_name, BaseTargetType_value)
	proto.RegisterEnum("proto.TroopType", TroopType_name, TroopType_value)
	proto.RegisterEnum("proto.TroopOperate", TroopOperate_name, TroopOperate_value)
	proto.RegisterEnum("proto.RegionType", RegionType_name, RegionType_value)
	proto.RegisterEnum("proto.MultiLevelNpcType", MultiLevelNpcType_name, MultiLevelNpcType_value)
}
func (m *BlockInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.X) > 0 {
		for _, num := range m.X {
			dAtA[i] = 0x8
			i++
			i = encodeVarintRegion(dAtA, i, uint64(num))
		}
	}
	if len(m.Y) > 0 {
		for _, num := range m.Y {
			dAtA[i] = 0x10
			i++
			i = encodeVarintRegion(dAtA, i, uint64(num))
		}
	}
	if len(m.Type) > 0 {
		for _, num := range m.Type {
			dAtA[i] = 0x18
			i++
			i = encodeVarintRegion(dAtA, i, uint64(num))
		}
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRegion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.H) > 0 {
		for _, num := range m.H {
			dAtA[i] = 0x28
			i++
			i = encodeVarintRegion(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *BlockLayoutProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockLayoutProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XLenPerBlock != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.XLenPerBlock))
	}
	if m.YLenPerBlock != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.YLenPerBlock))
	}
	if m.BlockLen != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.BlockLen))
	}
	if len(m.BlockName) > 0 {
		for _, s := range m.BlockName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *BaseUnitProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseUnitProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HeroId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRegion(dAtA, i, uint64(len(m.HeroId)))
		i += copy(dAtA[i:], m.HeroId)
	}
	if len(m.HeroName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRegion(dAtA, i, uint64(len(m.HeroName)))
		i += copy(dAtA[i:], m.HeroName)
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.GuildId))
	}
	if len(m.GuildFlagName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRegion(dAtA, i, uint64(len(m.GuildFlagName)))
		i += copy(dAtA[i:], m.GuildFlagName)
	}
	if m.Level != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.Level))
	}
	if m.BaseX != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.BaseX))
	}
	if m.BaseY != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.BaseY))
	}
	if m.MianDisappearTime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.MianDisappearTime))
	}
	if m.WhiteFlagGuildId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.WhiteFlagGuildId))
	}
	if len(m.WhiteFlagGuildFlagName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintRegion(dAtA, i, uint64(len(m.WhiteFlagGuildFlagName)))
		i += copy(dAtA[i:], m.WhiteFlagGuildFlagName)
	}
	if m.WhiteFlagDisappearTime != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.WhiteFlagDisappearTime))
	}
	if m.OuterCityUnlockBit != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.OuterCityUnlockBit))
	}
	if len(m.Sign) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintRegion(dAtA, i, uint64(len(m.Sign)))
		i += copy(dAtA[i:], m.Sign)
	}
	if m.Prosperty != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.Prosperty))
	}
	if m.StopLostProsperity {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.StopLostProsperity {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CountryId != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.CountryId))
	}
	if m.Title != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.Title))
	}
	if m.VipLevel != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.VipLevel))
	}
	return i, nil
}

func (m *TroopUnitProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TroopUnitProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.Action))
	}
	if m.MoveType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.MoveType))
	}
	if m.MoveStartTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.MoveStartTime))
	}
	if m.MoveArrivedTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.MoveArrivedTime))
	}
	if len(m.StartBaseId) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintRegion(dAtA, i, uint64(len(m.StartBaseId)))
		i += copy(dAtA[i:], m.StartBaseId)
	}
	if m.StartBaseX != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.StartBaseX))
	}
	if m.StartBaseY != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.StartBaseY))
	}
	if m.StartBaseGuildId != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.StartBaseGuildId))
	}
	if len(m.TargetBaseId) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRegion(dAtA, i, uint64(len(m.TargetBaseId)))
		i += copy(dAtA[i:], m.TargetBaseId)
	}
	if m.TargetBaseX != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.TargetBaseX))
	}
	if m.TargetBaseY != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.TargetBaseY))
	}
	if m.TargetBaseGuildId != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.TargetBaseGuildId))
	}
	if m.Type != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.Type))
	}
	if m.Dialogue != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.Dialogue))
	}
	if len(m.TroopId) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintRegion(dAtA, i, uint64(len(m.TroopId)))
		i += copy(dAtA[i:], m.TroopId)
	}
	return i, nil
}

func (m *RegionDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.Id))
	}
	if m.RegionType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.RegionType))
	}
	if m.Level != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.Level))
	}
	if m.BasicOutput != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.BasicOutput))
	}
	if m.IsVeryMuchJadeOreThreshold != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.IsVeryMuchJadeOreThreshold))
	}
	if m.IsMuchJadeOreThreshold != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.IsMuchJadeOreThreshold))
	}
	if len(m.CrowdedBaseCount) > 0 {
		for _, num := range m.CrowdedBaseCount {
			dAtA[i] = 0x58
			i++
			i = encodeVarintRegion(dAtA, i, uint64(num))
		}
	}
	if m.SubBlockXLen != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.SubBlockXLen))
	}
	if m.SubBlockYLen != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.SubBlockYLen))
	}
	if m.GuildMoveBaseMinRadius != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.GuildMoveBaseMinRadius))
	}
	if m.GuildMoveBaseMaxRadius != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.GuildMoveBaseMaxRadius))
	}
	return i, nil
}

func (m *RegionMultiLevelNpcTypeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionMultiLevelNpcTypeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.Type))
	}
	if m.MaxHate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.MaxHate))
	}
	if m.FightHate != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.FightHate))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRegion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *RegionMultiLevelNpcDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionMultiLevelNpcDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.Type))
	}
	if len(m.LevelBaseId) > 0 {
		for _, num := range m.LevelBaseId {
			dAtA[i] = 0x18
			i++
			i = encodeVarintRegion(dAtA, i, uint64(num))
		}
	}
	if m.OffsetBaseX != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.OffsetBaseX))
	}
	if m.OffsetBaseY != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.OffsetBaseY))
	}
	return i, nil
}

func (m *DiaoKeDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiaoKeDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CostJadeOre != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.CostJadeOre))
	}
	if m.JadePrize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.JadePrize))
	}
	return i, nil
}

func (m *DiaoKeMiscDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiaoKeMiscDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TimeCost) > 0 {
		for _, num := range m.TimeCost {
			dAtA[i] = 0x8
			i++
			i = encodeVarintRegion(dAtA, i, uint64(num))
		}
	}
	if m.OneYuanBaoExchangeDuration != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.OneYuanBaoExchangeDuration))
	}
	if m.DefaultDiaoKeData != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.DefaultDiaoKeData.Size()))
		n1, err := m.DefaultDiaoKeData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *AstDefendLogProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AstDefendLogProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LogTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.LogTime))
	}
	if len(m.HeroName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRegion(dAtA, i, uint64(len(m.HeroName)))
		i += copy(dAtA[i:], m.HeroName)
	}
	if m.DefendingDuration != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.DefendingDuration))
	}
	if m.AddProsperity != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRegion(dAtA, i, uint64(m.AddProsperity))
	}
	return i, nil
}

func encodeFixed64Region(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Region(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintRegion(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *BlockInfoProto) Size() (n int) {
	var l int
	_ = l
	if len(m.X) > 0 {
		for _, e := range m.X {
			n += 1 + sovRegion(uint64(e))
		}
	}
	if len(m.Y) > 0 {
		for _, e := range m.Y {
			n += 1 + sovRegion(uint64(e))
		}
	}
	if len(m.Type) > 0 {
		for _, e := range m.Type {
			n += 1 + sovRegion(uint64(e))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	if len(m.H) > 0 {
		for _, e := range m.H {
			n += 1 + sovRegion(uint64(e))
		}
	}
	return n
}

func (m *BlockLayoutProto) Size() (n int) {
	var l int
	_ = l
	if m.XLenPerBlock != 0 {
		n += 1 + sovRegion(uint64(m.XLenPerBlock))
	}
	if m.YLenPerBlock != 0 {
		n += 1 + sovRegion(uint64(m.YLenPerBlock))
	}
	if m.BlockLen != 0 {
		n += 1 + sovRegion(uint64(m.BlockLen))
	}
	if len(m.BlockName) > 0 {
		for _, s := range m.BlockName {
			l = len(s)
			n += 1 + l + sovRegion(uint64(l))
		}
	}
	return n
}

func (m *BaseUnitProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.HeroId)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	l = len(m.HeroName)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	if m.GuildId != 0 {
		n += 1 + sovRegion(uint64(m.GuildId))
	}
	l = len(m.GuildFlagName)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovRegion(uint64(m.Level))
	}
	if m.BaseX != 0 {
		n += 1 + sovRegion(uint64(m.BaseX))
	}
	if m.BaseY != 0 {
		n += 1 + sovRegion(uint64(m.BaseY))
	}
	if m.MianDisappearTime != 0 {
		n += 1 + sovRegion(uint64(m.MianDisappearTime))
	}
	if m.WhiteFlagGuildId != 0 {
		n += 1 + sovRegion(uint64(m.WhiteFlagGuildId))
	}
	l = len(m.WhiteFlagGuildFlagName)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	if m.WhiteFlagDisappearTime != 0 {
		n += 1 + sovRegion(uint64(m.WhiteFlagDisappearTime))
	}
	if m.OuterCityUnlockBit != 0 {
		n += 1 + sovRegion(uint64(m.OuterCityUnlockBit))
	}
	l = len(m.Sign)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	if m.Prosperty != 0 {
		n += 1 + sovRegion(uint64(m.Prosperty))
	}
	if m.StopLostProsperity {
		n += 3
	}
	if m.CountryId != 0 {
		n += 2 + sovRegion(uint64(m.CountryId))
	}
	if m.Title != 0 {
		n += 2 + sovRegion(uint64(m.Title))
	}
	if m.VipLevel != 0 {
		n += 2 + sovRegion(uint64(m.VipLevel))
	}
	return n
}

func (m *TroopUnitProto) Size() (n int) {
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovRegion(uint64(m.Action))
	}
	if m.MoveType != 0 {
		n += 1 + sovRegion(uint64(m.MoveType))
	}
	if m.MoveStartTime != 0 {
		n += 1 + sovRegion(uint64(m.MoveStartTime))
	}
	if m.MoveArrivedTime != 0 {
		n += 1 + sovRegion(uint64(m.MoveArrivedTime))
	}
	l = len(m.StartBaseId)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	if m.StartBaseX != 0 {
		n += 1 + sovRegion(uint64(m.StartBaseX))
	}
	if m.StartBaseY != 0 {
		n += 1 + sovRegion(uint64(m.StartBaseY))
	}
	if m.StartBaseGuildId != 0 {
		n += 1 + sovRegion(uint64(m.StartBaseGuildId))
	}
	l = len(m.TargetBaseId)
	if l > 0 {
		n += 2 + l + sovRegion(uint64(l))
	}
	if m.TargetBaseX != 0 {
		n += 2 + sovRegion(uint64(m.TargetBaseX))
	}
	if m.TargetBaseY != 0 {
		n += 2 + sovRegion(uint64(m.TargetBaseY))
	}
	if m.TargetBaseGuildId != 0 {
		n += 2 + sovRegion(uint64(m.TargetBaseGuildId))
	}
	if m.Type != 0 {
		n += 2 + sovRegion(uint64(m.Type))
	}
	if m.Dialogue != 0 {
		n += 2 + sovRegion(uint64(m.Dialogue))
	}
	l = len(m.TroopId)
	if l > 0 {
		n += 2 + l + sovRegion(uint64(l))
	}
	return n
}

func (m *RegionDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRegion(uint64(m.Id))
	}
	if m.RegionType != 0 {
		n += 1 + sovRegion(uint64(m.RegionType))
	}
	if m.Level != 0 {
		n += 1 + sovRegion(uint64(m.Level))
	}
	if m.BasicOutput != 0 {
		n += 1 + sovRegion(uint64(m.BasicOutput))
	}
	if m.IsVeryMuchJadeOreThreshold != 0 {
		n += 1 + sovRegion(uint64(m.IsVeryMuchJadeOreThreshold))
	}
	if m.IsMuchJadeOreThreshold != 0 {
		n += 1 + sovRegion(uint64(m.IsMuchJadeOreThreshold))
	}
	if len(m.CrowdedBaseCount) > 0 {
		for _, e := range m.CrowdedBaseCount {
			n += 1 + sovRegion(uint64(e))
		}
	}
	if m.SubBlockXLen != 0 {
		n += 1 + sovRegion(uint64(m.SubBlockXLen))
	}
	if m.SubBlockYLen != 0 {
		n += 1 + sovRegion(uint64(m.SubBlockYLen))
	}
	if m.GuildMoveBaseMinRadius != 0 {
		n += 1 + sovRegion(uint64(m.GuildMoveBaseMinRadius))
	}
	if m.GuildMoveBaseMaxRadius != 0 {
		n += 1 + sovRegion(uint64(m.GuildMoveBaseMaxRadius))
	}
	return n
}

func (m *RegionMultiLevelNpcTypeProto) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovRegion(uint64(m.Type))
	}
	if m.MaxHate != 0 {
		n += 1 + sovRegion(uint64(m.MaxHate))
	}
	if m.FightHate != 0 {
		n += 1 + sovRegion(uint64(m.FightHate))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	return n
}

func (m *RegionMultiLevelNpcDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRegion(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovRegion(uint64(m.Type))
	}
	if len(m.LevelBaseId) > 0 {
		for _, e := range m.LevelBaseId {
			n += 1 + sovRegion(uint64(e))
		}
	}
	if m.OffsetBaseX != 0 {
		n += 1 + sovRegion(uint64(m.OffsetBaseX))
	}
	if m.OffsetBaseY != 0 {
		n += 1 + sovRegion(uint64(m.OffsetBaseY))
	}
	return n
}

func (m *DiaoKeDataProto) Size() (n int) {
	var l int
	_ = l
	if m.CostJadeOre != 0 {
		n += 1 + sovRegion(uint64(m.CostJadeOre))
	}
	if m.JadePrize != 0 {
		n += 1 + sovRegion(uint64(m.JadePrize))
	}
	return n
}

func (m *DiaoKeMiscDataProto) Size() (n int) {
	var l int
	_ = l
	if len(m.TimeCost) > 0 {
		for _, e := range m.TimeCost {
			n += 1 + sovRegion(uint64(e))
		}
	}
	if m.OneYuanBaoExchangeDuration != 0 {
		n += 1 + sovRegion(uint64(m.OneYuanBaoExchangeDuration))
	}
	if m.DefaultDiaoKeData != nil {
		l = m.DefaultDiaoKeData.Size()
		n += 1 + l + sovRegion(uint64(l))
	}
	return n
}

func (m *AstDefendLogProto) Size() (n int) {
	var l int
	_ = l
	if m.LogTime != 0 {
		n += 1 + sovRegion(uint64(m.LogTime))
	}
	l = len(m.HeroName)
	if l > 0 {
		n += 1 + l + sovRegion(uint64(l))
	}
	if m.DefendingDuration != 0 {
		n += 1 + sovRegion(uint64(m.DefendingDuration))
	}
	if m.AddProsperity != 0 {
		n += 1 + sovRegion(uint64(m.AddProsperity))
	}
	return n
}

func sovRegion(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRegion(x uint64) (n int) {
	return sovRegion(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BlockInfoProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRegion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.X = append(m.X, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRegion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRegion
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRegion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.X = append(m.X, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRegion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Y = append(m.Y, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRegion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRegion
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRegion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Y = append(m.Y, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRegion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Type = append(m.Type, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRegion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRegion
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRegion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Type = append(m.Type, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRegion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.H = append(m.H, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRegion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRegion
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRegion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.H = append(m.H, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockLayoutProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockLayoutProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockLayoutProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XLenPerBlock", wireType)
			}
			m.XLenPerBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XLenPerBlock |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YLenPerBlock", wireType)
			}
			m.YLenPerBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YLenPerBlock |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockLen", wireType)
			}
			m.BlockLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockName = append(m.BlockName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseUnitProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseUnitProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseUnitProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeroId = append(m.HeroId[:0], dAtA[iNdEx:postIndex]...)
			if m.HeroId == nil {
				m.HeroId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeroName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildFlagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildFlagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseX", wireType)
			}
			m.BaseX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseY", wireType)
			}
			m.BaseY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MianDisappearTime", wireType)
			}
			m.MianDisappearTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MianDisappearTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhiteFlagGuildId", wireType)
			}
			m.WhiteFlagGuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WhiteFlagGuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhiteFlagGuildFlagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WhiteFlagGuildFlagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhiteFlagDisappearTime", wireType)
			}
			m.WhiteFlagDisappearTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WhiteFlagDisappearTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OuterCityUnlockBit", wireType)
			}
			m.OuterCityUnlockBit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OuterCityUnlockBit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prosperty", wireType)
			}
			m.Prosperty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prosperty |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopLostProsperity", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StopLostProsperity = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryId", wireType)
			}
			m.CountryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountryId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			m.Title = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Title |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipLevel", wireType)
			}
			m.VipLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TroopUnitProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TroopUnitProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TroopUnitProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveType", wireType)
			}
			m.MoveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveStartTime", wireType)
			}
			m.MoveStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveStartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveArrivedTime", wireType)
			}
			m.MoveArrivedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveArrivedTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBaseId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartBaseId = append(m.StartBaseId[:0], dAtA[iNdEx:postIndex]...)
			if m.StartBaseId == nil {
				m.StartBaseId = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBaseX", wireType)
			}
			m.StartBaseX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBaseX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBaseY", wireType)
			}
			m.StartBaseY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBaseY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBaseGuildId", wireType)
			}
			m.StartBaseGuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBaseGuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBaseId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetBaseId = append(m.TargetBaseId[:0], dAtA[iNdEx:postIndex]...)
			if m.TargetBaseId == nil {
				m.TargetBaseId = []byte{}
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBaseX", wireType)
			}
			m.TargetBaseX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetBaseX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBaseY", wireType)
			}
			m.TargetBaseY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetBaseY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBaseGuildId", wireType)
			}
			m.TargetBaseGuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetBaseGuildId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (TroopType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dialogue", wireType)
			}
			m.Dialogue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dialogue |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TroopId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TroopId = append(m.TroopId[:0], dAtA[iNdEx:postIndex]...)
			if m.TroopId == nil {
				m.TroopId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionType", wireType)
			}
			m.RegionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionType |= (RegionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicOutput", wireType)
			}
			m.BasicOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BasicOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVeryMuchJadeOreThreshold", wireType)
			}
			m.IsVeryMuchJadeOreThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsVeryMuchJadeOreThreshold |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMuchJadeOreThreshold", wireType)
			}
			m.IsMuchJadeOreThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsMuchJadeOreThreshold |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRegion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CrowdedBaseCount = append(m.CrowdedBaseCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRegion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRegion
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRegion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CrowdedBaseCount = append(m.CrowdedBaseCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CrowdedBaseCount", wireType)
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubBlockXLen", wireType)
			}
			m.SubBlockXLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubBlockXLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubBlockYLen", wireType)
			}
			m.SubBlockYLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubBlockYLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildMoveBaseMinRadius", wireType)
			}
			m.GuildMoveBaseMinRadius = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildMoveBaseMinRadius |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildMoveBaseMaxRadius", wireType)
			}
			m.GuildMoveBaseMaxRadius = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildMoveBaseMaxRadius |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionMultiLevelNpcTypeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionMultiLevelNpcTypeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionMultiLevelNpcTypeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MultiLevelNpcType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxHate", wireType)
			}
			m.MaxHate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxHate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightHate", wireType)
			}
			m.FightHate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightHate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionMultiLevelNpcDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionMultiLevelNpcDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionMultiLevelNpcDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MultiLevelNpcType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRegion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LevelBaseId = append(m.LevelBaseId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRegion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRegion
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRegion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LevelBaseId = append(m.LevelBaseId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelBaseId", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetBaseX", wireType)
			}
			m.OffsetBaseX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetBaseX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetBaseY", wireType)
			}
			m.OffsetBaseY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetBaseY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiaoKeDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiaoKeDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiaoKeDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostJadeOre", wireType)
			}
			m.CostJadeOre = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CostJadeOre |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JadePrize", wireType)
			}
			m.JadePrize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JadePrize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiaoKeMiscDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiaoKeMiscDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiaoKeMiscDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRegion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TimeCost = append(m.TimeCost, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRegion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRegion
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRegion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TimeCost = append(m.TimeCost, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeCost", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneYuanBaoExchangeDuration", wireType)
			}
			m.OneYuanBaoExchangeDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OneYuanBaoExchangeDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultDiaoKeData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultDiaoKeData == nil {
				m.DefaultDiaoKeData = &DiaoKeDataProto{}
			}
			if err := m.DefaultDiaoKeData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AstDefendLogProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AstDefendLogProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AstDefendLogProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogTime", wireType)
			}
			m.LogTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeroName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefendingDuration", wireType)
			}
			m.DefendingDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefendingDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddProsperity", wireType)
			}
			m.AddProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddProsperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRegion(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRegion
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRegion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRegion
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRegion
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRegion(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRegion = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRegion   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/shared_proto/region.proto", fileDescriptorRegion)
}

var fileDescriptorRegion = []byte{
	// 1744 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x57, 0xcf, 0x72, 0xdb, 0xc8,
	0xf1, 0x16, 0xf8, 0x47, 0x22, 0x9b, 0x14, 0x05, 0xc2, 0xb2, 0x16, 0xd2, 0xcf, 0x3f, 0xad, 0xc2,
	0xca, 0xba, 0x54, 0xaa, 0xac, 0xb5, 0x71, 0x52, 0x49, 0x65, 0x6f, 0xa4, 0xc4, 0x95, 0xe8, 0xe5,
	0x1f, 0x15, 0x0d, 0x6d, 0x24, 0x5f, 0xa6, 0x86, 0xc4, 0x88, 0x9c, 0x18, 0xc4, 0xa0, 0x80, 0x81,
	0x4c, 0xe4, 0x05, 0x72, 0xc8, 0x0b, 0x24, 0xa9, 0x5c, 0xf6, 0x9e, 0xb7, 0xc8, 0x25, 0x87, 0x1c,
	0xf2, 0x08, 0x29, 0xe7, 0x45, 0x52, 0xd3, 0x33, 0x22, 0x68, 0xd9, 0x9b, 0x4a, 0x4e, 0xe2, 0x7c,
	0xfd, 0xf5, 0x4c, 0xf7, 0xf4, 0x37, 0xdd, 0x10, 0xfc, 0x62, 0xc6, 0xe5, 0x3c, 0x9d, 0xbc, 0x98,
	0x8a, 0xc5, 0x69, 0xc0, 0x67, 0x73, 0x19, 0xd1, 0x77, 0xa7, 0x0b, 0x1a, 0xb0, 0x5f, 0x9e, 0x46,
	0x93, 0xd3, 0x64, 0x4e, 0x63, 0xe6, 0x93, 0x28, 0x16, 0x52, 0x9c, 0xc6, 0x6c, 0xc6, 0x45, 0xf8,
	0x02, 0x17, 0x4e, 0x19, 0xff, 0x1c, 0xfc, 0xfc, 0xbf, 0x77, 0x9f, 0xd0, 0x84, 0x69, 0xe7, 0x56,
	0x0c, 0x8d, 0x4e, 0x20, 0xa6, 0x6f, 0x7b, 0xe1, 0x9d, 0xb8, 0xc2, 0xed, 0x6c, 0xb0, 0x96, 0xae,
	0x75, 0x54, 0x3c, 0x2e, 0x77, 0x0a, 0xf6, 0xc6, 0xd8, 0x5a, 0x2a, 0x24, 0x73, 0x0b, 0x39, 0x92,
	0x39, 0x7b, 0x50, 0x92, 0x59, 0xc4, 0xdc, 0xe2, 0x0a, 0xc4, 0xb5, 0xe3, 0x40, 0x29, 0xa4, 0x0b,
	0xe6, 0x96, 0x8e, 0xac, 0xe3, 0xea, 0x18, 0x7f, 0x2b, 0xef, 0xb9, 0x5b, 0xce, 0xbd, 0xe7, 0xad,
	0x3f, 0x5b, 0x60, 0xe3, 0xa1, 0x7d, 0x9a, 0x89, 0x54, 0xea, 0x63, 0xbf, 0x80, 0x9d, 0x25, 0x09,
	0x58, 0x48, 0x22, 0x16, 0x93, 0x89, 0xb2, 0xba, 0xd6, 0x91, 0x75, 0x5c, 0x1e, 0xd7, 0x97, 0x7d,
	0x16, 0x5e, 0xb1, 0x18, 0x3d, 0x14, 0x2d, 0x7b, 0x44, 0x2b, 0x68, 0x5a, 0xb6, 0x4e, 0xfb, 0x3f,
	0xa8, 0xa2, 0x51, 0x51, 0xdd, 0x22, 0x12, 0x2a, 0x08, 0xf4, 0x59, 0xe8, 0xfc, 0x3f, 0x80, 0x36,
	0x9a, 0x58, 0x8b, 0xc7, 0xd5, 0xb1, 0xa6, 0x0f, 0xe9, 0x82, 0xb5, 0x7e, 0x5f, 0x86, 0xed, 0x0e,
	0x4d, 0xd8, 0x75, 0xc8, 0x4d, 0x6c, 0x9f, 0xc1, 0xd6, 0x9c, 0xc5, 0x82, 0x70, 0x1f, 0x63, 0xaa,
	0x8f, 0x37, 0xd5, 0xb2, 0xe7, 0xab, 0x63, 0xd0, 0x80, 0x1b, 0x15, 0x30, 0xe9, 0x8a, 0x02, 0xd4,
	0x3e, 0xce, 0x3e, 0x54, 0x66, 0x29, 0x0f, 0x7c, 0xe5, 0xa6, 0x43, 0xd8, 0xc2, 0x75, 0xcf, 0x77,
	0x9e, 0xc3, 0x8e, 0x36, 0xdd, 0x05, 0x74, 0xa6, 0xbd, 0xcb, 0xe8, 0xbd, 0x8d, 0xf0, 0x37, 0x01,
	0x9d, 0xe1, 0x16, 0xbb, 0x50, 0x0e, 0xd8, 0x3d, 0x0b, 0xdc, 0x4d, 0xf4, 0xd7, 0x0b, 0xe7, 0x29,
	0x6c, 0xaa, 0x0a, 0x92, 0xa5, 0xbb, 0xa5, 0x61, 0xb5, 0xba, 0x59, 0xc1, 0x99, 0x5b, 0xc9, 0xe1,
	0x5b, 0xe7, 0x05, 0x3c, 0x59, 0x70, 0x1a, 0x12, 0x9f, 0x27, 0x34, 0x8a, 0x18, 0x8d, 0x89, 0xe4,
	0x0b, 0xe6, 0x56, 0x91, 0xd3, 0x54, 0xa6, 0xf3, 0x07, 0x8b, 0xc7, 0x17, 0xcc, 0xf9, 0x12, 0x9e,
	0xbc, 0x9b, 0x73, 0xc9, 0x74, 0x6c, 0xab, 0x0c, 0x00, 0xf9, 0x36, 0x9a, 0x54, 0x7c, 0x17, 0x26,
	0x95, 0xaf, 0xe1, 0xe0, 0x23, 0x7a, 0x9e, 0x55, 0x0d, 0xb3, 0xda, 0xfb, 0xd0, 0x6b, 0x95, 0xde,
	0xaf, 0x60, 0x7f, 0xcd, 0xf7, 0x51, 0x80, 0x75, 0x3c, 0x30, 0x77, 0xfd, 0x30, 0xca, 0x9f, 0xc2,
	0x53, 0x91, 0x4a, 0x16, 0x93, 0x29, 0x97, 0x19, 0x49, 0x43, 0xac, 0xe7, 0x84, 0x4b, 0x77, 0x1b,
	0xdd, 0x1c, 0x34, 0x9e, 0x71, 0x99, 0x5d, 0xa3, 0xa9, 0xc3, 0xa5, 0x12, 0x67, 0xc2, 0x67, 0xa1,
	0xdb, 0xd0, 0xe2, 0x54, 0xbf, 0x9d, 0x67, 0x50, 0x8d, 0x62, 0x91, 0x44, 0x2c, 0x96, 0x99, 0xbb,
	0x83, 0xae, 0x39, 0xe0, 0x7c, 0x05, 0xbb, 0x89, 0x14, 0x11, 0x09, 0x44, 0x22, 0x89, 0x81, 0xb9,
	0xcc, 0x5c, 0xfb, 0xc8, 0x3a, 0xae, 0x8c, 0x1d, 0x65, 0xeb, 0x8b, 0x44, 0x89, 0xc4, 0x58, 0x94,
	0xb4, 0xa6, 0x22, 0x0d, 0x65, 0x9c, 0xa9, 0x3b, 0x6b, 0xea, 0x0d, 0x0d, 0xd2, 0xf3, 0x55, 0x3d,
	0x25, 0x97, 0x01, 0x73, 0x1d, 0x5d, 0x21, 0x5c, 0x28, 0x15, 0xdd, 0xf3, 0x88, 0xe8, 0x4a, 0x3f,
	0xd1, 0x62, 0xbd, 0xe7, 0x51, 0x5f, 0xad, 0x5b, 0x7f, 0x29, 0x41, 0xc3, 0x8b, 0x85, 0x88, 0x72,
	0x39, 0xee, 0xc1, 0x26, 0x9d, 0x4a, 0x2e, 0x42, 0x23, 0x7d, 0xb3, 0x52, 0xfb, 0x2c, 0xc4, 0x3d,
	0x23, 0xe6, 0x69, 0xe2, 0x3e, 0x0a, 0xf0, 0xd4, 0xd3, 0x7c, 0x0e, 0x3b, 0x68, 0x4c, 0x24, 0x8d,
	0xa5, 0xbe, 0xe1, 0x12, 0x52, 0xb6, 0x15, 0xfc, 0x5a, 0xa1, 0x78, 0xb1, 0x27, 0xd0, 0x44, 0x1e,
	0x8d, 0x63, 0x7e, 0xcf, 0x7c, 0xcd, 0x2c, 0x23, 0x13, 0x37, 0x68, 0x6b, 0x1c, 0xb9, 0x2d, 0xd8,
	0xd6, 0xdb, 0xa1, 0xee, 0xb8, 0x8f, 0xe5, 0xae, 0x8f, 0x6b, 0x08, 0xaa, 0x27, 0xd4, 0xf3, 0x9d,
	0x23, 0xa8, 0xaf, 0x71, 0x96, 0xa6, 0xac, 0xb0, 0xa2, 0xdc, 0x3c, 0x62, 0x64, 0xa6, 0x82, 0x39,
	0xe3, 0x56, 0x49, 0x72, 0x8d, 0xb1, 0x92, 0x64, 0x43, 0x4b, 0x72, 0x45, 0x7c, 0x90, 0xe4, 0x8f,
	0xa1, 0x21, 0x69, 0x3c, 0x63, 0x79, 0x5c, 0x4f, 0x31, 0xae, 0xba, 0x46, 0x4d, 0x60, 0x2d, 0xd8,
	0x5e, 0x67, 0x2d, 0xdd, 0x3d, 0xdc, 0xae, 0x96, 0x93, 0x6e, 0x1e, 0x73, 0x32, 0xf7, 0xb3, 0xc7,
	0x9c, 0x5b, 0xe7, 0x14, 0x76, 0xd7, 0x39, 0xab, 0xe8, 0x5c, 0xfd, 0xc0, 0x72, 0x6a, 0x1e, 0x9e,
	0x6e, 0x9e, 0xfb, 0x47, 0xd6, 0x71, 0xe3, 0xa5, 0xad, 0x1b, 0xf1, 0x0b, 0xac, 0xb1, 0xaa, 0x94,
	0x69, 0xa5, 0x07, 0x50, 0xf1, 0x39, 0x0d, 0xc4, 0x2c, 0x65, 0xee, 0x81, 0xae, 0xe5, 0xc3, 0x5a,
	0x75, 0x16, 0xa9, 0xe8, 0xea, 0x18, 0x86, 0xa9, 0x6d, 0xe1, 0xba, 0xe7, 0xb7, 0x7e, 0x57, 0x82,
	0x9d, 0x31, 0x4e, 0x87, 0x73, 0x2a, 0xa9, 0xd6, 0x4b, 0x03, 0x0a, 0xa6, 0x73, 0x95, 0xc7, 0x05,
	0xee, 0x3b, 0x2f, 0xa1, 0xa6, 0x07, 0x88, 0x56, 0x4a, 0x01, 0xe3, 0x68, 0x9a, 0x38, 0xb4, 0x33,
	0x06, 0x02, 0xf1, 0xea, 0x77, 0xde, 0x89, 0x8a, 0xeb, 0x9d, 0xe8, 0x47, 0x50, 0x9f, 0xd0, 0x84,
	0x4f, 0x89, 0x48, 0x65, 0x94, 0x4a, 0xa3, 0xa8, 0x1a, 0x62, 0x23, 0x84, 0x9c, 0x33, 0xf8, 0x9c,
	0x27, 0xe4, 0x9e, 0xc5, 0x19, 0x59, 0xa4, 0xd3, 0x39, 0xf9, 0x0d, 0xf5, 0x19, 0x11, 0x31, 0x23,
	0x72, 0x1e, 0xb3, 0x64, 0x2e, 0x02, 0xdf, 0xa8, 0xeb, 0x80, 0x27, 0xdf, 0xb1, 0x38, 0x1b, 0xa4,
	0xd3, 0xf9, 0x2b, 0xea, 0xb3, 0x51, 0xcc, 0xbc, 0x07, 0x86, 0x6a, 0x32, 0x3c, 0xf9, 0x41, 0x7f,
	0xdd, 0x1c, 0xf7, 0x78, 0xf2, 0x49, 0xdf, 0xaf, 0xc0, 0x99, 0xc6, 0xe2, 0x9d, 0xcf, 0x7c, 0x5d,
	0x20, 0x7c, 0x8d, 0x6e, 0x6d, 0x35, 0x90, 0x6c, 0x63, 0x55, 0x25, 0x3a, 0x53, 0x36, 0x35, 0x63,
	0x92, 0x74, 0xa2, 0xa7, 0x0b, 0xc1, 0xa1, 0x64, 0x54, 0x5b, 0x4f, 0xd2, 0x09, 0xce, 0x97, 0x1b,
	0x35, 0x46, 0x3e, 0xa0, 0xe1, 0x50, 0x32, 0xd2, 0x5d, 0xd1, 0x6e, 0x15, 0xed, 0x6b, 0x38, 0xd0,
	0x9a, 0xc0, 0x67, 0x85, 0x21, 0x2c, 0x78, 0x48, 0x62, 0xea, 0xf3, 0x34, 0x31, 0x1a, 0xde, 0x43,
	0xc6, 0x40, 0xdc, 0x33, 0x15, 0xc5, 0x80, 0x87, 0x63, 0xb4, 0x7e, 0xd2, 0x97, 0x2e, 0x1f, 0x7c,
	0x77, 0x3e, 0xe5, 0x4b, 0x97, 0xda, 0xb7, 0xf5, 0x27, 0x0b, 0x9e, 0xe9, 0x62, 0x0e, 0xd2, 0x40,
	0x72, 0xec, 0x26, 0xc3, 0x68, 0xaa, 0xaa, 0xa9, 0x65, 0xf1, 0x13, 0xa3, 0x43, 0x5d, 0x7f, 0xd7,
	0xd4, 0xff, 0x23, 0xb2, 0xd1, 0xe3, 0x3e, 0x54, 0xd4, 0xd1, 0x73, 0x2a, 0x1f, 0x7a, 0xcb, 0xd6,
	0x82, 0x2e, 0x2f, 0xa9, 0x64, 0xaa, 0xe9, 0xdd, 0xa9, 0x0f, 0x0e, 0x6d, 0xd4, 0x1a, 0xa8, 0x22,
	0x82, 0xe6, 0x87, 0x8f, 0x82, 0x72, 0xfe, 0x51, 0xd0, 0xfa, 0xfb, 0xa7, 0x83, 0xfb, 0x61, 0xcd,
	0xfe, 0x6f, 0xc1, 0x3e, 0x87, 0x6d, 0x14, 0xe8, 0xaa, 0x01, 0xe4, 0x1f, 0x2a, 0x35, 0x34, 0xe4,
	0x3d, 0x40, 0xdc, 0xdd, 0x25, 0x79, 0x0f, 0x30, 0x02, 0xd6, 0xe0, 0xaa, 0x07, 0xac, 0x73, 0x32,
	0x23, 0xd7, 0x35, 0xce, 0x6d, 0xcb, 0x83, 0x9d, 0x73, 0x4e, 0xc5, 0xb7, 0x2c, 0x4f, 0xa0, 0x05,
	0xdb, 0x53, 0x35, 0x36, 0x1e, 0xf4, 0x6a, 0x72, 0xa9, 0x29, 0xd0, 0x68, 0x54, 0x5d, 0x1c, 0x9a,
	0xa3, 0x98, 0xff, 0x96, 0x99, 0x66, 0x5e, 0x55, 0xc8, 0x95, 0x02, 0x5a, 0x7f, 0xb5, 0xe0, 0x89,
	0xde, 0x76, 0xc0, 0x93, 0xb5, 0xbb, 0xf9, 0x1c, 0xaa, 0xaa, 0x2b, 0x13, 0xb5, 0xd5, 0xda, 0x97,
	0x5a, 0x45, 0x81, 0x67, 0x22, 0x91, 0x4e, 0x07, 0x0e, 0x45, 0xc8, 0x48, 0x96, 0xd2, 0x90, 0x4c,
	0xa8, 0x20, 0x6c, 0x39, 0x9d, 0xd3, 0x70, 0xc6, 0x88, 0x9f, 0xc6, 0x74, 0x6d, 0x70, 0x1c, 0x88,
	0x90, 0xdd, 0xa6, 0x34, 0xec, 0x50, 0xd1, 0x35, 0x94, 0x73, 0xc3, 0x70, 0x2e, 0x60, 0xd7, 0x67,
	0x77, 0x34, 0x0d, 0x24, 0xf1, 0x39, 0x15, 0xe4, 0x2d, 0x23, 0x3e, 0x95, 0x14, 0x6b, 0x5f, 0x7b,
	0xb9, 0x67, 0x0a, 0xf0, 0x28, 0xeb, 0x71, 0xd3, 0xf8, 0xe4, 0x78, 0xeb, 0x7b, 0x0b, 0x9a, 0xed,
	0x44, 0x9e, 0xb3, 0x3b, 0x16, 0xfa, 0x7d, 0x31, 0xd3, 0x39, 0xec, 0x43, 0x25, 0x10, 0x33, 0x3d,
	0x5d, 0xf4, 0xcd, 0x6c, 0x05, 0x62, 0x86, 0x53, 0xe5, 0x3f, 0x7e, 0x54, 0x7d, 0x09, 0x8e, 0x8f,
	0x3b, 0xf1, 0x70, 0x96, 0xa7, 0xa3, 0x05, 0xd9, 0x5c, 0x59, 0x56, 0x59, 0x7c, 0x01, 0x0d, 0xea,
	0xfb, 0xeb, 0xb3, 0xdb, 0x0c, 0x3d, 0xea, 0xfb, 0xf9, 0xd8, 0x3e, 0xf9, 0xde, 0x82, 0x86, 0xaa,
	0xa4, 0x87, 0xcd, 0x1a, 0x1b, 0x5e, 0x0d, 0xb6, 0x86, 0xd1, 0xf4, 0x52, 0x2c, 0x98, 0xbd, 0xe1,
	0xb8, 0xb0, 0x3b, 0x8c, 0xa6, 0xb9, 0xda, 0x06, 0x22, 0x4c, 0x24, 0x8b, 0x6d, 0xcb, 0x69, 0x00,
	0x28, 0x8b, 0x59, 0x17, 0x9c, 0x3a, 0x54, 0x86, 0xd1, 0x14, 0x5b, 0xbd, 0x5d, 0x34, 0xd6, 0x1b,
	0x2e, 0xc2, 0xd9, 0x30, 0xb5, 0x4b, 0x66, 0xdd, 0xa1, 0xe2, 0x0d, 0x0d, 0x67, 0x76, 0xd9, 0xb1,
	0xa1, 0xae, 0xbc, 0x79, 0x38, 0x3b, 0x9b, 0xb3, 0x70, 0x66, 0x6f, 0x1a, 0xc6, 0xab, 0x34, 0xf4,
	0x52, 0x1a, 0xda, 0x5b, 0x4e, 0x05, 0x4a, 0x97, 0x2c, 0x16, 0xf6, 0xd1, 0x49, 0x0c, 0xd5, 0xd5,
	0x8c, 0x50, 0xd1, 0x79, 0x1e, 0xb9, 0xec, 0x8e, 0x47, 0xf6, 0x86, 0xd3, 0x84, 0x6d, 0xcf, 0x23,
	0xc3, 0xd1, 0x78, 0xd0, 0xee, 0x93, 0xe1, 0xd5, 0x99, 0x6d, 0x39, 0x0e, 0x34, 0x3c, 0x8f, 0x0c,
	0xae, 0xfb, 0x5e, 0x8f, 0xf4, 0xbb, 0xdf, 0x75, 0xfb, 0x76, 0xc1, 0xd9, 0x81, 0x9a, 0xe7, 0x91,
	0x9b, 0xde, 0x68, 0x78, 0x41, 0x86, 0xd7, 0x76, 0xd1, 0x00, 0x9d, 0xf6, 0x88, 0xbc, 0x69, 0x0f,
	0x2f, 0xec, 0x92, 0x01, 0xda, 0xaf, 0x5f, 0x77, 0x07, 0x9d, 0xfe, 0xad, 0x5d, 0x3e, 0xf9, 0xa3,
	0x05, 0x75, 0x3c, 0x74, 0x14, 0xb1, 0x58, 0xbd, 0x65, 0x80, 0x4d, 0x4f, 0x0c, 0x45, 0xa8, 0x2e,
	0xa5, 0x01, 0xe0, 0x89, 0x5e, 0x78, 0x4f, 0x13, 0x2e, 0x42, 0xdb, 0x52, 0xa9, 0x7b, 0xa2, 0x9d,
	0x24, 0x3c, 0x91, 0x76, 0x41, 0x5b, 0xdb, 0x49, 0xc2, 0x16, 0x93, 0x20, 0xb3, 0x8b, 0xce, 0x13,
	0xd8, 0xf1, 0xc4, 0xaf, 0x45, 0xfc, 0x36, 0x99, 0x8b, 0xa8, 0x83, 0xf7, 0x53, 0xc2, 0x30, 0x57,
	0xe0, 0x55, 0x2c, 0x7c, 0xbb, 0xfc, 0x21, 0x11, 0x1f, 0x82, 0xbd, 0x89, 0x29, 0xaa, 0xb3, 0x58,
	0x22, 0xf9, 0x8c, 0x4a, 0x66, 0x6f, 0x9d, 0x74, 0x01, 0xf2, 0x59, 0xe5, 0x3c, 0x85, 0xa6, 0x0a,
	0x25, 0xe0, 0x7e, 0x0e, 0xda, 0x1b, 0x78, 0x7d, 0xa3, 0x41, 0xd7, 0xb6, 0x9c, 0x2a, 0x94, 0x2f,
	0xae, 0x7b, 0xfd, 0x73, 0xbb, 0xa0, 0x2e, 0x6f, 0x30, 0x1a, 0xbe, 0xf6, 0xba, 0x63, 0xbb, 0x78,
	0xc2, 0xa0, 0xf9, 0x51, 0x17, 0x71, 0x9e, 0x81, 0x6b, 0x76, 0xfb, 0xc8, 0x66, 0x6f, 0x28, 0xff,
	0x7e, 0xef, 0x9a, 0x7c, 0x3b, 0xba, 0xb6, 0x2d, 0xb5, 0xb8, 0x6a, 0x0f, 0xc9, 0xab, 0xeb, 0xa1,
	0xde, 0xf9, 0xb2, 0xdd, 0x23, 0xe7, 0xed, 0x91, 0x5d, 0x54, 0x8b, 0x57, 0xbd, 0x2e, 0xf9, 0xa6,
	0xdb, 0xb3, 0x4b, 0x9d, 0xa3, 0xbf, 0xbd, 0x3f, 0xb4, 0xfe, 0xf1, 0xfe, 0xd0, 0xfa, 0xe7, 0xfb,
	0x43, 0xeb, 0x0f, 0xff, 0x3a, 0xdc, 0xb8, 0xb4, 0xde, 0xd4, 0xd7, 0xff, 0x29, 0x9b, 0x6c, 0xe2,
	0x9f, 0x9f, 0xfd, 0x3b, 0x00, 0x00, 0xff, 0xff, 0x79, 0x0f, 0xf8, 0xb7, 0x07, 0x0e, 0x00, 0x00,
}
