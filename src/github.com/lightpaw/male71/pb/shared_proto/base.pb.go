// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/shared_proto/base.proto
// DO NOT EDIT!

package shared_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Race int32

const (
	Race_InvalidRace Race = 0
	Race_BU          Race = 1
	Race_QI          Race = 2
	Race_GONG        Race = 3
	Race_CHE         Race = 4
	Race_XIE         Race = 5
)

var Race_name = map[int32]string{
	0: "InvalidRace",
	1: "BU",
	2: "QI",
	3: "GONG",
	4: "CHE",
	5: "XIE",
}
var Race_value = map[string]int32{
	"InvalidRace": 0,
	"BU":          1,
	"QI":          2,
	"GONG":        3,
	"CHE":         4,
	"XIE":         5,
}

func (x Race) String() string {
	return proto.EnumName(Race_name, int32(x))
}
func (Race) EnumDescriptor() ([]byte, []int) { return fileDescriptorBase, []int{0} }

type RestraintRoundType int32

const (
	RestraintRoundType_InvalidType RestraintRoundType = 0
	RestraintRoundType_ODD         RestraintRoundType = 1
	RestraintRoundType_EVEN        RestraintRoundType = 2
)

var RestraintRoundType_name = map[int32]string{
	0: "InvalidType",
	1: "ODD",
	2: "EVEN",
}
var RestraintRoundType_value = map[string]int32{
	"InvalidType": 0,
	"ODD":         1,
	"EVEN":        2,
}

func (x RestraintRoundType) String() string {
	return proto.EnumName(RestraintRoundType_name, int32(x))
}
func (RestraintRoundType) EnumDescriptor() ([]byte, []int) { return fileDescriptorBase, []int{1} }

type PosDiraction int32

const (
	PosDiraction_InvalidPosDiraction PosDiraction = 0
	PosDiraction_EAST                PosDiraction = 1
	PosDiraction_SOUTH               PosDiraction = 2
	PosDiraction_WEST                PosDiraction = 3
	PosDiraction_NORTH               PosDiraction = 4
)

var PosDiraction_name = map[int32]string{
	0: "InvalidPosDiraction",
	1: "EAST",
	2: "SOUTH",
	3: "WEST",
	4: "NORTH",
}
var PosDiraction_value = map[string]int32{
	"InvalidPosDiraction": 0,
	"EAST":                1,
	"SOUTH":               2,
	"WEST":                3,
	"NORTH":               4,
}

func (x PosDiraction) String() string {
	return proto.EnumName(PosDiraction_name, int32(x))
}
func (PosDiraction) EnumDescriptor() ([]byte, []int) { return fileDescriptorBase, []int{2} }

type Quality int32

const (
	Quality_InvalidQuality Quality = 0
	Quality_WHITE          Quality = 1
	Quality_GREEN          Quality = 2
	Quality_BLUE           Quality = 3
	Quality_PURPLE         Quality = 4
	Quality_ORANGE         Quality = 5
	Quality_RED            Quality = 6
)

var Quality_name = map[int32]string{
	0: "InvalidQuality",
	1: "WHITE",
	2: "GREEN",
	3: "BLUE",
	4: "PURPLE",
	5: "ORANGE",
	6: "RED",
}
var Quality_value = map[string]int32{
	"InvalidQuality": 0,
	"WHITE":          1,
	"GREEN":          2,
	"BLUE":           3,
	"PURPLE":         4,
	"ORANGE":         5,
	"RED":            6,
}

func (x Quality) String() string {
	return proto.EnumName(Quality_name, int32(x))
}
func (Quality) EnumDescriptor() ([]byte, []int) { return fileDescriptorBase, []int{3} }

type ResType int32

const (
	ResType_InvalidResType ResType = 0
	ResType_GOLD           ResType = 1
	ResType_FOOD           ResType = 2
	ResType_WOOD           ResType = 3
	ResType_STONE          ResType = 4
)

var ResType_name = map[int32]string{
	0: "InvalidResType",
	1: "GOLD",
	2: "FOOD",
	3: "WOOD",
	4: "STONE",
}
var ResType_value = map[string]int32{
	"InvalidResType": 0,
	"GOLD":           1,
	"FOOD":           2,
	"WOOD":           3,
	"STONE":          4,
}

func (x ResType) String() string {
	return proto.EnumName(ResType_name, int32(x))
}
func (ResType) EnumDescriptor() ([]byte, []int) { return fileDescriptorBase, []int{4} }

type AmountType int32

const (
	AmountType_InvalidAmountType          AmountType = 0
	AmountType_PT_GOLD                    AmountType = 1
	AmountType_PT_FOOD                    AmountType = 2
	AmountType_PT_WOOD                    AmountType = 3
	AmountType_PT_STONE                   AmountType = 4
	AmountType_PT_GOODS                   AmountType = 5
	AmountType_PT_EQUIP                   AmountType = 6
	AmountType_PT_CAPTAIN                 AmountType = 7
	AmountType_PT_GEM                     AmountType = 8
	AmountType_PT_CAPTAIN_EXP             AmountType = 9
	AmountType_PT_HERO_EXP                AmountType = 10
	AmountType_PT_PROSPERITY              AmountType = 11
	AmountType_PT_YUANBAO                 AmountType = 12
	AmountType_PT_JADE                    AmountType = 13
	AmountType_PT_JADE_ORE                AmountType = 14
	AmountType_PT_DIANQUAN                AmountType = 15
	AmountType_PT_GUILD_CONTRIBUTION_COIN AmountType = 16
	AmountType_PT_BAOWU                   AmountType = 17
	AmountType_PT_YINLIANG                AmountType = 18
	AmountType_PT_HUFU                    AmountType = 19
	AmountType_PT_SP                      AmountType = 20
)

var AmountType_name = map[int32]string{
	0:  "InvalidAmountType",
	1:  "PT_GOLD",
	2:  "PT_FOOD",
	3:  "PT_WOOD",
	4:  "PT_STONE",
	5:  "PT_GOODS",
	6:  "PT_EQUIP",
	7:  "PT_CAPTAIN",
	8:  "PT_GEM",
	9:  "PT_CAPTAIN_EXP",
	10: "PT_HERO_EXP",
	11: "PT_PROSPERITY",
	12: "PT_YUANBAO",
	13: "PT_JADE",
	14: "PT_JADE_ORE",
	15: "PT_DIANQUAN",
	16: "PT_GUILD_CONTRIBUTION_COIN",
	17: "PT_BAOWU",
	18: "PT_YINLIANG",
	19: "PT_HUFU",
	20: "PT_SP",
}
var AmountType_value = map[string]int32{
	"InvalidAmountType":          0,
	"PT_GOLD":                    1,
	"PT_FOOD":                    2,
	"PT_WOOD":                    3,
	"PT_STONE":                   4,
	"PT_GOODS":                   5,
	"PT_EQUIP":                   6,
	"PT_CAPTAIN":                 7,
	"PT_GEM":                     8,
	"PT_CAPTAIN_EXP":             9,
	"PT_HERO_EXP":                10,
	"PT_PROSPERITY":              11,
	"PT_YUANBAO":                 12,
	"PT_JADE":                    13,
	"PT_JADE_ORE":                14,
	"PT_DIANQUAN":                15,
	"PT_GUILD_CONTRIBUTION_COIN": 16,
	"PT_BAOWU":                   17,
	"PT_YINLIANG":                18,
	"PT_HUFU":                    19,
	"PT_SP":                      20,
}

func (x AmountType) String() string {
	return proto.EnumName(AmountType_name, int32(x))
}
func (AmountType) EnumDescriptor() ([]byte, []int) { return fileDescriptorBase, []int{5} }

type StatType int32

const (
	StatType_InvalidStatType StatType = 0
	StatType_ATTACK          StatType = 1
	StatType_DEFENSE         StatType = 2
	StatType_STRENGTH        StatType = 3
	StatType_DEXTERITY       StatType = 4
)

var StatType_name = map[int32]string{
	0: "InvalidStatType",
	1: "ATTACK",
	2: "DEFENSE",
	3: "STRENGTH",
	4: "DEXTERITY",
}
var StatType_value = map[string]int32{
	"InvalidStatType": 0,
	"ATTACK":          1,
	"DEFENSE":         2,
	"STRENGTH":        3,
	"DEXTERITY":       4,
}

func (x StatType) String() string {
	return proto.EnumName(StatType_name, int32(x))
}
func (StatType) EnumDescriptor() ([]byte, []int) { return fileDescriptorBase, []int{6} }

// 英雄事件类型
type HeroEvent int32

const (
	HeroEvent_InvalidHeroEvent                           HeroEvent = 0
	HeroEvent_HERO_EVENT_RECHARGE                        HeroEvent = 1
	HeroEvent_HERO_EVENT_HERO_LEVEL                      HeroEvent = 2
	HeroEvent_HERO_EVENT_BASE_LEVEL                      HeroEvent = 3
	HeroEvent_HERO_EVENT_ACTIVITY                        HeroEvent = 4
	HeroEvent_HERO_EVENT_DUNGEON                         HeroEvent = 5
	HeroEvent_HERO_EVENT_TOWER                           HeroEvent = 6
	HeroEvent_HERO_EVENT_KILL_MONSTER                    HeroEvent = 7
	HeroEvent_HERO_EVENT_UNLOCK_FUNC                     HeroEvent = 8
	HeroEvent_HERO_EVENT_COLLECT_BAI_ZHAN_SALARY         HeroEvent = 9
	HeroEvent_HERO_EVENT_KILL_BAOZ                       HeroEvent = 10
	HeroEvent_HERO_EVENT_BUY_GUILD_EVENT_PRIZE_FROM_SHOP HeroEvent = 11
	HeroEvent_HERO_EVENT_ASSEMBLY_KILL_MONSTER           HeroEvent = 12
)

var HeroEvent_name = map[int32]string{
	0:  "InvalidHeroEvent",
	1:  "HERO_EVENT_RECHARGE",
	2:  "HERO_EVENT_HERO_LEVEL",
	3:  "HERO_EVENT_BASE_LEVEL",
	4:  "HERO_EVENT_ACTIVITY",
	5:  "HERO_EVENT_DUNGEON",
	6:  "HERO_EVENT_TOWER",
	7:  "HERO_EVENT_KILL_MONSTER",
	8:  "HERO_EVENT_UNLOCK_FUNC",
	9:  "HERO_EVENT_COLLECT_BAI_ZHAN_SALARY",
	10: "HERO_EVENT_KILL_BAOZ",
	11: "HERO_EVENT_BUY_GUILD_EVENT_PRIZE_FROM_SHOP",
	12: "HERO_EVENT_ASSEMBLY_KILL_MONSTER",
}
var HeroEvent_value = map[string]int32{
	"InvalidHeroEvent":                           0,
	"HERO_EVENT_RECHARGE":                        1,
	"HERO_EVENT_HERO_LEVEL":                      2,
	"HERO_EVENT_BASE_LEVEL":                      3,
	"HERO_EVENT_ACTIVITY":                        4,
	"HERO_EVENT_DUNGEON":                         5,
	"HERO_EVENT_TOWER":                           6,
	"HERO_EVENT_KILL_MONSTER":                    7,
	"HERO_EVENT_UNLOCK_FUNC":                     8,
	"HERO_EVENT_COLLECT_BAI_ZHAN_SALARY":         9,
	"HERO_EVENT_KILL_BAOZ":                       10,
	"HERO_EVENT_BUY_GUILD_EVENT_PRIZE_FROM_SHOP": 11,
	"HERO_EVENT_ASSEMBLY_KILL_MONSTER":           12,
}

func (x HeroEvent) String() string {
	return proto.EnumName(HeroEvent_name, int32(x))
}
func (HeroEvent) EnumDescriptor() ([]byte, []int) { return fileDescriptorBase, []int{7} }

type ExtraTimesType int32

const (
	ExtraTimesType_InvalidExtraTimesType ExtraTimesType = 0
	ExtraTimesType_Ett_Season            ExtraTimesType = 1
)

var ExtraTimesType_name = map[int32]string{
	0: "InvalidExtraTimesType",
	1: "Ett_Season",
}
var ExtraTimesType_value = map[string]int32{
	"InvalidExtraTimesType": 0,
	"Ett_Season":            1,
}

func (x ExtraTimesType) String() string {
	return proto.EnumName(ExtraTimesType_name, int32(x))
}
func (ExtraTimesType) EnumDescriptor() ([]byte, []int) { return fileDescriptorBase, []int{8} }

// 广播类型
type BCType int32

const (
	BCType_BC_INVALID_TYPE BCType = 0
	BCType_BC_GM           BCType = 1
	BCType_BC_TIMING_SYS   BCType = 2
	BCType_BC_SYS          BCType = 3
	BCType_BC_HERO         BCType = 4
)

var BCType_name = map[int32]string{
	0: "BC_INVALID_TYPE",
	1: "BC_GM",
	2: "BC_TIMING_SYS",
	3: "BC_SYS",
	4: "BC_HERO",
}
var BCType_value = map[string]int32{
	"BC_INVALID_TYPE": 0,
	"BC_GM":           1,
	"BC_TIMING_SYS":   2,
	"BC_SYS":          3,
	"BC_HERO":         4,
}

func (x BCType) String() string {
	return proto.EnumName(BCType_name, int32(x))
}
func (BCType) EnumDescriptor() ([]byte, []int) { return fileDescriptorBase, []int{9} }

// 国家官职
type CountryOfficialType int32

const (
	CountryOfficialType_COT_NO_OFFICIAL CountryOfficialType = 0
	CountryOfficialType_COT_KING        CountryOfficialType = 1
	CountryOfficialType_COT_QUEEN       CountryOfficialType = 2
	CountryOfficialType_COT_MINISTER    CountryOfficialType = 3
	CountryOfficialType_COT_GENERAL     CountryOfficialType = 4
	CountryOfficialType_COT_CENSOR      CountryOfficialType = 5
	CountryOfficialType_COT_SIMA        CountryOfficialType = 6
)

var CountryOfficialType_name = map[int32]string{
	0: "COT_NO_OFFICIAL",
	1: "COT_KING",
	2: "COT_QUEEN",
	3: "COT_MINISTER",
	4: "COT_GENERAL",
	5: "COT_CENSOR",
	6: "COT_SIMA",
}
var CountryOfficialType_value = map[string]int32{
	"COT_NO_OFFICIAL": 0,
	"COT_KING":        1,
	"COT_QUEEN":       2,
	"COT_MINISTER":    3,
	"COT_GENERAL":     4,
	"COT_CENSOR":      5,
	"COT_SIMA":        6,
}

func (x CountryOfficialType) String() string {
	return proto.EnumName(CountryOfficialType_name, int32(x))
}
func (CountryOfficialType) EnumDescriptor() ([]byte, []int) { return fileDescriptorBase, []int{10} }

type RaceDataProto struct {
	Id                int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Race              Race  `protobuf:"varint,2,opt,name=race,proto3,enum=proto.Race" json:"race,omitempty"`
	AttackRange       int32 `protobuf:"varint,3,opt,name=attack_range,json=attackRange,proto3" json:"attack_range,omitempty"`
	MoveTimesPerRound int32 `protobuf:"varint,4,opt,name=move_times_per_round,json=moveTimesPerRound,proto3" json:"move_times_per_round,omitempty"`
	MoveSpeed         int32 `protobuf:"varint,5,opt,name=move_speed,json=moveSpeed,proto3" json:"move_speed,omitempty"`
	ViewRange         int32 `protobuf:"varint,19,opt,name=view_range,json=viewRange,proto3" json:"view_range,omitempty"`
	IsFar             bool  `protobuf:"varint,6,opt,name=is_far,json=isFar,proto3" json:"is_far,omitempty"`
	// 高优先级在前面
	Priority []Race `protobuf:"varint,11,rep,name=priority,enum=proto.Race" json:"priority,omitempty"`
	// 兵种克制系数
	RaceCoef []int32 `protobuf:"varint,12,rep,name=race_coef,json=raceCoef" json:"race_coef,omitempty"`
	// 对城墙的克制系数
	WallCoef int32 `protobuf:"varint,18,opt,name=wall_coef,json=wallCoef,proto3" json:"wall_coef,omitempty"`
	// 四维属性比例，分母1000
	AbilityRate []int32 `protobuf:"varint,22,rep,name=ability_rate,json=abilityRate" json:"ability_rate,omitempty"`
	// 克制职业
	RestraintRace []Race `protobuf:"varint,13,rep,name=restraint_race,json=restraintRace,enum=proto.Race" json:"restraint_race,omitempty"`
	// 克制轮次类型
	RestraintRoundType RestraintRoundType `protobuf:"varint,14,opt,name=restraint_round_type,json=restraintRoundType,proto3,enum=proto.RestraintRoundType" json:"restraint_round_type,omitempty"`
	// 克制技，获取通过Config.spell_config.Get(id)
	RestraintSpellId int32 `protobuf:"varint,15,opt,name=restraint_spell_id,json=restraintSpellId,proto3" json:"restraint_spell_id,omitempty"`
	// 解锁克制技需要的成长值
	UnlockRestraintSpellNeedAbility int32 `protobuf:"varint,16,opt,name=unlock_restraint_spell_need_ability,json=unlockRestraintSpellNeedAbility,proto3" json:"unlock_restraint_spell_need_ability,omitempty"`
	// 普通技，获取通过Config.spell_config.Get(id)
	NormalSpellId int32 `protobuf:"varint,17,opt,name=normal_spell_id,json=normalSpellId,proto3" json:"normal_spell_id,omitempty"`
	// 宝石镶嵌的槽位类型列表
	GemTypes []int32 `protobuf:"varint,20,rep,name=gem_types,json=gemTypes" json:"gem_types,omitempty"`
	// 兵种技能
	SoldierSpell []int32 `protobuf:"varint,21,rep,name=soldier_spell,json=soldierSpell" json:"soldier_spell,omitempty"`
	// 兵种攻速
	SoldierAttackSpeed int32 `protobuf:"varint,23,opt,name=soldier_attack_speed,json=soldierAttackSpeed,proto3" json:"soldier_attack_speed,omitempty"`
	// 兵种攻击距离
	SoldierAttackRange int32 `protobuf:"varint,24,opt,name=soldier_attack_range,json=soldierAttackRange,proto3" json:"soldier_attack_range,omitempty"`
}

func (m *RaceDataProto) Reset()                    { *m = RaceDataProto{} }
func (m *RaceDataProto) String() string            { return proto.CompactTextString(m) }
func (*RaceDataProto) ProtoMessage()               {}
func (*RaceDataProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{0} }

func (m *RaceDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RaceDataProto) GetRace() Race {
	if m != nil {
		return m.Race
	}
	return Race_InvalidRace
}

func (m *RaceDataProto) GetAttackRange() int32 {
	if m != nil {
		return m.AttackRange
	}
	return 0
}

func (m *RaceDataProto) GetMoveTimesPerRound() int32 {
	if m != nil {
		return m.MoveTimesPerRound
	}
	return 0
}

func (m *RaceDataProto) GetMoveSpeed() int32 {
	if m != nil {
		return m.MoveSpeed
	}
	return 0
}

func (m *RaceDataProto) GetViewRange() int32 {
	if m != nil {
		return m.ViewRange
	}
	return 0
}

func (m *RaceDataProto) GetIsFar() bool {
	if m != nil {
		return m.IsFar
	}
	return false
}

func (m *RaceDataProto) GetPriority() []Race {
	if m != nil {
		return m.Priority
	}
	return nil
}

func (m *RaceDataProto) GetRaceCoef() []int32 {
	if m != nil {
		return m.RaceCoef
	}
	return nil
}

func (m *RaceDataProto) GetWallCoef() int32 {
	if m != nil {
		return m.WallCoef
	}
	return 0
}

func (m *RaceDataProto) GetAbilityRate() []int32 {
	if m != nil {
		return m.AbilityRate
	}
	return nil
}

func (m *RaceDataProto) GetRestraintRace() []Race {
	if m != nil {
		return m.RestraintRace
	}
	return nil
}

func (m *RaceDataProto) GetRestraintRoundType() RestraintRoundType {
	if m != nil {
		return m.RestraintRoundType
	}
	return RestraintRoundType_InvalidType
}

func (m *RaceDataProto) GetRestraintSpellId() int32 {
	if m != nil {
		return m.RestraintSpellId
	}
	return 0
}

func (m *RaceDataProto) GetUnlockRestraintSpellNeedAbility() int32 {
	if m != nil {
		return m.UnlockRestraintSpellNeedAbility
	}
	return 0
}

func (m *RaceDataProto) GetNormalSpellId() int32 {
	if m != nil {
		return m.NormalSpellId
	}
	return 0
}

func (m *RaceDataProto) GetGemTypes() []int32 {
	if m != nil {
		return m.GemTypes
	}
	return nil
}

func (m *RaceDataProto) GetSoldierSpell() []int32 {
	if m != nil {
		return m.SoldierSpell
	}
	return nil
}

func (m *RaceDataProto) GetSoldierAttackSpeed() int32 {
	if m != nil {
		return m.SoldierAttackSpeed
	}
	return 0
}

func (m *RaceDataProto) GetSoldierAttackRange() int32 {
	if m != nil {
		return m.SoldierAttackRange
	}
	return 0
}

type ResProto struct {
	Type    ResType `protobuf:"varint,1,opt,name=type,proto3,enum=proto.ResType" json:"type,omitempty"`
	Amount  int32   `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
	Percent int32   `protobuf:"varint,3,opt,name=percent,proto3" json:"percent,omitempty"`
}

func (m *ResProto) Reset()                    { *m = ResProto{} }
func (m *ResProto) String() string            { return proto.CompactTextString(m) }
func (*ResProto) ProtoMessage()               {}
func (*ResProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{1} }

func (m *ResProto) GetType() ResType {
	if m != nil {
		return m.Type
	}
	return ResType_InvalidResType
}

func (m *ResProto) GetAmount() int32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *ResProto) GetPercent() int32 {
	if m != nil {
		return m.Percent
	}
	return 0
}

type AmountProto struct {
	Amount  int32 `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
	Percent int32 `protobuf:"varint,3,opt,name=percent,proto3" json:"percent,omitempty"`
}

func (m *AmountProto) Reset()                    { *m = AmountProto{} }
func (m *AmountProto) String() string            { return proto.CompactTextString(m) }
func (*AmountProto) ProtoMessage()               {}
func (*AmountProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{2} }

func (m *AmountProto) GetAmount() int32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *AmountProto) GetPercent() int32 {
	if m != nil {
		return m.Percent
	}
	return 0
}

type CombineCostProto struct {
	Cost               *CostProto `protobuf:"bytes,1,opt,name=cost" json:"cost,omitempty"`
	BuildingWorkerTime int32      `protobuf:"varint,2,opt,name=building_worker_time,json=buildingWorkerTime,proto3" json:"building_worker_time,omitempty"`
	TechWorkerTime     int32      `protobuf:"varint,3,opt,name=tech_worker_time,json=techWorkerTime,proto3" json:"tech_worker_time,omitempty"`
	Soldier            int32      `protobuf:"varint,4,opt,name=soldier,proto3" json:"soldier,omitempty"`
	InvadeTimes        int32      `protobuf:"varint,5,opt,name=invade_times,json=invadeTimes,proto3" json:"invade_times,omitempty"`
}

func (m *CombineCostProto) Reset()                    { *m = CombineCostProto{} }
func (m *CombineCostProto) String() string            { return proto.CompactTextString(m) }
func (*CombineCostProto) ProtoMessage()               {}
func (*CombineCostProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{3} }

func (m *CombineCostProto) GetCost() *CostProto {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *CombineCostProto) GetBuildingWorkerTime() int32 {
	if m != nil {
		return m.BuildingWorkerTime
	}
	return 0
}

func (m *CombineCostProto) GetTechWorkerTime() int32 {
	if m != nil {
		return m.TechWorkerTime
	}
	return 0
}

func (m *CombineCostProto) GetSoldier() int32 {
	if m != nil {
		return m.Soldier
	}
	return 0
}

func (m *CombineCostProto) GetInvadeTimes() int32 {
	if m != nil {
		return m.InvadeTimes
	}
	return 0
}

type CostProto struct {
	Gold                  int32   `protobuf:"varint,1,opt,name=gold,proto3" json:"gold,omitempty"`
	Food                  int32   `protobuf:"varint,2,opt,name=food,proto3" json:"food,omitempty"`
	Wood                  int32   `protobuf:"varint,3,opt,name=wood,proto3" json:"wood,omitempty"`
	Stone                 int32   `protobuf:"varint,4,opt,name=stone,proto3" json:"stone,omitempty"`
	Yuanbao               int32   `protobuf:"varint,7,opt,name=yuanbao,proto3" json:"yuanbao,omitempty"`
	Dianquan              int32   `protobuf:"varint,14,opt,name=dianquan,proto3" json:"dianquan,omitempty"`
	Yinliang              int32   `protobuf:"varint,15,opt,name=yinliang,proto3" json:"yinliang,omitempty"`
	GuildContributionCoin int32   `protobuf:"varint,8,opt,name=guild_contribution_coin,json=guildContributionCoin,proto3" json:"guild_contribution_coin,omitempty"`
	Jade                  int32   `protobuf:"varint,9,opt,name=jade,proto3" json:"jade,omitempty"`
	JadeOre               int32   `protobuf:"varint,12,opt,name=jade_ore,json=jadeOre,proto3" json:"jade_ore,omitempty"`
	GoodsId               []int32 `protobuf:"varint,5,rep,name=goods_id,json=goodsId" json:"goods_id,omitempty"`
	GoodsCount            []int32 `protobuf:"varint,6,rep,name=goods_count,json=goodsCount" json:"goods_count,omitempty"`
	GemId                 []int32 `protobuf:"varint,10,rep,name=gem_id,json=gemId" json:"gem_id,omitempty"`
	GemCount              []int32 `protobuf:"varint,11,rep,name=gem_count,json=gemCount" json:"gem_count,omitempty"`
	IsNotEmpty            bool    `protobuf:"varint,127,opt,name=is_not_empty,json=isNotEmpty,proto3" json:"is_not_empty,omitempty"`
}

func (m *CostProto) Reset()                    { *m = CostProto{} }
func (m *CostProto) String() string            { return proto.CompactTextString(m) }
func (*CostProto) ProtoMessage()               {}
func (*CostProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{4} }

func (m *CostProto) GetGold() int32 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *CostProto) GetFood() int32 {
	if m != nil {
		return m.Food
	}
	return 0
}

func (m *CostProto) GetWood() int32 {
	if m != nil {
		return m.Wood
	}
	return 0
}

func (m *CostProto) GetStone() int32 {
	if m != nil {
		return m.Stone
	}
	return 0
}

func (m *CostProto) GetYuanbao() int32 {
	if m != nil {
		return m.Yuanbao
	}
	return 0
}

func (m *CostProto) GetDianquan() int32 {
	if m != nil {
		return m.Dianquan
	}
	return 0
}

func (m *CostProto) GetYinliang() int32 {
	if m != nil {
		return m.Yinliang
	}
	return 0
}

func (m *CostProto) GetGuildContributionCoin() int32 {
	if m != nil {
		return m.GuildContributionCoin
	}
	return 0
}

func (m *CostProto) GetJade() int32 {
	if m != nil {
		return m.Jade
	}
	return 0
}

func (m *CostProto) GetJadeOre() int32 {
	if m != nil {
		return m.JadeOre
	}
	return 0
}

func (m *CostProto) GetGoodsId() []int32 {
	if m != nil {
		return m.GoodsId
	}
	return nil
}

func (m *CostProto) GetGoodsCount() []int32 {
	if m != nil {
		return m.GoodsCount
	}
	return nil
}

func (m *CostProto) GetGemId() []int32 {
	if m != nil {
		return m.GemId
	}
	return nil
}

func (m *CostProto) GetGemCount() []int32 {
	if m != nil {
		return m.GemCount
	}
	return nil
}

func (m *CostProto) GetIsNotEmpty() bool {
	if m != nil {
		return m.IsNotEmpty
	}
	return false
}

type PrizeProto struct {
	Gold  int32 `protobuf:"varint,1,opt,name=gold,proto3" json:"gold,omitempty"`
	Food  int32 `protobuf:"varint,2,opt,name=food,proto3" json:"food,omitempty"`
	Wood  int32 `protobuf:"varint,3,opt,name=wood,proto3" json:"wood,omitempty"`
	Stone int32 `protobuf:"varint,4,opt,name=stone,proto3" json:"stone,omitempty"`
	// 安全资源
	SafeGold              int32   `protobuf:"varint,21,opt,name=safe_gold,json=safeGold,proto3" json:"safe_gold,omitempty"`
	SafeFood              int32   `protobuf:"varint,22,opt,name=safe_food,json=safeFood,proto3" json:"safe_food,omitempty"`
	SafeWood              int32   `protobuf:"varint,23,opt,name=safe_wood,json=safeWood,proto3" json:"safe_wood,omitempty"`
	SafeStone             int32   `protobuf:"varint,24,opt,name=safe_stone,json=safeStone,proto3" json:"safe_stone,omitempty"`
	GoodsId               []int32 `protobuf:"varint,5,rep,name=goods_id,json=goodsId" json:"goods_id,omitempty"`
	GoodsCount            []int32 `protobuf:"varint,6,rep,name=goods_count,json=goodsCount" json:"goods_count,omitempty"`
	EquipmentId           []int32 `protobuf:"varint,7,rep,name=equipment_id,json=equipmentId" json:"equipment_id,omitempty"`
	EquipmentCount        []int32 `protobuf:"varint,8,rep,name=equipment_count,json=equipmentCount" json:"equipment_count,omitempty"`
	GemId                 []int32 `protobuf:"varint,11,rep,name=gem_id,json=gemId" json:"gem_id,omitempty"`
	GemCount              []int32 `protobuf:"varint,12,rep,name=gem_count,json=gemCount" json:"gem_count,omitempty"`
	BaowuId               []int32 `protobuf:"varint,13,rep,name=baowu_id,json=baowuId" json:"baowu_id,omitempty"`
	BaowuCount            []int32 `protobuf:"varint,14,rep,name=baowu_count,json=baowuCount" json:"baowu_count,omitempty"`
	CaptainId             []int32 `protobuf:"varint,15,rep,name=captain_id,json=captainId" json:"captain_id,omitempty"`
	CaptainCount          []int32 `protobuf:"varint,16,rep,name=captain_count,json=captainCount" json:"captain_count,omitempty"`
	CaptainExp            int32   `protobuf:"varint,31,opt,name=captain_exp,json=captainExp,proto3" json:"captain_exp,omitempty"`
	HeroExp               int32   `protobuf:"varint,32,opt,name=hero_exp,json=heroExp,proto3" json:"hero_exp,omitempty"`
	Prosperity            int32   `protobuf:"varint,35,opt,name=prosperity,proto3" json:"prosperity,omitempty"`
	Yuanbao               int32   `protobuf:"varint,40,opt,name=yuanbao,proto3" json:"yuanbao,omitempty"`
	Dianquan              int32   `protobuf:"varint,41,opt,name=dianquan,proto3" json:"dianquan,omitempty"`
	Yinliang              int32   `protobuf:"varint,42,opt,name=yinliang,proto3" json:"yinliang,omitempty"`
	Jade                  int32   `protobuf:"varint,46,opt,name=jade,proto3" json:"jade,omitempty"`
	JadeOre               int32   `protobuf:"varint,47,opt,name=jade_ore,json=jadeOre,proto3" json:"jade_ore,omitempty"`
	VipExp                int32   `protobuf:"varint,49,opt,name=vip_exp,json=vipExp,proto3" json:"vip_exp,omitempty"`
	Sp                    int32   `protobuf:"varint,50,opt,name=sp,proto3" json:"sp,omitempty"`
	GuildContributionCoin int32   `protobuf:"varint,48,opt,name=guild_contribution_coin,json=guildContributionCoin,proto3" json:"guild_contribution_coin,omitempty"`
	AmountShowSortId      int32   `protobuf:"varint,100,opt,name=amount_show_sort_id,json=amountShowSortId,proto3" json:"amount_show_sort_id,omitempty"`
	IsNotEmpty            bool    `protobuf:"varint,127,opt,name=is_not_empty,json=isNotEmpty,proto3" json:"is_not_empty,omitempty"`
}

func (m *PrizeProto) Reset()                    { *m = PrizeProto{} }
func (m *PrizeProto) String() string            { return proto.CompactTextString(m) }
func (*PrizeProto) ProtoMessage()               {}
func (*PrizeProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{5} }

func (m *PrizeProto) GetGold() int32 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *PrizeProto) GetFood() int32 {
	if m != nil {
		return m.Food
	}
	return 0
}

func (m *PrizeProto) GetWood() int32 {
	if m != nil {
		return m.Wood
	}
	return 0
}

func (m *PrizeProto) GetStone() int32 {
	if m != nil {
		return m.Stone
	}
	return 0
}

func (m *PrizeProto) GetSafeGold() int32 {
	if m != nil {
		return m.SafeGold
	}
	return 0
}

func (m *PrizeProto) GetSafeFood() int32 {
	if m != nil {
		return m.SafeFood
	}
	return 0
}

func (m *PrizeProto) GetSafeWood() int32 {
	if m != nil {
		return m.SafeWood
	}
	return 0
}

func (m *PrizeProto) GetSafeStone() int32 {
	if m != nil {
		return m.SafeStone
	}
	return 0
}

func (m *PrizeProto) GetGoodsId() []int32 {
	if m != nil {
		return m.GoodsId
	}
	return nil
}

func (m *PrizeProto) GetGoodsCount() []int32 {
	if m != nil {
		return m.GoodsCount
	}
	return nil
}

func (m *PrizeProto) GetEquipmentId() []int32 {
	if m != nil {
		return m.EquipmentId
	}
	return nil
}

func (m *PrizeProto) GetEquipmentCount() []int32 {
	if m != nil {
		return m.EquipmentCount
	}
	return nil
}

func (m *PrizeProto) GetGemId() []int32 {
	if m != nil {
		return m.GemId
	}
	return nil
}

func (m *PrizeProto) GetGemCount() []int32 {
	if m != nil {
		return m.GemCount
	}
	return nil
}

func (m *PrizeProto) GetBaowuId() []int32 {
	if m != nil {
		return m.BaowuId
	}
	return nil
}

func (m *PrizeProto) GetBaowuCount() []int32 {
	if m != nil {
		return m.BaowuCount
	}
	return nil
}

func (m *PrizeProto) GetCaptainId() []int32 {
	if m != nil {
		return m.CaptainId
	}
	return nil
}

func (m *PrizeProto) GetCaptainCount() []int32 {
	if m != nil {
		return m.CaptainCount
	}
	return nil
}

func (m *PrizeProto) GetCaptainExp() int32 {
	if m != nil {
		return m.CaptainExp
	}
	return 0
}

func (m *PrizeProto) GetHeroExp() int32 {
	if m != nil {
		return m.HeroExp
	}
	return 0
}

func (m *PrizeProto) GetProsperity() int32 {
	if m != nil {
		return m.Prosperity
	}
	return 0
}

func (m *PrizeProto) GetYuanbao() int32 {
	if m != nil {
		return m.Yuanbao
	}
	return 0
}

func (m *PrizeProto) GetDianquan() int32 {
	if m != nil {
		return m.Dianquan
	}
	return 0
}

func (m *PrizeProto) GetYinliang() int32 {
	if m != nil {
		return m.Yinliang
	}
	return 0
}

func (m *PrizeProto) GetJade() int32 {
	if m != nil {
		return m.Jade
	}
	return 0
}

func (m *PrizeProto) GetJadeOre() int32 {
	if m != nil {
		return m.JadeOre
	}
	return 0
}

func (m *PrizeProto) GetVipExp() int32 {
	if m != nil {
		return m.VipExp
	}
	return 0
}

func (m *PrizeProto) GetSp() int32 {
	if m != nil {
		return m.Sp
	}
	return 0
}

func (m *PrizeProto) GetGuildContributionCoin() int32 {
	if m != nil {
		return m.GuildContributionCoin
	}
	return 0
}

func (m *PrizeProto) GetAmountShowSortId() int32 {
	if m != nil {
		return m.AmountShowSortId
	}
	return 0
}

func (m *PrizeProto) GetIsNotEmpty() bool {
	if m != nil {
		return m.IsNotEmpty
	}
	return false
}

// 联盟条件奖励
type GuildLevelPrizeProto struct {
	Id         int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	GroupId    int32       `protobuf:"varint,2,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	GuildLevel int32       `protobuf:"varint,3,opt,name=guild_level,json=guildLevel,proto3" json:"guild_level,omitempty"`
	Prize      *PrizeProto `protobuf:"bytes,4,opt,name=prize" json:"prize,omitempty"`
}

func (m *GuildLevelPrizeProto) Reset()                    { *m = GuildLevelPrizeProto{} }
func (m *GuildLevelPrizeProto) String() string            { return proto.CompactTextString(m) }
func (*GuildLevelPrizeProto) ProtoMessage()               {}
func (*GuildLevelPrizeProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{6} }

func (m *GuildLevelPrizeProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GuildLevelPrizeProto) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *GuildLevelPrizeProto) GetGuildLevel() int32 {
	if m != nil {
		return m.GuildLevel
	}
	return 0
}

func (m *GuildLevelPrizeProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

type AmountShowSortProto struct {
	Id       int32        `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	TypeList []AmountType `protobuf:"varint,2,rep,name=type_list,json=typeList,enum=proto.AmountType" json:"type_list,omitempty"`
}

func (m *AmountShowSortProto) Reset()                    { *m = AmountShowSortProto{} }
func (m *AmountShowSortProto) String() string            { return proto.CompactTextString(m) }
func (*AmountShowSortProto) ProtoMessage()               {}
func (*AmountShowSortProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{7} }

func (m *AmountShowSortProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AmountShowSortProto) GetTypeList() []AmountType {
	if m != nil {
		return m.TypeList
	}
	return nil
}

type ExchangeDataProto struct {
	Id    int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Cost  *CostProto  `protobuf:"bytes,2,opt,name=cost" json:"cost,omitempty"`
	Prize *PrizeProto `protobuf:"bytes,3,opt,name=prize" json:"prize,omitempty"`
}

func (m *ExchangeDataProto) Reset()                    { *m = ExchangeDataProto{} }
func (m *ExchangeDataProto) String() string            { return proto.CompactTextString(m) }
func (*ExchangeDataProto) ProtoMessage()               {}
func (*ExchangeDataProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{8} }

func (m *ExchangeDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ExchangeDataProto) GetCost() *CostProto {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *ExchangeDataProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

type UnlockConditionProto struct {
	RequiredHeroLevel  int32 `protobuf:"varint,1,opt,name=required_hero_level,json=requiredHeroLevel,proto3" json:"required_hero_level,omitempty"`
	RequiredBaseLevel  int32 `protobuf:"varint,2,opt,name=required_base_level,json=requiredBaseLevel,proto3" json:"required_base_level,omitempty"`
	RequiredGuildLevel int32 `protobuf:"varint,3,opt,name=required_guild_level,json=requiredGuildLevel,proto3" json:"required_guild_level,omitempty"`
	RequiredVipLevel   int32 `protobuf:"varint,4,opt,name=required_vip_level,json=requiredVipLevel,proto3" json:"required_vip_level,omitempty"`
}

func (m *UnlockConditionProto) Reset()                    { *m = UnlockConditionProto{} }
func (m *UnlockConditionProto) String() string            { return proto.CompactTextString(m) }
func (*UnlockConditionProto) ProtoMessage()               {}
func (*UnlockConditionProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{9} }

func (m *UnlockConditionProto) GetRequiredHeroLevel() int32 {
	if m != nil {
		return m.RequiredHeroLevel
	}
	return 0
}

func (m *UnlockConditionProto) GetRequiredBaseLevel() int32 {
	if m != nil {
		return m.RequiredBaseLevel
	}
	return 0
}

func (m *UnlockConditionProto) GetRequiredGuildLevel() int32 {
	if m != nil {
		return m.RequiredGuildLevel
	}
	return 0
}

func (m *UnlockConditionProto) GetRequiredVipLevel() int32 {
	if m != nil {
		return m.RequiredVipLevel
	}
	return 0
}

type Int32Pair struct {
	Key   int32 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Value int32 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Int32Pair) Reset()                    { *m = Int32Pair{} }
func (m *Int32Pair) String() string            { return proto.CompactTextString(m) }
func (*Int32Pair) ProtoMessage()               {}
func (*Int32Pair) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{10} }

func (m *Int32Pair) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *Int32Pair) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type StringPair struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *StringPair) Reset()                    { *m = StringPair{} }
func (m *StringPair) String() string            { return proto.CompactTextString(m) }
func (*StringPair) ProtoMessage()               {}
func (*StringPair) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{11} }

func (m *StringPair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *StringPair) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type StringInt32Pair struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value int32  `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *StringInt32Pair) Reset()                    { *m = StringInt32Pair{} }
func (m *StringInt32Pair) String() string            { return proto.CompactTextString(m) }
func (*StringInt32Pair) ProtoMessage()               {}
func (*StringInt32Pair) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{12} }

func (m *StringInt32Pair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *StringInt32Pair) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type BytesInt32Pair struct {
	Key   []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value int32  `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *BytesInt32Pair) Reset()                    { *m = BytesInt32Pair{} }
func (m *BytesInt32Pair) String() string            { return proto.CompactTextString(m) }
func (*BytesInt32Pair) ProtoMessage()               {}
func (*BytesInt32Pair) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{13} }

func (m *BytesInt32Pair) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *BytesInt32Pair) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type Int32ArrayProto struct {
	V []int32 `protobuf:"varint,1,rep,name=v" json:"v,omitempty"`
}

func (m *Int32ArrayProto) Reset()                    { *m = Int32ArrayProto{} }
func (m *Int32ArrayProto) String() string            { return proto.CompactTextString(m) }
func (*Int32ArrayProto) ProtoMessage()               {}
func (*Int32ArrayProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{14} }

func (m *Int32ArrayProto) GetV() []int32 {
	if m != nil {
		return m.V
	}
	return nil
}

type StringArrayProto struct {
	V []string `protobuf:"bytes,1,rep,name=v" json:"v,omitempty"`
}

func (m *StringArrayProto) Reset()                    { *m = StringArrayProto{} }
func (m *StringArrayProto) String() string            { return proto.CompactTextString(m) }
func (*StringArrayProto) ProtoMessage()               {}
func (*StringArrayProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{15} }

func (m *StringArrayProto) GetV() []string {
	if m != nil {
		return m.V
	}
	return nil
}

type BytesArrayProto struct {
	V [][]byte `protobuf:"bytes,1,rep,name=v" json:"v,omitempty"`
}

func (m *BytesArrayProto) Reset()                    { *m = BytesArrayProto{} }
func (m *BytesArrayProto) String() string            { return proto.CompactTextString(m) }
func (*BytesArrayProto) ProtoMessage()               {}
func (*BytesArrayProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{16} }

func (m *BytesArrayProto) GetV() [][]byte {
	if m != nil {
		return m.V
	}
	return nil
}

type Int32PairInt32ArrayProto struct {
	K int32   `protobuf:"varint,1,opt,name=k,proto3" json:"k,omitempty"`
	V []int32 `protobuf:"varint,2,rep,name=v" json:"v,omitempty"`
}

func (m *Int32PairInt32ArrayProto) Reset()                    { *m = Int32PairInt32ArrayProto{} }
func (m *Int32PairInt32ArrayProto) String() string            { return proto.CompactTextString(m) }
func (*Int32PairInt32ArrayProto) ProtoMessage()               {}
func (*Int32PairInt32ArrayProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{17} }

func (m *Int32PairInt32ArrayProto) GetK() int32 {
	if m != nil {
		return m.K
	}
	return 0
}

func (m *Int32PairInt32ArrayProto) GetV() []int32 {
	if m != nil {
		return m.V
	}
	return nil
}

type SpriteStatProto struct {
	Attack           int32 `protobuf:"varint,1,opt,name=attack,proto3" json:"attack,omitempty"`
	Defense          int32 `protobuf:"varint,2,opt,name=defense,proto3" json:"defense,omitempty"`
	Strength         int32 `protobuf:"varint,3,opt,name=strength,proto3" json:"strength,omitempty"`
	Dexterity        int32 `protobuf:"varint,4,opt,name=dexterity,proto3" json:"dexterity,omitempty"`
	SoldierCapcity   int32 `protobuf:"varint,5,opt,name=soldier_capcity,json=soldierCapcity,proto3" json:"soldier_capcity,omitempty"`
	DamageIncrePer   int32 `protobuf:"varint,6,opt,name=damage_incre_per,json=damageIncrePer,proto3" json:"damage_incre_per,omitempty"`
	DamageDecrePer   int32 `protobuf:"varint,7,opt,name=damage_decre_per,json=damageDecrePer,proto3" json:"damage_decre_per,omitempty"`
	BeenHurtIncrePer int32 `protobuf:"varint,8,opt,name=been_hurt_incre_per,json=beenHurtIncrePer,proto3" json:"been_hurt_incre_per,omitempty"`
	BeenHurtDecrePer int32 `protobuf:"varint,9,opt,name=been_hurt_decre_per,json=beenHurtDecrePer,proto3" json:"been_hurt_decre_per,omitempty"`
}

func (m *SpriteStatProto) Reset()                    { *m = SpriteStatProto{} }
func (m *SpriteStatProto) String() string            { return proto.CompactTextString(m) }
func (*SpriteStatProto) ProtoMessage()               {}
func (*SpriteStatProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{18} }

func (m *SpriteStatProto) GetAttack() int32 {
	if m != nil {
		return m.Attack
	}
	return 0
}

func (m *SpriteStatProto) GetDefense() int32 {
	if m != nil {
		return m.Defense
	}
	return 0
}

func (m *SpriteStatProto) GetStrength() int32 {
	if m != nil {
		return m.Strength
	}
	return 0
}

func (m *SpriteStatProto) GetDexterity() int32 {
	if m != nil {
		return m.Dexterity
	}
	return 0
}

func (m *SpriteStatProto) GetSoldierCapcity() int32 {
	if m != nil {
		return m.SoldierCapcity
	}
	return 0
}

func (m *SpriteStatProto) GetDamageIncrePer() int32 {
	if m != nil {
		return m.DamageIncrePer
	}
	return 0
}

func (m *SpriteStatProto) GetDamageDecrePer() int32 {
	if m != nil {
		return m.DamageDecrePer
	}
	return 0
}

func (m *SpriteStatProto) GetBeenHurtIncrePer() int32 {
	if m != nil {
		return m.BeenHurtIncrePer
	}
	return 0
}

func (m *SpriteStatProto) GetBeenHurtDecrePer() int32 {
	if m != nil {
		return m.BeenHurtDecrePer
	}
	return 0
}

type SpriteStatArrayProto struct {
	SpriteStat []*SpriteStatProto `protobuf:"bytes,1,rep,name=sprite_stat,json=spriteStat" json:"sprite_stat,omitempty"`
}

func (m *SpriteStatArrayProto) Reset()                    { *m = SpriteStatArrayProto{} }
func (m *SpriteStatArrayProto) String() string            { return proto.CompactTextString(m) }
func (*SpriteStatArrayProto) ProtoMessage()               {}
func (*SpriteStatArrayProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{19} }

func (m *SpriteStatArrayProto) GetSpriteStat() []*SpriteStatProto {
	if m != nil {
		return m.SpriteStat
	}
	return nil
}

// 图像
type IconProto struct {
	Id           string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Icon         string `protobuf:"bytes,2,opt,name=icon,proto3" json:"icon,omitempty"`
	MiddleIcon   string `protobuf:"bytes,3,opt,name=middle_icon,json=middleIcon,proto3" json:"middle_icon,omitempty"`
	BigIcon      string `protobuf:"bytes,4,opt,name=big_icon,json=bigIcon,proto3" json:"big_icon,omitempty"`
	HeadIcon     string `protobuf:"bytes,8,opt,name=head_icon,json=headIcon,proto3" json:"head_icon,omitempty"`
	TailIcon     string `protobuf:"bytes,9,opt,name=tail_icon,json=tailIcon,proto3" json:"tail_icon,omitempty"`
	SuperBigIcon string `protobuf:"bytes,5,opt,name=super_big_icon,json=superBigIcon,proto3" json:"super_big_icon,omitempty"`
	Tab          int32  `protobuf:"varint,6,opt,name=tab,proto3" json:"tab,omitempty"`
	Text         string `protobuf:"bytes,7,opt,name=text,proto3" json:"text,omitempty"`
}

func (m *IconProto) Reset()                    { *m = IconProto{} }
func (m *IconProto) String() string            { return proto.CompactTextString(m) }
func (*IconProto) ProtoMessage()               {}
func (*IconProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{20} }

func (m *IconProto) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *IconProto) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *IconProto) GetMiddleIcon() string {
	if m != nil {
		return m.MiddleIcon
	}
	return ""
}

func (m *IconProto) GetBigIcon() string {
	if m != nil {
		return m.BigIcon
	}
	return ""
}

func (m *IconProto) GetHeadIcon() string {
	if m != nil {
		return m.HeadIcon
	}
	return ""
}

func (m *IconProto) GetTailIcon() string {
	if m != nil {
		return m.TailIcon
	}
	return ""
}

func (m *IconProto) GetSuperBigIcon() string {
	if m != nil {
		return m.SuperBigIcon
	}
	return ""
}

func (m *IconProto) GetTab() int32 {
	if m != nil {
		return m.Tab
	}
	return 0
}

func (m *IconProto) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type ExtraTimesListProto struct {
	TypeList []*ExtraTimesProto `protobuf:"bytes,1,rep,name=type_list,json=typeList" json:"type_list,omitempty"`
}

func (m *ExtraTimesListProto) Reset()                    { *m = ExtraTimesListProto{} }
func (m *ExtraTimesListProto) String() string            { return proto.CompactTextString(m) }
func (*ExtraTimesListProto) ProtoMessage()               {}
func (*ExtraTimesListProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{21} }

func (m *ExtraTimesListProto) GetTypeList() []*ExtraTimesProto {
	if m != nil {
		return m.TypeList
	}
	return nil
}

type ExtraTimesProto struct {
	Type      ExtraTimesType `protobuf:"varint,1,opt,name=type,proto3,enum=proto.ExtraTimesType" json:"type,omitempty"`
	UsedTimes int32          `protobuf:"varint,2,opt,name=used_times,json=usedTimes,proto3" json:"used_times,omitempty"`
}

func (m *ExtraTimesProto) Reset()                    { *m = ExtraTimesProto{} }
func (m *ExtraTimesProto) String() string            { return proto.CompactTextString(m) }
func (*ExtraTimesProto) ProtoMessage()               {}
func (*ExtraTimesProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{22} }

func (m *ExtraTimesProto) GetType() ExtraTimesType {
	if m != nil {
		return m.Type
	}
	return ExtraTimesType_InvalidExtraTimesType
}

func (m *ExtraTimesProto) GetUsedTimes() int32 {
	if m != nil {
		return m.UsedTimes
	}
	return 0
}

type RecoverableTimesWithExtraTimesProto struct {
	StartTime int32                `protobuf:"varint,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	List      *ExtraTimesListProto `protobuf:"bytes,2,opt,name=list" json:"list,omitempty"`
}

func (m *RecoverableTimesWithExtraTimesProto) Reset()         { *m = RecoverableTimesWithExtraTimesProto{} }
func (m *RecoverableTimesWithExtraTimesProto) String() string { return proto.CompactTextString(m) }
func (*RecoverableTimesWithExtraTimesProto) ProtoMessage()    {}
func (*RecoverableTimesWithExtraTimesProto) Descriptor() ([]byte, []int) {
	return fileDescriptorBase, []int{23}
}

func (m *RecoverableTimesWithExtraTimesProto) GetStartTime() int32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *RecoverableTimesWithExtraTimesProto) GetList() *ExtraTimesListProto {
	if m != nil {
		return m.List
	}
	return nil
}

type CaptainNameProto struct {
	Name       string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Title      string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Nickname   string `protobuf:"bytes,3,opt,name=nickname,proto3" json:"nickname,omitempty"`
	FamilyName string `protobuf:"bytes,4,opt,name=family_name,json=familyName,proto3" json:"family_name,omitempty"`
	GivenName  string `protobuf:"bytes,6,opt,name=given_name,json=givenName,proto3" json:"given_name,omitempty"`
	RaceName   string `protobuf:"bytes,5,opt,name=race_name,json=raceName,proto3" json:"race_name,omitempty"`
}

func (m *CaptainNameProto) Reset()                    { *m = CaptainNameProto{} }
func (m *CaptainNameProto) String() string            { return proto.CompactTextString(m) }
func (*CaptainNameProto) ProtoMessage()               {}
func (*CaptainNameProto) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{24} }

func (m *CaptainNameProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CaptainNameProto) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *CaptainNameProto) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *CaptainNameProto) GetFamilyName() string {
	if m != nil {
		return m.FamilyName
	}
	return ""
}

func (m *CaptainNameProto) GetGivenName() string {
	if m != nil {
		return m.GivenName
	}
	return ""
}

func (m *CaptainNameProto) GetRaceName() string {
	if m != nil {
		return m.RaceName
	}
	return ""
}

func init() {
	proto.RegisterType((*RaceDataProto)(nil), "proto.RaceDataProto")
	proto.RegisterType((*ResProto)(nil), "proto.ResProto")
	proto.RegisterType((*AmountProto)(nil), "proto.AmountProto")
	proto.RegisterType((*CombineCostProto)(nil), "proto.CombineCostProto")
	proto.RegisterType((*CostProto)(nil), "proto.CostProto")
	proto.RegisterType((*PrizeProto)(nil), "proto.PrizeProto")
	proto.RegisterType((*GuildLevelPrizeProto)(nil), "proto.GuildLevelPrizeProto")
	proto.RegisterType((*AmountShowSortProto)(nil), "proto.AmountShowSortProto")
	proto.RegisterType((*ExchangeDataProto)(nil), "proto.ExchangeDataProto")
	proto.RegisterType((*UnlockConditionProto)(nil), "proto.UnlockConditionProto")
	proto.RegisterType((*Int32Pair)(nil), "proto.Int32Pair")
	proto.RegisterType((*StringPair)(nil), "proto.StringPair")
	proto.RegisterType((*StringInt32Pair)(nil), "proto.StringInt32Pair")
	proto.RegisterType((*BytesInt32Pair)(nil), "proto.BytesInt32Pair")
	proto.RegisterType((*Int32ArrayProto)(nil), "proto.Int32ArrayProto")
	proto.RegisterType((*StringArrayProto)(nil), "proto.StringArrayProto")
	proto.RegisterType((*BytesArrayProto)(nil), "proto.BytesArrayProto")
	proto.RegisterType((*Int32PairInt32ArrayProto)(nil), "proto.Int32PairInt32ArrayProto")
	proto.RegisterType((*SpriteStatProto)(nil), "proto.SpriteStatProto")
	proto.RegisterType((*SpriteStatArrayProto)(nil), "proto.SpriteStatArrayProto")
	proto.RegisterType((*IconProto)(nil), "proto.IconProto")
	proto.RegisterType((*ExtraTimesListProto)(nil), "proto.ExtraTimesListProto")
	proto.RegisterType((*ExtraTimesProto)(nil), "proto.ExtraTimesProto")
	proto.RegisterType((*RecoverableTimesWithExtraTimesProto)(nil), "proto.RecoverableTimesWithExtraTimesProto")
	proto.RegisterType((*CaptainNameProto)(nil), "proto.CaptainNameProto")
	proto.RegisterEnum("proto.Race", Race_name, Race_value)
	proto.RegisterEnum("proto.RestraintRoundType", RestraintRoundType_name, RestraintRoundType_value)
	proto.RegisterEnum("proto.PosDiraction", PosDiraction_name, PosDiraction_value)
	proto.RegisterEnum("proto.Quality", Quality_name, Quality_value)
	proto.RegisterEnum("proto.ResType", ResType_name, ResType_value)
	proto.RegisterEnum("proto.AmountType", AmountType_name, AmountType_value)
	proto.RegisterEnum("proto.StatType", StatType_name, StatType_value)
	proto.RegisterEnum("proto.HeroEvent", HeroEvent_name, HeroEvent_value)
	proto.RegisterEnum("proto.ExtraTimesType", ExtraTimesType_name, ExtraTimesType_value)
	proto.RegisterEnum("proto.BCType", BCType_name, BCType_value)
	proto.RegisterEnum("proto.CountryOfficialType", CountryOfficialType_name, CountryOfficialType_value)
}
func (m *RaceDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaceDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Id))
	}
	if m.Race != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Race))
	}
	if m.AttackRange != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.AttackRange))
	}
	if m.MoveTimesPerRound != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.MoveTimesPerRound))
	}
	if m.MoveSpeed != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.MoveSpeed))
	}
	if m.IsFar {
		dAtA[i] = 0x30
		i++
		if m.IsFar {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Priority) > 0 {
		for _, num := range m.Priority {
			dAtA[i] = 0x58
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if len(m.RaceCoef) > 0 {
		for _, num := range m.RaceCoef {
			dAtA[i] = 0x60
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if len(m.RestraintRace) > 0 {
		for _, num := range m.RestraintRace {
			dAtA[i] = 0x68
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if m.RestraintRoundType != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.RestraintRoundType))
	}
	if m.RestraintSpellId != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.RestraintSpellId))
	}
	if m.UnlockRestraintSpellNeedAbility != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.UnlockRestraintSpellNeedAbility))
	}
	if m.NormalSpellId != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.NormalSpellId))
	}
	if m.WallCoef != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.WallCoef))
	}
	if m.ViewRange != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.ViewRange))
	}
	if len(m.GemTypes) > 0 {
		for _, num := range m.GemTypes {
			dAtA[i] = 0xa0
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if len(m.SoldierSpell) > 0 {
		for _, num := range m.SoldierSpell {
			dAtA[i] = 0xa8
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if len(m.AbilityRate) > 0 {
		for _, num := range m.AbilityRate {
			dAtA[i] = 0xb0
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if m.SoldierAttackSpeed != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.SoldierAttackSpeed))
	}
	if m.SoldierAttackRange != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.SoldierAttackRange))
	}
	return i, nil
}

func (m *ResProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Type))
	}
	if m.Amount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Amount))
	}
	if m.Percent != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Percent))
	}
	return i, nil
}

func (m *AmountProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AmountProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Amount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Amount))
	}
	if m.Percent != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Percent))
	}
	return i, nil
}

func (m *CombineCostProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombineCostProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cost != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Cost.Size()))
		n1, err := m.Cost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.BuildingWorkerTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.BuildingWorkerTime))
	}
	if m.TechWorkerTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.TechWorkerTime))
	}
	if m.Soldier != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Soldier))
	}
	if m.InvadeTimes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.InvadeTimes))
	}
	return i, nil
}

func (m *CostProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CostProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gold != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Gold))
	}
	if m.Food != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Food))
	}
	if m.Wood != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Wood))
	}
	if m.Stone != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Stone))
	}
	if len(m.GoodsId) > 0 {
		for _, num := range m.GoodsId {
			dAtA[i] = 0x28
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if len(m.GoodsCount) > 0 {
		for _, num := range m.GoodsCount {
			dAtA[i] = 0x30
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if m.Yuanbao != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Yuanbao))
	}
	if m.GuildContributionCoin != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.GuildContributionCoin))
	}
	if m.Jade != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Jade))
	}
	if len(m.GemId) > 0 {
		for _, num := range m.GemId {
			dAtA[i] = 0x50
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if len(m.GemCount) > 0 {
		for _, num := range m.GemCount {
			dAtA[i] = 0x58
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if m.JadeOre != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.JadeOre))
	}
	if m.Dianquan != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Dianquan))
	}
	if m.Yinliang != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Yinliang))
	}
	if m.IsNotEmpty {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x7
		i++
		if m.IsNotEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PrizeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrizeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gold != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Gold))
	}
	if m.Food != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Food))
	}
	if m.Wood != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Wood))
	}
	if m.Stone != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Stone))
	}
	if len(m.GoodsId) > 0 {
		for _, num := range m.GoodsId {
			dAtA[i] = 0x28
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if len(m.GoodsCount) > 0 {
		for _, num := range m.GoodsCount {
			dAtA[i] = 0x30
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if len(m.EquipmentId) > 0 {
		for _, num := range m.EquipmentId {
			dAtA[i] = 0x38
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if len(m.EquipmentCount) > 0 {
		for _, num := range m.EquipmentCount {
			dAtA[i] = 0x40
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if len(m.GemId) > 0 {
		for _, num := range m.GemId {
			dAtA[i] = 0x58
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if len(m.GemCount) > 0 {
		for _, num := range m.GemCount {
			dAtA[i] = 0x60
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if len(m.BaowuId) > 0 {
		for _, num := range m.BaowuId {
			dAtA[i] = 0x68
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if len(m.BaowuCount) > 0 {
		for _, num := range m.BaowuCount {
			dAtA[i] = 0x70
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if len(m.CaptainId) > 0 {
		for _, num := range m.CaptainId {
			dAtA[i] = 0x78
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if len(m.CaptainCount) > 0 {
		for _, num := range m.CaptainCount {
			dAtA[i] = 0x80
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	if m.SafeGold != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.SafeGold))
	}
	if m.SafeFood != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.SafeFood))
	}
	if m.SafeWood != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.SafeWood))
	}
	if m.SafeStone != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.SafeStone))
	}
	if m.CaptainExp != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.CaptainExp))
	}
	if m.HeroExp != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.HeroExp))
	}
	if m.Prosperity != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Prosperity))
	}
	if m.Yuanbao != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Yuanbao))
	}
	if m.Dianquan != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Dianquan))
	}
	if m.Yinliang != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Yinliang))
	}
	if m.Jade != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Jade))
	}
	if m.JadeOre != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.JadeOre))
	}
	if m.GuildContributionCoin != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.GuildContributionCoin))
	}
	if m.VipExp != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.VipExp))
	}
	if m.Sp != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Sp))
	}
	if m.AmountShowSortId != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.AmountShowSortId))
	}
	if m.IsNotEmpty {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x7
		i++
		if m.IsNotEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GuildLevelPrizeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuildLevelPrizeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Id))
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.GroupId))
	}
	if m.GuildLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.GuildLevel))
	}
	if m.Prize != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Prize.Size()))
		n2, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *AmountShowSortProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AmountShowSortProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Id))
	}
	if len(m.TypeList) > 0 {
		for _, num := range m.TypeList {
			dAtA[i] = 0x10
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *ExchangeDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Id))
	}
	if m.Cost != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Cost.Size()))
		n3, err := m.Cost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Prize != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Prize.Size()))
		n4, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *UnlockConditionProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockConditionProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequiredHeroLevel != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.RequiredHeroLevel))
	}
	if m.RequiredBaseLevel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.RequiredBaseLevel))
	}
	if m.RequiredGuildLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.RequiredGuildLevel))
	}
	if m.RequiredVipLevel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.RequiredVipLevel))
	}
	return i, nil
}

func (m *Int32Pair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Int32Pair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Key))
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Value))
	}
	return i, nil
}

func (m *StringPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *StringInt32Pair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringInt32Pair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Value))
	}
	return i, nil
}

func (m *BytesInt32Pair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BytesInt32Pair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Value))
	}
	return i, nil
}

func (m *Int32ArrayProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Int32ArrayProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.V) > 0 {
		for _, num := range m.V {
			dAtA[i] = 0x8
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *StringArrayProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringArrayProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.V) > 0 {
		for _, s := range m.V {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *BytesArrayProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BytesArrayProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.V) > 0 {
		for _, b := range m.V {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBase(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *Int32PairInt32ArrayProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Int32PairInt32ArrayProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.K != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.K))
	}
	if len(m.V) > 0 {
		for _, num := range m.V {
			dAtA[i] = 0x10
			i++
			i = encodeVarintBase(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *SpriteStatProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpriteStatProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Attack != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Attack))
	}
	if m.Defense != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Defense))
	}
	if m.Strength != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Strength))
	}
	if m.Dexterity != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Dexterity))
	}
	if m.SoldierCapcity != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.SoldierCapcity))
	}
	if m.DamageIncrePer != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.DamageIncrePer))
	}
	if m.DamageDecrePer != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.DamageDecrePer))
	}
	if m.BeenHurtIncrePer != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.BeenHurtIncrePer))
	}
	if m.BeenHurtDecrePer != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.BeenHurtDecrePer))
	}
	return i, nil
}

func (m *SpriteStatArrayProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpriteStatArrayProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SpriteStat) > 0 {
		for _, msg := range m.SpriteStat {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IconProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IconProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if len(m.MiddleIcon) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.MiddleIcon)))
		i += copy(dAtA[i:], m.MiddleIcon)
	}
	if len(m.BigIcon) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.BigIcon)))
		i += copy(dAtA[i:], m.BigIcon)
	}
	if len(m.SuperBigIcon) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.SuperBigIcon)))
		i += copy(dAtA[i:], m.SuperBigIcon)
	}
	if m.Tab != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Tab))
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if len(m.HeadIcon) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.HeadIcon)))
		i += copy(dAtA[i:], m.HeadIcon)
	}
	if len(m.TailIcon) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.TailIcon)))
		i += copy(dAtA[i:], m.TailIcon)
	}
	return i, nil
}

func (m *ExtraTimesListProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtraTimesListProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TypeList) > 0 {
		for _, msg := range m.TypeList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ExtraTimesProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtraTimesProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Type))
	}
	if m.UsedTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.UsedTimes))
	}
	return i, nil
}

func (m *RecoverableTimesWithExtraTimesProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoverableTimesWithExtraTimesProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.StartTime))
	}
	if m.List != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.List.Size()))
		n5, err := m.List.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *CaptainNameProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptainNameProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Nickname) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	if len(m.FamilyName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.FamilyName)))
		i += copy(dAtA[i:], m.FamilyName)
	}
	if len(m.RaceName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.RaceName)))
		i += copy(dAtA[i:], m.RaceName)
	}
	if len(m.GivenName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.GivenName)))
		i += copy(dAtA[i:], m.GivenName)
	}
	return i, nil
}

func encodeFixed64Base(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Base(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintBase(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RaceDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBase(uint64(m.Id))
	}
	if m.Race != 0 {
		n += 1 + sovBase(uint64(m.Race))
	}
	if m.AttackRange != 0 {
		n += 1 + sovBase(uint64(m.AttackRange))
	}
	if m.MoveTimesPerRound != 0 {
		n += 1 + sovBase(uint64(m.MoveTimesPerRound))
	}
	if m.MoveSpeed != 0 {
		n += 1 + sovBase(uint64(m.MoveSpeed))
	}
	if m.IsFar {
		n += 2
	}
	if len(m.Priority) > 0 {
		for _, e := range m.Priority {
			n += 1 + sovBase(uint64(e))
		}
	}
	if len(m.RaceCoef) > 0 {
		for _, e := range m.RaceCoef {
			n += 1 + sovBase(uint64(e))
		}
	}
	if len(m.RestraintRace) > 0 {
		for _, e := range m.RestraintRace {
			n += 1 + sovBase(uint64(e))
		}
	}
	if m.RestraintRoundType != 0 {
		n += 1 + sovBase(uint64(m.RestraintRoundType))
	}
	if m.RestraintSpellId != 0 {
		n += 1 + sovBase(uint64(m.RestraintSpellId))
	}
	if m.UnlockRestraintSpellNeedAbility != 0 {
		n += 2 + sovBase(uint64(m.UnlockRestraintSpellNeedAbility))
	}
	if m.NormalSpellId != 0 {
		n += 2 + sovBase(uint64(m.NormalSpellId))
	}
	if m.WallCoef != 0 {
		n += 2 + sovBase(uint64(m.WallCoef))
	}
	if m.ViewRange != 0 {
		n += 2 + sovBase(uint64(m.ViewRange))
	}
	if len(m.GemTypes) > 0 {
		for _, e := range m.GemTypes {
			n += 2 + sovBase(uint64(e))
		}
	}
	if len(m.SoldierSpell) > 0 {
		for _, e := range m.SoldierSpell {
			n += 2 + sovBase(uint64(e))
		}
	}
	if len(m.AbilityRate) > 0 {
		for _, e := range m.AbilityRate {
			n += 2 + sovBase(uint64(e))
		}
	}
	if m.SoldierAttackSpeed != 0 {
		n += 2 + sovBase(uint64(m.SoldierAttackSpeed))
	}
	if m.SoldierAttackRange != 0 {
		n += 2 + sovBase(uint64(m.SoldierAttackRange))
	}
	return n
}

func (m *ResProto) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovBase(uint64(m.Type))
	}
	if m.Amount != 0 {
		n += 1 + sovBase(uint64(m.Amount))
	}
	if m.Percent != 0 {
		n += 1 + sovBase(uint64(m.Percent))
	}
	return n
}

func (m *AmountProto) Size() (n int) {
	var l int
	_ = l
	if m.Amount != 0 {
		n += 1 + sovBase(uint64(m.Amount))
	}
	if m.Percent != 0 {
		n += 1 + sovBase(uint64(m.Percent))
	}
	return n
}

func (m *CombineCostProto) Size() (n int) {
	var l int
	_ = l
	if m.Cost != nil {
		l = m.Cost.Size()
		n += 1 + l + sovBase(uint64(l))
	}
	if m.BuildingWorkerTime != 0 {
		n += 1 + sovBase(uint64(m.BuildingWorkerTime))
	}
	if m.TechWorkerTime != 0 {
		n += 1 + sovBase(uint64(m.TechWorkerTime))
	}
	if m.Soldier != 0 {
		n += 1 + sovBase(uint64(m.Soldier))
	}
	if m.InvadeTimes != 0 {
		n += 1 + sovBase(uint64(m.InvadeTimes))
	}
	return n
}

func (m *CostProto) Size() (n int) {
	var l int
	_ = l
	if m.Gold != 0 {
		n += 1 + sovBase(uint64(m.Gold))
	}
	if m.Food != 0 {
		n += 1 + sovBase(uint64(m.Food))
	}
	if m.Wood != 0 {
		n += 1 + sovBase(uint64(m.Wood))
	}
	if m.Stone != 0 {
		n += 1 + sovBase(uint64(m.Stone))
	}
	if len(m.GoodsId) > 0 {
		for _, e := range m.GoodsId {
			n += 1 + sovBase(uint64(e))
		}
	}
	if len(m.GoodsCount) > 0 {
		for _, e := range m.GoodsCount {
			n += 1 + sovBase(uint64(e))
		}
	}
	if m.Yuanbao != 0 {
		n += 1 + sovBase(uint64(m.Yuanbao))
	}
	if m.GuildContributionCoin != 0 {
		n += 1 + sovBase(uint64(m.GuildContributionCoin))
	}
	if m.Jade != 0 {
		n += 1 + sovBase(uint64(m.Jade))
	}
	if len(m.GemId) > 0 {
		for _, e := range m.GemId {
			n += 1 + sovBase(uint64(e))
		}
	}
	if len(m.GemCount) > 0 {
		for _, e := range m.GemCount {
			n += 1 + sovBase(uint64(e))
		}
	}
	if m.JadeOre != 0 {
		n += 1 + sovBase(uint64(m.JadeOre))
	}
	if m.Dianquan != 0 {
		n += 1 + sovBase(uint64(m.Dianquan))
	}
	if m.Yinliang != 0 {
		n += 1 + sovBase(uint64(m.Yinliang))
	}
	if m.IsNotEmpty {
		n += 3
	}
	return n
}

func (m *PrizeProto) Size() (n int) {
	var l int
	_ = l
	if m.Gold != 0 {
		n += 1 + sovBase(uint64(m.Gold))
	}
	if m.Food != 0 {
		n += 1 + sovBase(uint64(m.Food))
	}
	if m.Wood != 0 {
		n += 1 + sovBase(uint64(m.Wood))
	}
	if m.Stone != 0 {
		n += 1 + sovBase(uint64(m.Stone))
	}
	if len(m.GoodsId) > 0 {
		for _, e := range m.GoodsId {
			n += 1 + sovBase(uint64(e))
		}
	}
	if len(m.GoodsCount) > 0 {
		for _, e := range m.GoodsCount {
			n += 1 + sovBase(uint64(e))
		}
	}
	if len(m.EquipmentId) > 0 {
		for _, e := range m.EquipmentId {
			n += 1 + sovBase(uint64(e))
		}
	}
	if len(m.EquipmentCount) > 0 {
		for _, e := range m.EquipmentCount {
			n += 1 + sovBase(uint64(e))
		}
	}
	if len(m.GemId) > 0 {
		for _, e := range m.GemId {
			n += 1 + sovBase(uint64(e))
		}
	}
	if len(m.GemCount) > 0 {
		for _, e := range m.GemCount {
			n += 1 + sovBase(uint64(e))
		}
	}
	if len(m.BaowuId) > 0 {
		for _, e := range m.BaowuId {
			n += 1 + sovBase(uint64(e))
		}
	}
	if len(m.BaowuCount) > 0 {
		for _, e := range m.BaowuCount {
			n += 1 + sovBase(uint64(e))
		}
	}
	if len(m.CaptainId) > 0 {
		for _, e := range m.CaptainId {
			n += 1 + sovBase(uint64(e))
		}
	}
	if len(m.CaptainCount) > 0 {
		for _, e := range m.CaptainCount {
			n += 2 + sovBase(uint64(e))
		}
	}
	if m.SafeGold != 0 {
		n += 2 + sovBase(uint64(m.SafeGold))
	}
	if m.SafeFood != 0 {
		n += 2 + sovBase(uint64(m.SafeFood))
	}
	if m.SafeWood != 0 {
		n += 2 + sovBase(uint64(m.SafeWood))
	}
	if m.SafeStone != 0 {
		n += 2 + sovBase(uint64(m.SafeStone))
	}
	if m.CaptainExp != 0 {
		n += 2 + sovBase(uint64(m.CaptainExp))
	}
	if m.HeroExp != 0 {
		n += 2 + sovBase(uint64(m.HeroExp))
	}
	if m.Prosperity != 0 {
		n += 2 + sovBase(uint64(m.Prosperity))
	}
	if m.Yuanbao != 0 {
		n += 2 + sovBase(uint64(m.Yuanbao))
	}
	if m.Dianquan != 0 {
		n += 2 + sovBase(uint64(m.Dianquan))
	}
	if m.Yinliang != 0 {
		n += 2 + sovBase(uint64(m.Yinliang))
	}
	if m.Jade != 0 {
		n += 2 + sovBase(uint64(m.Jade))
	}
	if m.JadeOre != 0 {
		n += 2 + sovBase(uint64(m.JadeOre))
	}
	if m.GuildContributionCoin != 0 {
		n += 2 + sovBase(uint64(m.GuildContributionCoin))
	}
	if m.VipExp != 0 {
		n += 2 + sovBase(uint64(m.VipExp))
	}
	if m.Sp != 0 {
		n += 2 + sovBase(uint64(m.Sp))
	}
	if m.AmountShowSortId != 0 {
		n += 2 + sovBase(uint64(m.AmountShowSortId))
	}
	if m.IsNotEmpty {
		n += 3
	}
	return n
}

func (m *GuildLevelPrizeProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBase(uint64(m.Id))
	}
	if m.GroupId != 0 {
		n += 1 + sovBase(uint64(m.GroupId))
	}
	if m.GuildLevel != 0 {
		n += 1 + sovBase(uint64(m.GuildLevel))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovBase(uint64(l))
	}
	return n
}

func (m *AmountShowSortProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBase(uint64(m.Id))
	}
	if len(m.TypeList) > 0 {
		for _, e := range m.TypeList {
			n += 1 + sovBase(uint64(e))
		}
	}
	return n
}

func (m *ExchangeDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBase(uint64(m.Id))
	}
	if m.Cost != nil {
		l = m.Cost.Size()
		n += 1 + l + sovBase(uint64(l))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovBase(uint64(l))
	}
	return n
}

func (m *UnlockConditionProto) Size() (n int) {
	var l int
	_ = l
	if m.RequiredHeroLevel != 0 {
		n += 1 + sovBase(uint64(m.RequiredHeroLevel))
	}
	if m.RequiredBaseLevel != 0 {
		n += 1 + sovBase(uint64(m.RequiredBaseLevel))
	}
	if m.RequiredGuildLevel != 0 {
		n += 1 + sovBase(uint64(m.RequiredGuildLevel))
	}
	if m.RequiredVipLevel != 0 {
		n += 1 + sovBase(uint64(m.RequiredVipLevel))
	}
	return n
}

func (m *Int32Pair) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovBase(uint64(m.Key))
	}
	if m.Value != 0 {
		n += 1 + sovBase(uint64(m.Value))
	}
	return n
}

func (m *StringPair) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	return n
}

func (m *StringInt32Pair) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovBase(uint64(m.Value))
	}
	return n
}

func (m *BytesInt32Pair) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovBase(uint64(m.Value))
	}
	return n
}

func (m *Int32ArrayProto) Size() (n int) {
	var l int
	_ = l
	if len(m.V) > 0 {
		for _, e := range m.V {
			n += 1 + sovBase(uint64(e))
		}
	}
	return n
}

func (m *StringArrayProto) Size() (n int) {
	var l int
	_ = l
	if len(m.V) > 0 {
		for _, s := range m.V {
			l = len(s)
			n += 1 + l + sovBase(uint64(l))
		}
	}
	return n
}

func (m *BytesArrayProto) Size() (n int) {
	var l int
	_ = l
	if len(m.V) > 0 {
		for _, b := range m.V {
			l = len(b)
			n += 1 + l + sovBase(uint64(l))
		}
	}
	return n
}

func (m *Int32PairInt32ArrayProto) Size() (n int) {
	var l int
	_ = l
	if m.K != 0 {
		n += 1 + sovBase(uint64(m.K))
	}
	if len(m.V) > 0 {
		for _, e := range m.V {
			n += 1 + sovBase(uint64(e))
		}
	}
	return n
}

func (m *SpriteStatProto) Size() (n int) {
	var l int
	_ = l
	if m.Attack != 0 {
		n += 1 + sovBase(uint64(m.Attack))
	}
	if m.Defense != 0 {
		n += 1 + sovBase(uint64(m.Defense))
	}
	if m.Strength != 0 {
		n += 1 + sovBase(uint64(m.Strength))
	}
	if m.Dexterity != 0 {
		n += 1 + sovBase(uint64(m.Dexterity))
	}
	if m.SoldierCapcity != 0 {
		n += 1 + sovBase(uint64(m.SoldierCapcity))
	}
	if m.DamageIncrePer != 0 {
		n += 1 + sovBase(uint64(m.DamageIncrePer))
	}
	if m.DamageDecrePer != 0 {
		n += 1 + sovBase(uint64(m.DamageDecrePer))
	}
	if m.BeenHurtIncrePer != 0 {
		n += 1 + sovBase(uint64(m.BeenHurtIncrePer))
	}
	if m.BeenHurtDecrePer != 0 {
		n += 1 + sovBase(uint64(m.BeenHurtDecrePer))
	}
	return n
}

func (m *SpriteStatArrayProto) Size() (n int) {
	var l int
	_ = l
	if len(m.SpriteStat) > 0 {
		for _, e := range m.SpriteStat {
			l = e.Size()
			n += 1 + l + sovBase(uint64(l))
		}
	}
	return n
}

func (m *IconProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = len(m.MiddleIcon)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = len(m.BigIcon)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = len(m.SuperBigIcon)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.Tab != 0 {
		n += 1 + sovBase(uint64(m.Tab))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = len(m.HeadIcon)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = len(m.TailIcon)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	return n
}

func (m *ExtraTimesListProto) Size() (n int) {
	var l int
	_ = l
	if len(m.TypeList) > 0 {
		for _, e := range m.TypeList {
			l = e.Size()
			n += 1 + l + sovBase(uint64(l))
		}
	}
	return n
}

func (m *ExtraTimesProto) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovBase(uint64(m.Type))
	}
	if m.UsedTimes != 0 {
		n += 1 + sovBase(uint64(m.UsedTimes))
	}
	return n
}

func (m *RecoverableTimesWithExtraTimesProto) Size() (n int) {
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovBase(uint64(m.StartTime))
	}
	if m.List != nil {
		l = m.List.Size()
		n += 1 + l + sovBase(uint64(l))
	}
	return n
}

func (m *CaptainNameProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = len(m.FamilyName)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = len(m.RaceName)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = len(m.GivenName)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	return n
}

func sovBase(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBase(x uint64) (n int) {
	return sovBase(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RaceDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaceDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaceDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Race", wireType)
			}
			m.Race = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Race |= (Race(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackRange", wireType)
			}
			m.AttackRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackRange |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveTimesPerRound", wireType)
			}
			m.MoveTimesPerRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveTimesPerRound |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveSpeed", wireType)
			}
			m.MoveSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveSpeed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFar", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFar = bool(v != 0)
		case 11:
			if wireType == 0 {
				var v Race
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Race(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Priority = append(m.Priority, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Race
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Race(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Priority = append(m.Priority, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RaceCoef = append(m.RaceCoef, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RaceCoef = append(m.RaceCoef, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RaceCoef", wireType)
			}
		case 13:
			if wireType == 0 {
				var v Race
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Race(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RestraintRace = append(m.RestraintRace, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Race
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Race(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RestraintRace = append(m.RestraintRace, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RestraintRace", wireType)
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestraintRoundType", wireType)
			}
			m.RestraintRoundType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestraintRoundType |= (RestraintRoundType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestraintSpellId", wireType)
			}
			m.RestraintSpellId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestraintSpellId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockRestraintSpellNeedAbility", wireType)
			}
			m.UnlockRestraintSpellNeedAbility = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnlockRestraintSpellNeedAbility |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalSpellId", wireType)
			}
			m.NormalSpellId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NormalSpellId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallCoef", wireType)
			}
			m.WallCoef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WallCoef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewRange", wireType)
			}
			m.ViewRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViewRange |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GemTypes = append(m.GemTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GemTypes = append(m.GemTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GemTypes", wireType)
			}
		case 21:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SoldierSpell = append(m.SoldierSpell, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SoldierSpell = append(m.SoldierSpell, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldierSpell", wireType)
			}
		case 22:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AbilityRate = append(m.AbilityRate, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AbilityRate = append(m.AbilityRate, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AbilityRate", wireType)
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldierAttackSpeed", wireType)
			}
			m.SoldierAttackSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoldierAttackSpeed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldierAttackRange", wireType)
			}
			m.SoldierAttackRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoldierAttackRange |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ResType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percent", wireType)
			}
			m.Percent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Percent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AmountProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AmountProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AmountProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percent", wireType)
			}
			m.Percent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Percent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombineCostProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombineCostProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombineCostProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &CostProto{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingWorkerTime", wireType)
			}
			m.BuildingWorkerTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingWorkerTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TechWorkerTime", wireType)
			}
			m.TechWorkerTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TechWorkerTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Soldier", wireType)
			}
			m.Soldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Soldier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvadeTimes", wireType)
			}
			m.InvadeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvadeTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CostProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CostProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CostProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Food", wireType)
			}
			m.Food = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Food |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wood", wireType)
			}
			m.Wood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Wood |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stone", wireType)
			}
			m.Stone = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stone |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GoodsId = append(m.GoodsId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GoodsId = append(m.GoodsId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsId", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GoodsCount = append(m.GoodsCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GoodsCount = append(m.GoodsCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsCount", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yuanbao", wireType)
			}
			m.Yuanbao = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Yuanbao |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildContributionCoin", wireType)
			}
			m.GuildContributionCoin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildContributionCoin |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jade", wireType)
			}
			m.Jade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Jade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GemId = append(m.GemId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GemId = append(m.GemId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GemId", wireType)
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GemCount = append(m.GemCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GemCount = append(m.GemCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GemCount", wireType)
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JadeOre", wireType)
			}
			m.JadeOre = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JadeOre |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dianquan", wireType)
			}
			m.Dianquan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dianquan |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yinliang", wireType)
			}
			m.Yinliang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Yinliang |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 127:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNotEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNotEmpty = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrizeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrizeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrizeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Food", wireType)
			}
			m.Food = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Food |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wood", wireType)
			}
			m.Wood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Wood |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stone", wireType)
			}
			m.Stone = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stone |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GoodsId = append(m.GoodsId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GoodsId = append(m.GoodsId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsId", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GoodsCount = append(m.GoodsCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GoodsCount = append(m.GoodsCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsCount", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EquipmentId = append(m.EquipmentId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EquipmentId = append(m.EquipmentId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipmentId", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EquipmentCount = append(m.EquipmentCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EquipmentCount = append(m.EquipmentCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipmentCount", wireType)
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GemId = append(m.GemId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GemId = append(m.GemId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GemId", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GemCount = append(m.GemCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GemCount = append(m.GemCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GemCount", wireType)
			}
		case 13:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BaowuId = append(m.BaowuId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BaowuId = append(m.BaowuId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BaowuId", wireType)
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BaowuCount = append(m.BaowuCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BaowuCount = append(m.BaowuCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BaowuCount", wireType)
			}
		case 15:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainId = append(m.CaptainId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainId = append(m.CaptainId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainId", wireType)
			}
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainCount = append(m.CaptainCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainCount = append(m.CaptainCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainCount", wireType)
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeGold", wireType)
			}
			m.SafeGold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafeGold |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeFood", wireType)
			}
			m.SafeFood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafeFood |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeWood", wireType)
			}
			m.SafeWood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafeWood |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeStone", wireType)
			}
			m.SafeStone = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafeStone |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainExp", wireType)
			}
			m.CaptainExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroExp", wireType)
			}
			m.HeroExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prosperity", wireType)
			}
			m.Prosperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prosperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yuanbao", wireType)
			}
			m.Yuanbao = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Yuanbao |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dianquan", wireType)
			}
			m.Dianquan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dianquan |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yinliang", wireType)
			}
			m.Yinliang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Yinliang |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jade", wireType)
			}
			m.Jade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Jade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JadeOre", wireType)
			}
			m.JadeOre = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JadeOre |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildContributionCoin", wireType)
			}
			m.GuildContributionCoin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildContributionCoin |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipExp", wireType)
			}
			m.VipExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sp", wireType)
			}
			m.Sp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountShowSortId", wireType)
			}
			m.AmountShowSortId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AmountShowSortId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 127:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNotEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNotEmpty = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuildLevelPrizeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuildLevelPrizeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuildLevelPrizeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildLevel", wireType)
			}
			m.GuildLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AmountShowSortProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AmountShowSortProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AmountShowSortProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v AmountType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (AmountType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TypeList = append(m.TypeList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v AmountType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (AmountType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TypeList = append(m.TypeList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &CostProto{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockConditionProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockConditionProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockConditionProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredHeroLevel", wireType)
			}
			m.RequiredHeroLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredHeroLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredBaseLevel", wireType)
			}
			m.RequiredBaseLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredBaseLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredGuildLevel", wireType)
			}
			m.RequiredGuildLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredGuildLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredVipLevel", wireType)
			}
			m.RequiredVipLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredVipLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Int32Pair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int32Pair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int32Pair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringInt32Pair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringInt32Pair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringInt32Pair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BytesInt32Pair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BytesInt32Pair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BytesInt32Pair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Int32ArrayProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int32ArrayProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int32ArrayProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.V = append(m.V, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.V = append(m.V, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringArrayProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringArrayProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringArrayProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V = append(m.V, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BytesArrayProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BytesArrayProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BytesArrayProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V = append(m.V, make([]byte, postIndex-iNdEx))
			copy(m.V[len(m.V)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Int32PairInt32ArrayProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int32PairInt32ArrayProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int32PairInt32ArrayProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			m.K = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.K |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.V = append(m.V, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.V = append(m.V, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpriteStatProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpriteStatProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpriteStatProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attack", wireType)
			}
			m.Attack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attack |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defense", wireType)
			}
			m.Defense = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Defense |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			m.Strength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dexterity", wireType)
			}
			m.Dexterity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dexterity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldierCapcity", wireType)
			}
			m.SoldierCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoldierCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DamageIncrePer", wireType)
			}
			m.DamageIncrePer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DamageIncrePer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DamageDecrePer", wireType)
			}
			m.DamageDecrePer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DamageDecrePer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeenHurtIncrePer", wireType)
			}
			m.BeenHurtIncrePer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeenHurtIncrePer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeenHurtDecrePer", wireType)
			}
			m.BeenHurtDecrePer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeenHurtDecrePer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpriteStatArrayProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpriteStatArrayProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpriteStatArrayProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpriteStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpriteStat = append(m.SpriteStat, &SpriteStatProto{})
			if err := m.SpriteStat[len(m.SpriteStat)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IconProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IconProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IconProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiddleIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MiddleIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BigIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuperBigIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuperBigIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tab", wireType)
			}
			m.Tab = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tab |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TailIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TailIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtraTimesListProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtraTimesListProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtraTimesListProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeList = append(m.TypeList, &ExtraTimesProto{})
			if err := m.TypeList[len(m.TypeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtraTimesProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtraTimesProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtraTimesProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ExtraTimesType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedTimes", wireType)
			}
			m.UsedTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoverableTimesWithExtraTimesProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoverableTimesWithExtraTimesProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoverableTimesWithExtraTimesProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.List == nil {
				m.List = &ExtraTimesListProto{}
			}
			if err := m.List.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptainNameProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptainNameProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptainNameProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FamilyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GivenName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GivenName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBase(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBase
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBase
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBase
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBase
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBase
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBase(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBase = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBase   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/shared_proto/base.proto", fileDescriptorBase)
}

var fileDescriptorBase = []byte{
	// 2836 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0xcb, 0x72, 0xdb, 0xc8,
	0xd5, 0x16, 0xef, 0xe4, 0x21, 0x45, 0xb5, 0x5a, 0xb2, 0x4d, 0xdb, 0xbf, 0x6d, 0x0d, 0x3d, 0x17,
	0x8f, 0xe6, 0x1f, 0x7b, 0x62, 0x4f, 0xcd, 0x4c, 0x92, 0x45, 0x0a, 0x04, 0x21, 0x0a, 0x63, 0x0a,
	0xa0, 0x41, 0xd0, 0x1e, 0x39, 0x55, 0x41, 0x40, 0xa2, 0x45, 0x21, 0x26, 0x01, 0x0e, 0x00, 0x4a,
	0x56, 0x36, 0xd9, 0xa6, 0x2a, 0x2f, 0x90, 0x17, 0x49, 0x55, 0xde, 0x20, 0x59, 0x26, 0x59, 0xa4,
	0xb2, 0x4a, 0xa5, 0x26, 0x4f, 0x90, 0x37, 0x48, 0x9d, 0xee, 0x06, 0x2f, 0xb2, 0xa2, 0xa9, 0xec,
	0xb2, 0x52, 0xf7, 0xf7, 0x9d, 0x3e, 0x7d, 0x4e, 0x9f, 0x4b, 0x37, 0x28, 0xf8, 0x7c, 0xec, 0x27,
	0xa7, 0xf3, 0xe1, 0xe3, 0x51, 0x38, 0x7d, 0x32, 0xf1, 0xc7, 0xa7, 0xc9, 0xcc, 0x3d, 0x7f, 0x32,
	0x75, 0x27, 0xec, 0xcb, 0x27, 0xb3, 0xe1, 0x93, 0xf8, 0xd4, 0x8d, 0x98, 0xe7, 0xcc, 0xa2, 0x30,
	0x09, 0x9f, 0x0c, 0xdd, 0x98, 0x3d, 0xe6, 0x43, 0x5a, 0xe0, 0x7f, 0x9a, 0x7f, 0x29, 0xc2, 0xa6,
	0xe5, 0x8e, 0x58, 0xdb, 0x4d, 0xdc, 0x1e, 0x27, 0xea, 0x90, 0xf5, 0xbd, 0x46, 0x66, 0x2f, 0xf3,
	0xa8, 0x60, 0x65, 0x7d, 0x8f, 0x3e, 0x80, 0x7c, 0xe4, 0x8e, 0x58, 0x23, 0xbb, 0x97, 0x79, 0x54,
	0x7f, 0x5a, 0x15, 0xcb, 0x1f, 0xe3, 0x1a, 0x8b, 0x13, 0xf4, 0x3d, 0xa8, 0xb9, 0x49, 0xe2, 0x8e,
	0xde, 0x38, 0x91, 0x1b, 0x8c, 0x59, 0x23, 0xc7, 0x97, 0x56, 0x05, 0x66, 0x21, 0x44, 0x9f, 0xc0,
	0xee, 0x34, 0x3c, 0x63, 0x4e, 0xe2, 0x4f, 0x59, 0xec, 0xcc, 0x58, 0xe4, 0x44, 0xe1, 0x3c, 0xf0,
	0x1a, 0x79, 0x2e, 0xba, 0x8d, 0x9c, 0x8d, 0x54, 0x8f, 0x45, 0x16, 0x12, 0xf4, 0x1e, 0x00, 0x5f,
	0x10, 0xcf, 0x18, 0xf3, 0x1a, 0x05, 0x2e, 0x56, 0x41, 0xa4, 0x8f, 0x00, 0xbd, 0x01, 0x45, 0x3f,
	0x76, 0x4e, 0xdc, 0xa8, 0x51, 0xdc, 0xcb, 0x3c, 0x2a, 0x5b, 0x05, 0x3f, 0x3e, 0x70, 0x23, 0xfa,
	0x09, 0x94, 0x67, 0x91, 0x1f, 0x46, 0x7e, 0x72, 0xd1, 0xa8, 0xee, 0xe5, 0x2e, 0x99, 0xdb, 0xca,
	0x92, 0x0d, 0x6b, 0x21, 0x40, 0x1f, 0x40, 0x05, 0xcd, 0x77, 0x46, 0x21, 0x3b, 0x69, 0xd4, 0xf6,
	0x72, 0x8f, 0x0a, 0x42, 0x00, 0x41, 0x35, 0x64, 0x27, 0xf4, 0x0b, 0xa8, 0x47, 0x2c, 0x4e, 0x22,
	0xd7, 0x0f, 0x12, 0x87, 0x1f, 0xc1, 0xe6, 0xd5, 0x3a, 0x37, 0x17, 0x62, 0x08, 0xd1, 0xe7, 0xb0,
	0xbb, 0xb2, 0x0e, 0xdd, 0x71, 0x92, 0x8b, 0x19, 0x6b, 0xd4, 0xf9, 0x01, 0xde, 0x4e, 0x57, 0x2f,
	0xd6, 0xa0, 0x84, 0x7d, 0x31, 0x63, 0x16, 0x8d, 0xde, 0xc1, 0xe8, 0xff, 0xc3, 0x12, 0xc5, 0xd3,
	0x98, 0x4c, 0x1c, 0xdf, 0x6b, 0x6c, 0xf1, 0x03, 0x21, 0x0b, 0xa6, 0x8f, 0x84, 0xee, 0xd1, 0x2e,
	0x3c, 0x9c, 0x07, 0x93, 0x10, 0x43, 0x71, 0x69, 0x51, 0xc0, 0x98, 0xe7, 0xb8, 0x43, 0x7f, 0x82,
	0x67, 0x43, 0xf8, 0xf2, 0x07, 0x42, 0xd4, 0x5a, 0x53, 0x62, 0x30, 0xe6, 0x29, 0x42, 0x8c, 0x7e,
	0x08, 0x5b, 0x41, 0x18, 0x4d, 0xdd, 0xc9, 0x72, 0xe3, 0x6d, 0xbe, 0x72, 0x53, 0xc0, 0xe9, 0xae,
	0x77, 0xa1, 0x72, 0xee, 0x4e, 0x26, 0xe2, 0x24, 0x29, 0x97, 0x28, 0x23, 0xc0, 0x4f, 0xf1, 0x1e,
	0xc0, 0x99, 0xcf, 0xce, 0x65, 0x6e, 0xec, 0x88, 0x48, 0x22, 0x22, 0x32, 0xe3, 0x01, 0x54, 0xc6,
	0x6c, 0xca, 0x0f, 0x28, 0x6e, 0xec, 0x2e, 0xa3, 0x30, 0x66, 0x53, 0xf4, 0x3f, 0xa6, 0x1f, 0xc1,
	0x66, 0x1c, 0x4e, 0x3c, 0x9f, 0x45, 0xc2, 0x8a, 0xc6, 0x8d, 0x85, 0x50, 0x4d, 0x12, 0xdc, 0x0e,
	0xfa, 0x01, 0xd4, 0xa4, 0x7f, 0x4e, 0xe4, 0x26, 0xac, 0x71, 0x73, 0x21, 0x57, 0x95, 0xb8, 0xe5,
	0x26, 0x8c, 0x7e, 0x06, 0xbb, 0xa9, 0x3e, 0x99, 0xb5, 0x22, 0xc7, 0x6e, 0x71, 0xcb, 0xa8, 0xe4,
	0x14, 0x4e, 0x89, 0x64, 0x7b, 0x77, 0x85, 0xf0, 0xa5, 0x71, 0xc5, 0x0a, 0xee, 0x54, 0xf3, 0xe7,
	0x50, 0xb6, 0x58, 0x2c, 0xca, 0xa9, 0x09, 0x79, 0x1e, 0xfd, 0x0c, 0x8f, 0x7e, 0x7d, 0x19, 0x7d,
	0x1e, 0x72, 0xce, 0xd1, 0x9b, 0x50, 0x74, 0xa7, 0xe1, 0x3c, 0x48, 0x78, 0x91, 0x15, 0x2c, 0x39,
	0xa3, 0x0d, 0x28, 0xcd, 0x58, 0x34, 0x62, 0x41, 0x22, 0x8b, 0x2a, 0x9d, 0x36, 0x7f, 0x02, 0x55,
	0x85, 0xcb, 0x88, 0x4d, 0xfe, 0x7b, 0x05, 0x7f, 0xce, 0x00, 0x51, 0xc3, 0xe9, 0xd0, 0x0f, 0x98,
	0x1a, 0xc6, 0x52, 0xcd, 0xfb, 0x90, 0x1f, 0x85, 0x71, 0xc2, 0x6d, 0xad, 0x3e, 0x25, 0xd2, 0xd6,
	0x05, 0x6f, 0x71, 0x16, 0xcf, 0x63, 0x38, 0xf7, 0x27, 0x9e, 0x1f, 0x8c, 0x9d, 0xf3, 0x30, 0x7a,
	0xc3, 0x22, 0x5e, 0xd7, 0x72, 0x6b, 0x9a, 0x72, 0xaf, 0x38, 0x85, 0x65, 0x4d, 0x1f, 0x01, 0x49,
	0xd8, 0xe8, 0x74, 0x4d, 0x5a, 0xd8, 0x53, 0x47, 0x7c, 0x45, 0xb2, 0x01, 0x25, 0x79, 0x9e, 0xb2,
	0x37, 0xa4, 0x53, 0xec, 0x32, 0x7e, 0x70, 0xe6, 0x7a, 0xb2, 0x89, 0xc8, 0x9e, 0x50, 0x15, 0x18,
	0x6f, 0x1e, 0xcd, 0xdf, 0xe7, 0xa0, 0xb2, 0x74, 0x86, 0x42, 0x7e, 0x1c, 0x4e, 0xd2, 0x4e, 0xc6,
	0xc7, 0x88, 0x9d, 0x84, 0xa1, 0x27, 0x4d, 0xe5, 0x63, 0xc4, 0xce, 0x11, 0x13, 0x06, 0xf1, 0x31,
	0xdd, 0x85, 0x42, 0x9c, 0x84, 0x01, 0x93, 0x46, 0x88, 0x09, 0xbd, 0x07, 0xe5, 0x71, 0x18, 0x7a,
	0x31, 0x16, 0x42, 0x61, 0x91, 0x5d, 0x25, 0x8e, 0xe9, 0x1e, 0x7d, 0x08, 0x55, 0x41, 0x8f, 0x78,
	0x24, 0x8a, 0x0b, 0x09, 0xe0, 0xb0, 0x9a, 0x46, 0xe4, 0x62, 0xee, 0x06, 0x43, 0x37, 0x6c, 0x94,
	0x84, 0x83, 0x72, 0x4a, 0xbf, 0x80, 0x5b, 0x63, 0x3c, 0x3a, 0x67, 0x14, 0x06, 0x49, 0xe4, 0x0f,
	0xe7, 0x89, 0x1f, 0x06, 0xce, 0x28, 0xf4, 0x83, 0x46, 0x99, 0x4b, 0xde, 0xe0, 0xb4, 0xba, 0xc2,
	0xaa, 0xa1, 0x1f, 0xa0, 0xfd, 0xbf, 0x70, 0x3d, 0xd6, 0xa8, 0x08, 0xfb, 0x71, 0x4c, 0x6f, 0x43,
	0x11, 0xab, 0xca, 0xf7, 0x1a, 0xb0, 0xb0, 0xa2, 0x30, 0x66, 0x53, 0xdd, 0x4b, 0x0b, 0x4e, 0xd8,
	0x58, 0x5d, 0x2b, 0x38, 0x61, 0xe1, 0x6d, 0x28, 0xa3, 0x0e, 0x27, 0x8c, 0x58, 0xa3, 0x26, 0x4c,
	0xc4, 0xb9, 0x19, 0x31, 0x7a, 0x07, 0xca, 0x9e, 0xef, 0x06, 0xdf, 0xce, 0xdd, 0x80, 0x77, 0xb3,
	0x82, 0xb5, 0x98, 0x23, 0x77, 0xe1, 0x07, 0x13, 0xdf, 0x0d, 0xc6, 0xb2, 0x3d, 0x2d, 0xe6, 0x74,
	0x0f, 0x6a, 0x7e, 0xec, 0x04, 0x61, 0xe2, 0xb0, 0xe9, 0x2c, 0xb9, 0x68, 0xfc, 0x8a, 0x37, 0x6d,
	0xf0, 0x63, 0x23, 0x4c, 0x34, 0x44, 0x9a, 0x7f, 0x28, 0x01, 0xf4, 0x22, 0xff, 0x97, 0xec, 0x7f,
	0x39, 0x76, 0x1f, 0x40, 0x8d, 0x7d, 0x3b, 0xf7, 0x67, 0x53, 0x16, 0x24, 0xa8, 0xa7, 0xb4, 0xec,
	0x30, 0x0b, 0x5c, 0xf7, 0xe8, 0x27, 0xb0, 0xb5, 0x14, 0x13, 0xfa, 0xca, 0x0b, 0xc9, 0xfa, 0x82,
	0x4a, 0x4f, 0x3b, 0x8d, 0x54, 0xf5, 0xda, 0x48, 0xd5, 0xae, 0x88, 0xd4, 0x3d, 0x28, 0x0f, 0xdd,
	0xf0, 0x7c, 0x8e, 0xab, 0x37, 0x97, 0x3e, 0x71, 0x4c, 0xf8, 0x24, 0x68, 0xa1, 0xa1, 0xbe, 0xf4,
	0x89, 0xc3, 0x42, 0xc7, 0x7b, 0x00, 0x23, 0x77, 0x96, 0xb8, 0x7e, 0x20, 0xee, 0x95, 0x54, 0xa6,
	0x22, 0x51, 0xdd, 0xc3, 0x0e, 0x9c, 0x8a, 0x08, 0x4d, 0x64, 0xd9, 0x81, 0x25, 0x21, 0x74, 0xdd,
	0x85, 0x4a, 0xec, 0x9e, 0x30, 0x87, 0x87, 0xee, 0x86, 0xc8, 0x01, 0x04, 0x3a, 0x18, 0xbe, 0x94,
	0xe4, 0x31, 0xbc, 0xb9, 0x24, 0x0f, 0x30, 0x66, 0x29, 0xc9, 0x83, 0x79, 0x6b, 0x49, 0xbe, 0x42,
	0xf2, 0x1e, 0x00, 0x27, 0x45, 0x54, 0x45, 0xd7, 0xe5, 0xe2, 0x7d, 0x1e, 0xd9, 0x07, 0x50, 0x4d,
	0xcd, 0x63, 0x6f, 0x67, 0x8d, 0x07, 0x9c, 0x4f, 0x9d, 0xd2, 0xde, 0xce, 0x30, 0xa1, 0x4f, 0x59,
	0x14, 0x72, 0x76, 0x4f, 0x24, 0x34, 0xce, 0x91, 0xba, 0x0f, 0x30, 0x8b, 0xc2, 0x78, 0xc6, 0xf8,
	0x93, 0xe1, 0xa1, 0x58, 0xba, 0x44, 0x56, 0xab, 0xf5, 0xd1, 0x7a, 0xb5, 0xae, 0x96, 0xc2, 0xc7,
	0xd7, 0x94, 0xc2, 0xfe, 0xa5, 0x52, 0x48, 0xab, 0xf5, 0xf1, 0x5a, 0xb5, 0x2e, 0x2b, 0xee, 0xc9,
	0x7a, 0xc5, 0x5d, 0xd3, 0x14, 0x3e, 0xbb, 0xae, 0x29, 0xdc, 0x82, 0xd2, 0x99, 0x3f, 0xe3, 0x2e,
	0xff, 0x40, 0xdc, 0x08, 0x67, 0xfe, 0x0c, 0x3d, 0xae, 0x43, 0x36, 0x9e, 0x35, 0x9e, 0x8a, 0xd7,
	0x5d, 0x3c, 0xa3, 0x9f, 0xc2, 0x8e, 0xb8, 0x2b, 0x9c, 0xf8, 0x34, 0x3c, 0x77, 0xe2, 0x30, 0xe2,
	0xa9, 0xed, 0x89, 0x07, 0x86, 0xa0, 0xfa, 0xa7, 0xe1, 0x79, 0x3f, 0x8c, 0x30, 0xb7, 0xbf, 0xbf,
	0x92, 0x7f, 0x93, 0x81, 0xdd, 0x0e, 0xda, 0xd4, 0x65, 0x67, 0x6c, 0xb2, 0x52, 0xd3, 0x97, 0xdf,
	0x95, 0xb7, 0xa1, 0x3c, 0x8e, 0xc2, 0xf9, 0x0c, 0xb7, 0x13, 0x35, 0x5d, 0xe2, 0x73, 0x9e, 0xf9,
	0x55, 0xe1, 0xf5, 0x04, 0x75, 0xc8, 0xea, 0x86, 0xf1, 0x42, 0x2b, 0xfd, 0x08, 0x0a, 0x33, 0xd4,
	0xcc, 0x6b, 0xbc, 0xfa, 0x74, 0x5b, 0xde, 0x54, 0xcb, 0xdd, 0x2c, 0xc1, 0x37, 0x8f, 0x61, 0x47,
	0x59, 0xf3, 0xe1, 0x6a, 0x5b, 0x9e, 0x42, 0x05, 0x2f, 0x62, 0x67, 0xe2, 0xc7, 0x78, 0x85, 0xe2,
	0x2b, 0x2f, 0xd5, 0x29, 0x96, 0xe3, 0x65, 0x2d, 0xaa, 0x0f, 0xe5, 0xba, 0x7e, 0x9c, 0x34, 0x23,
	0xd8, 0xd6, 0xde, 0x8e, 0x4e, 0xf1, 0xc2, 0xff, 0xcf, 0x8f, 0xe7, 0xf4, 0x46, 0xcd, 0x5e, 0x7b,
	0xa3, 0x2e, 0xdc, 0xc9, 0x7d, 0x8f, 0x3b, 0x7f, 0xcd, 0xc0, 0xee, 0x80, 0xbf, 0xda, 0xd4, 0x30,
	0xf0, 0x7c, 0x0c, 0xb7, 0xd8, 0xf7, 0x31, 0xec, 0x44, 0xd8, 0x59, 0xf0, 0xa9, 0xcf, 0x93, 0x5d,
	0x9c, 0x9c, 0x30, 0x64, 0x3b, 0xa5, 0x0e, 0x59, 0x14, 0x8a, 0x03, 0x5c, 0x95, 0xc7, 0x8f, 0x02,
	0x29, 0x9f, 0x5d, 0x97, 0x6f, 0xb9, 0x31, 0x13, 0xf2, 0x9f, 0xe1, 0x9b, 0x56, 0xca, 0xbf, 0x1b,
	0x1a, 0x9a, 0x72, 0xcb, 0xc0, 0x8b, 0x87, 0xab, 0x5c, 0x81, 0xa9, 0x28, 0xe4, 0xf3, 0xe9, 0xc3,
	0x55, 0x30, 0x2f, 0xfd, 0x19, 0x97, 0x6e, 0x3e, 0x83, 0x8a, 0x1e, 0x24, 0xcf, 0x9e, 0xf6, 0x5c,
	0x3f, 0xa2, 0x04, 0x72, 0x6f, 0xd8, 0x85, 0x34, 0x1e, 0x87, 0xd8, 0xd3, 0xcf, 0xdc, 0xc9, 0x3c,
	0x7d, 0x63, 0x88, 0x49, 0xf3, 0x73, 0x80, 0x7e, 0x12, 0xf9, 0xc1, 0xf8, 0xf2, 0xaa, 0xca, 0x15,
	0xab, 0x2a, 0xe9, 0xaa, 0x1f, 0xc2, 0x96, 0x58, 0x75, 0xe5, 0x86, 0x95, 0xeb, 0x36, 0xfc, 0x0a,
	0xea, 0xad, 0x8b, 0x84, 0xc5, 0x57, 0xae, 0xac, 0x5d, 0xb7, 0xf2, 0x21, 0x6c, 0xf1, 0x45, 0x4a,
	0x14, 0xb9, 0x17, 0x22, 0x64, 0x04, 0x32, 0x67, 0x8d, 0xcc, 0xa2, 0x95, 0x66, 0xce, 0x9a, 0x7b,
	0x40, 0x84, 0x65, 0x2b, 0x52, 0xb5, 0x54, 0xaa, 0x82, 0x12, 0x0f, 0x60, 0x8b, 0x1b, 0x70, 0x95,
	0x40, 0x0d, 0x05, 0x7e, 0x04, 0x8d, 0x85, 0x71, 0x97, 0x37, 0xac, 0x41, 0xe6, 0x8d, 0x3c, 0xd4,
	0xcc, 0x1b, 0xb1, 0x7d, 0x76, 0x75, 0xfb, 0xbf, 0x65, 0x61, 0xab, 0x3f, 0x8b, 0xfc, 0x84, 0xf5,
	0x13, 0x77, 0xe5, 0x61, 0xc9, 0x1f, 0xb6, 0x72, 0xa1, 0x9c, 0x61, 0x63, 0xf4, 0xd8, 0x09, 0x0b,
	0xe2, 0xd4, 0xcf, 0x74, 0x8a, 0xcd, 0x2f, 0x4e, 0x22, 0x16, 0x8c, 0x93, 0x53, 0x99, 0x1d, 0x8b,
	0x39, 0xfd, 0x3f, 0xa8, 0x78, 0xec, 0x6d, 0x22, 0xba, 0xad, 0x48, 0x85, 0x25, 0x40, 0x3f, 0x82,
	0xad, 0xf4, 0x9d, 0x3d, 0x72, 0x67, 0x23, 0x94, 0x11, 0x8f, 0xbc, 0xba, 0x84, 0x55, 0x81, 0xe2,
	0x73, 0xd2, 0x73, 0xa7, 0xee, 0x98, 0x39, 0x7e, 0x30, 0x8a, 0x18, 0x7e, 0x4f, 0xf2, 0xef, 0xc0,
	0x82, 0x55, 0x17, 0xb8, 0x8e, 0x70, 0x8f, 0x45, 0x2b, 0x92, 0x1e, 0x4b, 0x25, 0x4b, 0xab, 0x92,
	0x6d, 0x26, 0x25, 0x3f, 0x85, 0x9d, 0x21, 0x63, 0x81, 0x73, 0x3a, 0xc7, 0x06, 0xb8, 0x50, 0x2b,
	0x5e, 0x5e, 0x04, 0xa9, 0xc3, 0x79, 0x94, 0x2c, 0x14, 0xaf, 0x89, 0x2f, 0x75, 0x57, 0xd6, 0xc5,
	0x53, 0xed, 0x4d, 0x13, 0x76, 0x97, 0x27, 0xbb, 0x12, 0x92, 0x2f, 0xa1, 0x1a, 0x73, 0xdc, 0x89,
	0x13, 0x37, 0xe1, 0x61, 0xac, 0x3e, 0xbd, 0x29, 0xcb, 0xff, 0x52, 0x2c, 0x2c, 0x88, 0x17, 0x40,
	0xf3, 0x5f, 0x19, 0xa8, 0xe8, 0xa3, 0xb4, 0xfa, 0x97, 0x5d, 0xa7, 0xc2, 0xbb, 0x0e, 0x85, 0xbc,
	0x3f, 0x0a, 0x03, 0x99, 0xf7, 0x7c, 0x8c, 0x3d, 0x75, 0xea, 0x7b, 0xde, 0x84, 0x39, 0x9c, 0xca,
	0x71, 0x0a, 0x04, 0x84, 0x9a, 0xb0, 0x1f, 0x0f, 0xfd, 0xb1, 0x60, 0xf3, 0x9c, 0x2d, 0x0d, 0xfd,
	0x31, 0xa7, 0xde, 0x87, 0x7a, 0x3c, 0xc7, 0xaf, 0xf6, 0x85, 0x40, 0x81, 0x0b, 0xd4, 0x38, 0xda,
	0x92, 0x52, 0x04, 0x72, 0x89, 0x3b, 0x94, 0x91, 0xc0, 0x21, 0xda, 0x91, 0xb0, 0xb7, 0x09, 0x3f,
	0xf2, 0x8a, 0xc5, 0xc7, 0x78, 0xd5, 0x9f, 0x32, 0xd7, 0x13, 0x6a, 0xca, 0x9c, 0x28, 0x23, 0xc0,
	0x55, 0xdc, 0x85, 0x4a, 0xe2, 0xfa, 0x13, 0x41, 0x56, 0x04, 0x89, 0x00, 0x92, 0xcd, 0xaf, 0x61,
	0x47, 0x7b, 0x9b, 0x44, 0x2e, 0x7f, 0xec, 0x63, 0x0b, 0x16, 0xce, 0x3f, 0x5b, 0xed, 0xdd, 0xeb,
	0x27, 0xb8, 0x14, 0x17, 0x27, 0xb8, 0x6c, 0xde, 0x3f, 0x85, 0xad, 0x4b, 0x24, 0xfd, 0x78, 0xed,
	0x43, 0xed, 0xc6, 0x3b, 0x2a, 0x56, 0xbe, 0xd7, 0xee, 0x01, 0xcc, 0x63, 0xe6, 0xc9, 0x2f, 0x11,
	0x51, 0x00, 0x15, 0x44, 0xc4, 0x77, 0x48, 0x02, 0x0f, 0x2d, 0x36, 0x0a, 0xcf, 0x58, 0xe4, 0x0e,
	0x27, 0xe2, 0xdb, 0xe4, 0x95, 0x9f, 0x9c, 0x5e, 0xde, 0x10, 0xdf, 0x35, 0x89, 0x1b, 0x25, 0xe2,
	0x7b, 0x28, 0x23, 0xdf, 0x35, 0x88, 0xf0, 0x4f, 0xa1, 0xc7, 0x90, 0x97, 0xd7, 0x11, 0xde, 0x09,
	0x77, 0xde, 0xb1, 0x67, 0x71, 0x02, 0x16, 0x97, 0x6b, 0xfe, 0x0e, 0xbf, 0xe8, 0xc4, 0xab, 0xc7,
	0x70, 0xa7, 0xcb, 0x87, 0x74, 0xe0, 0x4a, 0xed, 0x15, 0x8b, 0x8f, 0xb1, 0x43, 0x25, 0x7e, 0x32,
	0x59, 0xb4, 0x45, 0x3e, 0xc1, 0xba, 0x0d, 0xfc, 0xd1, 0x1b, 0x2e, 0x2d, 0x92, 0x63, 0x31, 0xc7,
	0xdc, 0x39, 0x71, 0xa7, 0xfe, 0xe4, 0xc2, 0xe1, 0xb4, 0xc8, 0x0e, 0x10, 0x10, 0xee, 0x85, 0x71,
	0xe3, 0xbf, 0xa5, 0x70, 0x5a, 0xe4, 0x06, 0xff, 0x1d, 0x85, 0x93, 0xf7, 0x00, 0xc6, 0xfe, 0x19,
	0x0b, 0x04, 0x5b, 0xe4, 0x6c, 0x85, 0x23, 0x48, 0xef, 0xab, 0x90, 0xe7, 0x3f, 0x9b, 0x6c, 0x41,
	0x55, 0x0f, 0xce, 0xdc, 0x89, 0xef, 0xe1, 0x94, 0x6c, 0xd0, 0x22, 0x64, 0x5b, 0x03, 0x92, 0xc1,
	0xbf, 0x2f, 0x74, 0x92, 0xa5, 0x65, 0xc8, 0x77, 0x4c, 0xa3, 0x43, 0x72, 0xb4, 0x04, 0x39, 0xf5,
	0x50, 0x23, 0x79, 0x1c, 0x7c, 0xa3, 0x6b, 0xa4, 0xb0, 0xff, 0x15, 0xd0, 0x77, 0x7f, 0x50, 0x59,
	0x51, 0x89, 0x53, 0xb2, 0x81, 0xf2, 0x66, 0xbb, 0x4d, 0x32, 0xa8, 0x4b, 0x7b, 0xa9, 0x19, 0x24,
	0xbb, 0xff, 0x02, 0x6a, 0xbd, 0x30, 0x6e, 0xfb, 0x91, 0x3b, 0xc2, 0xeb, 0x94, 0xde, 0x82, 0x1d,
	0xb9, 0x66, 0x15, 0x26, 0x1b, 0x7c, 0x89, 0xd2, 0xb7, 0x49, 0x86, 0x56, 0xa0, 0xd0, 0x37, 0x07,
	0xf6, 0xa1, 0xb0, 0xe9, 0x95, 0xd6, 0xb7, 0x49, 0x0e, 0x41, 0xc3, 0xb4, 0xec, 0x43, 0x92, 0xdf,
	0xff, 0x19, 0x94, 0x5e, 0xcc, 0x5d, 0xfe, 0x13, 0x0a, 0x85, 0xba, 0xd4, 0x26, 0x11, 0xb2, 0x81,
	0x92, 0xaf, 0x0e, 0x75, 0x5b, 0x13, 0x9a, 0x3a, 0x96, 0x86, 0x76, 0xa0, 0xa6, 0x56, 0x77, 0xa0,
	0x91, 0x1c, 0x05, 0x28, 0xf6, 0x06, 0x56, 0xaf, 0x8b, 0x0e, 0x02, 0x14, 0x4d, 0x4b, 0x31, 0x3a,
	0x1a, 0x29, 0xa0, 0xf1, 0x96, 0xd6, 0x26, 0xc5, 0xfd, 0x03, 0x28, 0xc9, 0xdf, 0x0f, 0x56, 0xf4,
	0x4b, 0x44, 0x18, 0xda, 0x31, 0xbb, 0xd2, 0xcb, 0x03, 0xd3, 0x6c, 0x4b, 0x3b, 0x71, 0xc4, 0xed,
	0xec, 0xdb, 0xa6, 0xa1, 0x91, 0xfc, 0xfe, 0xdf, 0xb3, 0x00, 0xcb, 0xe7, 0x0d, 0xbd, 0x01, 0xdb,
	0x52, 0xd7, 0x12, 0x24, 0x1b, 0xb4, 0x0a, 0xa5, 0x9e, 0xed, 0x48, 0x8d, 0x62, 0x22, 0x95, 0x8a,
	0x89, 0xd4, 0x5b, 0x83, 0x72, 0xcf, 0x76, 0xa4, 0x6a, 0x39, 0xeb, 0x98, 0x66, 0xbb, 0x4f, 0x0a,
	0x72, 0xa6, 0xbd, 0x18, 0xe8, 0x3d, 0x52, 0xa4, 0x75, 0x80, 0x9e, 0xed, 0xa8, 0x4a, 0xcf, 0x56,
	0x74, 0x83, 0x94, 0xb8, 0xbf, 0xb6, 0xd3, 0xd1, 0x8e, 0x48, 0x19, 0xfd, 0x59, 0x72, 0x8e, 0xf6,
	0x4d, 0x8f, 0x54, 0x30, 0x8a, 0x3d, 0xdb, 0x39, 0xd4, 0x2c, 0x93, 0x03, 0x40, 0xb7, 0x61, 0xb3,
	0x67, 0x3b, 0x3d, 0xcb, 0xec, 0xf7, 0x34, 0x4b, 0xb7, 0x8f, 0x49, 0x55, 0xea, 0x3c, 0x1e, 0x28,
	0x46, 0x4b, 0x31, 0x49, 0x4d, 0x9a, 0xf6, 0xb5, 0xd2, 0xd6, 0xc8, 0xa6, 0x54, 0x80, 0x13, 0xc7,
	0xb4, 0x34, 0x52, 0x97, 0x40, 0x5b, 0x57, 0x8c, 0x17, 0x03, 0xc5, 0x20, 0x5b, 0xf4, 0x3e, 0xdc,
	0x41, 0x13, 0x06, 0x7a, 0xb7, 0xed, 0xa8, 0xa6, 0x61, 0x5b, 0x7a, 0x6b, 0x60, 0xeb, 0xa6, 0xe1,
	0xa8, 0xa6, 0x6e, 0x10, 0x22, 0x1d, 0x68, 0x29, 0xe6, 0xab, 0x01, 0xd9, 0x96, 0xcb, 0x8f, 0x75,
	0xa3, 0xab, 0x2b, 0x46, 0x87, 0x50, 0xb9, 0xdb, 0xe1, 0xe0, 0x60, 0x40, 0x76, 0xf0, 0x80, 0xf1,
	0x20, 0x7a, 0x64, 0x77, 0x7f, 0x00, 0x65, 0xec, 0xd6, 0xfc, 0x74, 0x77, 0xf0, 0x05, 0xc0, 0x4f,
	0x37, 0x85, 0xc8, 0x06, 0xba, 0xae, 0xd8, 0xb6, 0xa2, 0x3e, 0x17, 0x47, 0xdb, 0xd6, 0x0e, 0x34,
	0xa3, 0xaf, 0x91, 0x2c, 0x6e, 0xd8, 0xb7, 0x2d, 0xcd, 0xe8, 0xd8, 0x87, 0x24, 0x47, 0x37, 0xa1,
	0xd2, 0xd6, 0xbe, 0xb1, 0x85, 0xb3, 0xf9, 0xfd, 0x5f, 0xe7, 0xa0, 0x82, 0x4f, 0x39, 0xed, 0x8c,
	0x05, 0x09, 0xdd, 0x05, 0x22, 0x15, 0x2f, 0x30, 0xb2, 0x81, 0x69, 0x2c, 0x4e, 0xec, 0xa5, 0x66,
	0xd8, 0x8e, 0xa5, 0xa9, 0x87, 0x8a, 0xd5, 0xc1, 0x94, 0xbb, 0x0d, 0x37, 0x56, 0x08, 0x3e, 0xec,
	0x6a, 0x2f, 0xb5, 0x2e, 0xc9, 0x5e, 0xa2, 0x5a, 0x4a, 0x5f, 0x93, 0x54, 0xee, 0x92, 0x3a, 0x45,
	0xb5, 0xf5, 0x97, 0xdc, 0x16, 0x7a, 0x13, 0xe8, 0x0a, 0xd1, 0x1e, 0x18, 0x1d, 0xcd, 0x34, 0x48,
	0x01, 0xad, 0x5a, 0xc1, 0x6d, 0xf3, 0x95, 0x66, 0x91, 0x22, 0xbd, 0x0b, 0xb7, 0x56, 0xd0, 0xe7,
	0x7a, 0xb7, 0xeb, 0x1c, 0x99, 0x46, 0xdf, 0xd6, 0x2c, 0x52, 0xa2, 0x77, 0xe0, 0xe6, 0x0a, 0x39,
	0x30, 0xba, 0xa6, 0xfa, 0xdc, 0x39, 0x18, 0x18, 0x2a, 0x29, 0xd3, 0x0f, 0xa1, 0xb9, 0xc2, 0xa9,
	0x66, 0xb7, 0xab, 0xa9, 0x68, 0xa2, 0xee, 0xbc, 0x3e, 0x54, 0x0c, 0xa7, 0xaf, 0x74, 0x15, 0xeb,
	0x98, 0x54, 0x68, 0x03, 0x76, 0x2f, 0x6f, 0xd0, 0x52, 0xcc, 0xd7, 0x04, 0xe8, 0x63, 0xd8, 0x5f,
	0x75, 0x6e, 0x70, 0x2c, 0xc3, 0x2d, 0xe6, 0x3d, 0x4b, 0x7f, 0xad, 0x39, 0x07, 0x96, 0x79, 0xe4,
	0xf4, 0x0f, 0xcd, 0x1e, 0xa9, 0xd2, 0xf7, 0x61, 0x6f, 0xd5, 0xe3, 0x7e, 0x5f, 0x3b, 0x6a, 0x75,
	0x8f, 0xd7, 0x6d, 0xae, 0xed, 0xff, 0x18, 0xea, 0xeb, 0x37, 0x04, 0x1e, 0xa2, 0x0c, 0xc7, 0x3a,
	0x41, 0x36, 0x30, 0x49, 0xb5, 0x24, 0x71, 0xfa, 0xcc, 0x8d, 0xc3, 0x80, 0x64, 0xf6, 0x6d, 0x28,
	0xb6, 0xd4, 0x34, 0x39, 0x5a, 0xaa, 0xa3, 0x1b, 0x2f, 0x95, 0xae, 0xde, 0x76, 0xec, 0xe3, 0x9e,
	0x26, 0xfa, 0x44, 0x4b, 0x75, 0x3a, 0x47, 0x24, 0x83, 0x19, 0xdf, 0x52, 0x1d, 0x5b, 0x3f, 0xd2,
	0x8d, 0x8e, 0xd3, 0x3f, 0xee, 0x93, 0x2c, 0xa6, 0x4e, 0x4b, 0xe5, 0xe3, 0x1c, 0xa6, 0x4e, 0x4b,
	0xe5, 0xb1, 0xc4, 0xec, 0xc8, 0xc0, 0x0e, 0xff, 0x1e, 0x8f, 0x2e, 0xcc, 0x93, 0x13, 0x7f, 0xe4,
	0xbb, 0x93, 0x74, 0x0f, 0xd5, 0xb4, 0x1d, 0xc3, 0x74, 0xcc, 0x83, 0x03, 0x5d, 0xd5, 0x95, 0x2e,
	0xd9, 0xc0, 0x3c, 0x43, 0xf0, 0xb9, 0x6e, 0x74, 0x48, 0x06, 0xf3, 0x0c, 0x67, 0x2f, 0x06, 0xa2,
	0x25, 0x11, 0xa8, 0xe1, 0xf4, 0x48, 0x37, 0x74, 0xee, 0x6e, 0x0e, 0x33, 0x1f, 0x91, 0x8e, 0x66,
	0x68, 0x96, 0xd2, 0x25, 0x79, 0x74, 0x09, 0x01, 0x55, 0x33, 0xfa, 0xa6, 0x25, 0x2a, 0x1d, 0xe7,
	0x7d, 0xfd, 0x48, 0x21, 0xc5, 0xd6, 0xde, 0x1f, 0xbf, 0xbb, 0x9f, 0xf9, 0xd3, 0x77, 0xf7, 0x33,
	0xff, 0xf8, 0xee, 0x7e, 0xe6, 0xb7, 0xff, 0xbc, 0xbf, 0x71, 0x98, 0x79, 0x5d, 0x5b, 0xfd, 0x87,
	0xc4, 0xb0, 0xc8, 0xff, 0x3c, 0xfb, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x52, 0x1e, 0xf2, 0xdc,
	0xc4, 0x18, 0x00, 0x00,
}
