// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/shared_proto/config_gen.proto
// DO NOT EDIT!

package shared_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ConfigGen struct {
	MingcBaseData                     []*MingcBaseDataProto                     `protobuf:"bytes,1,rep,name=mingc_base_data,json=mingcBaseData" json:"mingc_base_data,omitempty"`
	XuanyuanMiscData                  *XuanyuanMiscDataProto                    `protobuf:"bytes,2,opt,name=xuanyuan_misc_data,json=xuanyuanMiscData" json:"xuanyuan_misc_data,omitempty"`
	XuanyuanRangeData                 []*XuanyuanRangeDataProto                 `protobuf:"bytes,3,rep,name=xuanyuan_range_data,json=xuanyuanRangeData" json:"xuanyuan_range_data,omitempty"`
	XuanyuanRankPrizeData             []*XuanyuanRankPrizeDataProto             `protobuf:"bytes,4,rep,name=xuanyuan_rank_prize_data,json=xuanyuanRankPrizeData" json:"xuanyuan_rank_prize_data,omitempty"`
	MiscGenConfig                     *MiscGenConfigProto                       `protobuf:"bytes,5,opt,name=misc_gen_config,json=miscGenConfig" json:"misc_gen_config,omitempty"`
	BaowuData                         []*BaowuDataProto                         `protobuf:"bytes,6,rep,name=baowu_data,json=baowuData" json:"baowu_data,omitempty"`
	BaozNpcData                       []*BaozNpcDataProto                       `protobuf:"bytes,7,rep,name=baoz_npc_data,json=baozNpcData" json:"baoz_npc_data,omitempty"`
	PushData                          []*PushDataProto                          `protobuf:"bytes,8,rep,name=push_data,json=pushData" json:"push_data,omitempty"`
	TitleData                         []*TitleDataProto                         `protobuf:"bytes,9,rep,name=title_data,json=titleData" json:"title_data,omitempty"`
	TitleTaskData                     []*TitleTaskDataProto                     `protobuf:"bytes,10,rep,name=title_task_data,json=titleTaskData" json:"title_task_data,omitempty"`
	SecretTowerWordsData              []*SecretTowerWordsDataProto              `protobuf:"bytes,11,rep,name=secret_tower_words_data,json=secretTowerWordsData" json:"secret_tower_words_data,omitempty"`
	GuildGenConfig                    *GuildGenConfigProto                      `protobuf:"bytes,12,opt,name=guild_gen_config,json=guildGenConfig" json:"guild_gen_config,omitempty"`
	LocationData                      []*LocationDataProto                      `protobuf:"bytes,13,rep,name=location_data,json=locationData" json:"location_data,omitempty"`
	CountryData                       []*CountryDataProto                       `protobuf:"bytes,14,rep,name=country_data,json=countryData" json:"country_data,omitempty"`
	CountryMiscData                   *CountryMiscDataProto                     `protobuf:"bytes,15,opt,name=country_misc_data,json=countryMiscData" json:"country_misc_data,omitempty"`
	FamilyNameData                    []*FamilyNameDataProto                    `protobuf:"bytes,16,rep,name=family_name_data,json=familyNameData" json:"family_name_data,omitempty"`
	LoginDayData                      []*LoginDayDataProto                      `protobuf:"bytes,17,rep,name=login_day_data,json=loginDayData" json:"login_day_data,omitempty"`
	HeroLevelFundData                 []*HeroLevelFundDataProto                 `protobuf:"bytes,18,rep,name=hero_level_fund_data,json=heroLevelFundData" json:"hero_level_fund_data,omitempty"`
	PromotionMiscData                 *PromotionMiscDataProto                   `protobuf:"bytes,19,opt,name=promotion_misc_data,json=promotionMiscData" json:"promotion_misc_data,omitempty"`
	BlackMarketGoodsData              []*BlackMarketGoodsDataProto              `protobuf:"bytes,20,rep,name=black_market_goods_data,json=blackMarketGoodsData" json:"black_market_goods_data,omitempty"`
	ShopMiscData                      *ShopMiscDataProto                        `protobuf:"bytes,21,opt,name=shop_misc_data,json=shopMiscData" json:"shop_misc_data,omitempty"`
	MingcMiscData                     *MingcMiscDataProto                       `protobuf:"bytes,22,opt,name=mingc_misc_data,json=mingcMiscData" json:"mingc_misc_data,omitempty"`
	MingcTimeData                     []*MingcTimeDataProto                     `protobuf:"bytes,23,rep,name=mingc_time_data,json=mingcTimeData" json:"mingc_time_data,omitempty"`
	MingcWarBuildingData              []*MingcWarBuildingDataProto              `protobuf:"bytes,24,rep,name=mingc_war_building_data,json=mingcWarBuildingData" json:"mingc_war_building_data,omitempty"`
	MingcWarMapData                   []*MingcWarMapDataProto                   `protobuf:"bytes,25,rep,name=mingc_war_map_data,json=mingcWarMapData" json:"mingc_war_map_data,omitempty"`
	MingcWarSceneData                 []*MingcWarSceneDataProto                 `protobuf:"bytes,26,rep,name=mingc_war_scene_data,json=mingcWarSceneData" json:"mingc_war_scene_data,omitempty"`
	RegionGenConfig                   *RegionGenConfigProto                     `protobuf:"bytes,27,opt,name=region_gen_config,json=regionGenConfig" json:"region_gen_config,omitempty"`
	OuterCityBuildingData             []*OuterCityBuildingDataProto             `protobuf:"bytes,28,rep,name=outer_city_building_data,json=outerCityBuildingData" json:"outer_city_building_data,omitempty"`
	DiscountColorData                 []*DiscountColorDataProto                 `protobuf:"bytes,30,rep,name=discount_color_data,json=discountColorData" json:"discount_color_data,omitempty"`
	MingcWarTroopLastBeatWhenFailData []*MingcWarTroopLastBeatWhenFailDataProto `protobuf:"bytes,32,rep,name=mingc_war_troop_last_beat_when_fail_data,json=mingcWarTroopLastBeatWhenFailData" json:"mingc_war_troop_last_beat_when_fail_data,omitempty"`
	MingcWarTouShiBuildingTargetData  []*MingcWarTouShiBuildingTargetDataProto  `protobuf:"bytes,33,rep,name=mingc_war_tou_shi_building_target_data,json=mingcWarTouShiBuildingTargetData" json:"mingc_war_tou_shi_building_target_data,omitempty"`
	CaptainData                       []*CaptainDataProto                       `protobuf:"bytes,34,rep,name=captain_data,json=captainData" json:"captain_data,omitempty"`
	CaptainRarityData                 []*CaptainRarityDataProto                 `protobuf:"bytes,35,rep,name=captain_rarity_data,json=captainRarityData" json:"captain_rarity_data,omitempty"`
	NamelessCaptainData               []*NamelessCaptainDataProto               `protobuf:"bytes,36,rep,name=nameless_captain_data,json=namelessCaptainData" json:"nameless_captain_data,omitempty"`
	SpellFacadeData                   []*SpellFacadeDataProto                   `protobuf:"bytes,38,rep,name=spell_facade_data,json=spellFacadeData" json:"spell_facade_data,omitempty"`
	BufferData                        []*BufferDataProto                        `protobuf:"bytes,39,rep,name=buffer_data,json=bufferData" json:"buffer_data,omitempty"`
	GuildRankPrizeData                []*GuildRankPrizeDataProto                `protobuf:"bytes,40,rep,name=guild_rank_prize_data,json=guildRankPrizeData" json:"guild_rank_prize_data,omitempty"`
	ChargePrizeData                   []*ChargePrizeDataProto                   `protobuf:"bytes,41,rep,name=charge_prize_data,json=chargePrizeData" json:"charge_prize_data,omitempty"`
	SpCollectionData                  []*SpCollectionDataProto                  `protobuf:"bytes,42,rep,name=sp_collection_data,json=spCollectionData" json:"sp_collection_data,omitempty"`
	StrategyEffectData                []*StrategyEffectDataProto                `protobuf:"bytes,43,rep,name=strategy_effect_data,json=strategyEffectData" json:"strategy_effect_data,omitempty"`
	DailyBargainData                  []*DailyBargainDataProto                  `protobuf:"bytes,44,rep,name=daily_bargain_data,json=dailyBargainData" json:"daily_bargain_data,omitempty"`
	DurationCardData                  []*DurationCardDataProto                  `protobuf:"bytes,45,rep,name=duration_card_data,json=durationCardData" json:"duration_card_data,omitempty"`
	CombatMiscConfig                  *CombatMiscConfigProto                    `protobuf:"bytes,46,opt,name=combat_misc_config,json=combatMiscConfig" json:"combat_misc_config,omitempty"`
	FreeGiftData                      []*FreeGiftDataProto                      `protobuf:"bytes,47,rep,name=free_gift_data,json=freeGiftData" json:"free_gift_data,omitempty"`
	ChargeObjData                     []*ChargeObjDataProto                     `protobuf:"bytes,48,rep,name=charge_obj_data,json=chargeObjData" json:"charge_obj_data,omitempty"`
	BuffEffectData                    []*BuffEffectDataProto                    `protobuf:"bytes,49,rep,name=buff_effect_data,json=buffEffectData" json:"buff_effect_data,omitempty"`
	AssemblyData                      []*AssemblyDataProto                      `protobuf:"bytes,50,rep,name=assembly_data,json=assemblyData" json:"assembly_data,omitempty"`
	JunTuanNpcData                    []*JunTuanNpcDataProto                    `protobuf:"bytes,51,rep,name=jun_tuan_npc_data,json=junTuanNpcData" json:"jun_tuan_npc_data,omitempty"`
	ProsperityDamageBuffData          []*ProsperityDamageBuffDataProto          `protobuf:"bytes,52,rep,name=prosperity_damage_buff_data,json=prosperityDamageBuffData" json:"prosperity_damage_buff_data,omitempty"`
	BufferTypeData                    []*BufferTypeDataProto                    `protobuf:"bytes,53,rep,name=buffer_type_data,json=bufferTypeData" json:"buffer_type_data,omitempty"`
	VipContinueDaysData               []*VipContinueDaysDataProto               `protobuf:"bytes,54,rep,name=vip_continue_days_data,json=vipContinueDaysData" json:"vip_continue_days_data,omitempty"`
	VipLevelData                      []*VipLevelDataProto                      `protobuf:"bytes,55,rep,name=vip_level_data,json=vipLevelData" json:"vip_level_data,omitempty"`
	VipMiscData                       *VipMiscDataProto                         `protobuf:"bytes,56,opt,name=vip_misc_data,json=vipMiscData" json:"vip_misc_data,omitempty"`
	PrivacySettingData                []*PrivacySettingDataProto                `protobuf:"bytes,57,rep,name=privacy_setting_data,json=privacySettingData" json:"privacy_setting_data,omitempty"`
	TimeLimitGiftData                 []*TimeLimitGiftDataProto                 `protobuf:"bytes,59,rep,name=time_limit_gift_data,json=timeLimitGiftData" json:"time_limit_gift_data,omitempty"`
	EventLimitGiftData                []*EventLimitGiftDataProto                `protobuf:"bytes,60,rep,name=event_limit_gift_data,json=eventLimitGiftData" json:"event_limit_gift_data,omitempty"`
	McBuildAddSupportData             []*McBuildAddSupportDataProto             `protobuf:"bytes,61,rep,name=mc_build_add_support_data,json=mcBuildAddSupportData" json:"mc_build_add_support_data,omitempty"`
	McBuildGuildMemberPrizeData       []*McBuildGuildMemberPrizeDataProto       `protobuf:"bytes,62,rep,name=mc_build_guild_member_prize_data,json=mcBuildGuildMemberPrizeData" json:"mc_build_guild_member_prize_data,omitempty"`
	McBuildMcSupportData              []*McBuildMcSupportDataProto              `protobuf:"bytes,64,rep,name=mc_build_mc_support_data,json=mcBuildMcSupportData" json:"mc_build_mc_support_data,omitempty"`
	McBuildMiscData                   *McBuildMiscDataProto                     `protobuf:"bytes,65,opt,name=mc_build_misc_data,json=mcBuildMiscData" json:"mc_build_misc_data,omitempty"`
	CaptainFriendshipData             []*CaptainFriendshipDataProto             `protobuf:"bytes,66,rep,name=captain_friendship_data,json=captainFriendshipData" json:"captain_friendship_data,omitempty"`
	RedPacketData                     []*RedPacketDataProto                     `protobuf:"bytes,67,rep,name=red_packet_data,json=redPacketData" json:"red_packet_data,omitempty"`
	TroopDialogueData                 []*TroopDialogueDataProto                 `protobuf:"bytes,68,rep,name=troop_dialogue_data,json=troopDialogueData" json:"troop_dialogue_data,omitempty"`
	TroopDialogueTextData             []*TroopDialogueTextDataProto             `protobuf:"bytes,69,rep,name=troop_dialogue_text_data,json=troopDialogueTextData" json:"troop_dialogue_text_data,omitempty"`
	CountryOfficialData               []*CountryOfficialDataProto               `protobuf:"bytes,70,rep,name=country_official_data,json=countryOfficialData" json:"country_official_data,omitempty"`
	CountryOfficialNpcData            []*CountryOfficialNpcDataProto            `protobuf:"bytes,71,rep,name=country_official_npc_data,json=countryOfficialNpcData" json:"country_official_npc_data,omitempty"`
	RegionAreaData                    []*RegionAreaDataProto                    `protobuf:"bytes,73,rep,name=region_area_data,json=regionAreaData" json:"region_area_data,omitempty"`
	FishingCaptainProbabilityData     []*FishingCaptainProbabilityDataProto     `protobuf:"bytes,74,rep,name=fishing_captain_probability_data,json=fishingCaptainProbabilityData" json:"fishing_captain_probability_data,omitempty"`
}

func (m *ConfigGen) Reset()                    { *m = ConfigGen{} }
func (m *ConfigGen) String() string            { return proto.CompactTextString(m) }
func (*ConfigGen) ProtoMessage()               {}
func (*ConfigGen) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{0} }

func (m *ConfigGen) GetMingcBaseData() []*MingcBaseDataProto {
	if m != nil {
		return m.MingcBaseData
	}
	return nil
}

func (m *ConfigGen) GetXuanyuanMiscData() *XuanyuanMiscDataProto {
	if m != nil {
		return m.XuanyuanMiscData
	}
	return nil
}

func (m *ConfigGen) GetXuanyuanRangeData() []*XuanyuanRangeDataProto {
	if m != nil {
		return m.XuanyuanRangeData
	}
	return nil
}

func (m *ConfigGen) GetXuanyuanRankPrizeData() []*XuanyuanRankPrizeDataProto {
	if m != nil {
		return m.XuanyuanRankPrizeData
	}
	return nil
}

func (m *ConfigGen) GetMiscGenConfig() *MiscGenConfigProto {
	if m != nil {
		return m.MiscGenConfig
	}
	return nil
}

func (m *ConfigGen) GetBaowuData() []*BaowuDataProto {
	if m != nil {
		return m.BaowuData
	}
	return nil
}

func (m *ConfigGen) GetBaozNpcData() []*BaozNpcDataProto {
	if m != nil {
		return m.BaozNpcData
	}
	return nil
}

func (m *ConfigGen) GetPushData() []*PushDataProto {
	if m != nil {
		return m.PushData
	}
	return nil
}

func (m *ConfigGen) GetTitleData() []*TitleDataProto {
	if m != nil {
		return m.TitleData
	}
	return nil
}

func (m *ConfigGen) GetTitleTaskData() []*TitleTaskDataProto {
	if m != nil {
		return m.TitleTaskData
	}
	return nil
}

func (m *ConfigGen) GetSecretTowerWordsData() []*SecretTowerWordsDataProto {
	if m != nil {
		return m.SecretTowerWordsData
	}
	return nil
}

func (m *ConfigGen) GetGuildGenConfig() *GuildGenConfigProto {
	if m != nil {
		return m.GuildGenConfig
	}
	return nil
}

func (m *ConfigGen) GetLocationData() []*LocationDataProto {
	if m != nil {
		return m.LocationData
	}
	return nil
}

func (m *ConfigGen) GetCountryData() []*CountryDataProto {
	if m != nil {
		return m.CountryData
	}
	return nil
}

func (m *ConfigGen) GetCountryMiscData() *CountryMiscDataProto {
	if m != nil {
		return m.CountryMiscData
	}
	return nil
}

func (m *ConfigGen) GetFamilyNameData() []*FamilyNameDataProto {
	if m != nil {
		return m.FamilyNameData
	}
	return nil
}

func (m *ConfigGen) GetLoginDayData() []*LoginDayDataProto {
	if m != nil {
		return m.LoginDayData
	}
	return nil
}

func (m *ConfigGen) GetHeroLevelFundData() []*HeroLevelFundDataProto {
	if m != nil {
		return m.HeroLevelFundData
	}
	return nil
}

func (m *ConfigGen) GetPromotionMiscData() *PromotionMiscDataProto {
	if m != nil {
		return m.PromotionMiscData
	}
	return nil
}

func (m *ConfigGen) GetBlackMarketGoodsData() []*BlackMarketGoodsDataProto {
	if m != nil {
		return m.BlackMarketGoodsData
	}
	return nil
}

func (m *ConfigGen) GetShopMiscData() *ShopMiscDataProto {
	if m != nil {
		return m.ShopMiscData
	}
	return nil
}

func (m *ConfigGen) GetMingcMiscData() *MingcMiscDataProto {
	if m != nil {
		return m.MingcMiscData
	}
	return nil
}

func (m *ConfigGen) GetMingcTimeData() []*MingcTimeDataProto {
	if m != nil {
		return m.MingcTimeData
	}
	return nil
}

func (m *ConfigGen) GetMingcWarBuildingData() []*MingcWarBuildingDataProto {
	if m != nil {
		return m.MingcWarBuildingData
	}
	return nil
}

func (m *ConfigGen) GetMingcWarMapData() []*MingcWarMapDataProto {
	if m != nil {
		return m.MingcWarMapData
	}
	return nil
}

func (m *ConfigGen) GetMingcWarSceneData() []*MingcWarSceneDataProto {
	if m != nil {
		return m.MingcWarSceneData
	}
	return nil
}

func (m *ConfigGen) GetRegionGenConfig() *RegionGenConfigProto {
	if m != nil {
		return m.RegionGenConfig
	}
	return nil
}

func (m *ConfigGen) GetOuterCityBuildingData() []*OuterCityBuildingDataProto {
	if m != nil {
		return m.OuterCityBuildingData
	}
	return nil
}

func (m *ConfigGen) GetDiscountColorData() []*DiscountColorDataProto {
	if m != nil {
		return m.DiscountColorData
	}
	return nil
}

func (m *ConfigGen) GetMingcWarTroopLastBeatWhenFailData() []*MingcWarTroopLastBeatWhenFailDataProto {
	if m != nil {
		return m.MingcWarTroopLastBeatWhenFailData
	}
	return nil
}

func (m *ConfigGen) GetMingcWarTouShiBuildingTargetData() []*MingcWarTouShiBuildingTargetDataProto {
	if m != nil {
		return m.MingcWarTouShiBuildingTargetData
	}
	return nil
}

func (m *ConfigGen) GetCaptainData() []*CaptainDataProto {
	if m != nil {
		return m.CaptainData
	}
	return nil
}

func (m *ConfigGen) GetCaptainRarityData() []*CaptainRarityDataProto {
	if m != nil {
		return m.CaptainRarityData
	}
	return nil
}

func (m *ConfigGen) GetNamelessCaptainData() []*NamelessCaptainDataProto {
	if m != nil {
		return m.NamelessCaptainData
	}
	return nil
}

func (m *ConfigGen) GetSpellFacadeData() []*SpellFacadeDataProto {
	if m != nil {
		return m.SpellFacadeData
	}
	return nil
}

func (m *ConfigGen) GetBufferData() []*BufferDataProto {
	if m != nil {
		return m.BufferData
	}
	return nil
}

func (m *ConfigGen) GetGuildRankPrizeData() []*GuildRankPrizeDataProto {
	if m != nil {
		return m.GuildRankPrizeData
	}
	return nil
}

func (m *ConfigGen) GetChargePrizeData() []*ChargePrizeDataProto {
	if m != nil {
		return m.ChargePrizeData
	}
	return nil
}

func (m *ConfigGen) GetSpCollectionData() []*SpCollectionDataProto {
	if m != nil {
		return m.SpCollectionData
	}
	return nil
}

func (m *ConfigGen) GetStrategyEffectData() []*StrategyEffectDataProto {
	if m != nil {
		return m.StrategyEffectData
	}
	return nil
}

func (m *ConfigGen) GetDailyBargainData() []*DailyBargainDataProto {
	if m != nil {
		return m.DailyBargainData
	}
	return nil
}

func (m *ConfigGen) GetDurationCardData() []*DurationCardDataProto {
	if m != nil {
		return m.DurationCardData
	}
	return nil
}

func (m *ConfigGen) GetCombatMiscConfig() *CombatMiscConfigProto {
	if m != nil {
		return m.CombatMiscConfig
	}
	return nil
}

func (m *ConfigGen) GetFreeGiftData() []*FreeGiftDataProto {
	if m != nil {
		return m.FreeGiftData
	}
	return nil
}

func (m *ConfigGen) GetChargeObjData() []*ChargeObjDataProto {
	if m != nil {
		return m.ChargeObjData
	}
	return nil
}

func (m *ConfigGen) GetBuffEffectData() []*BuffEffectDataProto {
	if m != nil {
		return m.BuffEffectData
	}
	return nil
}

func (m *ConfigGen) GetAssemblyData() []*AssemblyDataProto {
	if m != nil {
		return m.AssemblyData
	}
	return nil
}

func (m *ConfigGen) GetJunTuanNpcData() []*JunTuanNpcDataProto {
	if m != nil {
		return m.JunTuanNpcData
	}
	return nil
}

func (m *ConfigGen) GetProsperityDamageBuffData() []*ProsperityDamageBuffDataProto {
	if m != nil {
		return m.ProsperityDamageBuffData
	}
	return nil
}

func (m *ConfigGen) GetBufferTypeData() []*BufferTypeDataProto {
	if m != nil {
		return m.BufferTypeData
	}
	return nil
}

func (m *ConfigGen) GetVipContinueDaysData() []*VipContinueDaysDataProto {
	if m != nil {
		return m.VipContinueDaysData
	}
	return nil
}

func (m *ConfigGen) GetVipLevelData() []*VipLevelDataProto {
	if m != nil {
		return m.VipLevelData
	}
	return nil
}

func (m *ConfigGen) GetVipMiscData() *VipMiscDataProto {
	if m != nil {
		return m.VipMiscData
	}
	return nil
}

func (m *ConfigGen) GetPrivacySettingData() []*PrivacySettingDataProto {
	if m != nil {
		return m.PrivacySettingData
	}
	return nil
}

func (m *ConfigGen) GetTimeLimitGiftData() []*TimeLimitGiftDataProto {
	if m != nil {
		return m.TimeLimitGiftData
	}
	return nil
}

func (m *ConfigGen) GetEventLimitGiftData() []*EventLimitGiftDataProto {
	if m != nil {
		return m.EventLimitGiftData
	}
	return nil
}

func (m *ConfigGen) GetMcBuildAddSupportData() []*McBuildAddSupportDataProto {
	if m != nil {
		return m.McBuildAddSupportData
	}
	return nil
}

func (m *ConfigGen) GetMcBuildGuildMemberPrizeData() []*McBuildGuildMemberPrizeDataProto {
	if m != nil {
		return m.McBuildGuildMemberPrizeData
	}
	return nil
}

func (m *ConfigGen) GetMcBuildMcSupportData() []*McBuildMcSupportDataProto {
	if m != nil {
		return m.McBuildMcSupportData
	}
	return nil
}

func (m *ConfigGen) GetMcBuildMiscData() *McBuildMiscDataProto {
	if m != nil {
		return m.McBuildMiscData
	}
	return nil
}

func (m *ConfigGen) GetCaptainFriendshipData() []*CaptainFriendshipDataProto {
	if m != nil {
		return m.CaptainFriendshipData
	}
	return nil
}

func (m *ConfigGen) GetRedPacketData() []*RedPacketDataProto {
	if m != nil {
		return m.RedPacketData
	}
	return nil
}

func (m *ConfigGen) GetTroopDialogueData() []*TroopDialogueDataProto {
	if m != nil {
		return m.TroopDialogueData
	}
	return nil
}

func (m *ConfigGen) GetTroopDialogueTextData() []*TroopDialogueTextDataProto {
	if m != nil {
		return m.TroopDialogueTextData
	}
	return nil
}

func (m *ConfigGen) GetCountryOfficialData() []*CountryOfficialDataProto {
	if m != nil {
		return m.CountryOfficialData
	}
	return nil
}

func (m *ConfigGen) GetCountryOfficialNpcData() []*CountryOfficialNpcDataProto {
	if m != nil {
		return m.CountryOfficialNpcData
	}
	return nil
}

func (m *ConfigGen) GetRegionAreaData() []*RegionAreaDataProto {
	if m != nil {
		return m.RegionAreaData
	}
	return nil
}

func (m *ConfigGen) GetFishingCaptainProbabilityData() []*FishingCaptainProbabilityDataProto {
	if m != nil {
		return m.FishingCaptainProbabilityData
	}
	return nil
}

// 活动/收集活动.txt
type ActivityCollectionDataProto struct {
	Id         int32                          `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	Name       string                         `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty"`
	NameIcon   string                         `protobuf:"bytes,4,opt,name=name_icon,json=nameIcon,proto3" json:"name_icon,omitempty"`
	TimeShow   string                         `protobuf:"bytes,10,opt,name=time_show,json=timeShow,proto3" json:"time_show,omitempty"`
	Desc       string                         `protobuf:"bytes,1,opt,name=desc,proto3" json:"desc,omitempty"`
	Icon       string                         `protobuf:"bytes,8,opt,name=icon,proto3" json:"icon,omitempty"`
	IconSelect string                         `protobuf:"bytes,9,opt,name=icon_select,json=iconSelect,proto3" json:"icon_select,omitempty"`
	Image      string                         `protobuf:"bytes,5,opt,name=image,proto3" json:"image,omitempty"`
	Sort       int32                          `protobuf:"varint,6,opt,name=sort,proto3" json:"sort,omitempty"`
	Exchanges  []*CollectionExchangeDataProto `protobuf:"bytes,2,rep,name=exchanges" json:"exchanges,omitempty"`
}

func (m *ActivityCollectionDataProto) Reset()         { *m = ActivityCollectionDataProto{} }
func (m *ActivityCollectionDataProto) String() string { return proto.CompactTextString(m) }
func (*ActivityCollectionDataProto) ProtoMessage()    {}
func (*ActivityCollectionDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{1}
}

func (m *ActivityCollectionDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ActivityCollectionDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ActivityCollectionDataProto) GetNameIcon() string {
	if m != nil {
		return m.NameIcon
	}
	return ""
}

func (m *ActivityCollectionDataProto) GetTimeShow() string {
	if m != nil {
		return m.TimeShow
	}
	return ""
}

func (m *ActivityCollectionDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *ActivityCollectionDataProto) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *ActivityCollectionDataProto) GetIconSelect() string {
	if m != nil {
		return m.IconSelect
	}
	return ""
}

func (m *ActivityCollectionDataProto) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ActivityCollectionDataProto) GetSort() int32 {
	if m != nil {
		return m.Sort
	}
	return 0
}

func (m *ActivityCollectionDataProto) GetExchanges() []*CollectionExchangeDataProto {
	if m != nil {
		return m.Exchanges
	}
	return nil
}

// 活动/活动展示.txt
type ActivityShowDataProto struct {
	Id                  int32          `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	SpineId             int32          `protobuf:"varint,19,opt,name=spine_id,json=spineId,proto3" json:"spine_id,omitempty"`
	Name                string         `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	NameIcon            string         `protobuf:"bytes,13,opt,name=name_icon,json=nameIcon,proto3" json:"name_icon,omitempty"`
	TimeShow            string         `protobuf:"bytes,4,opt,name=time_show,json=timeShow,proto3" json:"time_show,omitempty"`
	Desc                string         `protobuf:"bytes,5,opt,name=desc,proto3" json:"desc,omitempty"`
	PrizeDesc           string         `protobuf:"bytes,6,opt,name=prize_desc,json=prizeDesc,proto3" json:"prize_desc,omitempty"`
	Icon                string         `protobuf:"bytes,7,opt,name=icon,proto3" json:"icon,omitempty"`
	IconSelect          string         `protobuf:"bytes,8,opt,name=icon_select,json=iconSelect,proto3" json:"icon_select,omitempty"`
	ShowCountdown       bool           `protobuf:"varint,9,opt,name=show_countdown,json=showCountdown,proto3" json:"show_countdown,omitempty"`
	Sort                int32          `protobuf:"varint,10,opt,name=sort,proto3" json:"sort,omitempty"`
	Image               string         `protobuf:"bytes,11,opt,name=image,proto3" json:"image,omitempty"`
	ImagePos            int32          `protobuf:"varint,12,opt,name=image_pos,json=imagePos,proto3" json:"image_pos,omitempty"`
	LinkName            string         `protobuf:"bytes,14,opt,name=link_name,json=linkName,proto3" json:"link_name,omitempty"`
	LinkTargetType      TaskTargetType `protobuf:"varint,16,opt,name=link_target_type,json=linkTargetType,proto3,enum=proto.TaskTargetType" json:"link_target_type,omitempty"`
	LinkTargetSubType   int32          `protobuf:"varint,17,opt,name=link_target_sub_type,json=linkTargetSubType,proto3" json:"link_target_sub_type,omitempty"`
	LinkTargetSubTypeId int32          `protobuf:"varint,18,opt,name=link_target_sub_type_id,json=linkTargetSubTypeId,proto3" json:"link_target_sub_type_id,omitempty"`
}

func (m *ActivityShowDataProto) Reset()                    { *m = ActivityShowDataProto{} }
func (m *ActivityShowDataProto) String() string            { return proto.CompactTextString(m) }
func (*ActivityShowDataProto) ProtoMessage()               {}
func (*ActivityShowDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{2} }

func (m *ActivityShowDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ActivityShowDataProto) GetSpineId() int32 {
	if m != nil {
		return m.SpineId
	}
	return 0
}

func (m *ActivityShowDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ActivityShowDataProto) GetNameIcon() string {
	if m != nil {
		return m.NameIcon
	}
	return ""
}

func (m *ActivityShowDataProto) GetTimeShow() string {
	if m != nil {
		return m.TimeShow
	}
	return ""
}

func (m *ActivityShowDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *ActivityShowDataProto) GetPrizeDesc() string {
	if m != nil {
		return m.PrizeDesc
	}
	return ""
}

func (m *ActivityShowDataProto) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *ActivityShowDataProto) GetIconSelect() string {
	if m != nil {
		return m.IconSelect
	}
	return ""
}

func (m *ActivityShowDataProto) GetShowCountdown() bool {
	if m != nil {
		return m.ShowCountdown
	}
	return false
}

func (m *ActivityShowDataProto) GetSort() int32 {
	if m != nil {
		return m.Sort
	}
	return 0
}

func (m *ActivityShowDataProto) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ActivityShowDataProto) GetImagePos() int32 {
	if m != nil {
		return m.ImagePos
	}
	return 0
}

func (m *ActivityShowDataProto) GetLinkName() string {
	if m != nil {
		return m.LinkName
	}
	return ""
}

func (m *ActivityShowDataProto) GetLinkTargetType() TaskTargetType {
	if m != nil {
		return m.LinkTargetType
	}
	return TaskTargetType_InvalidTaskTargetType
}

func (m *ActivityShowDataProto) GetLinkTargetSubType() int32 {
	if m != nil {
		return m.LinkTargetSubType
	}
	return 0
}

func (m *ActivityShowDataProto) GetLinkTargetSubTypeId() int32 {
	if m != nil {
		return m.LinkTargetSubTypeId
	}
	return 0
}

// 活动/活动任务.txt
type ActivityTaskDataProto struct {
	Id     int32            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name   string           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Text   string           `protobuf:"bytes,3,opt,name=text,proto3" json:"text,omitempty"`
	Target *TaskTargetProto `protobuf:"bytes,4,opt,name=target" json:"target,omitempty"`
	Link   string           `protobuf:"bytes,5,opt,name=link,proto3" json:"link,omitempty"`
	Prize  *PrizeProto      `protobuf:"bytes,6,opt,name=prize" json:"prize,omitempty"`
}

func (m *ActivityTaskDataProto) Reset()                    { *m = ActivityTaskDataProto{} }
func (m *ActivityTaskDataProto) String() string            { return proto.CompactTextString(m) }
func (*ActivityTaskDataProto) ProtoMessage()               {}
func (*ActivityTaskDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{3} }

func (m *ActivityTaskDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ActivityTaskDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ActivityTaskDataProto) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *ActivityTaskDataProto) GetTarget() *TaskTargetProto {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *ActivityTaskDataProto) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *ActivityTaskDataProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

// 活动/列表式任务活动.txt
type ActivityTaskListModeDataProto struct {
	Name       string                   `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	NameIcon   string                   `protobuf:"bytes,1,opt,name=name_icon,json=nameIcon,proto3" json:"name_icon,omitempty"`
	TimeShow   string                   `protobuf:"bytes,9,opt,name=time_show,json=timeShow,proto3" json:"time_show,omitempty"`
	Desc       string                   `protobuf:"bytes,6,opt,name=desc,proto3" json:"desc,omitempty"`
	Icon       string                   `protobuf:"bytes,7,opt,name=icon,proto3" json:"icon,omitempty"`
	IconSelect string                   `protobuf:"bytes,8,opt,name=icon_select,json=iconSelect,proto3" json:"icon_select,omitempty"`
	Image      string                   `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	Sort       int32                    `protobuf:"varint,4,opt,name=sort,proto3" json:"sort,omitempty"`
	Tasks      []*ActivityTaskDataProto `protobuf:"bytes,3,rep,name=tasks" json:"tasks,omitempty"`
}

func (m *ActivityTaskListModeDataProto) Reset()         { *m = ActivityTaskListModeDataProto{} }
func (m *ActivityTaskListModeDataProto) String() string { return proto.CompactTextString(m) }
func (*ActivityTaskListModeDataProto) ProtoMessage()    {}
func (*ActivityTaskListModeDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{4}
}

func (m *ActivityTaskListModeDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ActivityTaskListModeDataProto) GetNameIcon() string {
	if m != nil {
		return m.NameIcon
	}
	return ""
}

func (m *ActivityTaskListModeDataProto) GetTimeShow() string {
	if m != nil {
		return m.TimeShow
	}
	return ""
}

func (m *ActivityTaskListModeDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *ActivityTaskListModeDataProto) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *ActivityTaskListModeDataProto) GetIconSelect() string {
	if m != nil {
		return m.IconSelect
	}
	return ""
}

func (m *ActivityTaskListModeDataProto) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ActivityTaskListModeDataProto) GetSort() int32 {
	if m != nil {
		return m.Sort
	}
	return 0
}

func (m *ActivityTaskListModeDataProto) GetTasks() []*ActivityTaskDataProto {
	if m != nil {
		return m.Tasks
	}
	return nil
}

// 地图/区块链.txt
type AreaDataProto struct {
	CenterX   int32 `protobuf:"varint,1,opt,name=center_x,json=centerX,proto3" json:"center_x,omitempty"`
	CenterY   int32 `protobuf:"varint,2,opt,name=center_y,json=centerY,proto3" json:"center_y,omitempty"`
	MinRadius int32 `protobuf:"varint,3,opt,name=min_radius,json=minRadius,proto3" json:"min_radius,omitempty"`
	MaxRadius int32 `protobuf:"varint,4,opt,name=max_radius,json=maxRadius,proto3" json:"max_radius,omitempty"`
}

func (m *AreaDataProto) Reset()                    { *m = AreaDataProto{} }
func (m *AreaDataProto) String() string            { return proto.CompactTextString(m) }
func (*AreaDataProto) ProtoMessage()               {}
func (*AreaDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{5} }

func (m *AreaDataProto) GetCenterX() int32 {
	if m != nil {
		return m.CenterX
	}
	return 0
}

func (m *AreaDataProto) GetCenterY() int32 {
	if m != nil {
		return m.CenterY
	}
	return 0
}

func (m *AreaDataProto) GetMinRadius() int32 {
	if m != nil {
		return m.MinRadius
	}
	return 0
}

func (m *AreaDataProto) GetMaxRadius() int32 {
	if m != nil {
		return m.MaxRadius
	}
	return 0
}

// 武将/武将星数.txt
type CaptainStarDataProto struct {
	Star      int32            `protobuf:"varint,1,opt,name=star,proto3" json:"star,omitempty"`
	Coef      int32            `protobuf:"varint,4,opt,name=coef,proto3" json:"coef,omitempty"`
	AddedStat *SpriteStatProto `protobuf:"bytes,5,opt,name=added_stat,json=addedStat" json:"added_stat,omitempty"`
	Cost      *CostProto       `protobuf:"bytes,2,opt,name=cost" json:"cost,omitempty"`
	Spell     []int32          `protobuf:"varint,3,rep,name=spell" json:"spell,omitempty"`
}

func (m *CaptainStarDataProto) Reset()                    { *m = CaptainStarDataProto{} }
func (m *CaptainStarDataProto) String() string            { return proto.CompactTextString(m) }
func (*CaptainStarDataProto) ProtoMessage()               {}
func (*CaptainStarDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{6} }

func (m *CaptainStarDataProto) GetStar() int32 {
	if m != nil {
		return m.Star
	}
	return 0
}

func (m *CaptainStarDataProto) GetCoef() int32 {
	if m != nil {
		return m.Coef
	}
	return 0
}

func (m *CaptainStarDataProto) GetAddedStat() *SpriteStatProto {
	if m != nil {
		return m.AddedStat
	}
	return nil
}

func (m *CaptainStarDataProto) GetCost() *CostProto {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *CaptainStarDataProto) GetSpell() []int32 {
	if m != nil {
		return m.Spell
	}
	return nil
}

// 活动/收集兑换.txt
type CollectionExchangeDataProto struct {
	Id      int32                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Combine *GoodsCombineDataProto `protobuf:"bytes,2,opt,name=combine" json:"combine,omitempty"`
	Limit   int32                  `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *CollectionExchangeDataProto) Reset()         { *m = CollectionExchangeDataProto{} }
func (m *CollectionExchangeDataProto) String() string { return proto.CompactTextString(m) }
func (*CollectionExchangeDataProto) ProtoMessage()    {}
func (*CollectionExchangeDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{7}
}

func (m *CollectionExchangeDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CollectionExchangeDataProto) GetCombine() *GoodsCombineDataProto {
	if m != nil {
		return m.Combine
	}
	return nil
}

func (m *CollectionExchangeDataProto) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// 战斗/杂项.txt
type CombatConfigProto struct {
	Spell                      []*SpellDataProto           `protobuf:"bytes,1,rep,name=spell" json:"spell,omitempty"`
	State                      []*StateDataProto           `protobuf:"bytes,2,rep,name=state" json:"state,omitempty"`
	PassiveSpell               []*PassiveSpellDataProto    `protobuf:"bytes,3,rep,name=passive_spell,json=passiveSpell" json:"passive_spell,omitempty"`
	SpellIdMap                 []*SpellIdProto             `protobuf:"bytes,4,rep,name=spell_id_map,json=spellIdMap" json:"spell_id_map,omitempty"`
	Captain                    []*CaptainDataProto         `protobuf:"bytes,5,rep,name=captain" json:"captain,omitempty"`
	NamelessCaptain            []*NamelessCaptainDataProto `protobuf:"bytes,6,rep,name=nameless_captain,json=namelessCaptain" json:"nameless_captain,omitempty"`
	Race                       []*RaceDataProto            `protobuf:"bytes,7,rep,name=race" json:"race,omitempty"`
	FramePerSecond             int32                       `protobuf:"varint,8,opt,name=frame_per_second,json=framePerSecond,proto3" json:"frame_per_second,omitempty"`
	ConfigDenominator          int32                       `protobuf:"varint,9,opt,name=config_denominator,json=configDenominator,proto3" json:"config_denominator,omitempty"`
	MinAttackDuration          int32                       `protobuf:"varint,10,opt,name=min_attack_duration,json=minAttackDuration,proto3" json:"min_attack_duration,omitempty"`
	MaxAttackDuration          int32                       `protobuf:"varint,11,opt,name=max_attack_duration,json=maxAttackDuration,proto3" json:"max_attack_duration,omitempty"`
	MinMoveSpeed               int32                       `protobuf:"varint,12,opt,name=min_move_speed,json=minMoveSpeed,proto3" json:"min_move_speed,omitempty"`
	MaxMoveSpeed               int32                       `protobuf:"varint,13,opt,name=max_move_speed,json=maxMoveSpeed,proto3" json:"max_move_speed,omitempty"`
	MinStat                    *SpriteStatProto            `protobuf:"bytes,14,opt,name=min_stat,json=minStat" json:"min_stat,omitempty"`
	MaxDuration                int32                       `protobuf:"varint,15,opt,name=max_duration,json=maxDuration,proto3" json:"max_duration,omitempty"`
	ScorePercent               []int32                     `protobuf:"varint,16,rep,name=score_percent,json=scorePercent" json:"score_percent,omitempty"`
	CheckMoveDuration          int32                       `protobuf:"varint,17,opt,name=check_move_duration,json=checkMoveDuration,proto3" json:"check_move_duration,omitempty"`
	CritRate                   int32                       `protobuf:"varint,18,opt,name=crit_rate,json=critRate,proto3" json:"crit_rate,omitempty"`
	Coef                       int32                       `protobuf:"varint,19,opt,name=coef,proto3" json:"coef,omitempty"`
	CellLen                    int32                       `protobuf:"varint,20,opt,name=cell_len,json=cellLen,proto3" json:"cell_len,omitempty"`
	MaxRage                    int32                       `protobuf:"varint,21,opt,name=max_rage,json=maxRage,proto3" json:"max_rage,omitempty"`
	AddRagePerHint             int32                       `protobuf:"varint,22,opt,name=add_rage_per_hint,json=addRagePerHint,proto3" json:"add_rage_per_hint,omitempty"`
	AddRageLost1Percent        int32                       `protobuf:"varint,23,opt,name=add_rage_lost1_percent,json=addRageLost1Percent,proto3" json:"add_rage_lost1_percent,omitempty"`
	RageRecoverSpeed           int32                       `protobuf:"varint,24,opt,name=rage_recover_speed,json=rageRecoverSpeed,proto3" json:"rage_recover_speed,omitempty"`
	InitAttackerX              int32                       `protobuf:"varint,30,opt,name=init_attacker_x,json=initAttackerX,proto3" json:"init_attacker_x,omitempty"`
	InitDefenserX              int32                       `protobuf:"varint,31,opt,name=init_defenser_x,json=initDefenserX,proto3" json:"init_defenser_x,omitempty"`
	InitWallX                  int32                       `protobuf:"varint,32,opt,name=init_wall_x,json=initWallX,proto3" json:"init_wall_x,omitempty"`
	WallWaitDuration           int32                       `protobuf:"varint,25,opt,name=wall_wait_duration,json=wallWaitDuration,proto3" json:"wall_wait_duration,omitempty"`
	WallAttackFixDamageTimes   int32                       `protobuf:"varint,26,opt,name=wall_attack_fix_damage_times,json=wallAttackFixDamageTimes,proto3" json:"wall_attack_fix_damage_times,omitempty"`
	WallBeenHurtLostMaxPercent int32                       `protobuf:"varint,27,opt,name=wall_been_hurt_lost_max_percent,json=wallBeenHurtLostMaxPercent,proto3" json:"wall_been_hurt_lost_max_percent,omitempty"`
	WallSpell                  int32                       `protobuf:"varint,28,opt,name=wall_spell,json=wallSpell,proto3" json:"wall_spell,omitempty"`
	WallFlyMinDuration         int32                       `protobuf:"varint,33,opt,name=wall_fly_min_duration,json=wallFlyMinDuration,proto3" json:"wall_fly_min_duration,omitempty"`
	ShortMoveDistance          int32                       `protobuf:"varint,29,opt,name=short_move_distance,json=shortMoveDistance,proto3" json:"short_move_distance,omitempty"`
}

func (m *CombatConfigProto) Reset()                    { *m = CombatConfigProto{} }
func (m *CombatConfigProto) String() string            { return proto.CompactTextString(m) }
func (*CombatConfigProto) ProtoMessage()               {}
func (*CombatConfigProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{8} }

func (m *CombatConfigProto) GetSpell() []*SpellDataProto {
	if m != nil {
		return m.Spell
	}
	return nil
}

func (m *CombatConfigProto) GetState() []*StateDataProto {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *CombatConfigProto) GetPassiveSpell() []*PassiveSpellDataProto {
	if m != nil {
		return m.PassiveSpell
	}
	return nil
}

func (m *CombatConfigProto) GetSpellIdMap() []*SpellIdProto {
	if m != nil {
		return m.SpellIdMap
	}
	return nil
}

func (m *CombatConfigProto) GetCaptain() []*CaptainDataProto {
	if m != nil {
		return m.Captain
	}
	return nil
}

func (m *CombatConfigProto) GetNamelessCaptain() []*NamelessCaptainDataProto {
	if m != nil {
		return m.NamelessCaptain
	}
	return nil
}

func (m *CombatConfigProto) GetRace() []*RaceDataProto {
	if m != nil {
		return m.Race
	}
	return nil
}

func (m *CombatConfigProto) GetFramePerSecond() int32 {
	if m != nil {
		return m.FramePerSecond
	}
	return 0
}

func (m *CombatConfigProto) GetConfigDenominator() int32 {
	if m != nil {
		return m.ConfigDenominator
	}
	return 0
}

func (m *CombatConfigProto) GetMinAttackDuration() int32 {
	if m != nil {
		return m.MinAttackDuration
	}
	return 0
}

func (m *CombatConfigProto) GetMaxAttackDuration() int32 {
	if m != nil {
		return m.MaxAttackDuration
	}
	return 0
}

func (m *CombatConfigProto) GetMinMoveSpeed() int32 {
	if m != nil {
		return m.MinMoveSpeed
	}
	return 0
}

func (m *CombatConfigProto) GetMaxMoveSpeed() int32 {
	if m != nil {
		return m.MaxMoveSpeed
	}
	return 0
}

func (m *CombatConfigProto) GetMinStat() *SpriteStatProto {
	if m != nil {
		return m.MinStat
	}
	return nil
}

func (m *CombatConfigProto) GetMaxDuration() int32 {
	if m != nil {
		return m.MaxDuration
	}
	return 0
}

func (m *CombatConfigProto) GetScorePercent() []int32 {
	if m != nil {
		return m.ScorePercent
	}
	return nil
}

func (m *CombatConfigProto) GetCheckMoveDuration() int32 {
	if m != nil {
		return m.CheckMoveDuration
	}
	return 0
}

func (m *CombatConfigProto) GetCritRate() int32 {
	if m != nil {
		return m.CritRate
	}
	return 0
}

func (m *CombatConfigProto) GetCoef() int32 {
	if m != nil {
		return m.Coef
	}
	return 0
}

func (m *CombatConfigProto) GetCellLen() int32 {
	if m != nil {
		return m.CellLen
	}
	return 0
}

func (m *CombatConfigProto) GetMaxRage() int32 {
	if m != nil {
		return m.MaxRage
	}
	return 0
}

func (m *CombatConfigProto) GetAddRagePerHint() int32 {
	if m != nil {
		return m.AddRagePerHint
	}
	return 0
}

func (m *CombatConfigProto) GetAddRageLost1Percent() int32 {
	if m != nil {
		return m.AddRageLost1Percent
	}
	return 0
}

func (m *CombatConfigProto) GetRageRecoverSpeed() int32 {
	if m != nil {
		return m.RageRecoverSpeed
	}
	return 0
}

func (m *CombatConfigProto) GetInitAttackerX() int32 {
	if m != nil {
		return m.InitAttackerX
	}
	return 0
}

func (m *CombatConfigProto) GetInitDefenserX() int32 {
	if m != nil {
		return m.InitDefenserX
	}
	return 0
}

func (m *CombatConfigProto) GetInitWallX() int32 {
	if m != nil {
		return m.InitWallX
	}
	return 0
}

func (m *CombatConfigProto) GetWallWaitDuration() int32 {
	if m != nil {
		return m.WallWaitDuration
	}
	return 0
}

func (m *CombatConfigProto) GetWallAttackFixDamageTimes() int32 {
	if m != nil {
		return m.WallAttackFixDamageTimes
	}
	return 0
}

func (m *CombatConfigProto) GetWallBeenHurtLostMaxPercent() int32 {
	if m != nil {
		return m.WallBeenHurtLostMaxPercent
	}
	return 0
}

func (m *CombatConfigProto) GetWallSpell() int32 {
	if m != nil {
		return m.WallSpell
	}
	return 0
}

func (m *CombatConfigProto) GetWallFlyMinDuration() int32 {
	if m != nil {
		return m.WallFlyMinDuration
	}
	return 0
}

func (m *CombatConfigProto) GetShortMoveDistance() int32 {
	if m != nil {
		return m.ShortMoveDistance
	}
	return 0
}

// 战斗/被动技能.txt
type PassiveSpellDataProto struct {
	Id                    int32                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Animation             int32                 `protobuf:"varint,2,opt,name=animation,proto3" json:"animation,omitempty"`
	TriggerRate           int32                 `protobuf:"varint,3,opt,name=trigger_rate,json=triggerRate,proto3" json:"trigger_rate,omitempty"`
	TriggerType           SpellTriggerType      `protobuf:"varint,4,opt,name=trigger_type,json=triggerType,proto3,enum=proto.SpellTriggerType" json:"trigger_type,omitempty"`
	TriggerTarget         *SpellTargetDataProto `protobuf:"bytes,5,opt,name=trigger_target,json=triggerTarget" json:"trigger_target,omitempty"`
	TriggerHit            int32                 `protobuf:"varint,6,opt,name=trigger_hit,json=triggerHit,proto3" json:"trigger_hit,omitempty"`
	TargetCooldown        int32                 `protobuf:"varint,17,opt,name=target_cooldown,json=targetCooldown,proto3" json:"target_cooldown,omitempty"`
	SelfState             []int32               `protobuf:"varint,7,rep,name=self_state,json=selfState" json:"self_state,omitempty"`
	TargetState           []int32               `protobuf:"varint,8,rep,name=target_state,json=targetState" json:"target_state,omitempty"`
	Spell                 int32                 `protobuf:"varint,9,opt,name=spell,proto3" json:"spell,omitempty"`
	ExciteEffectType      int32                 `protobuf:"varint,10,opt,name=excite_effect_type,json=exciteEffectType,proto3" json:"excite_effect_type,omitempty"`
	Rage                  int32                 `protobuf:"varint,11,opt,name=rage,proto3" json:"rage,omitempty"`
	SpriteStat            *SpriteStatProto      `protobuf:"bytes,12,opt,name=sprite_stat,json=spriteStat" json:"sprite_stat,omitempty"`
	BeenHurtEffectIncType []int32               `protobuf:"varint,13,rep,name=been_hurt_effect_inc_type,json=beenHurtEffectIncType" json:"been_hurt_effect_inc_type,omitempty"`
	BeenHurtEffectInc     []int32               `protobuf:"varint,14,rep,name=been_hurt_effect_inc,json=beenHurtEffectInc" json:"been_hurt_effect_inc,omitempty"`
	BeenHurtEffectDecType []int32               `protobuf:"varint,15,rep,name=been_hurt_effect_dec_type,json=beenHurtEffectDecType" json:"been_hurt_effect_dec_type,omitempty"`
	BeenHurtEffectDec     []int32               `protobuf:"varint,16,rep,name=been_hurt_effect_dec,json=beenHurtEffectDec" json:"been_hurt_effect_dec,omitempty"`
	RelivePercent         int32                 `protobuf:"varint,18,opt,name=relive_percent,json=relivePercent,proto3" json:"relive_percent,omitempty"`
}

func (m *PassiveSpellDataProto) Reset()                    { *m = PassiveSpellDataProto{} }
func (m *PassiveSpellDataProto) String() string            { return proto.CompactTextString(m) }
func (*PassiveSpellDataProto) ProtoMessage()               {}
func (*PassiveSpellDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{9} }

func (m *PassiveSpellDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PassiveSpellDataProto) GetAnimation() int32 {
	if m != nil {
		return m.Animation
	}
	return 0
}

func (m *PassiveSpellDataProto) GetTriggerRate() int32 {
	if m != nil {
		return m.TriggerRate
	}
	return 0
}

func (m *PassiveSpellDataProto) GetTriggerType() SpellTriggerType {
	if m != nil {
		return m.TriggerType
	}
	return SpellTriggerType_STNone
}

func (m *PassiveSpellDataProto) GetTriggerTarget() *SpellTargetDataProto {
	if m != nil {
		return m.TriggerTarget
	}
	return nil
}

func (m *PassiveSpellDataProto) GetTriggerHit() int32 {
	if m != nil {
		return m.TriggerHit
	}
	return 0
}

func (m *PassiveSpellDataProto) GetTargetCooldown() int32 {
	if m != nil {
		return m.TargetCooldown
	}
	return 0
}

func (m *PassiveSpellDataProto) GetSelfState() []int32 {
	if m != nil {
		return m.SelfState
	}
	return nil
}

func (m *PassiveSpellDataProto) GetTargetState() []int32 {
	if m != nil {
		return m.TargetState
	}
	return nil
}

func (m *PassiveSpellDataProto) GetSpell() int32 {
	if m != nil {
		return m.Spell
	}
	return 0
}

func (m *PassiveSpellDataProto) GetExciteEffectType() int32 {
	if m != nil {
		return m.ExciteEffectType
	}
	return 0
}

func (m *PassiveSpellDataProto) GetRage() int32 {
	if m != nil {
		return m.Rage
	}
	return 0
}

func (m *PassiveSpellDataProto) GetSpriteStat() *SpriteStatProto {
	if m != nil {
		return m.SpriteStat
	}
	return nil
}

func (m *PassiveSpellDataProto) GetBeenHurtEffectIncType() []int32 {
	if m != nil {
		return m.BeenHurtEffectIncType
	}
	return nil
}

func (m *PassiveSpellDataProto) GetBeenHurtEffectInc() []int32 {
	if m != nil {
		return m.BeenHurtEffectInc
	}
	return nil
}

func (m *PassiveSpellDataProto) GetBeenHurtEffectDecType() []int32 {
	if m != nil {
		return m.BeenHurtEffectDecType
	}
	return nil
}

func (m *PassiveSpellDataProto) GetBeenHurtEffectDec() []int32 {
	if m != nil {
		return m.BeenHurtEffectDec
	}
	return nil
}

func (m *PassiveSpellDataProto) GetRelivePercent() int32 {
	if m != nil {
		return m.RelivePercent
	}
	return 0
}

// 战斗/技能.txt
type SpellDataProto struct {
	Id              int32                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name            string                `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Animation       int32                 `protobuf:"varint,3,opt,name=animation,proto3" json:"animation,omitempty"`
	Cooldown        int32                 `protobuf:"varint,4,opt,name=cooldown,proto3" json:"cooldown,omitempty"`
	StrongeDuration int32                 `protobuf:"varint,5,opt,name=stronge_duration,json=strongeDuration,proto3" json:"stronge_duration,omitempty"`
	RageSpell       bool                  `protobuf:"varint,6,opt,name=rage_spell,json=rageSpell,proto3" json:"rage_spell,omitempty"`
	KeepMove        bool                  `protobuf:"varint,7,opt,name=keep_move,json=keepMove,proto3" json:"keep_move,omitempty"`
	FriendSpell     bool                  `protobuf:"varint,8,opt,name=friend_spell,json=friendSpell,proto3" json:"friend_spell,omitempty"`
	SelfAsTarget    bool                  `protobuf:"varint,9,opt,name=self_as_target,json=selfAsTarget,proto3" json:"self_as_target,omitempty"`
	TargetSubType   SpellTargetSubType    `protobuf:"varint,10,opt,name=target_sub_type,json=targetSubType,proto3,enum=proto.SpellTargetSubType" json:"target_sub_type,omitempty"`
	Target          *SpellTargetDataProto `protobuf:"bytes,11,opt,name=target" json:"target,omitempty"`
	ReleaseRange    int32                 `protobuf:"varint,12,opt,name=release_range,json=releaseRange,proto3" json:"release_range,omitempty"`
	HurtRange       int32                 `protobuf:"varint,13,opt,name=hurt_range,json=hurtRange,proto3" json:"hurt_range,omitempty"`
	HurtCount       int32                 `protobuf:"varint,14,opt,name=hurt_count,json=hurtCount,proto3" json:"hurt_count,omitempty"`
	HurtType        int32                 `protobuf:"varint,25,opt,name=hurt_type,json=hurtType,proto3" json:"hurt_type,omitempty"`
	Coef            int32                 `protobuf:"varint,15,opt,name=coef,proto3" json:"coef,omitempty"`
	FlySpeed        int32                 `protobuf:"varint,24,opt,name=fly_speed,json=flySpeed,proto3" json:"fly_speed,omitempty"`
	EffectType      int32                 `protobuf:"varint,17,opt,name=effect_type,json=effectType,proto3" json:"effect_type,omitempty"`
	SelfState       []int32               `protobuf:"varint,18,rep,name=self_state,json=selfState" json:"self_state,omitempty"`
	SelfStateRate   []int32               `protobuf:"varint,19,rep,name=self_state_rate,json=selfStateRate" json:"self_state_rate,omitempty"`
	TargetState     []int32               `protobuf:"varint,20,rep,name=target_state,json=targetState" json:"target_state,omitempty"`
	TargetStateRate []int32               `protobuf:"varint,21,rep,name=target_state_rate,json=targetStateRate" json:"target_state_rate,omitempty"`
	SelfRage        int32                 `protobuf:"varint,22,opt,name=self_rage,json=selfRage,proto3" json:"self_rage,omitempty"`
	TargetRage      int32                 `protobuf:"varint,23,opt,name=target_rage,json=targetRage,proto3" json:"target_rage,omitempty"`
}

func (m *SpellDataProto) Reset()                    { *m = SpellDataProto{} }
func (m *SpellDataProto) String() string            { return proto.CompactTextString(m) }
func (*SpellDataProto) ProtoMessage()               {}
func (*SpellDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{10} }

func (m *SpellDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SpellDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SpellDataProto) GetAnimation() int32 {
	if m != nil {
		return m.Animation
	}
	return 0
}

func (m *SpellDataProto) GetCooldown() int32 {
	if m != nil {
		return m.Cooldown
	}
	return 0
}

func (m *SpellDataProto) GetStrongeDuration() int32 {
	if m != nil {
		return m.StrongeDuration
	}
	return 0
}

func (m *SpellDataProto) GetRageSpell() bool {
	if m != nil {
		return m.RageSpell
	}
	return false
}

func (m *SpellDataProto) GetKeepMove() bool {
	if m != nil {
		return m.KeepMove
	}
	return false
}

func (m *SpellDataProto) GetFriendSpell() bool {
	if m != nil {
		return m.FriendSpell
	}
	return false
}

func (m *SpellDataProto) GetSelfAsTarget() bool {
	if m != nil {
		return m.SelfAsTarget
	}
	return false
}

func (m *SpellDataProto) GetTargetSubType() SpellTargetSubType {
	if m != nil {
		return m.TargetSubType
	}
	return SpellTargetSubType_SSTNone
}

func (m *SpellDataProto) GetTarget() *SpellTargetDataProto {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *SpellDataProto) GetReleaseRange() int32 {
	if m != nil {
		return m.ReleaseRange
	}
	return 0
}

func (m *SpellDataProto) GetHurtRange() int32 {
	if m != nil {
		return m.HurtRange
	}
	return 0
}

func (m *SpellDataProto) GetHurtCount() int32 {
	if m != nil {
		return m.HurtCount
	}
	return 0
}

func (m *SpellDataProto) GetHurtType() int32 {
	if m != nil {
		return m.HurtType
	}
	return 0
}

func (m *SpellDataProto) GetCoef() int32 {
	if m != nil {
		return m.Coef
	}
	return 0
}

func (m *SpellDataProto) GetFlySpeed() int32 {
	if m != nil {
		return m.FlySpeed
	}
	return 0
}

func (m *SpellDataProto) GetEffectType() int32 {
	if m != nil {
		return m.EffectType
	}
	return 0
}

func (m *SpellDataProto) GetSelfState() []int32 {
	if m != nil {
		return m.SelfState
	}
	return nil
}

func (m *SpellDataProto) GetSelfStateRate() []int32 {
	if m != nil {
		return m.SelfStateRate
	}
	return nil
}

func (m *SpellDataProto) GetTargetState() []int32 {
	if m != nil {
		return m.TargetState
	}
	return nil
}

func (m *SpellDataProto) GetTargetStateRate() []int32 {
	if m != nil {
		return m.TargetStateRate
	}
	return nil
}

func (m *SpellDataProto) GetSelfRage() int32 {
	if m != nil {
		return m.SelfRage
	}
	return 0
}

func (m *SpellDataProto) GetTargetRage() int32 {
	if m != nil {
		return m.TargetRage
	}
	return 0
}

//
type SpellTargetDataProto struct {
	TargetRace          []Race `protobuf:"varint,1,rep,name=target_race,json=targetRace,enum=proto.Race" json:"target_race,omitempty"`
	TargetEffectType    int32  `protobuf:"varint,2,opt,name=target_effect_type,json=targetEffectType,proto3" json:"target_effect_type,omitempty"`
	TargetUnmovable     bool   `protobuf:"varint,3,opt,name=target_unmovable,json=targetUnmovable,proto3" json:"target_unmovable,omitempty"`
	TargetNotAttackable bool   `protobuf:"varint,4,opt,name=target_not_attackable,json=targetNotAttackable,proto3" json:"target_not_attackable,omitempty"`
	TargetSilence       bool   `protobuf:"varint,5,opt,name=target_silence,json=targetSilence,proto3" json:"target_silence,omitempty"`
	TargetStun          bool   `protobuf:"varint,6,opt,name=target_stun,json=targetStun,proto3" json:"target_stun,omitempty"`
}

func (m *SpellTargetDataProto) Reset()                    { *m = SpellTargetDataProto{} }
func (m *SpellTargetDataProto) String() string            { return proto.CompactTextString(m) }
func (*SpellTargetDataProto) ProtoMessage()               {}
func (*SpellTargetDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{11} }

func (m *SpellTargetDataProto) GetTargetRace() []Race {
	if m != nil {
		return m.TargetRace
	}
	return nil
}

func (m *SpellTargetDataProto) GetTargetEffectType() int32 {
	if m != nil {
		return m.TargetEffectType
	}
	return 0
}

func (m *SpellTargetDataProto) GetTargetUnmovable() bool {
	if m != nil {
		return m.TargetUnmovable
	}
	return false
}

func (m *SpellTargetDataProto) GetTargetNotAttackable() bool {
	if m != nil {
		return m.TargetNotAttackable
	}
	return false
}

func (m *SpellTargetDataProto) GetTargetSilence() bool {
	if m != nil {
		return m.TargetSilence
	}
	return false
}

func (m *SpellTargetDataProto) GetTargetStun() bool {
	if m != nil {
		return m.TargetStun
	}
	return false
}

// 战斗/状态.txt
type StateDataProto struct {
	Id                    int32            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                  string           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Animation             int32            `protobuf:"varint,3,opt,name=animation,proto3" json:"animation,omitempty"`
	StackType             StateStackType   `protobuf:"varint,4,opt,name=stack_type,json=stackType,proto3,enum=proto.StateStackType" json:"stack_type,omitempty"`
	StackMaxTimes         int32            `protobuf:"varint,5,opt,name=stack_max_times,json=stackMaxTimes,proto3" json:"stack_max_times,omitempty"`
	TickTimes             int32            `protobuf:"varint,6,opt,name=tick_times,json=tickTimes,proto3" json:"tick_times,omitempty"`
	TickDuration          int32            `protobuf:"varint,7,opt,name=tick_duration,json=tickDuration,proto3" json:"tick_duration,omitempty"`
	ChangeStat            *SpriteStatProto `protobuf:"bytes,8,opt,name=change_stat,json=changeStat" json:"change_stat,omitempty"`
	IsAddStat             bool             `protobuf:"varint,9,opt,name=is_add_stat,json=isAddStat,proto3" json:"is_add_stat,omitempty"`
	MoveSpeedRate         int32            `protobuf:"varint,10,opt,name=move_speed_rate,json=moveSpeedRate,proto3" json:"move_speed_rate,omitempty"`
	AttackSpeedRate       int32            `protobuf:"varint,11,opt,name=attack_speed_rate,json=attackSpeedRate,proto3" json:"attack_speed_rate,omitempty"`
	ShieldRate            int32            `protobuf:"varint,12,opt,name=shield_rate,json=shieldRate,proto3" json:"shield_rate,omitempty"`
	ShieldEffectRate      int32            `protobuf:"varint,26,opt,name=shield_effect_rate,json=shieldEffectRate,proto3" json:"shield_effect_rate,omitempty"`
	Unmovable             bool             `protobuf:"varint,13,opt,name=unmovable,proto3" json:"unmovable,omitempty"`
	NotAttackable         bool             `protobuf:"varint,14,opt,name=not_attackable,json=notAttackable,proto3" json:"not_attackable,omitempty"`
	Silence               bool             `protobuf:"varint,15,opt,name=silence,proto3" json:"silence,omitempty"`
	Stun                  bool             `protobuf:"varint,16,opt,name=stun,proto3" json:"stun,omitempty"`
	EffectType            int32            `protobuf:"varint,17,opt,name=effect_type,json=effectType,proto3" json:"effect_type,omitempty"`
	BeenHurtEffectIncType []int32          `protobuf:"varint,23,rep,name=been_hurt_effect_inc_type,json=beenHurtEffectIncType" json:"been_hurt_effect_inc_type,omitempty"`
	BeenHurtEffectInc     []int32          `protobuf:"varint,19,rep,name=been_hurt_effect_inc,json=beenHurtEffectInc" json:"been_hurt_effect_inc,omitempty"`
	BeenHurtEffectDecType []int32          `protobuf:"varint,24,rep,name=been_hurt_effect_dec_type,json=beenHurtEffectDecType" json:"been_hurt_effect_dec_type,omitempty"`
	BeenHurtEffectDec     []int32          `protobuf:"varint,25,rep,name=been_hurt_effect_dec,json=beenHurtEffectDec" json:"been_hurt_effect_dec,omitempty"`
	DamageCoef            int32            `protobuf:"varint,20,opt,name=damage_coef,json=damageCoef,proto3" json:"damage_coef,omitempty"`
	DamageHurtType        int32            `protobuf:"varint,27,opt,name=damage_hurt_type,json=damageHurtType,proto3" json:"damage_hurt_type,omitempty"`
	Rage                  int32            `protobuf:"varint,21,opt,name=rage,proto3" json:"rage,omitempty"`
	RageRecoverRate       int32            `protobuf:"varint,22,opt,name=rage_recover_rate,json=rageRecoverRate,proto3" json:"rage_recover_rate,omitempty"`
}

func (m *StateDataProto) Reset()                    { *m = StateDataProto{} }
func (m *StateDataProto) String() string            { return proto.CompactTextString(m) }
func (*StateDataProto) ProtoMessage()               {}
func (*StateDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{12} }

func (m *StateDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StateDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StateDataProto) GetAnimation() int32 {
	if m != nil {
		return m.Animation
	}
	return 0
}

func (m *StateDataProto) GetStackType() StateStackType {
	if m != nil {
		return m.StackType
	}
	return StateStackType_SSNone
}

func (m *StateDataProto) GetStackMaxTimes() int32 {
	if m != nil {
		return m.StackMaxTimes
	}
	return 0
}

func (m *StateDataProto) GetTickTimes() int32 {
	if m != nil {
		return m.TickTimes
	}
	return 0
}

func (m *StateDataProto) GetTickDuration() int32 {
	if m != nil {
		return m.TickDuration
	}
	return 0
}

func (m *StateDataProto) GetChangeStat() *SpriteStatProto {
	if m != nil {
		return m.ChangeStat
	}
	return nil
}

func (m *StateDataProto) GetIsAddStat() bool {
	if m != nil {
		return m.IsAddStat
	}
	return false
}

func (m *StateDataProto) GetMoveSpeedRate() int32 {
	if m != nil {
		return m.MoveSpeedRate
	}
	return 0
}

func (m *StateDataProto) GetAttackSpeedRate() int32 {
	if m != nil {
		return m.AttackSpeedRate
	}
	return 0
}

func (m *StateDataProto) GetShieldRate() int32 {
	if m != nil {
		return m.ShieldRate
	}
	return 0
}

func (m *StateDataProto) GetShieldEffectRate() int32 {
	if m != nil {
		return m.ShieldEffectRate
	}
	return 0
}

func (m *StateDataProto) GetUnmovable() bool {
	if m != nil {
		return m.Unmovable
	}
	return false
}

func (m *StateDataProto) GetNotAttackable() bool {
	if m != nil {
		return m.NotAttackable
	}
	return false
}

func (m *StateDataProto) GetSilence() bool {
	if m != nil {
		return m.Silence
	}
	return false
}

func (m *StateDataProto) GetStun() bool {
	if m != nil {
		return m.Stun
	}
	return false
}

func (m *StateDataProto) GetEffectType() int32 {
	if m != nil {
		return m.EffectType
	}
	return 0
}

func (m *StateDataProto) GetBeenHurtEffectIncType() []int32 {
	if m != nil {
		return m.BeenHurtEffectIncType
	}
	return nil
}

func (m *StateDataProto) GetBeenHurtEffectInc() []int32 {
	if m != nil {
		return m.BeenHurtEffectInc
	}
	return nil
}

func (m *StateDataProto) GetBeenHurtEffectDecType() []int32 {
	if m != nil {
		return m.BeenHurtEffectDecType
	}
	return nil
}

func (m *StateDataProto) GetBeenHurtEffectDec() []int32 {
	if m != nil {
		return m.BeenHurtEffectDec
	}
	return nil
}

func (m *StateDataProto) GetDamageCoef() int32 {
	if m != nil {
		return m.DamageCoef
	}
	return 0
}

func (m *StateDataProto) GetDamageHurtType() int32 {
	if m != nil {
		return m.DamageHurtType
	}
	return 0
}

func (m *StateDataProto) GetRage() int32 {
	if m != nil {
		return m.Rage
	}
	return 0
}

func (m *StateDataProto) GetRageRecoverRate() int32 {
	if m != nil {
		return m.RageRecoverRate
	}
	return 0
}

// 名城战/名城.txt
type MingcBaseDataProto struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Model                string   `protobuf:"bytes,3,opt,name=model,proto3" json:"model,omitempty"`
	BaseX                int32    `protobuf:"varint,4,opt,name=base_x,json=baseX,proto3" json:"base_x,omitempty"`
	BaseY                int32    `protobuf:"varint,5,opt,name=base_y,json=baseY,proto3" json:"base_y,omitempty"`
	Radius               int32    `protobuf:"varint,6,opt,name=radius,proto3" json:"radius,omitempty"`
	Type                 MincType `protobuf:"varint,7,opt,name=type,proto3,enum=proto.MincType" json:"type,omitempty"`
	ZhouCaptain          bool     `protobuf:"varint,10,opt,name=zhou_captain,json=zhouCaptain,proto3" json:"zhou_captain,omitempty"`
	DefaultYinliang      int32    `protobuf:"varint,11,opt,name=default_yinliang,json=defaultYinliang,proto3" json:"default_yinliang,omitempty"`
	DailyAddYinliang     int32    `protobuf:"varint,12,opt,name=daily_add_yinliang,json=dailyAddYinliang,proto3" json:"daily_add_yinliang,omitempty"`
	MaxYinliang          int32    `protobuf:"varint,13,opt,name=max_yinliang,json=maxYinliang,proto3" json:"max_yinliang,omitempty"`
	HostDailyAddYinliang int32    `protobuf:"varint,14,opt,name=host_daily_add_yinliang,json=hostDailyAddYinliang,proto3" json:"host_daily_add_yinliang,omitempty"`
	Country              int32    `protobuf:"varint,8,opt,name=country,proto3" json:"country,omitempty"`
	WarIcon              string   `protobuf:"bytes,15,opt,name=war_icon,json=warIcon,proto3" json:"war_icon,omitempty"`
	AtkMinHufu           int32    `protobuf:"varint,16,opt,name=atk_min_hufu,json=atkMinHufu,proto3" json:"atk_min_hufu,omitempty"`
	AtkMinGuildLevel     int32    `protobuf:"varint,17,opt,name=atk_min_guild_level,json=atkMinGuildLevel,proto3" json:"atk_min_guild_level,omitempty"`
	AstMaxGuild          int32    `protobuf:"varint,18,opt,name=ast_max_guild,json=astMaxGuild,proto3" json:"ast_max_guild,omitempty"`
	BaseMinDistance      int32    `protobuf:"varint,19,opt,name=base_min_distance,json=baseMinDistance,proto3" json:"base_min_distance,omitempty"`
}

func (m *MingcBaseDataProto) Reset()                    { *m = MingcBaseDataProto{} }
func (m *MingcBaseDataProto) String() string            { return proto.CompactTextString(m) }
func (*MingcBaseDataProto) ProtoMessage()               {}
func (*MingcBaseDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{13} }

func (m *MingcBaseDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MingcBaseDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MingcBaseDataProto) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *MingcBaseDataProto) GetBaseX() int32 {
	if m != nil {
		return m.BaseX
	}
	return 0
}

func (m *MingcBaseDataProto) GetBaseY() int32 {
	if m != nil {
		return m.BaseY
	}
	return 0
}

func (m *MingcBaseDataProto) GetRadius() int32 {
	if m != nil {
		return m.Radius
	}
	return 0
}

func (m *MingcBaseDataProto) GetType() MincType {
	if m != nil {
		return m.Type
	}
	return MincType_MC_INVALID_MINC
}

func (m *MingcBaseDataProto) GetZhouCaptain() bool {
	if m != nil {
		return m.ZhouCaptain
	}
	return false
}

func (m *MingcBaseDataProto) GetDefaultYinliang() int32 {
	if m != nil {
		return m.DefaultYinliang
	}
	return 0
}

func (m *MingcBaseDataProto) GetDailyAddYinliang() int32 {
	if m != nil {
		return m.DailyAddYinliang
	}
	return 0
}

func (m *MingcBaseDataProto) GetMaxYinliang() int32 {
	if m != nil {
		return m.MaxYinliang
	}
	return 0
}

func (m *MingcBaseDataProto) GetHostDailyAddYinliang() int32 {
	if m != nil {
		return m.HostDailyAddYinliang
	}
	return 0
}

func (m *MingcBaseDataProto) GetCountry() int32 {
	if m != nil {
		return m.Country
	}
	return 0
}

func (m *MingcBaseDataProto) GetWarIcon() string {
	if m != nil {
		return m.WarIcon
	}
	return ""
}

func (m *MingcBaseDataProto) GetAtkMinHufu() int32 {
	if m != nil {
		return m.AtkMinHufu
	}
	return 0
}

func (m *MingcBaseDataProto) GetAtkMinGuildLevel() int32 {
	if m != nil {
		return m.AtkMinGuildLevel
	}
	return 0
}

func (m *MingcBaseDataProto) GetAstMaxGuild() int32 {
	if m != nil {
		return m.AstMaxGuild
	}
	return 0
}

func (m *MingcBaseDataProto) GetBaseMinDistance() int32 {
	if m != nil {
		return m.BaseMinDistance
	}
	return 0
}

// 轩辕会武/杂项.txt
type XuanyuanMiscDataProto struct {
	ChallengeTimesLimit int32 `protobuf:"varint,1,opt,name=challenge_times_limit,json=challengeTimesLimit,proto3" json:"challenge_times_limit,omitempty"`
}

func (m *XuanyuanMiscDataProto) Reset()                    { *m = XuanyuanMiscDataProto{} }
func (m *XuanyuanMiscDataProto) String() string            { return proto.CompactTextString(m) }
func (*XuanyuanMiscDataProto) ProtoMessage()               {}
func (*XuanyuanMiscDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{14} }

func (m *XuanyuanMiscDataProto) GetChallengeTimesLimit() int32 {
	if m != nil {
		return m.ChallengeTimesLimit
	}
	return 0
}

// 轩辕会武/积分区间.txt
type XuanyuanRangeDataProto struct {
	Id               int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	LowRank          int32  `protobuf:"varint,2,opt,name=low_rank,json=lowRank,proto3" json:"low_rank,omitempty"`
	HighRank         int32  `protobuf:"varint,3,opt,name=high_rank,json=highRank,proto3" json:"high_rank,omitempty"`
	WinScore         int32  `protobuf:"varint,4,opt,name=win_score,json=winScore,proto3" json:"win_score,omitempty"`
	LoseScore        int32  `protobuf:"varint,5,opt,name=lose_score,json=loseScore,proto3" json:"lose_score,omitempty"`
	DefenseLostScore int32  `protobuf:"varint,6,opt,name=defense_lost_score,json=defenseLostScore,proto3" json:"defense_lost_score,omitempty"`
	CombatScene      string `protobuf:"bytes,7,opt,name=combat_scene,json=combatScene,proto3" json:"combat_scene,omitempty"`
}

func (m *XuanyuanRangeDataProto) Reset()                    { *m = XuanyuanRangeDataProto{} }
func (m *XuanyuanRangeDataProto) String() string            { return proto.CompactTextString(m) }
func (*XuanyuanRangeDataProto) ProtoMessage()               {}
func (*XuanyuanRangeDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{15} }

func (m *XuanyuanRangeDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *XuanyuanRangeDataProto) GetLowRank() int32 {
	if m != nil {
		return m.LowRank
	}
	return 0
}

func (m *XuanyuanRangeDataProto) GetHighRank() int32 {
	if m != nil {
		return m.HighRank
	}
	return 0
}

func (m *XuanyuanRangeDataProto) GetWinScore() int32 {
	if m != nil {
		return m.WinScore
	}
	return 0
}

func (m *XuanyuanRangeDataProto) GetLoseScore() int32 {
	if m != nil {
		return m.LoseScore
	}
	return 0
}

func (m *XuanyuanRangeDataProto) GetDefenseLostScore() int32 {
	if m != nil {
		return m.DefenseLostScore
	}
	return 0
}

func (m *XuanyuanRangeDataProto) GetCombatScene() string {
	if m != nil {
		return m.CombatScene
	}
	return ""
}

// 轩辕会武/排名奖励.txt
type XuanyuanRankPrizeDataProto struct {
	Id        int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Rank      int32       `protobuf:"varint,2,opt,name=rank,proto3" json:"rank,omitempty"`
	Prize     *PrizeProto `protobuf:"bytes,3,opt,name=prize" json:"prize,omitempty"`
	ShowPrize *PrizeProto `protobuf:"bytes,5,opt,name=show_prize,json=showPrize" json:"show_prize,omitempty"`
}

func (m *XuanyuanRankPrizeDataProto) Reset()         { *m = XuanyuanRankPrizeDataProto{} }
func (m *XuanyuanRankPrizeDataProto) String() string { return proto.CompactTextString(m) }
func (*XuanyuanRankPrizeDataProto) ProtoMessage()    {}
func (*XuanyuanRankPrizeDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{16}
}

func (m *XuanyuanRankPrizeDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *XuanyuanRankPrizeDataProto) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *XuanyuanRankPrizeDataProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

func (m *XuanyuanRankPrizeDataProto) GetShowPrize() *PrizeProto {
	if m != nil {
		return m.ShowPrize
	}
	return nil
}

// 杂项/杂项.txt
type MiscGenConfigProto struct {
	DianquanToGold                  int32        `protobuf:"varint,31,opt,name=dianquan_to_gold,json=dianquanToGold,proto3" json:"dianquan_to_gold,omitempty"`
	DianquanToStone                 int32        `protobuf:"varint,32,opt,name=dianquan_to_stone,json=dianquanToStone,proto3" json:"dianquan_to_stone,omitempty"`
	Stronger4Coef                   []int32      `protobuf:"varint,1,rep,name=stronger4_coef,json=stronger4Coef" json:"stronger4_coef,omitempty"`
	MiaoBaowuDuration               int32        `protobuf:"varint,2,opt,name=miao_baowu_duration,json=miaoBaowuDuration,proto3" json:"miao_baowu_duration,omitempty"`
	MiaoBaowuCost                   *CostProto   `protobuf:"bytes,3,opt,name=miao_baowu_cost,json=miaoBaowuCost" json:"miao_baowu_cost,omitempty"`
	DailyMiaoBaowuLimit             int32        `protobuf:"varint,4,opt,name=daily_miao_baowu_limit,json=dailyMiaoBaowuLimit,proto3" json:"daily_miao_baowu_limit,omitempty"`
	BaowuLogLimit                   int32        `protobuf:"varint,5,opt,name=baowu_log_limit,json=baowuLogLimit,proto3" json:"baowu_log_limit,omitempty"`
	FirstNpcBaowu                   int32        `protobuf:"varint,8,opt,name=first_npc_baowu,json=firstNpcBaowu,proto3" json:"first_npc_baowu,omitempty"`
	FriendMaxCount                  int32        `protobuf:"varint,6,opt,name=friend_max_count,json=friendMaxCount,proto3" json:"friend_max_count,omitempty"`
	BlackMaxCount                   int32        `protobuf:"varint,7,opt,name=black_max_count,json=blackMaxCount,proto3" json:"black_max_count,omitempty"`
	BuySpValue                      int32        `protobuf:"varint,18,opt,name=buy_sp_value,json=buySpValue,proto3" json:"buy_sp_value,omitempty"`
	BuySpCost                       int32        `protobuf:"varint,19,opt,name=buy_sp_cost,json=buySpCost,proto3" json:"buy_sp_cost,omitempty"`
	BuySpLimit                      int32        `protobuf:"varint,20,opt,name=buy_sp_limit,json=buySpLimit,proto3" json:"buy_sp_limit,omitempty"`
	SpDuration                      int32        `protobuf:"varint,17,opt,name=sp_duration,json=spDuration,proto3" json:"sp_duration,omitempty"`
	AutoFullSoldoerDuration         int32        `protobuf:"varint,9,opt,name=auto_full_soldoer_duration,json=autoFullSoldoerDuration,proto3" json:"auto_full_soldoer_duration,omitempty"`
	TaxDuration                     int32        `protobuf:"varint,10,opt,name=tax_duration,json=taxDuration,proto3" json:"tax_duration,omitempty"`
	FishMaxPoint                    []int32      `protobuf:"varint,11,rep,name=fish_max_point,json=fishMaxPoint" json:"fish_max_point,omitempty"`
	FishPointCaptainSoul            []int32      `protobuf:"varint,12,rep,name=fish_point_captain_soul,json=fishPointCaptainSoul" json:"fish_point_captain_soul,omitempty"`
	DaZhaoSwitchLevelLimit          int32        `protobuf:"varint,13,opt,name=da_zhao_switch_level_limit,json=daZhaoSwitchLevelLimit,proto3" json:"da_zhao_switch_level_limit,omitempty"`
	UpdateOuterCityTypeCost         *CostProto   `protobuf:"bytes,14,opt,name=update_outer_city_type_cost,json=updateOuterCityTypeCost" json:"update_outer_city_type_cost,omitempty"`
	RandomEventBigRefreshDuration   int32        `protobuf:"varint,15,opt,name=random_event_big_refresh_duration,json=randomEventBigRefreshDuration,proto3" json:"random_event_big_refresh_duration,omitempty"`
	RandomEventSmallRefreshDuration int32        `protobuf:"varint,16,opt,name=random_event_small_refresh_duration,json=randomEventSmallRefreshDuration,proto3" json:"random_event_small_refresh_duration,omitempty"`
	CaptainResetCost                *CostProto   `protobuf:"bytes,21,opt,name=captain_reset_cost,json=captainResetCost" json:"captain_reset_cost,omitempty"`
	SkipFightingHeroLevel           int32        `protobuf:"varint,22,opt,name=skip_fighting_hero_level,json=skipFightingHeroLevel,proto3" json:"skip_fighting_hero_level,omitempty"`
	SkipFightingVipLevel            int32        `protobuf:"varint,23,opt,name=skip_fighting_vip_level,json=skipFightingVipLevel,proto3" json:"skip_fighting_vip_level,omitempty"`
	SkipFightingWaitDuration        int32        `protobuf:"varint,24,opt,name=skip_fighting_wait_duration,json=skipFightingWaitDuration,proto3" json:"skip_fighting_wait_duration,omitempty"`
	SecretTowerCd                   int32        `protobuf:"varint,25,opt,name=secret_tower_cd,json=secretTowerCd,proto3" json:"secret_tower_cd,omitempty"`
	XuanyuanCd                      int32        `protobuf:"varint,26,opt,name=xuanyuan_cd,json=xuanyuanCd,proto3" json:"xuanyuan_cd,omitempty"`
	BaizhanCd                       int32        `protobuf:"varint,27,opt,name=baizhan_cd,json=baizhanCd,proto3" json:"baizhan_cd,omitempty"`
	HebiCd                          int32        `protobuf:"varint,28,opt,name=hebi_cd,json=hebiCd,proto3" json:"hebi_cd,omitempty"`
	XiongnuCd                       int32        `protobuf:"varint,29,opt,name=xiongnu_cd,json=xiongnuCd,proto3" json:"xiongnu_cd,omitempty"`
	MailCd                          int32        `protobuf:"varint,30,opt,name=mail_cd,json=mailCd,proto3" json:"mail_cd,omitempty"`
	SoldierPerGroup                 int32        `protobuf:"varint,33,opt,name=soldier_per_group,json=soldierPerGroup,proto3" json:"soldier_per_group,omitempty"`
	HeroBaozDuration                int32        `protobuf:"varint,34,opt,name=hero_baoz_duration,json=heroBaozDuration,proto3" json:"hero_baoz_duration,omitempty"`
	HeroBaozMaxDistance             int32        `protobuf:"varint,35,opt,name=hero_baoz_max_distance,json=heroBaozMaxDistance,proto3" json:"hero_baoz_max_distance,omitempty"`
	YuanbaoGiftPercent              *AmountProto `protobuf:"bytes,37,opt,name=yuanbao_gift_percent,json=yuanbaoGiftPercent" json:"yuanbao_gift_percent,omitempty"`
}

func (m *MiscGenConfigProto) Reset()                    { *m = MiscGenConfigProto{} }
func (m *MiscGenConfigProto) String() string            { return proto.CompactTextString(m) }
func (*MiscGenConfigProto) ProtoMessage()               {}
func (*MiscGenConfigProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{17} }

func (m *MiscGenConfigProto) GetDianquanToGold() int32 {
	if m != nil {
		return m.DianquanToGold
	}
	return 0
}

func (m *MiscGenConfigProto) GetDianquanToStone() int32 {
	if m != nil {
		return m.DianquanToStone
	}
	return 0
}

func (m *MiscGenConfigProto) GetStronger4Coef() []int32 {
	if m != nil {
		return m.Stronger4Coef
	}
	return nil
}

func (m *MiscGenConfigProto) GetMiaoBaowuDuration() int32 {
	if m != nil {
		return m.MiaoBaowuDuration
	}
	return 0
}

func (m *MiscGenConfigProto) GetMiaoBaowuCost() *CostProto {
	if m != nil {
		return m.MiaoBaowuCost
	}
	return nil
}

func (m *MiscGenConfigProto) GetDailyMiaoBaowuLimit() int32 {
	if m != nil {
		return m.DailyMiaoBaowuLimit
	}
	return 0
}

func (m *MiscGenConfigProto) GetBaowuLogLimit() int32 {
	if m != nil {
		return m.BaowuLogLimit
	}
	return 0
}

func (m *MiscGenConfigProto) GetFirstNpcBaowu() int32 {
	if m != nil {
		return m.FirstNpcBaowu
	}
	return 0
}

func (m *MiscGenConfigProto) GetFriendMaxCount() int32 {
	if m != nil {
		return m.FriendMaxCount
	}
	return 0
}

func (m *MiscGenConfigProto) GetBlackMaxCount() int32 {
	if m != nil {
		return m.BlackMaxCount
	}
	return 0
}

func (m *MiscGenConfigProto) GetBuySpValue() int32 {
	if m != nil {
		return m.BuySpValue
	}
	return 0
}

func (m *MiscGenConfigProto) GetBuySpCost() int32 {
	if m != nil {
		return m.BuySpCost
	}
	return 0
}

func (m *MiscGenConfigProto) GetBuySpLimit() int32 {
	if m != nil {
		return m.BuySpLimit
	}
	return 0
}

func (m *MiscGenConfigProto) GetSpDuration() int32 {
	if m != nil {
		return m.SpDuration
	}
	return 0
}

func (m *MiscGenConfigProto) GetAutoFullSoldoerDuration() int32 {
	if m != nil {
		return m.AutoFullSoldoerDuration
	}
	return 0
}

func (m *MiscGenConfigProto) GetTaxDuration() int32 {
	if m != nil {
		return m.TaxDuration
	}
	return 0
}

func (m *MiscGenConfigProto) GetFishMaxPoint() []int32 {
	if m != nil {
		return m.FishMaxPoint
	}
	return nil
}

func (m *MiscGenConfigProto) GetFishPointCaptainSoul() []int32 {
	if m != nil {
		return m.FishPointCaptainSoul
	}
	return nil
}

func (m *MiscGenConfigProto) GetDaZhaoSwitchLevelLimit() int32 {
	if m != nil {
		return m.DaZhaoSwitchLevelLimit
	}
	return 0
}

func (m *MiscGenConfigProto) GetUpdateOuterCityTypeCost() *CostProto {
	if m != nil {
		return m.UpdateOuterCityTypeCost
	}
	return nil
}

func (m *MiscGenConfigProto) GetRandomEventBigRefreshDuration() int32 {
	if m != nil {
		return m.RandomEventBigRefreshDuration
	}
	return 0
}

func (m *MiscGenConfigProto) GetRandomEventSmallRefreshDuration() int32 {
	if m != nil {
		return m.RandomEventSmallRefreshDuration
	}
	return 0
}

func (m *MiscGenConfigProto) GetCaptainResetCost() *CostProto {
	if m != nil {
		return m.CaptainResetCost
	}
	return nil
}

func (m *MiscGenConfigProto) GetSkipFightingHeroLevel() int32 {
	if m != nil {
		return m.SkipFightingHeroLevel
	}
	return 0
}

func (m *MiscGenConfigProto) GetSkipFightingVipLevel() int32 {
	if m != nil {
		return m.SkipFightingVipLevel
	}
	return 0
}

func (m *MiscGenConfigProto) GetSkipFightingWaitDuration() int32 {
	if m != nil {
		return m.SkipFightingWaitDuration
	}
	return 0
}

func (m *MiscGenConfigProto) GetSecretTowerCd() int32 {
	if m != nil {
		return m.SecretTowerCd
	}
	return 0
}

func (m *MiscGenConfigProto) GetXuanyuanCd() int32 {
	if m != nil {
		return m.XuanyuanCd
	}
	return 0
}

func (m *MiscGenConfigProto) GetBaizhanCd() int32 {
	if m != nil {
		return m.BaizhanCd
	}
	return 0
}

func (m *MiscGenConfigProto) GetHebiCd() int32 {
	if m != nil {
		return m.HebiCd
	}
	return 0
}

func (m *MiscGenConfigProto) GetXiongnuCd() int32 {
	if m != nil {
		return m.XiongnuCd
	}
	return 0
}

func (m *MiscGenConfigProto) GetMailCd() int32 {
	if m != nil {
		return m.MailCd
	}
	return 0
}

func (m *MiscGenConfigProto) GetSoldierPerGroup() int32 {
	if m != nil {
		return m.SoldierPerGroup
	}
	return 0
}

func (m *MiscGenConfigProto) GetHeroBaozDuration() int32 {
	if m != nil {
		return m.HeroBaozDuration
	}
	return 0
}

func (m *MiscGenConfigProto) GetHeroBaozMaxDistance() int32 {
	if m != nil {
		return m.HeroBaozMaxDistance
	}
	return 0
}

func (m *MiscGenConfigProto) GetYuanbaoGiftPercent() *AmountProto {
	if m != nil {
		return m.YuanbaoGiftPercent
	}
	return nil
}

// 物品/宝物.txt
type BaowuDataProto struct {
	Id               int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Group            int32       `protobuf:"varint,2,opt,name=group,proto3" json:"group,omitempty"`
	Level            int32       `protobuf:"varint,3,opt,name=level,proto3" json:"level,omitempty"`
	Name             string      `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Desc             string      `protobuf:"bytes,5,opt,name=desc,proto3" json:"desc,omitempty"`
	Icon             string      `protobuf:"bytes,6,opt,name=icon,proto3" json:"icon,omitempty"`
	Quality          Quality     `protobuf:"varint,7,opt,name=quality,proto3,enum=proto.Quality" json:"quality,omitempty"`
	GoodsQuality     int32       `protobuf:"varint,8,opt,name=goods_quality,json=goodsQuality,proto3" json:"goods_quality,omitempty"`
	UnlockDuration   int32       `protobuf:"varint,9,opt,name=unlock_duration,json=unlockDuration,proto3" json:"unlock_duration,omitempty"`
	PlunderPrize     *PrizeProto `protobuf:"bytes,10,opt,name=plunder_prize,json=plunderPrize" json:"plunder_prize,omitempty"`
	UpgradeNeedCount int32       `protobuf:"varint,11,opt,name=upgrade_need_count,json=upgradeNeedCount,proto3" json:"upgrade_need_count,omitempty"`
	DecomposeGold    int32       `protobuf:"varint,14,opt,name=decompose_gold,json=decomposeGold,proto3" json:"decompose_gold,omitempty"`
	DecomposeStone   int32       `protobuf:"varint,15,opt,name=decompose_stone,json=decomposeStone,proto3" json:"decompose_stone,omitempty"`
	MiaoDuration     int32       `protobuf:"varint,17,opt,name=miao_duration,json=miaoDuration,proto3" json:"miao_duration,omitempty"`
	Prestige         int32       `protobuf:"varint,16,opt,name=prestige,proto3" json:"prestige,omitempty"`
}

func (m *BaowuDataProto) Reset()                    { *m = BaowuDataProto{} }
func (m *BaowuDataProto) String() string            { return proto.CompactTextString(m) }
func (*BaowuDataProto) ProtoMessage()               {}
func (*BaowuDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{18} }

func (m *BaowuDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BaowuDataProto) GetGroup() int32 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *BaowuDataProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *BaowuDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BaowuDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *BaowuDataProto) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *BaowuDataProto) GetQuality() Quality {
	if m != nil {
		return m.Quality
	}
	return Quality_InvalidQuality
}

func (m *BaowuDataProto) GetGoodsQuality() int32 {
	if m != nil {
		return m.GoodsQuality
	}
	return 0
}

func (m *BaowuDataProto) GetUnlockDuration() int32 {
	if m != nil {
		return m.UnlockDuration
	}
	return 0
}

func (m *BaowuDataProto) GetPlunderPrize() *PrizeProto {
	if m != nil {
		return m.PlunderPrize
	}
	return nil
}

func (m *BaowuDataProto) GetUpgradeNeedCount() int32 {
	if m != nil {
		return m.UpgradeNeedCount
	}
	return 0
}

func (m *BaowuDataProto) GetDecomposeGold() int32 {
	if m != nil {
		return m.DecomposeGold
	}
	return 0
}

func (m *BaowuDataProto) GetDecomposeStone() int32 {
	if m != nil {
		return m.DecomposeStone
	}
	return 0
}

func (m *BaowuDataProto) GetMiaoDuration() int32 {
	if m != nil {
		return m.MiaoDuration
	}
	return 0
}

func (m *BaowuDataProto) GetPrestige() int32 {
	if m != nil {
		return m.Prestige
	}
	return 0
}

// 地图/宝藏怪物.txt
type BaozNpcDataProto struct {
	Id                int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Npc               int32 `protobuf:"varint,2,opt,name=npc,proto3" json:"npc,omitempty"`
	RequiredHeroLevel int32 `protobuf:"varint,3,opt,name=required_hero_level,json=requiredHeroLevel,proto3" json:"required_hero_level,omitempty"`
}

func (m *BaozNpcDataProto) Reset()                    { *m = BaozNpcDataProto{} }
func (m *BaozNpcDataProto) String() string            { return proto.CompactTextString(m) }
func (*BaozNpcDataProto) ProtoMessage()               {}
func (*BaozNpcDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{19} }

func (m *BaozNpcDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BaozNpcDataProto) GetNpc() int32 {
	if m != nil {
		return m.Npc
	}
	return 0
}

func (m *BaozNpcDataProto) GetRequiredHeroLevel() int32 {
	if m != nil {
		return m.RequiredHeroLevel
	}
	return 0
}

// 杂项/推送.txt
type PushDataProto struct {
	Id       int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type     SettingType `protobuf:"varint,2,opt,name=type,proto3,enum=proto.SettingType" json:"type,omitempty"`
	Title    string      `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	Content  string      `protobuf:"bytes,4,opt,name=content,proto3" json:"content,omitempty"`
	TickTime string      `protobuf:"bytes,5,opt,name=tick_time,json=tickTime,proto3" json:"tick_time,omitempty"`
}

func (m *PushDataProto) Reset()                    { *m = PushDataProto{} }
func (m *PushDataProto) String() string            { return proto.CompactTextString(m) }
func (*PushDataProto) ProtoMessage()               {}
func (*PushDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{20} }

func (m *PushDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PushDataProto) GetType() SettingType {
	if m != nil {
		return m.Type
	}
	return SettingType_InvalidSettingType
}

func (m *PushDataProto) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *PushDataProto) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *PushDataProto) GetTickTime() string {
	if m != nil {
		return m.TickTime
	}
	return ""
}

// 任务/称号.txt
type TitleDataProto struct {
	Id                         int32            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                       string           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Desc                       string           `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	Image                      string           `protobuf:"bytes,9,opt,name=image,proto3" json:"image,omitempty"`
	Quality                    Quality          `protobuf:"varint,7,opt,name=quality,proto3,enum=proto.Quality" json:"quality,omitempty"`
	SpriteStat                 *SpriteStatProto `protobuf:"bytes,4,opt,name=sprite_stat,json=spriteStat" json:"sprite_stat,omitempty"`
	Task                       []int32          `protobuf:"varint,5,rep,name=task" json:"task,omitempty"`
	TitleCost                  *CostProto       `protobuf:"bytes,10,opt,name=title_cost,json=titleCost" json:"title_cost,omitempty"`
	TotalStat                  *SpriteStatProto `protobuf:"bytes,6,opt,name=total_stat,json=totalStat" json:"total_stat,omitempty"`
	PoltId                     int32            `protobuf:"varint,8,opt,name=polt_id,json=poltId,proto3" json:"polt_id,omitempty"`
	CountryChangeNameVoteCount int32            `protobuf:"varint,11,opt,name=country_change_name_vote_count,json=countryChangeNameVoteCount,proto3" json:"country_change_name_vote_count,omitempty"`
}

func (m *TitleDataProto) Reset()                    { *m = TitleDataProto{} }
func (m *TitleDataProto) String() string            { return proto.CompactTextString(m) }
func (*TitleDataProto) ProtoMessage()               {}
func (*TitleDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{21} }

func (m *TitleDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TitleDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TitleDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *TitleDataProto) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *TitleDataProto) GetQuality() Quality {
	if m != nil {
		return m.Quality
	}
	return Quality_InvalidQuality
}

func (m *TitleDataProto) GetSpriteStat() *SpriteStatProto {
	if m != nil {
		return m.SpriteStat
	}
	return nil
}

func (m *TitleDataProto) GetTask() []int32 {
	if m != nil {
		return m.Task
	}
	return nil
}

func (m *TitleDataProto) GetTitleCost() *CostProto {
	if m != nil {
		return m.TitleCost
	}
	return nil
}

func (m *TitleDataProto) GetTotalStat() *SpriteStatProto {
	if m != nil {
		return m.TotalStat
	}
	return nil
}

func (m *TitleDataProto) GetPoltId() int32 {
	if m != nil {
		return m.PoltId
	}
	return 0
}

func (m *TitleDataProto) GetCountryChangeNameVoteCount() int32 {
	if m != nil {
		return m.CountryChangeNameVoteCount
	}
	return 0
}

// 任务/称号任务.txt
type TitleTaskDataProto struct {
	Id     int32            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name   string           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Target *TaskTargetProto `protobuf:"bytes,3,opt,name=target" json:"target,omitempty"`
}

func (m *TitleTaskDataProto) Reset()                    { *m = TitleTaskDataProto{} }
func (m *TitleTaskDataProto) String() string            { return proto.CompactTextString(m) }
func (*TitleTaskDataProto) ProtoMessage()               {}
func (*TitleTaskDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{22} }

func (m *TitleTaskDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TitleTaskDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TitleTaskDataProto) GetTarget() *TaskTargetProto {
	if m != nil {
		return m.Target
	}
	return nil
}

// 系统模块/重楼密室聊天.txt
type SecretTowerWordsDataProto struct {
	Id    int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Words string `protobuf:"bytes,2,opt,name=words,proto3" json:"words,omitempty"`
}

func (m *SecretTowerWordsDataProto) Reset()         { *m = SecretTowerWordsDataProto{} }
func (m *SecretTowerWordsDataProto) String() string { return proto.CompactTextString(m) }
func (*SecretTowerWordsDataProto) ProtoMessage()    {}
func (*SecretTowerWordsDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{23}
}

func (m *SecretTowerWordsDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SecretTowerWordsDataProto) GetWords() string {
	if m != nil {
		return m.Words
	}
	return ""
}

// 联盟/联盟杂项.txt
type GuildGenConfigProto struct {
	LeaveAfterJoinDuration           int32      `protobuf:"varint,1,opt,name=leave_after_join_duration,json=leaveAfterJoinDuration,proto3" json:"leave_after_join_duration,omitempty"`
	GuildMarkCount                   int32      `protobuf:"varint,2,opt,name=guild_mark_count,json=guildMarkCount,proto3" json:"guild_mark_count,omitempty"`
	GuildMarkMsgCharLimit            int32      `protobuf:"varint,3,opt,name=guild_mark_msg_char_limit,json=guildMarkMsgCharLimit,proto3" json:"guild_mark_msg_char_limit,omitempty"`
	SendMinYinliangToMember          int32      `protobuf:"varint,4,opt,name=send_min_yinliang_to_member,json=sendMinYinliangToMember,proto3" json:"send_min_yinliang_to_member,omitempty"`
	SendMaxYinliangToMember          int32      `protobuf:"varint,5,opt,name=send_max_yinliang_to_member,json=sendMaxYinliangToMember,proto3" json:"send_max_yinliang_to_member,omitempty"`
	SendMinYinliangToGuild           int32      `protobuf:"varint,6,opt,name=send_min_yinliang_to_guild,json=sendMinYinliangToGuild,proto3" json:"send_min_yinliang_to_guild,omitempty"`
	SendMaxYinliangToGuild           int32      `protobuf:"varint,7,opt,name=send_max_yinliang_to_guild,json=sendMaxYinliangToGuild,proto3" json:"send_max_yinliang_to_guild,omitempty"`
	SendMinSalary                    int32      `protobuf:"varint,8,opt,name=send_min_salary,json=sendMinSalary,proto3" json:"send_min_salary,omitempty"`
	SendMaxSalary                    int32      `protobuf:"varint,9,opt,name=send_max_salary,json=sendMaxSalary,proto3" json:"send_max_salary,omitempty"`
	ConveneCooldown                  int32      `protobuf:"varint,10,opt,name=convene_cooldown,json=conveneCooldown,proto3" json:"convene_cooldown,omitempty"`
	WorkshopBuildDuration            int32      `protobuf:"varint,11,opt,name=workshop_build_duration,json=workshopBuildDuration,proto3" json:"workshop_build_duration,omitempty"`
	WorkshopHeroBuildDuration        int32      `protobuf:"varint,12,opt,name=workshop_hero_build_duration,json=workshopHeroBuildDuration,proto3" json:"workshop_hero_build_duration,omitempty"`
	WorkshopGuildBuildMaxTimes       int32      `protobuf:"varint,26,opt,name=workshop_guild_build_max_times,json=workshopGuildBuildMaxTimes,proto3" json:"workshop_guild_build_max_times,omitempty"`
	WorkshopHeroBuildMaxTimes        int32      `protobuf:"varint,27,opt,name=workshop_hero_build_max_times,json=workshopHeroBuildMaxTimes,proto3" json:"workshop_hero_build_max_times,omitempty"`
	WorkshopOutputMaxTimes           int32      `protobuf:"varint,28,opt,name=workshop_output_max_times,json=workshopOutputMaxTimes,proto3" json:"workshop_output_max_times,omitempty"`
	WorkshopOutputRecoveryDuration   int32      `protobuf:"varint,29,opt,name=workshop_output_recovery_duration,json=workshopOutputRecoveryDuration,proto3" json:"workshop_output_recovery_duration,omitempty"`
	WorkshopHurtDuration             int32      `protobuf:"varint,15,opt,name=workshop_hurt_duration,json=workshopHurtDuration,proto3" json:"workshop_hurt_duration,omitempty"`
	WorkshopHurtTotalTimesLimit      int32      `protobuf:"varint,16,opt,name=workshop_hurt_total_times_limit,json=workshopHurtTotalTimesLimit,proto3" json:"workshop_hurt_total_times_limit,omitempty"`
	WorkshopHurtHeroTimesLimit       int32      `protobuf:"varint,17,opt,name=workshop_hurt_hero_times_limit,json=workshopHurtHeroTimesLimit,proto3" json:"workshop_hurt_hero_times_limit,omitempty"`
	WorkshopHurtCooldown             int32      `protobuf:"varint,18,opt,name=workshop_hurt_cooldown,json=workshopHurtCooldown,proto3" json:"workshop_hurt_cooldown,omitempty"`
	WorkshopHurtProsperity           int32      `protobuf:"varint,19,opt,name=workshop_hurt_prosperity,json=workshopHurtProsperity,proto3" json:"workshop_hurt_prosperity,omitempty"`
	WorkshopProsperityCapcity        int32      `protobuf:"varint,20,opt,name=workshop_prosperity_capcity,json=workshopProsperityCapcity,proto3" json:"workshop_prosperity_capcity,omitempty"`
	WorkshopBarrenProsperity         int32      `protobuf:"varint,25,opt,name=workshop_barren_prosperity,json=workshopBarrenProsperity,proto3" json:"workshop_barren_prosperity,omitempty"`
	WorkshopPrizeMaxCount            int32      `protobuf:"varint,21,opt,name=workshop_prize_max_count,json=workshopPrizeMaxCount,proto3" json:"workshop_prize_max_count,omitempty"`
	WorkshopReduceProsperityDuration int32      `protobuf:"varint,22,opt,name=workshop_reduce_prosperity_duration,json=workshopReduceProsperityDuration,proto3" json:"workshop_reduce_prosperity_duration,omitempty"`
	WorkshopReduceProsperity         int32      `protobuf:"varint,23,opt,name=workshop_reduce_prosperity,json=workshopReduceProsperity,proto3" json:"workshop_reduce_prosperity,omitempty"`
	WorkshopDistanceLimit            int32      `protobuf:"varint,24,opt,name=workshop_distance_limit,json=workshopDistanceLimit,proto3" json:"workshop_distance_limit,omitempty"`
	GuildChangeCountryCost           *CostProto `protobuf:"bytes,30,opt,name=guild_change_country_cost,json=guildChangeCountryCost" json:"guild_change_country_cost,omitempty"`
	GuildChangeCountryWaitDuration   int32      `protobuf:"varint,31,opt,name=guild_change_country_wait_duration,json=guildChangeCountryWaitDuration,proto3" json:"guild_change_country_wait_duration,omitempty"`
	GuildChangeCountryCooldown       int32      `protobuf:"varint,32,opt,name=guild_change_country_cooldown,json=guildChangeCountryCooldown,proto3" json:"guild_change_country_cooldown,omitempty"`
	TaskOpenLevel                    int32      `protobuf:"varint,33,opt,name=task_open_level,json=taskOpenLevel,proto3" json:"task_open_level,omitempty"`
}

func (m *GuildGenConfigProto) Reset()                    { *m = GuildGenConfigProto{} }
func (m *GuildGenConfigProto) String() string            { return proto.CompactTextString(m) }
func (*GuildGenConfigProto) ProtoMessage()               {}
func (*GuildGenConfigProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{24} }

func (m *GuildGenConfigProto) GetLeaveAfterJoinDuration() int32 {
	if m != nil {
		return m.LeaveAfterJoinDuration
	}
	return 0
}

func (m *GuildGenConfigProto) GetGuildMarkCount() int32 {
	if m != nil {
		return m.GuildMarkCount
	}
	return 0
}

func (m *GuildGenConfigProto) GetGuildMarkMsgCharLimit() int32 {
	if m != nil {
		return m.GuildMarkMsgCharLimit
	}
	return 0
}

func (m *GuildGenConfigProto) GetSendMinYinliangToMember() int32 {
	if m != nil {
		return m.SendMinYinliangToMember
	}
	return 0
}

func (m *GuildGenConfigProto) GetSendMaxYinliangToMember() int32 {
	if m != nil {
		return m.SendMaxYinliangToMember
	}
	return 0
}

func (m *GuildGenConfigProto) GetSendMinYinliangToGuild() int32 {
	if m != nil {
		return m.SendMinYinliangToGuild
	}
	return 0
}

func (m *GuildGenConfigProto) GetSendMaxYinliangToGuild() int32 {
	if m != nil {
		return m.SendMaxYinliangToGuild
	}
	return 0
}

func (m *GuildGenConfigProto) GetSendMinSalary() int32 {
	if m != nil {
		return m.SendMinSalary
	}
	return 0
}

func (m *GuildGenConfigProto) GetSendMaxSalary() int32 {
	if m != nil {
		return m.SendMaxSalary
	}
	return 0
}

func (m *GuildGenConfigProto) GetConveneCooldown() int32 {
	if m != nil {
		return m.ConveneCooldown
	}
	return 0
}

func (m *GuildGenConfigProto) GetWorkshopBuildDuration() int32 {
	if m != nil {
		return m.WorkshopBuildDuration
	}
	return 0
}

func (m *GuildGenConfigProto) GetWorkshopHeroBuildDuration() int32 {
	if m != nil {
		return m.WorkshopHeroBuildDuration
	}
	return 0
}

func (m *GuildGenConfigProto) GetWorkshopGuildBuildMaxTimes() int32 {
	if m != nil {
		return m.WorkshopGuildBuildMaxTimes
	}
	return 0
}

func (m *GuildGenConfigProto) GetWorkshopHeroBuildMaxTimes() int32 {
	if m != nil {
		return m.WorkshopHeroBuildMaxTimes
	}
	return 0
}

func (m *GuildGenConfigProto) GetWorkshopOutputMaxTimes() int32 {
	if m != nil {
		return m.WorkshopOutputMaxTimes
	}
	return 0
}

func (m *GuildGenConfigProto) GetWorkshopOutputRecoveryDuration() int32 {
	if m != nil {
		return m.WorkshopOutputRecoveryDuration
	}
	return 0
}

func (m *GuildGenConfigProto) GetWorkshopHurtDuration() int32 {
	if m != nil {
		return m.WorkshopHurtDuration
	}
	return 0
}

func (m *GuildGenConfigProto) GetWorkshopHurtTotalTimesLimit() int32 {
	if m != nil {
		return m.WorkshopHurtTotalTimesLimit
	}
	return 0
}

func (m *GuildGenConfigProto) GetWorkshopHurtHeroTimesLimit() int32 {
	if m != nil {
		return m.WorkshopHurtHeroTimesLimit
	}
	return 0
}

func (m *GuildGenConfigProto) GetWorkshopHurtCooldown() int32 {
	if m != nil {
		return m.WorkshopHurtCooldown
	}
	return 0
}

func (m *GuildGenConfigProto) GetWorkshopHurtProsperity() int32 {
	if m != nil {
		return m.WorkshopHurtProsperity
	}
	return 0
}

func (m *GuildGenConfigProto) GetWorkshopProsperityCapcity() int32 {
	if m != nil {
		return m.WorkshopProsperityCapcity
	}
	return 0
}

func (m *GuildGenConfigProto) GetWorkshopBarrenProsperity() int32 {
	if m != nil {
		return m.WorkshopBarrenProsperity
	}
	return 0
}

func (m *GuildGenConfigProto) GetWorkshopPrizeMaxCount() int32 {
	if m != nil {
		return m.WorkshopPrizeMaxCount
	}
	return 0
}

func (m *GuildGenConfigProto) GetWorkshopReduceProsperityDuration() int32 {
	if m != nil {
		return m.WorkshopReduceProsperityDuration
	}
	return 0
}

func (m *GuildGenConfigProto) GetWorkshopReduceProsperity() int32 {
	if m != nil {
		return m.WorkshopReduceProsperity
	}
	return 0
}

func (m *GuildGenConfigProto) GetWorkshopDistanceLimit() int32 {
	if m != nil {
		return m.WorkshopDistanceLimit
	}
	return 0
}

func (m *GuildGenConfigProto) GetGuildChangeCountryCost() *CostProto {
	if m != nil {
		return m.GuildChangeCountryCost
	}
	return nil
}

func (m *GuildGenConfigProto) GetGuildChangeCountryWaitDuration() int32 {
	if m != nil {
		return m.GuildChangeCountryWaitDuration
	}
	return 0
}

func (m *GuildGenConfigProto) GetGuildChangeCountryCooldown() int32 {
	if m != nil {
		return m.GuildChangeCountryCooldown
	}
	return 0
}

func (m *GuildGenConfigProto) GetTaskOpenLevel() int32 {
	if m != nil {
		return m.TaskOpenLevel
	}
	return 0
}

// 杂项/省市.txt
type LocationDataProto struct {
	Id               int32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name             string  `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	RecommendCountry []int32 `protobuf:"varint,3,rep,name=recommend_country,json=recommendCountry" json:"recommend_country,omitempty"`
}

func (m *LocationDataProto) Reset()                    { *m = LocationDataProto{} }
func (m *LocationDataProto) String() string            { return proto.CompactTextString(m) }
func (*LocationDataProto) ProtoMessage()               {}
func (*LocationDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{25} }

func (m *LocationDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LocationDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LocationDataProto) GetRecommendCountry() []int32 {
	if m != nil {
		return m.RecommendCountry
	}
	return nil
}

// 国家/国家.txt
type CountryDataProto struct {
	Id              int32                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name            string                `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Desc            string                `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	DefaultPrestige int32                 `protobuf:"varint,5,opt,name=default_prestige,json=defaultPrestige,proto3" json:"default_prestige,omitempty"`
	Capital         int32                 `protobuf:"varint,13,opt,name=capital,proto3" json:"capital,omitempty"`
	NpcOfficial     []CountryOfficialType `protobuf:"varint,11,rep,name=npc_official,json=npcOfficial,enum=proto.CountryOfficialType" json:"npc_official,omitempty"`
	NpcId           []int32               `protobuf:"varint,12,rep,name=npc_id,json=npcId" json:"npc_id,omitempty"`
}

func (m *CountryDataProto) Reset()                    { *m = CountryDataProto{} }
func (m *CountryDataProto) String() string            { return proto.CompactTextString(m) }
func (*CountryDataProto) ProtoMessage()               {}
func (*CountryDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{26} }

func (m *CountryDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CountryDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CountryDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *CountryDataProto) GetDefaultPrestige() int32 {
	if m != nil {
		return m.DefaultPrestige
	}
	return 0
}

func (m *CountryDataProto) GetCapital() int32 {
	if m != nil {
		return m.Capital
	}
	return 0
}

func (m *CountryDataProto) GetNpcOfficial() []CountryOfficialType {
	if m != nil {
		return m.NpcOfficial
	}
	return nil
}

func (m *CountryDataProto) GetNpcId() []int32 {
	if m != nil {
		return m.NpcId
	}
	return nil
}

// 国家/国家杂项.txt
type CountryMiscDataProto struct {
	NormalChangeCountryGoods  int32      `protobuf:"varint,1,opt,name=normal_change_country_goods,json=normalChangeCountryGoods,proto3" json:"normal_change_country_goods,omitempty"`
	NewHeroChangeCountryCd    int32      `protobuf:"varint,2,opt,name=new_hero_change_country_cd,json=newHeroChangeCountryCd,proto3" json:"new_hero_change_country_cd,omitempty"`
	NormalChangeCountryCd     int32      `protobuf:"varint,3,opt,name=normal_change_country_cd,json=normalChangeCountryCd,proto3" json:"normal_change_country_cd,omitempty"`
	NewHeroMaxLevel           int32      `protobuf:"varint,4,opt,name=new_hero_max_level,json=newHeroMaxLevel,proto3" json:"new_hero_max_level,omitempty"`
	ChangeNameVoteDuration    int32      `protobuf:"varint,7,opt,name=change_name_vote_duration,json=changeNameVoteDuration,proto3" json:"change_name_vote_duration,omitempty"`
	ChangeNameCost            *CostProto `protobuf:"bytes,6,opt,name=change_name_cost,json=changeNameCost" json:"change_name_cost,omitempty"`
	ChangeNameCd              int32      `protobuf:"varint,5,opt,name=change_name_cd,json=changeNameCd,proto3" json:"change_name_cd,omitempty"`
	MaxSearchHeroDefaultCount int32      `protobuf:"varint,9,opt,name=max_search_hero_default_count,json=maxSearchHeroDefaultCount,proto3" json:"max_search_hero_default_count,omitempty"`
	MaxSearchHeroByNameCount  int32      `protobuf:"varint,10,opt,name=max_search_hero_by_name_count,json=maxSearchHeroByNameCount,proto3" json:"max_search_hero_by_name_count,omitempty"`
}

func (m *CountryMiscDataProto) Reset()                    { *m = CountryMiscDataProto{} }
func (m *CountryMiscDataProto) String() string            { return proto.CompactTextString(m) }
func (*CountryMiscDataProto) ProtoMessage()               {}
func (*CountryMiscDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{27} }

func (m *CountryMiscDataProto) GetNormalChangeCountryGoods() int32 {
	if m != nil {
		return m.NormalChangeCountryGoods
	}
	return 0
}

func (m *CountryMiscDataProto) GetNewHeroChangeCountryCd() int32 {
	if m != nil {
		return m.NewHeroChangeCountryCd
	}
	return 0
}

func (m *CountryMiscDataProto) GetNormalChangeCountryCd() int32 {
	if m != nil {
		return m.NormalChangeCountryCd
	}
	return 0
}

func (m *CountryMiscDataProto) GetNewHeroMaxLevel() int32 {
	if m != nil {
		return m.NewHeroMaxLevel
	}
	return 0
}

func (m *CountryMiscDataProto) GetChangeNameVoteDuration() int32 {
	if m != nil {
		return m.ChangeNameVoteDuration
	}
	return 0
}

func (m *CountryMiscDataProto) GetChangeNameCost() *CostProto {
	if m != nil {
		return m.ChangeNameCost
	}
	return nil
}

func (m *CountryMiscDataProto) GetChangeNameCd() int32 {
	if m != nil {
		return m.ChangeNameCd
	}
	return 0
}

func (m *CountryMiscDataProto) GetMaxSearchHeroDefaultCount() int32 {
	if m != nil {
		return m.MaxSearchHeroDefaultCount
	}
	return 0
}

func (m *CountryMiscDataProto) GetMaxSearchHeroByNameCount() int32 {
	if m != nil {
		return m.MaxSearchHeroByNameCount
	}
	return 0
}

// 国家/姓氏荐国.txt
type FamilyNameDataProto struct {
	Id               int32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name             string  `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Desc             string  `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	RecommendCountry []int32 `protobuf:"varint,4,rep,name=recommend_country,json=recommendCountry" json:"recommend_country,omitempty"`
}

func (m *FamilyNameDataProto) Reset()                    { *m = FamilyNameDataProto{} }
func (m *FamilyNameDataProto) String() string            { return proto.CompactTextString(m) }
func (*FamilyNameDataProto) ProtoMessage()               {}
func (*FamilyNameDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{28} }

func (m *FamilyNameDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *FamilyNameDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FamilyNameDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *FamilyNameDataProto) GetRecommendCountry() []int32 {
	if m != nil {
		return m.RecommendCountry
	}
	return nil
}

// 福利/7日登陆奖励.txt
type LoginDayDataProto struct {
	Day   int32       `protobuf:"varint,1,opt,name=day,proto3" json:"day,omitempty"`
	Prize *PrizeProto `protobuf:"bytes,2,opt,name=prize" json:"prize,omitempty"`
}

func (m *LoginDayDataProto) Reset()                    { *m = LoginDayDataProto{} }
func (m *LoginDayDataProto) String() string            { return proto.CompactTextString(m) }
func (*LoginDayDataProto) ProtoMessage()               {}
func (*LoginDayDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{29} }

func (m *LoginDayDataProto) GetDay() int32 {
	if m != nil {
		return m.Day
	}
	return 0
}

func (m *LoginDayDataProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

// 福利/君主等级基金.txt
type HeroLevelFundDataProto struct {
	Level  int32       `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	Rebate int32       `protobuf:"varint,3,opt,name=rebate,proto3" json:"rebate,omitempty"`
	Prize  *PrizeProto `protobuf:"bytes,2,opt,name=prize" json:"prize,omitempty"`
}

func (m *HeroLevelFundDataProto) Reset()                    { *m = HeroLevelFundDataProto{} }
func (m *HeroLevelFundDataProto) String() string            { return proto.CompactTextString(m) }
func (*HeroLevelFundDataProto) ProtoMessage()               {}
func (*HeroLevelFundDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{30} }

func (m *HeroLevelFundDataProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *HeroLevelFundDataProto) GetRebate() int32 {
	if m != nil {
		return m.Rebate
	}
	return 0
}

func (m *HeroLevelFundDataProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

// 福利/福利杂项.txt
type PromotionMiscDataProto struct {
	HeroLevelFundCost *CostProto `protobuf:"bytes,1,opt,name=hero_level_fund_cost,json=heroLevelFundCost" json:"hero_level_fund_cost,omitempty"`
}

func (m *PromotionMiscDataProto) Reset()                    { *m = PromotionMiscDataProto{} }
func (m *PromotionMiscDataProto) String() string            { return proto.CompactTextString(m) }
func (*PromotionMiscDataProto) ProtoMessage()               {}
func (*PromotionMiscDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{31} }

func (m *PromotionMiscDataProto) GetHeroLevelFundCost() *CostProto {
	if m != nil {
		return m.HeroLevelFundCost
	}
	return nil
}

// 商店/黑市商品.txt
type BlackMarketGoodsDataProto struct {
	Id        int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ShowPrize *PrizeProto `protobuf:"bytes,2,opt,name=show_prize,json=showPrize" json:"show_prize,omitempty"`
	Cost      *CostProto  `protobuf:"bytes,3,opt,name=cost" json:"cost,omitempty"`
	Quality   Quality     `protobuf:"varint,4,opt,name=quality,proto3,enum=proto.Quality" json:"quality,omitempty"`
}

func (m *BlackMarketGoodsDataProto) Reset()         { *m = BlackMarketGoodsDataProto{} }
func (m *BlackMarketGoodsDataProto) String() string { return proto.CompactTextString(m) }
func (*BlackMarketGoodsDataProto) ProtoMessage()    {}
func (*BlackMarketGoodsDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{32}
}

func (m *BlackMarketGoodsDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BlackMarketGoodsDataProto) GetShowPrize() *PrizeProto {
	if m != nil {
		return m.ShowPrize
	}
	return nil
}

func (m *BlackMarketGoodsDataProto) GetCost() *CostProto {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *BlackMarketGoodsDataProto) GetQuality() Quality {
	if m != nil {
		return m.Quality
	}
	return Quality_InvalidQuality
}

// 商店/商店杂项.txt
type ShopMiscDataProto struct {
	RefreshBlackMarketCost         []*CostProto `protobuf:"bytes,1,rep,name=refresh_black_market_cost,json=refreshBlackMarketCost" json:"refresh_black_market_cost,omitempty"`
	AutoRefreshBlackMarketDuration []int32      `protobuf:"varint,2,rep,name=auto_refresh_black_market_duration,json=autoRefreshBlackMarketDuration" json:"auto_refresh_black_market_duration,omitempty"`
}

func (m *ShopMiscDataProto) Reset()                    { *m = ShopMiscDataProto{} }
func (m *ShopMiscDataProto) String() string            { return proto.CompactTextString(m) }
func (*ShopMiscDataProto) ProtoMessage()               {}
func (*ShopMiscDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{33} }

func (m *ShopMiscDataProto) GetRefreshBlackMarketCost() []*CostProto {
	if m != nil {
		return m.RefreshBlackMarketCost
	}
	return nil
}

func (m *ShopMiscDataProto) GetAutoRefreshBlackMarketDuration() []int32 {
	if m != nil {
		return m.AutoRefreshBlackMarketDuration
	}
	return nil
}

// 名城战/杂项.txt
type MingcMiscDataProto struct {
	FightPrepareDuration                   int32        `protobuf:"varint,1,opt,name=fight_prepare_duration,json=fightPrepareDuration,proto3" json:"fight_prepare_duration,omitempty"`
	JoinFightDuration                      int32        `protobuf:"varint,2,opt,name=join_fight_duration,json=joinFightDuration,proto3" json:"join_fight_duration,omitempty"`
	ApplyAstLimit                          int32        `protobuf:"varint,3,opt,name=apply_ast_limit,json=applyAstLimit,proto3" json:"apply_ast_limit,omitempty"`
	StartAfterServerOpen                   int32        `protobuf:"varint,4,opt,name=start_after_server_open,json=startAfterServerOpen,proto3" json:"start_after_server_open,omitempty"`
	StartSelfCapitalAfterServerOpen        int32        `protobuf:"varint,30,opt,name=start_self_capital_after_server_open,json=startSelfCapitalAfterServerOpen,proto3" json:"start_self_capital_after_server_open,omitempty"`
	StartOtherCapitalAfterServerOpen       int32        `protobuf:"varint,31,opt,name=start_other_capital_after_server_open,json=startOtherCapitalAfterServerOpen,proto3" json:"start_other_capital_after_server_open,omitempty"`
	StartSelfCapitalNoticeAfterServerOpen  int32        `protobuf:"varint,32,opt,name=start_self_capital_notice_after_server_open,json=startSelfCapitalNoticeAfterServerOpen,proto3" json:"start_self_capital_notice_after_server_open,omitempty"`
	StartOtherCapitalNoticeAfterServerOpen int32        `protobuf:"varint,33,opt,name=start_other_capital_notice_after_server_open,json=startOtherCapitalNoticeAfterServerOpen,proto3" json:"start_other_capital_notice_after_server_open,omitempty"`
	DestroyProsperityMaxTroop              int32        `protobuf:"varint,5,opt,name=destroy_prosperity_max_troop,json=destroyProsperityMaxTroop,proto3" json:"destroy_prosperity_max_troop,omitempty"`
	PerDestroyProsperity                   int32        `protobuf:"varint,6,opt,name=per_destroy_prosperity,json=perDestroyProsperity,proto3" json:"per_destroy_prosperity,omitempty"`
	DestroyProsperityDuration              int32        `protobuf:"varint,7,opt,name=destroy_prosperity_duration,json=destroyProsperityDuration,proto3" json:"destroy_prosperity_duration,omitempty"`
	ReliveDuration                         int32        `protobuf:"varint,8,opt,name=relive_duration,json=reliveDuration,proto3" json:"relive_duration,omitempty"`
	WallLevel                              int32        `protobuf:"varint,10,opt,name=wall_level,json=wallLevel,proto3" json:"wall_level,omitempty"`
	Speed                                  int32        `protobuf:"varint,9,opt,name=speed,proto3" json:"speed,omitempty"`
	CloseDuCheng                           bool         `protobuf:"varint,12,opt,name=close_du_cheng,json=closeDuCheng,proto3" json:"close_du_cheng,omitempty"`
	JoinFightHeroMinLevel                  int32        `protobuf:"varint,13,opt,name=join_fight_hero_min_level,json=joinFightHeroMinLevel,proto3" json:"join_fight_hero_min_level,omitempty"`
	DailyUpdateMingcTime                   int32        `protobuf:"varint,27,opt,name=daily_update_mingc_time,json=dailyUpdateMingcTime,proto3" json:"daily_update_mingc_time,omitempty"`
	FreeTankSpeed                          int32        `protobuf:"varint,14,opt,name=free_tank_speed,json=freeTankSpeed,proto3" json:"free_tank_speed,omitempty"`
	FreeTankPerDestroyProsperity           int32        `protobuf:"varint,15,opt,name=free_tank_per_destroy_prosperity,json=freeTankPerDestroyProsperity,proto3" json:"free_tank_per_destroy_prosperity,omitempty"`
	TouShiBuildingTurnDuration             int32        `protobuf:"varint,16,opt,name=tou_shi_building_turn_duration,json=touShiBuildingTurnDuration,proto3" json:"tou_shi_building_turn_duration,omitempty"`
	TouShiBuildingPrepareDuration          int32        `protobuf:"varint,17,opt,name=tou_shi_building_prepare_duration,json=touShiBuildingPrepareDuration,proto3" json:"tou_shi_building_prepare_duration,omitempty"`
	TouShiBuildingDestroyProsperity        int32        `protobuf:"varint,18,opt,name=tou_shi_building_destroy_prosperity,json=touShiBuildingDestroyProsperity,proto3" json:"tou_shi_building_destroy_prosperity,omitempty"`
	TouShiBuildingBaseHurt                 int32        `protobuf:"varint,19,opt,name=tou_shi_building_base_hurt,json=touShiBuildingBaseHurt,proto3" json:"tou_shi_building_base_hurt,omitempty"`
	TouShiBuildingHurtPercent              *AmountProto `protobuf:"bytes,21,opt,name=tou_shi_building_hurt_percent,json=touShiBuildingHurtPercent" json:"tou_shi_building_hurt_percent,omitempty"`
	TouShiBuildingBaseHurtMaxTroop         int32        `protobuf:"varint,22,opt,name=tou_shi_building_base_hurt_max_troop,json=touShiBuildingBaseHurtMaxTroop,proto3" json:"tou_shi_building_base_hurt_max_troop,omitempty"`
	TouShiBuildingBombFlyDuration          int32        `protobuf:"varint,23,opt,name=tou_shi_building_bomb_fly_duration,json=touShiBuildingBombFlyDuration,proto3" json:"tou_shi_building_bomb_fly_duration,omitempty"`
	DurmDuration                           int32        `protobuf:"varint,24,opt,name=durm_duration,json=durmDuration,proto3" json:"durm_duration,omitempty"`
	DrumStopDuration                       int32        `protobuf:"varint,25,opt,name=drum_stop_duration,json=drumStopDuration,proto3" json:"drum_stop_duration,omitempty"`
	DrumMinBaiZhanLevel                    int32        `protobuf:"varint,26,opt,name=drum_min_bai_zhan_level,json=drumMinBaiZhanLevel,proto3" json:"drum_min_bai_zhan_level,omitempty"`
}

func (m *MingcMiscDataProto) Reset()                    { *m = MingcMiscDataProto{} }
func (m *MingcMiscDataProto) String() string            { return proto.CompactTextString(m) }
func (*MingcMiscDataProto) ProtoMessage()               {}
func (*MingcMiscDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{34} }

func (m *MingcMiscDataProto) GetFightPrepareDuration() int32 {
	if m != nil {
		return m.FightPrepareDuration
	}
	return 0
}

func (m *MingcMiscDataProto) GetJoinFightDuration() int32 {
	if m != nil {
		return m.JoinFightDuration
	}
	return 0
}

func (m *MingcMiscDataProto) GetApplyAstLimit() int32 {
	if m != nil {
		return m.ApplyAstLimit
	}
	return 0
}

func (m *MingcMiscDataProto) GetStartAfterServerOpen() int32 {
	if m != nil {
		return m.StartAfterServerOpen
	}
	return 0
}

func (m *MingcMiscDataProto) GetStartSelfCapitalAfterServerOpen() int32 {
	if m != nil {
		return m.StartSelfCapitalAfterServerOpen
	}
	return 0
}

func (m *MingcMiscDataProto) GetStartOtherCapitalAfterServerOpen() int32 {
	if m != nil {
		return m.StartOtherCapitalAfterServerOpen
	}
	return 0
}

func (m *MingcMiscDataProto) GetStartSelfCapitalNoticeAfterServerOpen() int32 {
	if m != nil {
		return m.StartSelfCapitalNoticeAfterServerOpen
	}
	return 0
}

func (m *MingcMiscDataProto) GetStartOtherCapitalNoticeAfterServerOpen() int32 {
	if m != nil {
		return m.StartOtherCapitalNoticeAfterServerOpen
	}
	return 0
}

func (m *MingcMiscDataProto) GetDestroyProsperityMaxTroop() int32 {
	if m != nil {
		return m.DestroyProsperityMaxTroop
	}
	return 0
}

func (m *MingcMiscDataProto) GetPerDestroyProsperity() int32 {
	if m != nil {
		return m.PerDestroyProsperity
	}
	return 0
}

func (m *MingcMiscDataProto) GetDestroyProsperityDuration() int32 {
	if m != nil {
		return m.DestroyProsperityDuration
	}
	return 0
}

func (m *MingcMiscDataProto) GetReliveDuration() int32 {
	if m != nil {
		return m.ReliveDuration
	}
	return 0
}

func (m *MingcMiscDataProto) GetWallLevel() int32 {
	if m != nil {
		return m.WallLevel
	}
	return 0
}

func (m *MingcMiscDataProto) GetSpeed() int32 {
	if m != nil {
		return m.Speed
	}
	return 0
}

func (m *MingcMiscDataProto) GetCloseDuCheng() bool {
	if m != nil {
		return m.CloseDuCheng
	}
	return false
}

func (m *MingcMiscDataProto) GetJoinFightHeroMinLevel() int32 {
	if m != nil {
		return m.JoinFightHeroMinLevel
	}
	return 0
}

func (m *MingcMiscDataProto) GetDailyUpdateMingcTime() int32 {
	if m != nil {
		return m.DailyUpdateMingcTime
	}
	return 0
}

func (m *MingcMiscDataProto) GetFreeTankSpeed() int32 {
	if m != nil {
		return m.FreeTankSpeed
	}
	return 0
}

func (m *MingcMiscDataProto) GetFreeTankPerDestroyProsperity() int32 {
	if m != nil {
		return m.FreeTankPerDestroyProsperity
	}
	return 0
}

func (m *MingcMiscDataProto) GetTouShiBuildingTurnDuration() int32 {
	if m != nil {
		return m.TouShiBuildingTurnDuration
	}
	return 0
}

func (m *MingcMiscDataProto) GetTouShiBuildingPrepareDuration() int32 {
	if m != nil {
		return m.TouShiBuildingPrepareDuration
	}
	return 0
}

func (m *MingcMiscDataProto) GetTouShiBuildingDestroyProsperity() int32 {
	if m != nil {
		return m.TouShiBuildingDestroyProsperity
	}
	return 0
}

func (m *MingcMiscDataProto) GetTouShiBuildingBaseHurt() int32 {
	if m != nil {
		return m.TouShiBuildingBaseHurt
	}
	return 0
}

func (m *MingcMiscDataProto) GetTouShiBuildingHurtPercent() *AmountProto {
	if m != nil {
		return m.TouShiBuildingHurtPercent
	}
	return nil
}

func (m *MingcMiscDataProto) GetTouShiBuildingBaseHurtMaxTroop() int32 {
	if m != nil {
		return m.TouShiBuildingBaseHurtMaxTroop
	}
	return 0
}

func (m *MingcMiscDataProto) GetTouShiBuildingBombFlyDuration() int32 {
	if m != nil {
		return m.TouShiBuildingBombFlyDuration
	}
	return 0
}

func (m *MingcMiscDataProto) GetDurmDuration() int32 {
	if m != nil {
		return m.DurmDuration
	}
	return 0
}

func (m *MingcMiscDataProto) GetDrumStopDuration() int32 {
	if m != nil {
		return m.DrumStopDuration
	}
	return 0
}

func (m *MingcMiscDataProto) GetDrumMinBaiZhanLevel() int32 {
	if m != nil {
		return m.DrumMinBaiZhanLevel
	}
	return 0
}

// 名城战/时间.txt
type MingcTimeDataProto struct {
	Id               int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Desc             string `protobuf:"bytes,2,opt,name=desc,proto3" json:"desc,omitempty"`
	ApplyAtkStart    string `protobuf:"bytes,3,opt,name=apply_atk_start,json=applyAtkStart,proto3" json:"apply_atk_start,omitempty"`
	ApplyAtkDuration int32  `protobuf:"varint,4,opt,name=apply_atk_duration,json=applyAtkDuration,proto3" json:"apply_atk_duration,omitempty"`
	ApplyAstStart    string `protobuf:"bytes,5,opt,name=apply_ast_start,json=applyAstStart,proto3" json:"apply_ast_start,omitempty"`
	ApplyAstDuration int32  `protobuf:"varint,6,opt,name=apply_ast_duration,json=applyAstDuration,proto3" json:"apply_ast_duration,omitempty"`
	FightStart       string `protobuf:"bytes,7,opt,name=fight_start,json=fightStart,proto3" json:"fight_start,omitempty"`
	FightDuration    int32  `protobuf:"varint,8,opt,name=fight_duration,json=fightDuration,proto3" json:"fight_duration,omitempty"`
}

func (m *MingcTimeDataProto) Reset()                    { *m = MingcTimeDataProto{} }
func (m *MingcTimeDataProto) String() string            { return proto.CompactTextString(m) }
func (*MingcTimeDataProto) ProtoMessage()               {}
func (*MingcTimeDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{35} }

func (m *MingcTimeDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MingcTimeDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *MingcTimeDataProto) GetApplyAtkStart() string {
	if m != nil {
		return m.ApplyAtkStart
	}
	return ""
}

func (m *MingcTimeDataProto) GetApplyAtkDuration() int32 {
	if m != nil {
		return m.ApplyAtkDuration
	}
	return 0
}

func (m *MingcTimeDataProto) GetApplyAstStart() string {
	if m != nil {
		return m.ApplyAstStart
	}
	return ""
}

func (m *MingcTimeDataProto) GetApplyAstDuration() int32 {
	if m != nil {
		return m.ApplyAstDuration
	}
	return 0
}

func (m *MingcTimeDataProto) GetFightStart() string {
	if m != nil {
		return m.FightStart
	}
	return ""
}

func (m *MingcTimeDataProto) GetFightDuration() int32 {
	if m != nil {
		return m.FightDuration
	}
	return 0
}

// 名城战/据点.txt
type MingcWarBuildingDataProto struct {
	Id          int32                `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type        MingcWarBuildingType `protobuf:"varint,2,opt,name=type,proto3,enum=proto.MingcWarBuildingType" json:"type,omitempty"`
	Prosperity  int32                `protobuf:"varint,3,opt,name=prosperity,proto3" json:"prosperity,omitempty"`
	AtkModel    string               `protobuf:"bytes,9,opt,name=atk_model,json=atkModel,proto3" json:"atk_model,omitempty"`
	DefModel    string               `protobuf:"bytes,10,opt,name=def_model,json=defModel,proto3" json:"def_model,omitempty"`
	WallAtk     bool                 `protobuf:"varint,5,opt,name=wall_atk,json=wallAtk,proto3" json:"wall_atk,omitempty"`
	CanBeAtked  bool                 `protobuf:"varint,6,opt,name=can_be_atked,json=canBeAtked,proto3" json:"can_be_atked,omitempty"`
	CombatScene string               `protobuf:"bytes,7,opt,name=combat_scene,json=combatScene,proto3" json:"combat_scene,omitempty"`
}

func (m *MingcWarBuildingDataProto) Reset()         { *m = MingcWarBuildingDataProto{} }
func (m *MingcWarBuildingDataProto) String() string { return proto.CompactTextString(m) }
func (*MingcWarBuildingDataProto) ProtoMessage()    {}
func (*MingcWarBuildingDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{36}
}

func (m *MingcWarBuildingDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MingcWarBuildingDataProto) GetType() MingcWarBuildingType {
	if m != nil {
		return m.Type
	}
	return MingcWarBuildingType_MC_B_INVALID
}

func (m *MingcWarBuildingDataProto) GetProsperity() int32 {
	if m != nil {
		return m.Prosperity
	}
	return 0
}

func (m *MingcWarBuildingDataProto) GetAtkModel() string {
	if m != nil {
		return m.AtkModel
	}
	return ""
}

func (m *MingcWarBuildingDataProto) GetDefModel() string {
	if m != nil {
		return m.DefModel
	}
	return ""
}

func (m *MingcWarBuildingDataProto) GetWallAtk() bool {
	if m != nil {
		return m.WallAtk
	}
	return false
}

func (m *MingcWarBuildingDataProto) GetCanBeAtked() bool {
	if m != nil {
		return m.CanBeAtked
	}
	return false
}

func (m *MingcWarBuildingDataProto) GetCombatScene() string {
	if m != nil {
		return m.CombatScene
	}
	return ""
}

// 名城战/地图.txt
type MingcWarMapDataProto struct {
	Id     int32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Mingc  int32   `protobuf:"varint,2,opt,name=mingc,proto3" json:"mingc,omitempty"`
	StartX int32   `protobuf:"varint,3,opt,name=start_x,json=startX,proto3" json:"start_x,omitempty"`
	StartY int32   `protobuf:"varint,4,opt,name=start_y,json=startY,proto3" json:"start_y,omitempty"`
	DestX  []int32 `protobuf:"varint,5,rep,name=dest_x,json=destX" json:"dest_x,omitempty"`
	DestY  []int32 `protobuf:"varint,6,rep,name=dest_y,json=destY" json:"dest_y,omitempty"`
}

func (m *MingcWarMapDataProto) Reset()                    { *m = MingcWarMapDataProto{} }
func (m *MingcWarMapDataProto) String() string            { return proto.CompactTextString(m) }
func (*MingcWarMapDataProto) ProtoMessage()               {}
func (*MingcWarMapDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{37} }

func (m *MingcWarMapDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MingcWarMapDataProto) GetMingc() int32 {
	if m != nil {
		return m.Mingc
	}
	return 0
}

func (m *MingcWarMapDataProto) GetStartX() int32 {
	if m != nil {
		return m.StartX
	}
	return 0
}

func (m *MingcWarMapDataProto) GetStartY() int32 {
	if m != nil {
		return m.StartY
	}
	return 0
}

func (m *MingcWarMapDataProto) GetDestX() []int32 {
	if m != nil {
		return m.DestX
	}
	return nil
}

func (m *MingcWarMapDataProto) GetDestY() []int32 {
	if m != nil {
		return m.DestY
	}
	return nil
}

// 名城战/场景.txt
type MingcWarSceneDataProto struct {
	Id                int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Desc              string   `protobuf:"bytes,2,opt,name=desc,proto3" json:"desc,omitempty"`
	AtkReliveName     string   `protobuf:"bytes,21,opt,name=atk_relive_name,json=atkReliveName,proto3" json:"atk_relive_name,omitempty"`
	AtkRelivePosX     int32    `protobuf:"varint,3,opt,name=atk_relive_pos_x,json=atkRelivePosX,proto3" json:"atk_relive_pos_x,omitempty"`
	AtkRelivePosY     int32    `protobuf:"varint,4,opt,name=atk_relive_pos_y,json=atkRelivePosY,proto3" json:"atk_relive_pos_y,omitempty"`
	AtkHomeName       string   `protobuf:"bytes,22,opt,name=atk_home_name,json=atkHomeName,proto3" json:"atk_home_name,omitempty"`
	AtkHomePosX       int32    `protobuf:"varint,5,opt,name=atk_home_pos_x,json=atkHomePosX,proto3" json:"atk_home_pos_x,omitempty"`
	AtkHomePosY       int32    `protobuf:"varint,6,opt,name=atk_home_pos_y,json=atkHomePosY,proto3" json:"atk_home_pos_y,omitempty"`
	AtkCastleName     []string `protobuf:"bytes,23,rep,name=atk_castle_name,json=atkCastleName" json:"atk_castle_name,omitempty"`
	AtkCastlePosX     []int32  `protobuf:"varint,7,rep,name=atk_castle_pos_x,json=atkCastlePosX" json:"atk_castle_pos_x,omitempty"`
	AtkCastlePosY     []int32  `protobuf:"varint,8,rep,name=atk_castle_pos_y,json=atkCastlePosY" json:"atk_castle_pos_y,omitempty"`
	AtkGateName       []string `protobuf:"bytes,24,rep,name=atk_gate_name,json=atkGateName" json:"atk_gate_name,omitempty"`
	AtkGatePosX       []int32  `protobuf:"varint,9,rep,name=atk_gate_pos_x,json=atkGatePosX" json:"atk_gate_pos_x,omitempty"`
	AtkGatePosY       []int32  `protobuf:"varint,10,rep,name=atk_gate_pos_y,json=atkGatePosY" json:"atk_gate_pos_y,omitempty"`
	DefReliveName     string   `protobuf:"bytes,25,opt,name=def_relive_name,json=defReliveName,proto3" json:"def_relive_name,omitempty"`
	DefRelivePosX     int32    `protobuf:"varint,11,opt,name=def_relive_pos_x,json=defRelivePosX,proto3" json:"def_relive_pos_x,omitempty"`
	DefRelivePosY     int32    `protobuf:"varint,12,opt,name=def_relive_pos_y,json=defRelivePosY,proto3" json:"def_relive_pos_y,omitempty"`
	DefHomeName       string   `protobuf:"bytes,26,opt,name=def_home_name,json=defHomeName,proto3" json:"def_home_name,omitempty"`
	DefHomePosX       int32    `protobuf:"varint,13,opt,name=def_home_pos_x,json=defHomePosX,proto3" json:"def_home_pos_x,omitempty"`
	DefHomePosY       int32    `protobuf:"varint,14,opt,name=def_home_pos_y,json=defHomePosY,proto3" json:"def_home_pos_y,omitempty"`
	DefCastleName     []string `protobuf:"bytes,27,rep,name=def_castle_name,json=defCastleName" json:"def_castle_name,omitempty"`
	DefCastlePosX     []int32  `protobuf:"varint,15,rep,name=def_castle_pos_x,json=defCastlePosX" json:"def_castle_pos_x,omitempty"`
	DefCastlePosY     []int32  `protobuf:"varint,16,rep,name=def_castle_pos_y,json=defCastlePosY" json:"def_castle_pos_y,omitempty"`
	DefGateName       []string `protobuf:"bytes,28,rep,name=def_gate_name,json=defGateName" json:"def_gate_name,omitempty"`
	DefGatePosX       []int32  `protobuf:"varint,17,rep,name=def_gate_pos_x,json=defGatePosX" json:"def_gate_pos_x,omitempty"`
	DefGatePosY       []int32  `protobuf:"varint,18,rep,name=def_gate_pos_y,json=defGatePosY" json:"def_gate_pos_y,omitempty"`
	AtkTouShiName     []string `protobuf:"bytes,32,rep,name=atk_tou_shi_name,json=atkTouShiName" json:"atk_tou_shi_name,omitempty"`
	AtkTouShiPosX     []int32  `protobuf:"varint,33,rep,name=atk_tou_shi_pos_x,json=atkTouShiPosX" json:"atk_tou_shi_pos_x,omitempty"`
	AtkTouShiPosY     []int32  `protobuf:"varint,34,rep,name=atk_tou_shi_pos_y,json=atkTouShiPosY" json:"atk_tou_shi_pos_y,omitempty"`
	DefTouShiName     []string `protobuf:"bytes,35,rep,name=def_tou_shi_name,json=defTouShiName" json:"def_tou_shi_name,omitempty"`
	DefTouShiPosX     []int32  `protobuf:"varint,36,rep,name=def_tou_shi_pos_x,json=defTouShiPosX" json:"def_tou_shi_pos_x,omitempty"`
	DefTouShiPosY     []int32  `protobuf:"varint,37,rep,name=def_tou_shi_pos_y,json=defTouShiPosY" json:"def_tou_shi_pos_y,omitempty"`
	AtkFullProsperity int32    `protobuf:"varint,19,opt,name=atk_full_prosperity,json=atkFullProsperity,proto3" json:"atk_full_prosperity,omitempty"`
	DefFullProsperity int32    `protobuf:"varint,20,opt,name=def_full_prosperity,json=defFullProsperity,proto3" json:"def_full_prosperity,omitempty"`
}

func (m *MingcWarSceneDataProto) Reset()                    { *m = MingcWarSceneDataProto{} }
func (m *MingcWarSceneDataProto) String() string            { return proto.CompactTextString(m) }
func (*MingcWarSceneDataProto) ProtoMessage()               {}
func (*MingcWarSceneDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{38} }

func (m *MingcWarSceneDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MingcWarSceneDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *MingcWarSceneDataProto) GetAtkReliveName() string {
	if m != nil {
		return m.AtkReliveName
	}
	return ""
}

func (m *MingcWarSceneDataProto) GetAtkRelivePosX() int32 {
	if m != nil {
		return m.AtkRelivePosX
	}
	return 0
}

func (m *MingcWarSceneDataProto) GetAtkRelivePosY() int32 {
	if m != nil {
		return m.AtkRelivePosY
	}
	return 0
}

func (m *MingcWarSceneDataProto) GetAtkHomeName() string {
	if m != nil {
		return m.AtkHomeName
	}
	return ""
}

func (m *MingcWarSceneDataProto) GetAtkHomePosX() int32 {
	if m != nil {
		return m.AtkHomePosX
	}
	return 0
}

func (m *MingcWarSceneDataProto) GetAtkHomePosY() int32 {
	if m != nil {
		return m.AtkHomePosY
	}
	return 0
}

func (m *MingcWarSceneDataProto) GetAtkCastleName() []string {
	if m != nil {
		return m.AtkCastleName
	}
	return nil
}

func (m *MingcWarSceneDataProto) GetAtkCastlePosX() []int32 {
	if m != nil {
		return m.AtkCastlePosX
	}
	return nil
}

func (m *MingcWarSceneDataProto) GetAtkCastlePosY() []int32 {
	if m != nil {
		return m.AtkCastlePosY
	}
	return nil
}

func (m *MingcWarSceneDataProto) GetAtkGateName() []string {
	if m != nil {
		return m.AtkGateName
	}
	return nil
}

func (m *MingcWarSceneDataProto) GetAtkGatePosX() []int32 {
	if m != nil {
		return m.AtkGatePosX
	}
	return nil
}

func (m *MingcWarSceneDataProto) GetAtkGatePosY() []int32 {
	if m != nil {
		return m.AtkGatePosY
	}
	return nil
}

func (m *MingcWarSceneDataProto) GetDefReliveName() string {
	if m != nil {
		return m.DefReliveName
	}
	return ""
}

func (m *MingcWarSceneDataProto) GetDefRelivePosX() int32 {
	if m != nil {
		return m.DefRelivePosX
	}
	return 0
}

func (m *MingcWarSceneDataProto) GetDefRelivePosY() int32 {
	if m != nil {
		return m.DefRelivePosY
	}
	return 0
}

func (m *MingcWarSceneDataProto) GetDefHomeName() string {
	if m != nil {
		return m.DefHomeName
	}
	return ""
}

func (m *MingcWarSceneDataProto) GetDefHomePosX() int32 {
	if m != nil {
		return m.DefHomePosX
	}
	return 0
}

func (m *MingcWarSceneDataProto) GetDefHomePosY() int32 {
	if m != nil {
		return m.DefHomePosY
	}
	return 0
}

func (m *MingcWarSceneDataProto) GetDefCastleName() []string {
	if m != nil {
		return m.DefCastleName
	}
	return nil
}

func (m *MingcWarSceneDataProto) GetDefCastlePosX() []int32 {
	if m != nil {
		return m.DefCastlePosX
	}
	return nil
}

func (m *MingcWarSceneDataProto) GetDefCastlePosY() []int32 {
	if m != nil {
		return m.DefCastlePosY
	}
	return nil
}

func (m *MingcWarSceneDataProto) GetDefGateName() []string {
	if m != nil {
		return m.DefGateName
	}
	return nil
}

func (m *MingcWarSceneDataProto) GetDefGatePosX() []int32 {
	if m != nil {
		return m.DefGatePosX
	}
	return nil
}

func (m *MingcWarSceneDataProto) GetDefGatePosY() []int32 {
	if m != nil {
		return m.DefGatePosY
	}
	return nil
}

func (m *MingcWarSceneDataProto) GetAtkTouShiName() []string {
	if m != nil {
		return m.AtkTouShiName
	}
	return nil
}

func (m *MingcWarSceneDataProto) GetAtkTouShiPosX() []int32 {
	if m != nil {
		return m.AtkTouShiPosX
	}
	return nil
}

func (m *MingcWarSceneDataProto) GetAtkTouShiPosY() []int32 {
	if m != nil {
		return m.AtkTouShiPosY
	}
	return nil
}

func (m *MingcWarSceneDataProto) GetDefTouShiName() []string {
	if m != nil {
		return m.DefTouShiName
	}
	return nil
}

func (m *MingcWarSceneDataProto) GetDefTouShiPosX() []int32 {
	if m != nil {
		return m.DefTouShiPosX
	}
	return nil
}

func (m *MingcWarSceneDataProto) GetDefTouShiPosY() []int32 {
	if m != nil {
		return m.DefTouShiPosY
	}
	return nil
}

func (m *MingcWarSceneDataProto) GetAtkFullProsperity() int32 {
	if m != nil {
		return m.AtkFullProsperity
	}
	return 0
}

func (m *MingcWarSceneDataProto) GetDefFullProsperity() int32 {
	if m != nil {
		return m.DefFullProsperity
	}
	return 0
}

// 地图/地区杂项.txt
type RegionGenConfigProto struct {
	UseGoodsMianMaxDuraion     int32 `protobuf:"varint,1,opt,name=use_goods_mian_max_duraion,json=useGoodsMianMaxDuraion,proto3" json:"use_goods_mian_max_duraion,omitempty"`
	InvaseHeroMaxTimes         int32 `protobuf:"varint,2,opt,name=invase_hero_max_times,json=invaseHeroMaxTimes,proto3" json:"invase_hero_max_times,omitempty"`
	InvaseHeroRecoveryDuration int32 `protobuf:"varint,3,opt,name=invase_hero_recovery_duration,json=invaseHeroRecoveryDuration,proto3" json:"invase_hero_recovery_duration,omitempty"`
	JunTuanNpcMaxTimes         int32 `protobuf:"varint,4,opt,name=jun_tuan_npc_max_times,json=junTuanNpcMaxTimes,proto3" json:"jun_tuan_npc_max_times,omitempty"`
	JunTuanNpcRecoveryDuration int32 `protobuf:"varint,5,opt,name=jun_tuan_npc_recovery_duration,json=junTuanNpcRecoveryDuration,proto3" json:"jun_tuan_npc_recovery_duration,omitempty"`
	JunTuanWinTimeLimit        int32 `protobuf:"varint,6,opt,name=jun_tuan_win_time_limit,json=junTuanWinTimeLimit,proto3" json:"jun_tuan_win_time_limit,omitempty"`
}

func (m *RegionGenConfigProto) Reset()                    { *m = RegionGenConfigProto{} }
func (m *RegionGenConfigProto) String() string            { return proto.CompactTextString(m) }
func (*RegionGenConfigProto) ProtoMessage()               {}
func (*RegionGenConfigProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{39} }

func (m *RegionGenConfigProto) GetUseGoodsMianMaxDuraion() int32 {
	if m != nil {
		return m.UseGoodsMianMaxDuraion
	}
	return 0
}

func (m *RegionGenConfigProto) GetInvaseHeroMaxTimes() int32 {
	if m != nil {
		return m.InvaseHeroMaxTimes
	}
	return 0
}

func (m *RegionGenConfigProto) GetInvaseHeroRecoveryDuration() int32 {
	if m != nil {
		return m.InvaseHeroRecoveryDuration
	}
	return 0
}

func (m *RegionGenConfigProto) GetJunTuanNpcMaxTimes() int32 {
	if m != nil {
		return m.JunTuanNpcMaxTimes
	}
	return 0
}

func (m *RegionGenConfigProto) GetJunTuanNpcRecoveryDuration() int32 {
	if m != nil {
		return m.JunTuanNpcRecoveryDuration
	}
	return 0
}

func (m *RegionGenConfigProto) GetJunTuanWinTimeLimit() int32 {
	if m != nil {
		return m.JunTuanWinTimeLimit
	}
	return 0
}

// 内政/外城建筑.txt
type OuterCityBuildingDataProto struct {
	Id           int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	LockIconId   string `protobuf:"bytes,2,opt,name=lock_icon_id,json=lockIconId,proto3" json:"lock_icon_id,omitempty"`
	UnlockIconId string `protobuf:"bytes,3,opt,name=unlock_icon_id,json=unlockIconId,proto3" json:"unlock_icon_id,omitempty"`
	BuildingId   int32  `protobuf:"varint,4,opt,name=building_id,json=buildingId,proto3" json:"building_id,omitempty"`
	Desc         string `protobuf:"bytes,5,opt,name=desc,proto3" json:"desc,omitempty"`
}

func (m *OuterCityBuildingDataProto) Reset()         { *m = OuterCityBuildingDataProto{} }
func (m *OuterCityBuildingDataProto) String() string { return proto.CompactTextString(m) }
func (*OuterCityBuildingDataProto) ProtoMessage()    {}
func (*OuterCityBuildingDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{40}
}

func (m *OuterCityBuildingDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *OuterCityBuildingDataProto) GetLockIconId() string {
	if m != nil {
		return m.LockIconId
	}
	return ""
}

func (m *OuterCityBuildingDataProto) GetUnlockIconId() string {
	if m != nil {
		return m.UnlockIconId
	}
	return ""
}

func (m *OuterCityBuildingDataProto) GetBuildingId() int32 {
	if m != nil {
		return m.BuildingId
	}
	return 0
}

func (m *OuterCityBuildingDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

// 商店/折扣颜色.txt
type DiscountColorDataProto struct {
	Discount int32  `protobuf:"varint,1,opt,name=discount,proto3" json:"discount,omitempty"`
	Color    string `protobuf:"bytes,2,opt,name=color,proto3" json:"color,omitempty"`
}

func (m *DiscountColorDataProto) Reset()                    { *m = DiscountColorDataProto{} }
func (m *DiscountColorDataProto) String() string            { return proto.CompactTextString(m) }
func (*DiscountColorDataProto) ProtoMessage()               {}
func (*DiscountColorDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{41} }

func (m *DiscountColorDataProto) GetDiscount() int32 {
	if m != nil {
		return m.Discount
	}
	return 0
}

func (m *DiscountColorDataProto) GetColor() string {
	if m != nil {
		return m.Color
	}
	return ""
}

// 名城战/舍命一击.txt
type MingcWarTroopLastBeatWhenFailDataProto struct {
	BaiZhanLevel       int32        `protobuf:"varint,1,opt,name=bai_zhan_level,json=baiZhanLevel,proto3" json:"bai_zhan_level,omitempty"`
	SoliderAmount      int32        `protobuf:"varint,2,opt,name=solider_amount,json=soliderAmount,proto3" json:"solider_amount,omitempty"`
	HurtPercent        *AmountProto `protobuf:"bytes,3,opt,name=hurt_percent,json=hurtPercent" json:"hurt_percent,omitempty"`
	AtkBackHurtPercent *AmountProto `protobuf:"bytes,4,opt,name=atk_back_hurt_percent,json=atkBackHurtPercent" json:"atk_back_hurt_percent,omitempty"`
}

func (m *MingcWarTroopLastBeatWhenFailDataProto) Reset() {
	*m = MingcWarTroopLastBeatWhenFailDataProto{}
}
func (m *MingcWarTroopLastBeatWhenFailDataProto) String() string { return proto.CompactTextString(m) }
func (*MingcWarTroopLastBeatWhenFailDataProto) ProtoMessage()    {}
func (*MingcWarTroopLastBeatWhenFailDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{42}
}

func (m *MingcWarTroopLastBeatWhenFailDataProto) GetBaiZhanLevel() int32 {
	if m != nil {
		return m.BaiZhanLevel
	}
	return 0
}

func (m *MingcWarTroopLastBeatWhenFailDataProto) GetSoliderAmount() int32 {
	if m != nil {
		return m.SoliderAmount
	}
	return 0
}

func (m *MingcWarTroopLastBeatWhenFailDataProto) GetHurtPercent() *AmountProto {
	if m != nil {
		return m.HurtPercent
	}
	return nil
}

func (m *MingcWarTroopLastBeatWhenFailDataProto) GetAtkBackHurtPercent() *AmountProto {
	if m != nil {
		return m.AtkBackHurtPercent
	}
	return nil
}

// 名城战/投石机目标.txt
type MingcWarTouShiBuildingTargetDataProto struct {
	Id      int32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Mingc   int32   `protobuf:"varint,2,opt,name=mingc,proto3" json:"mingc,omitempty"`
	PosX    int32   `protobuf:"varint,3,opt,name=pos_x,json=posX,proto3" json:"pos_x,omitempty"`
	PosY    int32   `protobuf:"varint,4,opt,name=pos_y,json=posY,proto3" json:"pos_y,omitempty"`
	TargetX []int32 `protobuf:"varint,5,rep,name=target_x,json=targetX" json:"target_x,omitempty"`
	TargetY []int32 `protobuf:"varint,6,rep,name=target_y,json=targetY" json:"target_y,omitempty"`
}

func (m *MingcWarTouShiBuildingTargetDataProto) Reset()         { *m = MingcWarTouShiBuildingTargetDataProto{} }
func (m *MingcWarTouShiBuildingTargetDataProto) String() string { return proto.CompactTextString(m) }
func (*MingcWarTouShiBuildingTargetDataProto) ProtoMessage()    {}
func (*MingcWarTouShiBuildingTargetDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{43}
}

func (m *MingcWarTouShiBuildingTargetDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MingcWarTouShiBuildingTargetDataProto) GetMingc() int32 {
	if m != nil {
		return m.Mingc
	}
	return 0
}

func (m *MingcWarTouShiBuildingTargetDataProto) GetPosX() int32 {
	if m != nil {
		return m.PosX
	}
	return 0
}

func (m *MingcWarTouShiBuildingTargetDataProto) GetPosY() int32 {
	if m != nil {
		return m.PosY
	}
	return 0
}

func (m *MingcWarTouShiBuildingTargetDataProto) GetTargetX() []int32 {
	if m != nil {
		return m.TargetX
	}
	return nil
}

func (m *MingcWarTouShiBuildingTargetDataProto) GetTargetY() []int32 {
	if m != nil {
		return m.TargetY
	}
	return nil
}

// 武将/武将.txt
type CaptainDataProto struct {
	Id            int32                   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Rarity        int32                   `protobuf:"varint,2,opt,name=rarity,proto3" json:"rarity,omitempty"`
	Name          string                  `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	IconId        string                  `protobuf:"bytes,4,opt,name=icon_id,json=iconId,proto3" json:"icon_id,omitempty"`
	Spine         string                  `protobuf:"bytes,13,opt,name=spine,proto3" json:"spine,omitempty"`
	Desc          string                  `protobuf:"bytes,5,opt,name=desc,proto3" json:"desc,omitempty"`
	Race          Race                    `protobuf:"varint,6,opt,name=race,proto3,enum=proto.Race" json:"race,omitempty"`
	PrizeIfHas    *PrizeProto             `protobuf:"bytes,7,opt,name=prize_if_has,json=prizeIfHas" json:"prize_if_has,omitempty"`
	ObtainWays    []int32                 `protobuf:"varint,8,rep,name=obtain_ways,json=obtainWays" json:"obtain_ways,omitempty"`
	FishingObtain bool                    `protobuf:"varint,14,opt,name=fishing_obtain,json=fishingObtain,proto3" json:"fishing_obtain,omitempty"`
	Sound         string                  `protobuf:"bytes,10,opt,name=sound,proto3" json:"sound,omitempty"`
	BaseSpell     int32                   `protobuf:"varint,11,opt,name=base_spell,json=baseSpell,proto3" json:"base_spell,omitempty"`
	Star          []*CaptainStarDataProto `protobuf:"bytes,12,rep,name=star" json:"star,omitempty"`
	InitRage      int32                   `protobuf:"varint,15,opt,name=init_rage,json=initRage,proto3" json:"init_rage,omitempty"`
}

func (m *CaptainDataProto) Reset()                    { *m = CaptainDataProto{} }
func (m *CaptainDataProto) String() string            { return proto.CompactTextString(m) }
func (*CaptainDataProto) ProtoMessage()               {}
func (*CaptainDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{44} }

func (m *CaptainDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CaptainDataProto) GetRarity() int32 {
	if m != nil {
		return m.Rarity
	}
	return 0
}

func (m *CaptainDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CaptainDataProto) GetIconId() string {
	if m != nil {
		return m.IconId
	}
	return ""
}

func (m *CaptainDataProto) GetSpine() string {
	if m != nil {
		return m.Spine
	}
	return ""
}

func (m *CaptainDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *CaptainDataProto) GetRace() Race {
	if m != nil {
		return m.Race
	}
	return Race_InvalidRace
}

func (m *CaptainDataProto) GetPrizeIfHas() *PrizeProto {
	if m != nil {
		return m.PrizeIfHas
	}
	return nil
}

func (m *CaptainDataProto) GetObtainWays() []int32 {
	if m != nil {
		return m.ObtainWays
	}
	return nil
}

func (m *CaptainDataProto) GetFishingObtain() bool {
	if m != nil {
		return m.FishingObtain
	}
	return false
}

func (m *CaptainDataProto) GetSound() string {
	if m != nil {
		return m.Sound
	}
	return ""
}

func (m *CaptainDataProto) GetBaseSpell() int32 {
	if m != nil {
		return m.BaseSpell
	}
	return 0
}

func (m *CaptainDataProto) GetStar() []*CaptainStarDataProto {
	if m != nil {
		return m.Star
	}
	return nil
}

func (m *CaptainDataProto) GetInitRage() int32 {
	if m != nil {
		return m.InitRage
	}
	return 0
}

// 武将/稀有度.txt
type CaptainRarityDataProto struct {
	Id   int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Coef int32  `protobuf:"varint,3,opt,name=coef,proto3" json:"coef,omitempty"`
}

func (m *CaptainRarityDataProto) Reset()                    { *m = CaptainRarityDataProto{} }
func (m *CaptainRarityDataProto) String() string            { return proto.CompactTextString(m) }
func (*CaptainRarityDataProto) ProtoMessage()               {}
func (*CaptainRarityDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{45} }

func (m *CaptainRarityDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CaptainRarityDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CaptainRarityDataProto) GetCoef() int32 {
	if m != nil {
		return m.Coef
	}
	return 0
}

// 武将/无名武将.txt
type NamelessCaptainDataProto struct {
	Id        int32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name      string  `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	IconId    string  `protobuf:"bytes,3,opt,name=icon_id,json=iconId,proto3" json:"icon_id,omitempty"`
	Spine     string  `protobuf:"bytes,8,opt,name=spine,proto3" json:"spine,omitempty"`
	Male      bool    `protobuf:"varint,4,opt,name=male,proto3" json:"male,omitempty"`
	Race      Race    `protobuf:"varint,5,opt,name=race,proto3,enum=proto.Race" json:"race,omitempty"`
	BaseSpell int32   `protobuf:"varint,6,opt,name=base_spell,json=baseSpell,proto3" json:"base_spell,omitempty"`
	Spell     []int32 `protobuf:"varint,7,rep,name=spell" json:"spell,omitempty"`
	InitRage  int32   `protobuf:"varint,9,opt,name=init_rage,json=initRage,proto3" json:"init_rage,omitempty"`
}

func (m *NamelessCaptainDataProto) Reset()         { *m = NamelessCaptainDataProto{} }
func (m *NamelessCaptainDataProto) String() string { return proto.CompactTextString(m) }
func (*NamelessCaptainDataProto) ProtoMessage()    {}
func (*NamelessCaptainDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{46}
}

func (m *NamelessCaptainDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *NamelessCaptainDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NamelessCaptainDataProto) GetIconId() string {
	if m != nil {
		return m.IconId
	}
	return ""
}

func (m *NamelessCaptainDataProto) GetSpine() string {
	if m != nil {
		return m.Spine
	}
	return ""
}

func (m *NamelessCaptainDataProto) GetMale() bool {
	if m != nil {
		return m.Male
	}
	return false
}

func (m *NamelessCaptainDataProto) GetRace() Race {
	if m != nil {
		return m.Race
	}
	return Race_InvalidRace
}

func (m *NamelessCaptainDataProto) GetBaseSpell() int32 {
	if m != nil {
		return m.BaseSpell
	}
	return 0
}

func (m *NamelessCaptainDataProto) GetSpell() []int32 {
	if m != nil {
		return m.Spell
	}
	return nil
}

func (m *NamelessCaptainDataProto) GetInitRage() int32 {
	if m != nil {
		return m.InitRage
	}
	return 0
}

// 战斗/技能盒.txt
type SpellFacadeDataProto struct {
	Id        int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	IconId    string `protobuf:"bytes,3,opt,name=icon_id,json=iconId,proto3" json:"icon_id,omitempty"`
	Desc      string `protobuf:"bytes,4,opt,name=desc,proto3" json:"desc,omitempty"`
	SubDesc   string `protobuf:"bytes,7,opt,name=sub_desc,json=subDesc,proto3" json:"sub_desc,omitempty"`
	Group     int32  `protobuf:"varint,5,opt,name=group,proto3" json:"group,omitempty"`
	Level     int32  `protobuf:"varint,6,opt,name=level,proto3" json:"level,omitempty"`
	SpellType int32  `protobuf:"varint,8,opt,name=spell_type,json=spellType,proto3" json:"spell_type,omitempty"`
}

func (m *SpellFacadeDataProto) Reset()                    { *m = SpellFacadeDataProto{} }
func (m *SpellFacadeDataProto) String() string            { return proto.CompactTextString(m) }
func (*SpellFacadeDataProto) ProtoMessage()               {}
func (*SpellFacadeDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{47} }

func (m *SpellFacadeDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SpellFacadeDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SpellFacadeDataProto) GetIconId() string {
	if m != nil {
		return m.IconId
	}
	return ""
}

func (m *SpellFacadeDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *SpellFacadeDataProto) GetSubDesc() string {
	if m != nil {
		return m.SubDesc
	}
	return ""
}

func (m *SpellFacadeDataProto) GetGroup() int32 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *SpellFacadeDataProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *SpellFacadeDataProto) GetSpellType() int32 {
	if m != nil {
		return m.SpellType
	}
	return 0
}

// 策略/增益.txt
type BufferDataProto struct {
	Id               int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name             string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	NameDesc         string `protobuf:"bytes,13,opt,name=name_desc,json=nameDesc,proto3" json:"name_desc,omitempty"`
	IconId           string `protobuf:"bytes,14,opt,name=icon_id,json=iconId,proto3" json:"icon_id,omitempty"`
	Desc             string `protobuf:"bytes,5,opt,name=desc,proto3" json:"desc,omitempty"`
	Type             int32  `protobuf:"varint,6,opt,name=type,proto3" json:"type,omitempty"`
	ShowKeepDuration int32  `protobuf:"varint,17,opt,name=show_keep_duration,json=showKeepDuration,proto3" json:"show_keep_duration,omitempty"`
	ShowLevel        int32  `protobuf:"varint,18,opt,name=show_level,json=showLevel,proto3" json:"show_level,omitempty"`
	BuffGoodsId      int32  `protobuf:"varint,11,opt,name=buff_goods_id,json=buffGoodsId,proto3" json:"buff_goods_id,omitempty"`
}

func (m *BufferDataProto) Reset()                    { *m = BufferDataProto{} }
func (m *BufferDataProto) String() string            { return proto.CompactTextString(m) }
func (*BufferDataProto) ProtoMessage()               {}
func (*BufferDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{48} }

func (m *BufferDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BufferDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BufferDataProto) GetNameDesc() string {
	if m != nil {
		return m.NameDesc
	}
	return ""
}

func (m *BufferDataProto) GetIconId() string {
	if m != nil {
		return m.IconId
	}
	return ""
}

func (m *BufferDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *BufferDataProto) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *BufferDataProto) GetShowKeepDuration() int32 {
	if m != nil {
		return m.ShowKeepDuration
	}
	return 0
}

func (m *BufferDataProto) GetShowLevel() int32 {
	if m != nil {
		return m.ShowLevel
	}
	return 0
}

func (m *BufferDataProto) GetBuffGoodsId() int32 {
	if m != nil {
		return m.BuffGoodsId
	}
	return 0
}

// 联盟/联盟排行奖励.txt
type GuildRankPrizeDataProto struct {
	Rank                int32       `protobuf:"varint,1,opt,name=rank,proto3" json:"rank,omitempty"`
	Prize               *PrizeProto `protobuf:"bytes,2,opt,name=prize" json:"prize,omitempty"`
	CountryDestroyPrize *PrizeProto `protobuf:"bytes,3,opt,name=country_destroy_prize,json=countryDestroyPrize" json:"country_destroy_prize,omitempty"`
}

func (m *GuildRankPrizeDataProto) Reset()         { *m = GuildRankPrizeDataProto{} }
func (m *GuildRankPrizeDataProto) String() string { return proto.CompactTextString(m) }
func (*GuildRankPrizeDataProto) ProtoMessage()    {}
func (*GuildRankPrizeDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{49}
}

func (m *GuildRankPrizeDataProto) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *GuildRankPrizeDataProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

func (m *GuildRankPrizeDataProto) GetCountryDestroyPrize() *PrizeProto {
	if m != nil {
		return m.CountryDestroyPrize
	}
	return nil
}

// 充值/充值奖励.txt
type ChargePrizeDataProto struct {
	Id     int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name   string      `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	Image  string      `protobuf:"bytes,7,opt,name=image,proto3" json:"image,omitempty"`
	Amount int32       `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
	Value  int32       `protobuf:"varint,3,opt,name=value,proto3" json:"value,omitempty"`
	Prize  *PrizeProto `protobuf:"bytes,4,opt,name=prize" json:"prize,omitempty"`
	Desc   string      `protobuf:"bytes,5,opt,name=desc,proto3" json:"desc,omitempty"`
}

func (m *ChargePrizeDataProto) Reset()                    { *m = ChargePrizeDataProto{} }
func (m *ChargePrizeDataProto) String() string            { return proto.CompactTextString(m) }
func (*ChargePrizeDataProto) ProtoMessage()               {}
func (*ChargePrizeDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{50} }

func (m *ChargePrizeDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ChargePrizeDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ChargePrizeDataProto) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ChargePrizeDataProto) GetAmount() int32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *ChargePrizeDataProto) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *ChargePrizeDataProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

func (m *ChargePrizeDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

// 福利/体力领取.txt
type SpCollectionDataProto struct {
	Id            int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name          string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Icon          string      `protobuf:"bytes,3,opt,name=icon,proto3" json:"icon,omitempty"`
	TimeShow      string      `protobuf:"bytes,4,opt,name=time_show,json=timeShow,proto3" json:"time_show,omitempty"`
	StartDuration int32       `protobuf:"varint,5,opt,name=start_duration,json=startDuration,proto3" json:"start_duration,omitempty"`
	EndDuration   int32       `protobuf:"varint,6,opt,name=end_duration,json=endDuration,proto3" json:"end_duration,omitempty"`
	Sp            int32       `protobuf:"varint,7,opt,name=sp,proto3" json:"sp,omitempty"`
	RepairVip     int32       `protobuf:"varint,8,opt,name=repair_vip,json=repairVip,proto3" json:"repair_vip,omitempty"`
	SpPrize       *PrizeProto `protobuf:"bytes,9,opt,name=sp_prize,json=spPrize" json:"sp_prize,omitempty"`
	RepairCost    *CostProto  `protobuf:"bytes,10,opt,name=repair_cost,json=repairCost" json:"repair_cost,omitempty"`
}

func (m *SpCollectionDataProto) Reset()                    { *m = SpCollectionDataProto{} }
func (m *SpCollectionDataProto) String() string            { return proto.CompactTextString(m) }
func (*SpCollectionDataProto) ProtoMessage()               {}
func (*SpCollectionDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{51} }

func (m *SpCollectionDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SpCollectionDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SpCollectionDataProto) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *SpCollectionDataProto) GetTimeShow() string {
	if m != nil {
		return m.TimeShow
	}
	return ""
}

func (m *SpCollectionDataProto) GetStartDuration() int32 {
	if m != nil {
		return m.StartDuration
	}
	return 0
}

func (m *SpCollectionDataProto) GetEndDuration() int32 {
	if m != nil {
		return m.EndDuration
	}
	return 0
}

func (m *SpCollectionDataProto) GetSp() int32 {
	if m != nil {
		return m.Sp
	}
	return 0
}

func (m *SpCollectionDataProto) GetRepairVip() int32 {
	if m != nil {
		return m.RepairVip
	}
	return 0
}

func (m *SpCollectionDataProto) GetSpPrize() *PrizeProto {
	if m != nil {
		return m.SpPrize
	}
	return nil
}

func (m *SpCollectionDataProto) GetRepairCost() *CostProto {
	if m != nil {
		return m.RepairCost
	}
	return nil
}

// 策略/策略效果.txt
type StrategyEffectDataProto struct {
	StrategyId              int32              `protobuf:"varint,1,opt,name=strategy_id,json=strategyId,proto3" json:"strategy_id,omitempty"`
	EffectType              StrategyEffectType `protobuf:"varint,9,opt,name=effect_type,json=effectType,proto3,enum=proto.StrategyEffectType" json:"effect_type,omitempty"`
	HeroLevel               int32              `protobuf:"varint,2,opt,name=hero_level,json=heroLevel,proto3" json:"hero_level,omitempty"`
	Cost                    *CombineCostProto  `protobuf:"bytes,3,opt,name=cost" json:"cost,omitempty"`
	Prize                   *PrizeProto        `protobuf:"bytes,4,opt,name=prize" json:"prize,omitempty"`
	FarmFastHarvestDuration int32              `protobuf:"varint,6,opt,name=farm_fast_harvest_duration,json=farmFastHarvestDuration,proto3" json:"farm_fast_harvest_duration,omitempty"`
	TargetReduceSolider     int32              `protobuf:"varint,10,opt,name=target_reduce_solider,json=targetReduceSolider,proto3" json:"target_reduce_solider,omitempty"`
}

func (m *StrategyEffectDataProto) Reset()         { *m = StrategyEffectDataProto{} }
func (m *StrategyEffectDataProto) String() string { return proto.CompactTextString(m) }
func (*StrategyEffectDataProto) ProtoMessage()    {}
func (*StrategyEffectDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{52}
}

func (m *StrategyEffectDataProto) GetStrategyId() int32 {
	if m != nil {
		return m.StrategyId
	}
	return 0
}

func (m *StrategyEffectDataProto) GetEffectType() StrategyEffectType {
	if m != nil {
		return m.EffectType
	}
	return StrategyEffectType_Strategy_ET_invalid
}

func (m *StrategyEffectDataProto) GetHeroLevel() int32 {
	if m != nil {
		return m.HeroLevel
	}
	return 0
}

func (m *StrategyEffectDataProto) GetCost() *CombineCostProto {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *StrategyEffectDataProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

func (m *StrategyEffectDataProto) GetFarmFastHarvestDuration() int32 {
	if m != nil {
		return m.FarmFastHarvestDuration
	}
	return 0
}

func (m *StrategyEffectDataProto) GetTargetReduceSolider() int32 {
	if m != nil {
		return m.TargetReduceSolider
	}
	return 0
}

// 福利/每日特惠.txt
type DailyBargainDataProto struct {
	Id           int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name         string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	GiveYuanbao  int32       `protobuf:"varint,3,opt,name=give_yuanbao,json=giveYuanbao,proto3" json:"give_yuanbao,omitempty"`
	ShowYuanbao  int32       `protobuf:"varint,4,opt,name=show_yuanbao,json=showYuanbao,proto3" json:"show_yuanbao,omitempty"`
	Limit        int32       `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
	ChargeAmount int32       `protobuf:"varint,6,opt,name=charge_amount,json=chargeAmount,proto3" json:"charge_amount,omitempty"`
	Prize        *PrizeProto `protobuf:"bytes,7,opt,name=prize" json:"prize,omitempty"`
}

func (m *DailyBargainDataProto) Reset()                    { *m = DailyBargainDataProto{} }
func (m *DailyBargainDataProto) String() string            { return proto.CompactTextString(m) }
func (*DailyBargainDataProto) ProtoMessage()               {}
func (*DailyBargainDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{53} }

func (m *DailyBargainDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DailyBargainDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DailyBargainDataProto) GetGiveYuanbao() int32 {
	if m != nil {
		return m.GiveYuanbao
	}
	return 0
}

func (m *DailyBargainDataProto) GetShowYuanbao() int32 {
	if m != nil {
		return m.ShowYuanbao
	}
	return 0
}

func (m *DailyBargainDataProto) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *DailyBargainDataProto) GetChargeAmount() int32 {
	if m != nil {
		return m.ChargeAmount
	}
	return 0
}

func (m *DailyBargainDataProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

// 福利/尊享卡.txt
type DurationCardDataProto struct {
	Id                   int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Icon                 string      `protobuf:"bytes,3,opt,name=icon,proto3" json:"icon,omitempty"`
	Desc                 string      `protobuf:"bytes,4,opt,name=desc,proto3" json:"desc,omitempty"`
	Duration             int32       `protobuf:"varint,5,opt,name=duration,proto3" json:"duration,omitempty"`
	ChargeAmount         int32       `protobuf:"varint,6,opt,name=charge_amount,json=chargeAmount,proto3" json:"charge_amount,omitempty"`
	Prize                *PrizeProto `protobuf:"bytes,7,opt,name=prize" json:"prize,omitempty"`
	DailyPrize           *PrizeProto `protobuf:"bytes,8,opt,name=daily_prize,json=dailyPrize" json:"daily_prize,omitempty"`
	BeforePromptDuration int32       `protobuf:"varint,9,opt,name=before_prompt_duration,json=beforePromptDuration,proto3" json:"before_prompt_duration,omitempty"`
}

func (m *DurationCardDataProto) Reset()                    { *m = DurationCardDataProto{} }
func (m *DurationCardDataProto) String() string            { return proto.CompactTextString(m) }
func (*DurationCardDataProto) ProtoMessage()               {}
func (*DurationCardDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{54} }

func (m *DurationCardDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DurationCardDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DurationCardDataProto) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *DurationCardDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *DurationCardDataProto) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *DurationCardDataProto) GetChargeAmount() int32 {
	if m != nil {
		return m.ChargeAmount
	}
	return 0
}

func (m *DurationCardDataProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

func (m *DurationCardDataProto) GetDailyPrize() *PrizeProto {
	if m != nil {
		return m.DailyPrize
	}
	return nil
}

func (m *DurationCardDataProto) GetBeforePromptDuration() int32 {
	if m != nil {
		return m.BeforePromptDuration
	}
	return 0
}

// 战斗/杂项.txt
type CombatMiscConfigProto struct {
	Spell                 []int32 `protobuf:"varint,1,rep,name=spell" json:"spell,omitempty"`
	SpellAnimation        []int32 `protobuf:"varint,2,rep,name=spell_animation,json=spellAnimation" json:"spell_animation,omitempty"`
	PassiveSpell          []int32 `protobuf:"varint,3,rep,name=passive_spell,json=passiveSpell" json:"passive_spell,omitempty"`
	PassiveSpellAnimation []int32 `protobuf:"varint,4,rep,name=passive_spell_animation,json=passiveSpellAnimation" json:"passive_spell_animation,omitempty"`
	State                 []int32 `protobuf:"varint,5,rep,name=state" json:"state,omitempty"`
	StateAnimation        []int32 `protobuf:"varint,6,rep,name=state_animation,json=stateAnimation" json:"state_animation,omitempty"`
	MaxRage               int32   `protobuf:"varint,7,opt,name=max_rage,json=maxRage,proto3" json:"max_rage,omitempty"`
	WallAttackSpeed       int32   `protobuf:"varint,8,opt,name=wall_attack_speed,json=wallAttackSpeed,proto3" json:"wall_attack_speed,omitempty"`
}

func (m *CombatMiscConfigProto) Reset()                    { *m = CombatMiscConfigProto{} }
func (m *CombatMiscConfigProto) String() string            { return proto.CompactTextString(m) }
func (*CombatMiscConfigProto) ProtoMessage()               {}
func (*CombatMiscConfigProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{55} }

func (m *CombatMiscConfigProto) GetSpell() []int32 {
	if m != nil {
		return m.Spell
	}
	return nil
}

func (m *CombatMiscConfigProto) GetSpellAnimation() []int32 {
	if m != nil {
		return m.SpellAnimation
	}
	return nil
}

func (m *CombatMiscConfigProto) GetPassiveSpell() []int32 {
	if m != nil {
		return m.PassiveSpell
	}
	return nil
}

func (m *CombatMiscConfigProto) GetPassiveSpellAnimation() []int32 {
	if m != nil {
		return m.PassiveSpellAnimation
	}
	return nil
}

func (m *CombatMiscConfigProto) GetState() []int32 {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *CombatMiscConfigProto) GetStateAnimation() []int32 {
	if m != nil {
		return m.StateAnimation
	}
	return nil
}

func (m *CombatMiscConfigProto) GetMaxRage() int32 {
	if m != nil {
		return m.MaxRage
	}
	return 0
}

func (m *CombatMiscConfigProto) GetWallAttackSpeed() int32 {
	if m != nil {
		return m.WallAttackSpeed
	}
	return 0
}

// 福利/免费礼包.txt
type FreeGiftDataProto struct {
	Id       int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name     string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	GiftType GiftType    `protobuf:"varint,3,opt,name=gift_type,json=giftType,proto3,enum=proto.GiftType" json:"gift_type,omitempty"`
	Daily    bool        `protobuf:"varint,4,opt,name=daily,proto3" json:"daily,omitempty"`
	Prize    *PrizeProto `protobuf:"bytes,5,opt,name=prize" json:"prize,omitempty"`
}

func (m *FreeGiftDataProto) Reset()                    { *m = FreeGiftDataProto{} }
func (m *FreeGiftDataProto) String() string            { return proto.CompactTextString(m) }
func (*FreeGiftDataProto) ProtoMessage()               {}
func (*FreeGiftDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{56} }

func (m *FreeGiftDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *FreeGiftDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FreeGiftDataProto) GetGiftType() GiftType {
	if m != nil {
		return m.GiftType
	}
	return GiftType_InvalidGift
}

func (m *FreeGiftDataProto) GetDaily() bool {
	if m != nil {
		return m.Daily
	}
	return false
}

func (m *FreeGiftDataProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

// 充值/充值项.txt
type ChargeObjDataProto struct {
	Id                 int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name               string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Icon               string `protobuf:"bytes,9,opt,name=icon,proto3" json:"icon,omitempty"`
	Image              string `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	ProductId          int32  `protobuf:"varint,10,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	ChargeAmount       int32  `protobuf:"varint,4,opt,name=charge_amount,json=chargeAmount,proto3" json:"charge_amount,omitempty"`
	Yuanbao            int32  `protobuf:"varint,5,opt,name=yuanbao,proto3" json:"yuanbao,omitempty"`
	YuanbaoAddition    int32  `protobuf:"varint,6,opt,name=yuanbao_addition,json=yuanbaoAddition,proto3" json:"yuanbao_addition,omitempty"`
	FirstChargeYuanbao int32  `protobuf:"varint,7,opt,name=first_charge_yuanbao,json=firstChargeYuanbao,proto3" json:"first_charge_yuanbao,omitempty"`
	VipExp             int32  `protobuf:"varint,8,opt,name=vip_exp,json=vipExp,proto3" json:"vip_exp,omitempty"`
}

func (m *ChargeObjDataProto) Reset()                    { *m = ChargeObjDataProto{} }
func (m *ChargeObjDataProto) String() string            { return proto.CompactTextString(m) }
func (*ChargeObjDataProto) ProtoMessage()               {}
func (*ChargeObjDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{57} }

func (m *ChargeObjDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ChargeObjDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ChargeObjDataProto) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *ChargeObjDataProto) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ChargeObjDataProto) GetProductId() int32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *ChargeObjDataProto) GetChargeAmount() int32 {
	if m != nil {
		return m.ChargeAmount
	}
	return 0
}

func (m *ChargeObjDataProto) GetYuanbao() int32 {
	if m != nil {
		return m.Yuanbao
	}
	return 0
}

func (m *ChargeObjDataProto) GetYuanbaoAddition() int32 {
	if m != nil {
		return m.YuanbaoAddition
	}
	return 0
}

func (m *ChargeObjDataProto) GetFirstChargeYuanbao() int32 {
	if m != nil {
		return m.FirstChargeYuanbao
	}
	return 0
}

func (m *ChargeObjDataProto) GetVipExp() int32 {
	if m != nil {
		return m.VipExp
	}
	return 0
}

// 杂项/buff.txt
type BuffEffectDataProto struct {
	Id           int32            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name         string           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Desc         string           `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	Group        int32            `protobuf:"varint,13,opt,name=group,proto3" json:"group,omitempty"`
	EffectType   BuffEffectType   `protobuf:"varint,4,opt,name=effect_type,json=effectType,proto3,enum=proto.BuffEffectType" json:"effect_type,omitempty"`
	Level        int32            `protobuf:"varint,8,opt,name=level,proto3" json:"level,omitempty"`
	KeepDuration int32            `protobuf:"varint,9,opt,name=keep_duration,json=keepDuration,proto3" json:"keep_duration,omitempty"`
	NoDuration   bool             `protobuf:"varint,15,opt,name=no_duration,json=noDuration,proto3" json:"no_duration,omitempty"`
	PvpBuff      bool             `protobuf:"varint,16,opt,name=pvp_buff,json=pvpBuff,proto3" json:"pvp_buff,omitempty"`
	StatBuff     *SpriteStatProto `protobuf:"bytes,10,opt,name=stat_buff,json=statBuff" json:"stat_buff,omitempty"`
	CaptainTrain *AmountProto     `protobuf:"bytes,11,opt,name=captain_train,json=captainTrain" json:"captain_train,omitempty"`
	FarmHarvest  *AmountProto     `protobuf:"bytes,12,opt,name=farm_harvest,json=farmHarvest" json:"farm_harvest,omitempty"`
	Tax          *AmountProto     `protobuf:"bytes,14,opt,name=tax" json:"tax,omitempty"`
	AdvantageId  int32            `protobuf:"varint,17,opt,name=advantage_id,json=advantageId,proto3" json:"advantage_id,omitempty"`
}

func (m *BuffEffectDataProto) Reset()                    { *m = BuffEffectDataProto{} }
func (m *BuffEffectDataProto) String() string            { return proto.CompactTextString(m) }
func (*BuffEffectDataProto) ProtoMessage()               {}
func (*BuffEffectDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{58} }

func (m *BuffEffectDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BuffEffectDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BuffEffectDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *BuffEffectDataProto) GetGroup() int32 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *BuffEffectDataProto) GetEffectType() BuffEffectType {
	if m != nil {
		return m.EffectType
	}
	return BuffEffectType_Buff_ET_invalid
}

func (m *BuffEffectDataProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *BuffEffectDataProto) GetKeepDuration() int32 {
	if m != nil {
		return m.KeepDuration
	}
	return 0
}

func (m *BuffEffectDataProto) GetNoDuration() bool {
	if m != nil {
		return m.NoDuration
	}
	return false
}

func (m *BuffEffectDataProto) GetPvpBuff() bool {
	if m != nil {
		return m.PvpBuff
	}
	return false
}

func (m *BuffEffectDataProto) GetStatBuff() *SpriteStatProto {
	if m != nil {
		return m.StatBuff
	}
	return nil
}

func (m *BuffEffectDataProto) GetCaptainTrain() *AmountProto {
	if m != nil {
		return m.CaptainTrain
	}
	return nil
}

func (m *BuffEffectDataProto) GetFarmHarvest() *AmountProto {
	if m != nil {
		return m.FarmHarvest
	}
	return nil
}

func (m *BuffEffectDataProto) GetTax() *AmountProto {
	if m != nil {
		return m.Tax
	}
	return nil
}

func (m *BuffEffectDataProto) GetAdvantageId() int32 {
	if m != nil {
		return m.AdvantageId
	}
	return 0
}

// 地图/集结.txt
type AssemblyDataProto struct {
	Id           int32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	MemberCount  int32   `protobuf:"varint,2,opt,name=member_count,json=memberCount,proto3" json:"member_count,omitempty"`
	WaitDuration []int32 `protobuf:"varint,3,rep,name=wait_duration,json=waitDuration" json:"wait_duration,omitempty"`
}

func (m *AssemblyDataProto) Reset()                    { *m = AssemblyDataProto{} }
func (m *AssemblyDataProto) String() string            { return proto.CompactTextString(m) }
func (*AssemblyDataProto) ProtoMessage()               {}
func (*AssemblyDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{59} }

func (m *AssemblyDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AssemblyDataProto) GetMemberCount() int32 {
	if m != nil {
		return m.MemberCount
	}
	return 0
}

func (m *AssemblyDataProto) GetWaitDuration() []int32 {
	if m != nil {
		return m.WaitDuration
	}
	return nil
}

// 地图/军团怪物.txt
type JunTuanNpcDataProto struct {
	Id                int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Npc               int32 `protobuf:"varint,2,opt,name=npc,proto3" json:"npc,omitempty"`
	TroopCount        int32 `protobuf:"varint,3,opt,name=troop_count,json=troopCount,proto3" json:"troop_count,omitempty"`
	Group             int32 `protobuf:"varint,4,opt,name=group,proto3" json:"group,omitempty"`
	Level             int32 `protobuf:"varint,5,opt,name=level,proto3" json:"level,omitempty"`
	RequiredHeroLevel int32 `protobuf:"varint,6,opt,name=required_hero_level,json=requiredHeroLevel,proto3" json:"required_hero_level,omitempty"`
}

func (m *JunTuanNpcDataProto) Reset()                    { *m = JunTuanNpcDataProto{} }
func (m *JunTuanNpcDataProto) String() string            { return proto.CompactTextString(m) }
func (*JunTuanNpcDataProto) ProtoMessage()               {}
func (*JunTuanNpcDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{60} }

func (m *JunTuanNpcDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *JunTuanNpcDataProto) GetNpc() int32 {
	if m != nil {
		return m.Npc
	}
	return 0
}

func (m *JunTuanNpcDataProto) GetTroopCount() int32 {
	if m != nil {
		return m.TroopCount
	}
	return 0
}

func (m *JunTuanNpcDataProto) GetGroup() int32 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *JunTuanNpcDataProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *JunTuanNpcDataProto) GetRequiredHeroLevel() int32 {
	if m != nil {
		return m.RequiredHeroLevel
	}
	return 0
}

// 内政/繁荣度buff.txt
type ProsperityDamageBuffDataProto struct {
	Id         int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	MinPercent int32  `protobuf:"varint,6,opt,name=min_percent,json=minPercent,proto3" json:"min_percent,omitempty"`
	MaxPercent int32  `protobuf:"varint,7,opt,name=max_percent,json=maxPercent,proto3" json:"max_percent,omitempty"`
	Desc       string `protobuf:"bytes,4,opt,name=desc,proto3" json:"desc,omitempty"`
	BuffId     int32  `protobuf:"varint,5,opt,name=buff_id,json=buffId,proto3" json:"buff_id,omitempty"`
}

func (m *ProsperityDamageBuffDataProto) Reset()         { *m = ProsperityDamageBuffDataProto{} }
func (m *ProsperityDamageBuffDataProto) String() string { return proto.CompactTextString(m) }
func (*ProsperityDamageBuffDataProto) ProtoMessage()    {}
func (*ProsperityDamageBuffDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{61}
}

func (m *ProsperityDamageBuffDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ProsperityDamageBuffDataProto) GetMinPercent() int32 {
	if m != nil {
		return m.MinPercent
	}
	return 0
}

func (m *ProsperityDamageBuffDataProto) GetMaxPercent() int32 {
	if m != nil {
		return m.MaxPercent
	}
	return 0
}

func (m *ProsperityDamageBuffDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *ProsperityDamageBuffDataProto) GetBuffId() int32 {
	if m != nil {
		return m.BuffId
	}
	return 0
}

// 策略/增益类型.txt
type BufferTypeDataProto struct {
	Id        int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	TypeName  string `protobuf:"bytes,2,opt,name=type_name,json=typeName,proto3" json:"type_name,omitempty"`
	TypeDesc  string `protobuf:"bytes,3,opt,name=type_desc,json=typeDesc,proto3" json:"type_desc,omitempty"`
	IsMian    bool   `protobuf:"varint,5,opt,name=is_mian,json=isMian,proto3" json:"is_mian,omitempty"`
	BuffGroup int32  `protobuf:"varint,6,opt,name=buff_group,json=buffGroup,proto3" json:"buff_group,omitempty"`
	IconId    string `protobuf:"bytes,4,opt,name=icon_id,json=iconId,proto3" json:"icon_id,omitempty"`
	Sort      int32  `protobuf:"varint,7,opt,name=sort,proto3" json:"sort,omitempty"`
}

func (m *BufferTypeDataProto) Reset()                    { *m = BufferTypeDataProto{} }
func (m *BufferTypeDataProto) String() string            { return proto.CompactTextString(m) }
func (*BufferTypeDataProto) ProtoMessage()               {}
func (*BufferTypeDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{62} }

func (m *BufferTypeDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BufferTypeDataProto) GetTypeName() string {
	if m != nil {
		return m.TypeName
	}
	return ""
}

func (m *BufferTypeDataProto) GetTypeDesc() string {
	if m != nil {
		return m.TypeDesc
	}
	return ""
}

func (m *BufferTypeDataProto) GetIsMian() bool {
	if m != nil {
		return m.IsMian
	}
	return false
}

func (m *BufferTypeDataProto) GetBuffGroup() int32 {
	if m != nil {
		return m.BuffGroup
	}
	return 0
}

func (m *BufferTypeDataProto) GetIconId() string {
	if m != nil {
		return m.IconId
	}
	return ""
}

func (m *BufferTypeDataProto) GetSort() int32 {
	if m != nil {
		return m.Sort
	}
	return 0
}

// vip/连续登录奖励.txt
type VipContinueDaysDataProto struct {
	Level int32   `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	Days  []int32 `protobuf:"varint,2,rep,name=days" json:"days,omitempty"`
	Exp   []int32 `protobuf:"varint,5,rep,name=exp" json:"exp,omitempty"`
}

func (m *VipContinueDaysDataProto) Reset()         { *m = VipContinueDaysDataProto{} }
func (m *VipContinueDaysDataProto) String() string { return proto.CompactTextString(m) }
func (*VipContinueDaysDataProto) ProtoMessage()    {}
func (*VipContinueDaysDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{63}
}

func (m *VipContinueDaysDataProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *VipContinueDaysDataProto) GetDays() []int32 {
	if m != nil {
		return m.Days
	}
	return nil
}

func (m *VipContinueDaysDataProto) GetExp() []int32 {
	if m != nil {
		return m.Exp
	}
	return nil
}

// vip/vip等级.txt
type VipLevelDataProto struct {
	Level                            int32       `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	Name                             string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	IconId                           string      `protobuf:"bytes,3,opt,name=icon_id,json=iconId,proto3" json:"icon_id,omitempty"`
	UpgradeExp                       int32       `protobuf:"varint,4,opt,name=upgrade_exp,json=upgradeExp,proto3" json:"upgrade_exp,omitempty"`
	DailyExp                         int32       `protobuf:"varint,8,opt,name=daily_exp,json=dailyExp,proto3" json:"daily_exp,omitempty"`
	DailyPrize                       *PrizeProto `protobuf:"bytes,9,opt,name=daily_prize,json=dailyPrize" json:"daily_prize,omitempty"`
	ShowDailyPrizeCost               *CostProto  `protobuf:"bytes,18,opt,name=show_daily_prize_cost,json=showDailyPrizeCost" json:"show_daily_prize_cost,omitempty"`
	LevelPrize                       *PrizeProto `protobuf:"bytes,10,opt,name=level_prize,json=levelPrize" json:"level_prize,omitempty"`
	LevelPrizeCost                   *CostProto  `protobuf:"bytes,11,opt,name=level_prize_cost,json=levelPrizeCost" json:"level_prize_cost,omitempty"`
	ShowLevelPrizeCost               *CostProto  `protobuf:"bytes,19,opt,name=show_level_prize_cost,json=showLevelPrizeCost" json:"show_level_prize_cost,omitempty"`
	BuyProsperity                    bool        `protobuf:"varint,20,opt,name=buy_prosperity,json=buyProsperity,proto3" json:"buy_prosperity,omitempty"`
	JiuGuanAutoMax                   bool        `protobuf:"varint,13,opt,name=jiu_guan_auto_max,json=jiuGuanAutoMax,proto3" json:"jiu_guan_auto_max,omitempty"`
	JiuGuanCostRefreshCount          int32       `protobuf:"varint,16,opt,name=jiu_guan_cost_refresh_count,json=jiuGuanCostRefreshCount,proto3" json:"jiu_guan_cost_refresh_count,omitempty"`
	JiuGuanCostRefreshInfinite       bool        `protobuf:"varint,17,opt,name=jiu_guan_cost_refresh_infinite,json=jiuGuanCostRefreshInfinite,proto3" json:"jiu_guan_cost_refresh_infinite,omitempty"`
	JiuGuanQuickConsult              bool        `protobuf:"varint,23,opt,name=jiu_guan_quick_consult,json=jiuGuanQuickConsult,proto3" json:"jiu_guan_quick_consult,omitempty"`
	CaptainTrainCoef                 int32       `protobuf:"varint,21,opt,name=captain_train_coef,json=captainTrainCoef,proto3" json:"captain_train_coef,omitempty"`
	CaptainTrainCapacity             int32       `protobuf:"varint,22,opt,name=captain_train_capacity,json=captainTrainCapacity,proto3" json:"captain_train_capacity,omitempty"`
	WallAutoFullSoldier              bool        `protobuf:"varint,24,opt,name=wall_auto_full_soldier,json=wallAutoFullSoldier,proto3" json:"wall_auto_full_soldier,omitempty"`
	BuySpMaxTimes                    int32       `protobuf:"varint,25,opt,name=buy_sp_max_times,json=buySpMaxTimes,proto3" json:"buy_sp_max_times,omitempty"`
	DungeonMaxCostTimesLimit         int32       `protobuf:"varint,30,opt,name=dungeon_max_cost_times_limit,json=dungeonMaxCostTimesLimit,proto3" json:"dungeon_max_cost_times_limit,omitempty"`
	WorkerUnlockPos                  int32       `protobuf:"varint,28,opt,name=worker_unlock_pos,json=workerUnlockPos,proto3" json:"worker_unlock_pos,omitempty"`
	InvadeMultiLevelMonsterOnceCount int32       `protobuf:"varint,29,opt,name=invade_multi_level_monster_once_count,json=invadeMultiLevelMonsterOnceCount,proto3" json:"invade_multi_level_monster_once_count,omitempty"`
	GuildPrizeOneKeyCollect          bool        `protobuf:"varint,31,opt,name=guild_prize_one_key_collect,json=guildPrizeOneKeyCollect,proto3" json:"guild_prize_one_key_collect,omitempty"`
	AddBlackMarketRefreshTimes       int32       `protobuf:"varint,32,opt,name=add_black_market_refresh_times,json=addBlackMarketRefreshTimes,proto3" json:"add_black_market_refresh_times,omitempty"`
	FishingCaptainProbability        bool        `protobuf:"varint,33,opt,name=fishing_captain_probability,json=fishingCaptainProbability,proto3" json:"fishing_captain_probability,omitempty"`
	ShowRegionHome                   bool        `protobuf:"varint,34,opt,name=show_region_home,json=showRegionHome,proto3" json:"show_region_home,omitempty"`
	ShowRegionSign                   bool        `protobuf:"varint,35,opt,name=show_region_sign,json=showRegionSign,proto3" json:"show_region_sign,omitempty"`
	ShowRegionTitle                  bool        `protobuf:"varint,36,opt,name=show_region_title,json=showRegionTitle,proto3" json:"show_region_title,omitempty"`
	ShowHeadFrame                    bool        `protobuf:"varint,37,opt,name=show_head_frame,json=showHeadFrame,proto3" json:"show_head_frame,omitempty"`
	ZhengWuAutoCompleted             bool        `protobuf:"varint,38,opt,name=zheng_wu_auto_completed,json=zhengWuAutoCompleted,proto3" json:"zheng_wu_auto_completed,omitempty"`
	WorkshopAutoCompleted            bool        `protobuf:"varint,39,opt,name=workshop_auto_completed,json=workshopAutoCompleted,proto3" json:"workshop_auto_completed,omitempty"`
	CollectDailySp                   bool        `protobuf:"varint,40,opt,name=collect_daily_sp,json=collectDailySp,proto3" json:"collect_daily_sp,omitempty"`
}

func (m *VipLevelDataProto) Reset()                    { *m = VipLevelDataProto{} }
func (m *VipLevelDataProto) String() string            { return proto.CompactTextString(m) }
func (*VipLevelDataProto) ProtoMessage()               {}
func (*VipLevelDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{64} }

func (m *VipLevelDataProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *VipLevelDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VipLevelDataProto) GetIconId() string {
	if m != nil {
		return m.IconId
	}
	return ""
}

func (m *VipLevelDataProto) GetUpgradeExp() int32 {
	if m != nil {
		return m.UpgradeExp
	}
	return 0
}

func (m *VipLevelDataProto) GetDailyExp() int32 {
	if m != nil {
		return m.DailyExp
	}
	return 0
}

func (m *VipLevelDataProto) GetDailyPrize() *PrizeProto {
	if m != nil {
		return m.DailyPrize
	}
	return nil
}

func (m *VipLevelDataProto) GetShowDailyPrizeCost() *CostProto {
	if m != nil {
		return m.ShowDailyPrizeCost
	}
	return nil
}

func (m *VipLevelDataProto) GetLevelPrize() *PrizeProto {
	if m != nil {
		return m.LevelPrize
	}
	return nil
}

func (m *VipLevelDataProto) GetLevelPrizeCost() *CostProto {
	if m != nil {
		return m.LevelPrizeCost
	}
	return nil
}

func (m *VipLevelDataProto) GetShowLevelPrizeCost() *CostProto {
	if m != nil {
		return m.ShowLevelPrizeCost
	}
	return nil
}

func (m *VipLevelDataProto) GetBuyProsperity() bool {
	if m != nil {
		return m.BuyProsperity
	}
	return false
}

func (m *VipLevelDataProto) GetJiuGuanAutoMax() bool {
	if m != nil {
		return m.JiuGuanAutoMax
	}
	return false
}

func (m *VipLevelDataProto) GetJiuGuanCostRefreshCount() int32 {
	if m != nil {
		return m.JiuGuanCostRefreshCount
	}
	return 0
}

func (m *VipLevelDataProto) GetJiuGuanCostRefreshInfinite() bool {
	if m != nil {
		return m.JiuGuanCostRefreshInfinite
	}
	return false
}

func (m *VipLevelDataProto) GetJiuGuanQuickConsult() bool {
	if m != nil {
		return m.JiuGuanQuickConsult
	}
	return false
}

func (m *VipLevelDataProto) GetCaptainTrainCoef() int32 {
	if m != nil {
		return m.CaptainTrainCoef
	}
	return 0
}

func (m *VipLevelDataProto) GetCaptainTrainCapacity() int32 {
	if m != nil {
		return m.CaptainTrainCapacity
	}
	return 0
}

func (m *VipLevelDataProto) GetWallAutoFullSoldier() bool {
	if m != nil {
		return m.WallAutoFullSoldier
	}
	return false
}

func (m *VipLevelDataProto) GetBuySpMaxTimes() int32 {
	if m != nil {
		return m.BuySpMaxTimes
	}
	return 0
}

func (m *VipLevelDataProto) GetDungeonMaxCostTimesLimit() int32 {
	if m != nil {
		return m.DungeonMaxCostTimesLimit
	}
	return 0
}

func (m *VipLevelDataProto) GetWorkerUnlockPos() int32 {
	if m != nil {
		return m.WorkerUnlockPos
	}
	return 0
}

func (m *VipLevelDataProto) GetInvadeMultiLevelMonsterOnceCount() int32 {
	if m != nil {
		return m.InvadeMultiLevelMonsterOnceCount
	}
	return 0
}

func (m *VipLevelDataProto) GetGuildPrizeOneKeyCollect() bool {
	if m != nil {
		return m.GuildPrizeOneKeyCollect
	}
	return false
}

func (m *VipLevelDataProto) GetAddBlackMarketRefreshTimes() int32 {
	if m != nil {
		return m.AddBlackMarketRefreshTimes
	}
	return 0
}

func (m *VipLevelDataProto) GetFishingCaptainProbability() bool {
	if m != nil {
		return m.FishingCaptainProbability
	}
	return false
}

func (m *VipLevelDataProto) GetShowRegionHome() bool {
	if m != nil {
		return m.ShowRegionHome
	}
	return false
}

func (m *VipLevelDataProto) GetShowRegionSign() bool {
	if m != nil {
		return m.ShowRegionSign
	}
	return false
}

func (m *VipLevelDataProto) GetShowRegionTitle() bool {
	if m != nil {
		return m.ShowRegionTitle
	}
	return false
}

func (m *VipLevelDataProto) GetShowHeadFrame() bool {
	if m != nil {
		return m.ShowHeadFrame
	}
	return false
}

func (m *VipLevelDataProto) GetZhengWuAutoCompleted() bool {
	if m != nil {
		return m.ZhengWuAutoCompleted
	}
	return false
}

func (m *VipLevelDataProto) GetWorkshopAutoCompleted() bool {
	if m != nil {
		return m.WorkshopAutoCompleted
	}
	return false
}

func (m *VipLevelDataProto) GetCollectDailySp() bool {
	if m != nil {
		return m.CollectDailySp
	}
	return false
}

// vip/vip杂项.txt
type VipMiscDataProto struct {
	CollectVipDailyExpMinHeroLevel int32        `protobuf:"varint,1,opt,name=collect_vip_daily_exp_min_hero_level,json=collectVipDailyExpMinHeroLevel,proto3" json:"collect_vip_daily_exp_min_hero_level,omitempty"`
	DungeonTimesCost               []*CostProto `protobuf:"bytes,2,rep,name=dungeon_times_cost,json=dungeonTimesCost" json:"dungeon_times_cost,omitempty"`
	DungeonTimesEachBuy            []int32      `protobuf:"varint,4,rep,name=dungeon_times_each_buy,json=dungeonTimesEachBuy" json:"dungeon_times_each_buy,omitempty"`
}

func (m *VipMiscDataProto) Reset()                    { *m = VipMiscDataProto{} }
func (m *VipMiscDataProto) String() string            { return proto.CompactTextString(m) }
func (*VipMiscDataProto) ProtoMessage()               {}
func (*VipMiscDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{65} }

func (m *VipMiscDataProto) GetCollectVipDailyExpMinHeroLevel() int32 {
	if m != nil {
		return m.CollectVipDailyExpMinHeroLevel
	}
	return 0
}

func (m *VipMiscDataProto) GetDungeonTimesCost() []*CostProto {
	if m != nil {
		return m.DungeonTimesCost
	}
	return nil
}

func (m *VipMiscDataProto) GetDungeonTimesEachBuy() []int32 {
	if m != nil {
		return m.DungeonTimesEachBuy
	}
	return nil
}

// 设置/隐私设置.txt
type PrivacySettingDataProto struct {
	SettingType PrivacySettingType `protobuf:"varint,6,opt,name=setting_type,json=settingType,proto3,enum=proto.PrivacySettingType" json:"setting_type,omitempty"`
	Name        string             `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	NameType    string             `protobuf:"bytes,3,opt,name=name_type,json=nameType,proto3" json:"name_type,omitempty"`
	RuleTitle   string             `protobuf:"bytes,4,opt,name=rule_title,json=ruleTitle,proto3" json:"rule_title,omitempty"`
	RuleDesc    string             `protobuf:"bytes,5,opt,name=rule_desc,json=ruleDesc,proto3" json:"rule_desc,omitempty"`
}

func (m *PrivacySettingDataProto) Reset()         { *m = PrivacySettingDataProto{} }
func (m *PrivacySettingDataProto) String() string { return proto.CompactTextString(m) }
func (*PrivacySettingDataProto) ProtoMessage()    {}
func (*PrivacySettingDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{66}
}

func (m *PrivacySettingDataProto) GetSettingType() PrivacySettingType {
	if m != nil {
		return m.SettingType
	}
	return PrivacySettingType_InvalidPrivacySettingType
}

func (m *PrivacySettingDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PrivacySettingDataProto) GetNameType() string {
	if m != nil {
		return m.NameType
	}
	return ""
}

func (m *PrivacySettingDataProto) GetRuleTitle() string {
	if m != nil {
		return m.RuleTitle
	}
	return ""
}

func (m *PrivacySettingDataProto) GetRuleDesc() string {
	if m != nil {
		return m.RuleDesc
	}
	return ""
}

// 福利/定时时限礼包.txt
type TimeLimitGiftDataProto struct {
	Id                int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name              string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Icon              string      `protobuf:"bytes,8,opt,name=icon,proto3" json:"icon,omitempty"`
	Image             string      `protobuf:"bytes,9,opt,name=image,proto3" json:"image,omitempty"`
	Desc              string      `protobuf:"bytes,10,opt,name=desc,proto3" json:"desc,omitempty"`
	YuanbaoPrice      int32       `protobuf:"varint,3,opt,name=yuanbao_price,json=yuanbaoPrice,proto3" json:"yuanbao_price,omitempty"`
	OldPrice          int32       `protobuf:"varint,4,opt,name=old_price,json=oldPrice,proto3" json:"old_price,omitempty"`
	SignIcon          string      `protobuf:"bytes,11,opt,name=sign_icon,json=signIcon,proto3" json:"sign_icon,omitempty"`
	SignName          string      `protobuf:"bytes,12,opt,name=sign_name,json=signName,proto3" json:"sign_name,omitempty"`
	DiscountIcon      string      `protobuf:"bytes,6,opt,name=discount_icon,json=discountIcon,proto3" json:"discount_icon,omitempty"`
	Discount          string      `protobuf:"bytes,13,opt,name=discount,proto3" json:"discount,omitempty"`
	Dianquan          int32       `protobuf:"varint,7,opt,name=dianquan,proto3" json:"dianquan,omitempty"`
	Priority          int32       `protobuf:"varint,14,opt,name=priority,proto3" json:"priority,omitempty"`
	Prize             *PrizeProto `protobuf:"bytes,20,opt,name=prize" json:"prize,omitempty"`
	BuyLimit          int32       `protobuf:"varint,19,opt,name=buy_limit,json=buyLimit,proto3" json:"buy_limit,omitempty"`
	Sort              int32       `protobuf:"varint,21,opt,name=sort,proto3" json:"sort,omitempty"`
	ShowPrize         *PrizeProto `protobuf:"bytes,22,opt,name=show_prize,json=showPrize" json:"show_prize,omitempty"`
	GuildEventPrizeId int32       `protobuf:"varint,23,opt,name=guild_event_prize_id,json=guildEventPrizeId,proto3" json:"guild_event_prize_id,omitempty"`
}

func (m *TimeLimitGiftDataProto) Reset()                    { *m = TimeLimitGiftDataProto{} }
func (m *TimeLimitGiftDataProto) String() string            { return proto.CompactTextString(m) }
func (*TimeLimitGiftDataProto) ProtoMessage()               {}
func (*TimeLimitGiftDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{67} }

func (m *TimeLimitGiftDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TimeLimitGiftDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TimeLimitGiftDataProto) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *TimeLimitGiftDataProto) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *TimeLimitGiftDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *TimeLimitGiftDataProto) GetYuanbaoPrice() int32 {
	if m != nil {
		return m.YuanbaoPrice
	}
	return 0
}

func (m *TimeLimitGiftDataProto) GetOldPrice() int32 {
	if m != nil {
		return m.OldPrice
	}
	return 0
}

func (m *TimeLimitGiftDataProto) GetSignIcon() string {
	if m != nil {
		return m.SignIcon
	}
	return ""
}

func (m *TimeLimitGiftDataProto) GetSignName() string {
	if m != nil {
		return m.SignName
	}
	return ""
}

func (m *TimeLimitGiftDataProto) GetDiscountIcon() string {
	if m != nil {
		return m.DiscountIcon
	}
	return ""
}

func (m *TimeLimitGiftDataProto) GetDiscount() string {
	if m != nil {
		return m.Discount
	}
	return ""
}

func (m *TimeLimitGiftDataProto) GetDianquan() int32 {
	if m != nil {
		return m.Dianquan
	}
	return 0
}

func (m *TimeLimitGiftDataProto) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *TimeLimitGiftDataProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

func (m *TimeLimitGiftDataProto) GetBuyLimit() int32 {
	if m != nil {
		return m.BuyLimit
	}
	return 0
}

func (m *TimeLimitGiftDataProto) GetSort() int32 {
	if m != nil {
		return m.Sort
	}
	return 0
}

func (m *TimeLimitGiftDataProto) GetShowPrize() *PrizeProto {
	if m != nil {
		return m.ShowPrize
	}
	return nil
}

func (m *TimeLimitGiftDataProto) GetGuildEventPrizeId() int32 {
	if m != nil {
		return m.GuildEventPrizeId
	}
	return 0
}

// 福利/事件时限礼包.txt
type EventLimitGiftDataProto struct {
	Id                int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name              string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Icon              string      `protobuf:"bytes,3,opt,name=icon,proto3" json:"icon,omitempty"`
	Image             string      `protobuf:"bytes,4,opt,name=image,proto3" json:"image,omitempty"`
	Desc              string      `protobuf:"bytes,5,opt,name=desc,proto3" json:"desc,omitempty"`
	YuanbaoPrice      int32       `protobuf:"varint,6,opt,name=yuanbao_price,json=yuanbaoPrice,proto3" json:"yuanbao_price,omitempty"`
	OldPrice          int32       `protobuf:"varint,7,opt,name=old_price,json=oldPrice,proto3" json:"old_price,omitempty"`
	SignIcon          string      `protobuf:"bytes,8,opt,name=sign_icon,json=signIcon,proto3" json:"sign_icon,omitempty"`
	SignName          string      `protobuf:"bytes,9,opt,name=sign_name,json=signName,proto3" json:"sign_name,omitempty"`
	DiscountIcon      string      `protobuf:"bytes,10,opt,name=discount_icon,json=discountIcon,proto3" json:"discount_icon,omitempty"`
	Discount          string      `protobuf:"bytes,11,opt,name=discount,proto3" json:"discount,omitempty"`
	Dianquan          int32       `protobuf:"varint,12,opt,name=dianquan,proto3" json:"dianquan,omitempty"`
	Priority          int32       `protobuf:"varint,13,opt,name=priority,proto3" json:"priority,omitempty"`
	BuyLimit          int32       `protobuf:"varint,18,opt,name=buy_limit,json=buyLimit,proto3" json:"buy_limit,omitempty"`
	ShowPrize         *PrizeProto `protobuf:"bytes,19,opt,name=show_prize,json=showPrize" json:"show_prize,omitempty"`
	GuildEventPrizeId int32       `protobuf:"varint,20,opt,name=guild_event_prize_id,json=guildEventPrizeId,proto3" json:"guild_event_prize_id,omitempty"`
}

func (m *EventLimitGiftDataProto) Reset()         { *m = EventLimitGiftDataProto{} }
func (m *EventLimitGiftDataProto) String() string { return proto.CompactTextString(m) }
func (*EventLimitGiftDataProto) ProtoMessage()    {}
func (*EventLimitGiftDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{68}
}

func (m *EventLimitGiftDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EventLimitGiftDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EventLimitGiftDataProto) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *EventLimitGiftDataProto) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *EventLimitGiftDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *EventLimitGiftDataProto) GetYuanbaoPrice() int32 {
	if m != nil {
		return m.YuanbaoPrice
	}
	return 0
}

func (m *EventLimitGiftDataProto) GetOldPrice() int32 {
	if m != nil {
		return m.OldPrice
	}
	return 0
}

func (m *EventLimitGiftDataProto) GetSignIcon() string {
	if m != nil {
		return m.SignIcon
	}
	return ""
}

func (m *EventLimitGiftDataProto) GetSignName() string {
	if m != nil {
		return m.SignName
	}
	return ""
}

func (m *EventLimitGiftDataProto) GetDiscountIcon() string {
	if m != nil {
		return m.DiscountIcon
	}
	return ""
}

func (m *EventLimitGiftDataProto) GetDiscount() string {
	if m != nil {
		return m.Discount
	}
	return ""
}

func (m *EventLimitGiftDataProto) GetDianquan() int32 {
	if m != nil {
		return m.Dianquan
	}
	return 0
}

func (m *EventLimitGiftDataProto) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *EventLimitGiftDataProto) GetBuyLimit() int32 {
	if m != nil {
		return m.BuyLimit
	}
	return 0
}

func (m *EventLimitGiftDataProto) GetShowPrize() *PrizeProto {
	if m != nil {
		return m.ShowPrize
	}
	return nil
}

func (m *EventLimitGiftDataProto) GetGuildEventPrizeId() int32 {
	if m != nil {
		return m.GuildEventPrizeId
	}
	return 0
}

// 名城营建/增加民心.txt
type McBuildAddSupportDataProto struct {
	BaiZhanLevel int32 `protobuf:"varint,1,opt,name=bai_zhan_level,json=baiZhanLevel,proto3" json:"bai_zhan_level,omitempty"`
	AddSupport   int32 `protobuf:"varint,2,opt,name=add_support,json=addSupport,proto3" json:"add_support,omitempty"`
}

func (m *McBuildAddSupportDataProto) Reset()         { *m = McBuildAddSupportDataProto{} }
func (m *McBuildAddSupportDataProto) String() string { return proto.CompactTextString(m) }
func (*McBuildAddSupportDataProto) ProtoMessage()    {}
func (*McBuildAddSupportDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{69}
}

func (m *McBuildAddSupportDataProto) GetBaiZhanLevel() int32 {
	if m != nil {
		return m.BaiZhanLevel
	}
	return 0
}

func (m *McBuildAddSupportDataProto) GetAddSupport() int32 {
	if m != nil {
		return m.AddSupport
	}
	return 0
}

// 名城营建/联盟成员奖励.txt
type McBuildGuildMemberPrizeDataProto struct {
	MinBuildCount int32       `protobuf:"varint,2,opt,name=min_build_count,json=minBuildCount,proto3" json:"min_build_count,omitempty"`
	MaxBuildCount int32       `protobuf:"varint,3,opt,name=max_build_count,json=maxBuildCount,proto3" json:"max_build_count,omitempty"`
	Prize         *PrizeProto `protobuf:"bytes,4,opt,name=prize" json:"prize,omitempty"`
}

func (m *McBuildGuildMemberPrizeDataProto) Reset()         { *m = McBuildGuildMemberPrizeDataProto{} }
func (m *McBuildGuildMemberPrizeDataProto) String() string { return proto.CompactTextString(m) }
func (*McBuildGuildMemberPrizeDataProto) ProtoMessage()    {}
func (*McBuildGuildMemberPrizeDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{70}
}

func (m *McBuildGuildMemberPrizeDataProto) GetMinBuildCount() int32 {
	if m != nil {
		return m.MinBuildCount
	}
	return 0
}

func (m *McBuildGuildMemberPrizeDataProto) GetMaxBuildCount() int32 {
	if m != nil {
		return m.MaxBuildCount
	}
	return 0
}

func (m *McBuildGuildMemberPrizeDataProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

// 名城营建/名城民心.txt
type McBuildMcSupportDataProto struct {
	Level                int32 `protobuf:"varint,7,opt,name=level,proto3" json:"level,omitempty"`
	UpgradeSupport       int32 `protobuf:"varint,8,opt,name=upgrade_support,json=upgradeSupport,proto3" json:"upgrade_support,omitempty"`
	AddDailyYinliang     int32 `protobuf:"varint,4,opt,name=add_daily_yinliang,json=addDailyYinliang,proto3" json:"add_daily_yinliang,omitempty"`
	AddMaxYinliang       int32 `protobuf:"varint,5,opt,name=add_max_yinliang,json=addMaxYinliang,proto3" json:"add_max_yinliang,omitempty"`
	AddHostDailyYinliang int32 `protobuf:"varint,6,opt,name=add_host_daily_yinliang,json=addHostDailyYinliang,proto3" json:"add_host_daily_yinliang,omitempty"`
}

func (m *McBuildMcSupportDataProto) Reset()         { *m = McBuildMcSupportDataProto{} }
func (m *McBuildMcSupportDataProto) String() string { return proto.CompactTextString(m) }
func (*McBuildMcSupportDataProto) ProtoMessage()    {}
func (*McBuildMcSupportDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{71}
}

func (m *McBuildMcSupportDataProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *McBuildMcSupportDataProto) GetUpgradeSupport() int32 {
	if m != nil {
		return m.UpgradeSupport
	}
	return 0
}

func (m *McBuildMcSupportDataProto) GetAddDailyYinliang() int32 {
	if m != nil {
		return m.AddDailyYinliang
	}
	return 0
}

func (m *McBuildMcSupportDataProto) GetAddMaxYinliang() int32 {
	if m != nil {
		return m.AddMaxYinliang
	}
	return 0
}

func (m *McBuildMcSupportDataProto) GetAddHostDailyYinliang() int32 {
	if m != nil {
		return m.AddHostDailyYinliang
	}
	return 0
}

// 名城营建/营建杂项.txt
type McBuildMiscDataProto struct {
	MaxDailyAddSupport       int32 `protobuf:"varint,2,opt,name=max_daily_add_support,json=maxDailyAddSupport,proto3" json:"max_daily_add_support,omitempty"`
	DailyReduceSupport       int32 `protobuf:"varint,3,opt,name=daily_reduce_support,json=dailyReduceSupport,proto3" json:"daily_reduce_support,omitempty"`
	BuildCd                  int32 `protobuf:"varint,8,opt,name=build_cd,json=buildCd,proto3" json:"build_cd,omitempty"`
	DailyBuildMaxCount       int32 `protobuf:"varint,5,opt,name=daily_build_max_count,json=dailyBuildMaxCount,proto3" json:"daily_build_max_count,omitempty"`
	BuildMinHeroLevel        int32 `protobuf:"varint,6,opt,name=build_min_hero_level,json=buildMinHeroLevel,proto3" json:"build_min_hero_level,omitempty"`
	MaxRecommendMcGuildCount int32 `protobuf:"varint,9,opt,name=max_recommend_mc_guild_count,json=maxRecommendMcGuildCount,proto3" json:"max_recommend_mc_guild_count,omitempty"`
	MaxMcBuildLogCount       int32 `protobuf:"varint,10,opt,name=max_mc_build_log_count,json=maxMcBuildLogCount,proto3" json:"max_mc_build_log_count,omitempty"`
}

func (m *McBuildMiscDataProto) Reset()                    { *m = McBuildMiscDataProto{} }
func (m *McBuildMiscDataProto) String() string            { return proto.CompactTextString(m) }
func (*McBuildMiscDataProto) ProtoMessage()               {}
func (*McBuildMiscDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{72} }

func (m *McBuildMiscDataProto) GetMaxDailyAddSupport() int32 {
	if m != nil {
		return m.MaxDailyAddSupport
	}
	return 0
}

func (m *McBuildMiscDataProto) GetDailyReduceSupport() int32 {
	if m != nil {
		return m.DailyReduceSupport
	}
	return 0
}

func (m *McBuildMiscDataProto) GetBuildCd() int32 {
	if m != nil {
		return m.BuildCd
	}
	return 0
}

func (m *McBuildMiscDataProto) GetDailyBuildMaxCount() int32 {
	if m != nil {
		return m.DailyBuildMaxCount
	}
	return 0
}

func (m *McBuildMiscDataProto) GetBuildMinHeroLevel() int32 {
	if m != nil {
		return m.BuildMinHeroLevel
	}
	return 0
}

func (m *McBuildMiscDataProto) GetMaxRecommendMcGuildCount() int32 {
	if m != nil {
		return m.MaxRecommendMcGuildCount
	}
	return 0
}

func (m *McBuildMiscDataProto) GetMaxMcBuildLogCount() int32 {
	if m != nil {
		return m.MaxMcBuildLogCount
	}
	return 0
}

// 武将/武将羁绊.txt
type CaptainFriendshipDataProto struct {
	Id           int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name         string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Desc         string   `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	Tips         string   `protobuf:"bytes,4,opt,name=tips,proto3" json:"tips,omitempty"`
	Captains     []int32  `protobuf:"varint,5,rep,name=captains" json:"captains,omitempty"`
	EffectDesc   []string `protobuf:"bytes,6,rep,name=effect_desc,json=effectDesc" json:"effect_desc,omitempty"`
	EffectAmount []int32  `protobuf:"varint,7,rep,name=effect_amount,json=effectAmount" json:"effect_amount,omitempty"`
}

func (m *CaptainFriendshipDataProto) Reset()         { *m = CaptainFriendshipDataProto{} }
func (m *CaptainFriendshipDataProto) String() string { return proto.CompactTextString(m) }
func (*CaptainFriendshipDataProto) ProtoMessage()    {}
func (*CaptainFriendshipDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{73}
}

func (m *CaptainFriendshipDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CaptainFriendshipDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CaptainFriendshipDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *CaptainFriendshipDataProto) GetTips() string {
	if m != nil {
		return m.Tips
	}
	return ""
}

func (m *CaptainFriendshipDataProto) GetCaptains() []int32 {
	if m != nil {
		return m.Captains
	}
	return nil
}

func (m *CaptainFriendshipDataProto) GetEffectDesc() []string {
	if m != nil {
		return m.EffectDesc
	}
	return nil
}

func (m *CaptainFriendshipDataProto) GetEffectAmount() []int32 {
	if m != nil {
		return m.EffectAmount
	}
	return nil
}

// 杂项/红包.txt
type RedPacketDataProto struct {
	Id              int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Icon            *IconProto  `protobuf:"bytes,2,opt,name=icon" json:"icon,omitempty"`
	Name            string      `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Desc            string      `protobuf:"bytes,4,opt,name=desc,proto3" json:"desc,omitempty"`
	DefaultText     string      `protobuf:"bytes,5,opt,name=default_text,json=defaultText,proto3" json:"default_text,omitempty"`
	Cost            *CostProto  `protobuf:"bytes,6,opt,name=cost" json:"cost,omitempty"`
	AmountType      AmountType  `protobuf:"varint,7,opt,name=amount_type,json=amountType,proto3,enum=proto.AmountType" json:"amount_type,omitempty"`
	Money           int32       `protobuf:"varint,8,opt,name=money,proto3" json:"money,omitempty"`
	AllGarbbedPrize *PrizeProto `protobuf:"bytes,9,opt,name=all_garbbed_prize,json=allGarbbedPrize" json:"all_garbbed_prize,omitempty"`
	ExpiredDuration int32       `protobuf:"varint,10,opt,name=expired_duration,json=expiredDuration,proto3" json:"expired_duration,omitempty"`
	MinCount        int32       `protobuf:"varint,11,opt,name=min_count,json=minCount,proto3" json:"min_count,omitempty"`
	MaxCount        int32       `protobuf:"varint,12,opt,name=max_count,json=maxCount,proto3" json:"max_count,omitempty"`
	MaxTextLen      int32       `protobuf:"varint,13,opt,name=max_text_len,json=maxTextLen,proto3" json:"max_text_len,omitempty"`
}

func (m *RedPacketDataProto) Reset()                    { *m = RedPacketDataProto{} }
func (m *RedPacketDataProto) String() string            { return proto.CompactTextString(m) }
func (*RedPacketDataProto) ProtoMessage()               {}
func (*RedPacketDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{74} }

func (m *RedPacketDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RedPacketDataProto) GetIcon() *IconProto {
	if m != nil {
		return m.Icon
	}
	return nil
}

func (m *RedPacketDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RedPacketDataProto) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *RedPacketDataProto) GetDefaultText() string {
	if m != nil {
		return m.DefaultText
	}
	return ""
}

func (m *RedPacketDataProto) GetCost() *CostProto {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *RedPacketDataProto) GetAmountType() AmountType {
	if m != nil {
		return m.AmountType
	}
	return AmountType_InvalidAmountType
}

func (m *RedPacketDataProto) GetMoney() int32 {
	if m != nil {
		return m.Money
	}
	return 0
}

func (m *RedPacketDataProto) GetAllGarbbedPrize() *PrizeProto {
	if m != nil {
		return m.AllGarbbedPrize
	}
	return nil
}

func (m *RedPacketDataProto) GetExpiredDuration() int32 {
	if m != nil {
		return m.ExpiredDuration
	}
	return 0
}

func (m *RedPacketDataProto) GetMinCount() int32 {
	if m != nil {
		return m.MinCount
	}
	return 0
}

func (m *RedPacketDataProto) GetMaxCount() int32 {
	if m != nil {
		return m.MaxCount
	}
	return 0
}

func (m *RedPacketDataProto) GetMaxTextLen() int32 {
	if m != nil {
		return m.MaxTextLen
	}
	return 0
}

// 地图/部队对话.txt
type TroopDialogueDataProto struct {
	Id                int32          `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	BaseTargetType    BaseTargetType `protobuf:"varint,2,opt,name=base_target_type,json=baseTargetType,proto3,enum=proto.BaseTargetType" json:"base_target_type,omitempty"`
	BaseTargetSubType int32          `protobuf:"varint,3,opt,name=base_target_sub_type,json=baseTargetSubType,proto3" json:"base_target_sub_type,omitempty"`
	FirstDelay        int32          `protobuf:"varint,4,opt,name=first_delay,json=firstDelay,proto3" json:"first_delay,omitempty"`
	NextDelay         int32          `protobuf:"varint,5,opt,name=next_delay,json=nextDelay,proto3" json:"next_delay,omitempty"`
	RandomText        bool           `protobuf:"varint,6,opt,name=random_text,json=randomText,proto3" json:"random_text,omitempty"`
	Texts             []int32        `protobuf:"varint,7,rep,name=texts" json:"texts,omitempty"`
}

func (m *TroopDialogueDataProto) Reset()                    { *m = TroopDialogueDataProto{} }
func (m *TroopDialogueDataProto) String() string            { return proto.CompactTextString(m) }
func (*TroopDialogueDataProto) ProtoMessage()               {}
func (*TroopDialogueDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{75} }

func (m *TroopDialogueDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TroopDialogueDataProto) GetBaseTargetType() BaseTargetType {
	if m != nil {
		return m.BaseTargetType
	}
	return BaseTargetType_NpcHome
}

func (m *TroopDialogueDataProto) GetBaseTargetSubType() int32 {
	if m != nil {
		return m.BaseTargetSubType
	}
	return 0
}

func (m *TroopDialogueDataProto) GetFirstDelay() int32 {
	if m != nil {
		return m.FirstDelay
	}
	return 0
}

func (m *TroopDialogueDataProto) GetNextDelay() int32 {
	if m != nil {
		return m.NextDelay
	}
	return 0
}

func (m *TroopDialogueDataProto) GetRandomText() bool {
	if m != nil {
		return m.RandomText
	}
	return false
}

func (m *TroopDialogueDataProto) GetTexts() []int32 {
	if m != nil {
		return m.Texts
	}
	return nil
}

// 地图/部队对话文字.txt
type TroopDialogueTextDataProto struct {
	Id        int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Head      string `protobuf:"bytes,2,opt,name=head,proto3" json:"head,omitempty"`
	Text      string `protobuf:"bytes,3,opt,name=text,proto3" json:"text,omitempty"`
	Duration  int32  `protobuf:"varint,4,opt,name=duration,proto3" json:"duration,omitempty"`
	Direction int32  `protobuf:"varint,5,opt,name=direction,proto3" json:"direction,omitempty"`
}

func (m *TroopDialogueTextDataProto) Reset()         { *m = TroopDialogueTextDataProto{} }
func (m *TroopDialogueTextDataProto) String() string { return proto.CompactTextString(m) }
func (*TroopDialogueTextDataProto) ProtoMessage()    {}
func (*TroopDialogueTextDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{76}
}

func (m *TroopDialogueTextDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TroopDialogueTextDataProto) GetHead() string {
	if m != nil {
		return m.Head
	}
	return ""
}

func (m *TroopDialogueTextDataProto) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *TroopDialogueTextDataProto) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *TroopDialogueTextDataProto) GetDirection() int32 {
	if m != nil {
		return m.Direction
	}
	return 0
}

// 国家/官职.txt
type CountryOfficialDataProto struct {
	OfficialType   CountryOfficialType   `protobuf:"varint,2,opt,name=official_type,json=officialType,proto3,enum=proto.CountryOfficialType" json:"official_type,omitempty"`
	Name           string                `protobuf:"bytes,13,opt,name=name,proto3" json:"name,omitempty"`
	BuildingEffect *DomesticEffectProto  `protobuf:"bytes,3,opt,name=building_effect,json=buildingEffect" json:"building_effect,omitempty"`
	Buff           *BuffEffectDataProto  `protobuf:"bytes,4,opt,name=buff" json:"buff,omitempty"`
	Count          int32                 `protobuf:"varint,5,opt,name=count,proto3" json:"count,omitempty"`
	ShowSalary     *PrizeProto           `protobuf:"bytes,6,opt,name=show_salary,json=showSalary" json:"show_salary,omitempty"`
	Icon           string                `protobuf:"bytes,8,opt,name=icon,proto3" json:"icon,omitempty"`
	Head           string                `protobuf:"bytes,11,opt,name=head,proto3" json:"head,omitempty"`
	Body           int32                 `protobuf:"varint,12,opt,name=body,proto3" json:"body,omitempty"`
	Cd             int32                 `protobuf:"varint,9,opt,name=cd,proto3" json:"cd,omitempty"`
	EffectDesc     string                `protobuf:"bytes,14,opt,name=effect_desc,json=effectDesc,proto3" json:"effect_desc,omitempty"`
	SubOfficials   []CountryOfficialType `protobuf:"varint,10,rep,name=sub_officials,json=subOfficials,enum=proto.CountryOfficialType" json:"sub_officials,omitempty"`
}

func (m *CountryOfficialDataProto) Reset()         { *m = CountryOfficialDataProto{} }
func (m *CountryOfficialDataProto) String() string { return proto.CompactTextString(m) }
func (*CountryOfficialDataProto) ProtoMessage()    {}
func (*CountryOfficialDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{77}
}

func (m *CountryOfficialDataProto) GetOfficialType() CountryOfficialType {
	if m != nil {
		return m.OfficialType
	}
	return CountryOfficialType_COT_NO_OFFICIAL
}

func (m *CountryOfficialDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CountryOfficialDataProto) GetBuildingEffect() *DomesticEffectProto {
	if m != nil {
		return m.BuildingEffect
	}
	return nil
}

func (m *CountryOfficialDataProto) GetBuff() *BuffEffectDataProto {
	if m != nil {
		return m.Buff
	}
	return nil
}

func (m *CountryOfficialDataProto) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *CountryOfficialDataProto) GetShowSalary() *PrizeProto {
	if m != nil {
		return m.ShowSalary
	}
	return nil
}

func (m *CountryOfficialDataProto) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *CountryOfficialDataProto) GetHead() string {
	if m != nil {
		return m.Head
	}
	return ""
}

func (m *CountryOfficialDataProto) GetBody() int32 {
	if m != nil {
		return m.Body
	}
	return 0
}

func (m *CountryOfficialDataProto) GetCd() int32 {
	if m != nil {
		return m.Cd
	}
	return 0
}

func (m *CountryOfficialDataProto) GetEffectDesc() string {
	if m != nil {
		return m.EffectDesc
	}
	return ""
}

func (m *CountryOfficialDataProto) GetSubOfficials() []CountryOfficialType {
	if m != nil {
		return m.SubOfficials
	}
	return nil
}

// 国家/官职npc.txt
type CountryOfficialNpcDataProto struct {
	Id   int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Head string `protobuf:"bytes,3,opt,name=head,proto3" json:"head,omitempty"`
	Body int32  `protobuf:"varint,4,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *CountryOfficialNpcDataProto) Reset()         { *m = CountryOfficialNpcDataProto{} }
func (m *CountryOfficialNpcDataProto) String() string { return proto.CompactTextString(m) }
func (*CountryOfficialNpcDataProto) ProtoMessage()    {}
func (*CountryOfficialNpcDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{78}
}

func (m *CountryOfficialNpcDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CountryOfficialNpcDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CountryOfficialNpcDataProto) GetHead() string {
	if m != nil {
		return m.Head
	}
	return ""
}

func (m *CountryOfficialNpcDataProto) GetBody() int32 {
	if m != nil {
		return m.Body
	}
	return 0
}

// 地图/地区区域带.txt
type RegionAreaDataProto struct {
	Id                int32          `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name              string         `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Area              *AreaDataProto `protobuf:"bytes,3,opt,name=area" json:"area,omitempty"`
	WorkshopPrizeCoef int32          `protobuf:"varint,4,opt,name=workshop_prize_coef,json=workshopPrizeCoef,proto3" json:"workshop_prize_coef,omitempty"`
}

func (m *RegionAreaDataProto) Reset()                    { *m = RegionAreaDataProto{} }
func (m *RegionAreaDataProto) String() string            { return proto.CompactTextString(m) }
func (*RegionAreaDataProto) ProtoMessage()               {}
func (*RegionAreaDataProto) Descriptor() ([]byte, []int) { return fileDescriptorConfigGen, []int{79} }

func (m *RegionAreaDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RegionAreaDataProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RegionAreaDataProto) GetArea() *AreaDataProto {
	if m != nil {
		return m.Area
	}
	return nil
}

func (m *RegionAreaDataProto) GetWorkshopPrizeCoef() int32 {
	if m != nil {
		return m.WorkshopPrizeCoef
	}
	return 0
}

// 钓鱼/金杆钓.txt
type FishingCaptainProbabilityDataProto struct {
	CaptainId int32 `protobuf:"varint,1,opt,name=captain_id,json=captainId,proto3" json:"captain_id,omitempty"`
	Multiple  int32 `protobuf:"varint,2,opt,name=multiple,proto3" json:"multiple,omitempty"`
}

func (m *FishingCaptainProbabilityDataProto) Reset()         { *m = FishingCaptainProbabilityDataProto{} }
func (m *FishingCaptainProbabilityDataProto) String() string { return proto.CompactTextString(m) }
func (*FishingCaptainProbabilityDataProto) ProtoMessage()    {}
func (*FishingCaptainProbabilityDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorConfigGen, []int{80}
}

func (m *FishingCaptainProbabilityDataProto) GetCaptainId() int32 {
	if m != nil {
		return m.CaptainId
	}
	return 0
}

func (m *FishingCaptainProbabilityDataProto) GetMultiple() int32 {
	if m != nil {
		return m.Multiple
	}
	return 0
}

func init() {
	proto.RegisterType((*ConfigGen)(nil), "proto.ConfigGen")
	proto.RegisterType((*ActivityCollectionDataProto)(nil), "proto.ActivityCollectionDataProto")
	proto.RegisterType((*ActivityShowDataProto)(nil), "proto.ActivityShowDataProto")
	proto.RegisterType((*ActivityTaskDataProto)(nil), "proto.ActivityTaskDataProto")
	proto.RegisterType((*ActivityTaskListModeDataProto)(nil), "proto.ActivityTaskListModeDataProto")
	proto.RegisterType((*AreaDataProto)(nil), "proto.AreaDataProto")
	proto.RegisterType((*CaptainStarDataProto)(nil), "proto.CaptainStarDataProto")
	proto.RegisterType((*CollectionExchangeDataProto)(nil), "proto.CollectionExchangeDataProto")
	proto.RegisterType((*CombatConfigProto)(nil), "proto.CombatConfigProto")
	proto.RegisterType((*PassiveSpellDataProto)(nil), "proto.PassiveSpellDataProto")
	proto.RegisterType((*SpellDataProto)(nil), "proto.SpellDataProto")
	proto.RegisterType((*SpellTargetDataProto)(nil), "proto.SpellTargetDataProto")
	proto.RegisterType((*StateDataProto)(nil), "proto.StateDataProto")
	proto.RegisterType((*MingcBaseDataProto)(nil), "proto.MingcBaseDataProto")
	proto.RegisterType((*XuanyuanMiscDataProto)(nil), "proto.XuanyuanMiscDataProto")
	proto.RegisterType((*XuanyuanRangeDataProto)(nil), "proto.XuanyuanRangeDataProto")
	proto.RegisterType((*XuanyuanRankPrizeDataProto)(nil), "proto.XuanyuanRankPrizeDataProto")
	proto.RegisterType((*MiscGenConfigProto)(nil), "proto.MiscGenConfigProto")
	proto.RegisterType((*BaowuDataProto)(nil), "proto.BaowuDataProto")
	proto.RegisterType((*BaozNpcDataProto)(nil), "proto.BaozNpcDataProto")
	proto.RegisterType((*PushDataProto)(nil), "proto.PushDataProto")
	proto.RegisterType((*TitleDataProto)(nil), "proto.TitleDataProto")
	proto.RegisterType((*TitleTaskDataProto)(nil), "proto.TitleTaskDataProto")
	proto.RegisterType((*SecretTowerWordsDataProto)(nil), "proto.SecretTowerWordsDataProto")
	proto.RegisterType((*GuildGenConfigProto)(nil), "proto.GuildGenConfigProto")
	proto.RegisterType((*LocationDataProto)(nil), "proto.LocationDataProto")
	proto.RegisterType((*CountryDataProto)(nil), "proto.CountryDataProto")
	proto.RegisterType((*CountryMiscDataProto)(nil), "proto.CountryMiscDataProto")
	proto.RegisterType((*FamilyNameDataProto)(nil), "proto.FamilyNameDataProto")
	proto.RegisterType((*LoginDayDataProto)(nil), "proto.LoginDayDataProto")
	proto.RegisterType((*HeroLevelFundDataProto)(nil), "proto.HeroLevelFundDataProto")
	proto.RegisterType((*PromotionMiscDataProto)(nil), "proto.PromotionMiscDataProto")
	proto.RegisterType((*BlackMarketGoodsDataProto)(nil), "proto.BlackMarketGoodsDataProto")
	proto.RegisterType((*ShopMiscDataProto)(nil), "proto.ShopMiscDataProto")
	proto.RegisterType((*MingcMiscDataProto)(nil), "proto.MingcMiscDataProto")
	proto.RegisterType((*MingcTimeDataProto)(nil), "proto.MingcTimeDataProto")
	proto.RegisterType((*MingcWarBuildingDataProto)(nil), "proto.MingcWarBuildingDataProto")
	proto.RegisterType((*MingcWarMapDataProto)(nil), "proto.MingcWarMapDataProto")
	proto.RegisterType((*MingcWarSceneDataProto)(nil), "proto.MingcWarSceneDataProto")
	proto.RegisterType((*RegionGenConfigProto)(nil), "proto.RegionGenConfigProto")
	proto.RegisterType((*OuterCityBuildingDataProto)(nil), "proto.OuterCityBuildingDataProto")
	proto.RegisterType((*DiscountColorDataProto)(nil), "proto.DiscountColorDataProto")
	proto.RegisterType((*MingcWarTroopLastBeatWhenFailDataProto)(nil), "proto.MingcWarTroopLastBeatWhenFailDataProto")
	proto.RegisterType((*MingcWarTouShiBuildingTargetDataProto)(nil), "proto.MingcWarTouShiBuildingTargetDataProto")
	proto.RegisterType((*CaptainDataProto)(nil), "proto.CaptainDataProto")
	proto.RegisterType((*CaptainRarityDataProto)(nil), "proto.CaptainRarityDataProto")
	proto.RegisterType((*NamelessCaptainDataProto)(nil), "proto.NamelessCaptainDataProto")
	proto.RegisterType((*SpellFacadeDataProto)(nil), "proto.SpellFacadeDataProto")
	proto.RegisterType((*BufferDataProto)(nil), "proto.BufferDataProto")
	proto.RegisterType((*GuildRankPrizeDataProto)(nil), "proto.GuildRankPrizeDataProto")
	proto.RegisterType((*ChargePrizeDataProto)(nil), "proto.ChargePrizeDataProto")
	proto.RegisterType((*SpCollectionDataProto)(nil), "proto.SpCollectionDataProto")
	proto.RegisterType((*StrategyEffectDataProto)(nil), "proto.StrategyEffectDataProto")
	proto.RegisterType((*DailyBargainDataProto)(nil), "proto.DailyBargainDataProto")
	proto.RegisterType((*DurationCardDataProto)(nil), "proto.DurationCardDataProto")
	proto.RegisterType((*CombatMiscConfigProto)(nil), "proto.CombatMiscConfigProto")
	proto.RegisterType((*FreeGiftDataProto)(nil), "proto.FreeGiftDataProto")
	proto.RegisterType((*ChargeObjDataProto)(nil), "proto.ChargeObjDataProto")
	proto.RegisterType((*BuffEffectDataProto)(nil), "proto.BuffEffectDataProto")
	proto.RegisterType((*AssemblyDataProto)(nil), "proto.AssemblyDataProto")
	proto.RegisterType((*JunTuanNpcDataProto)(nil), "proto.JunTuanNpcDataProto")
	proto.RegisterType((*ProsperityDamageBuffDataProto)(nil), "proto.ProsperityDamageBuffDataProto")
	proto.RegisterType((*BufferTypeDataProto)(nil), "proto.BufferTypeDataProto")
	proto.RegisterType((*VipContinueDaysDataProto)(nil), "proto.VipContinueDaysDataProto")
	proto.RegisterType((*VipLevelDataProto)(nil), "proto.VipLevelDataProto")
	proto.RegisterType((*VipMiscDataProto)(nil), "proto.VipMiscDataProto")
	proto.RegisterType((*PrivacySettingDataProto)(nil), "proto.PrivacySettingDataProto")
	proto.RegisterType((*TimeLimitGiftDataProto)(nil), "proto.TimeLimitGiftDataProto")
	proto.RegisterType((*EventLimitGiftDataProto)(nil), "proto.EventLimitGiftDataProto")
	proto.RegisterType((*McBuildAddSupportDataProto)(nil), "proto.McBuildAddSupportDataProto")
	proto.RegisterType((*McBuildGuildMemberPrizeDataProto)(nil), "proto.McBuildGuildMemberPrizeDataProto")
	proto.RegisterType((*McBuildMcSupportDataProto)(nil), "proto.McBuildMcSupportDataProto")
	proto.RegisterType((*McBuildMiscDataProto)(nil), "proto.McBuildMiscDataProto")
	proto.RegisterType((*CaptainFriendshipDataProto)(nil), "proto.CaptainFriendshipDataProto")
	proto.RegisterType((*RedPacketDataProto)(nil), "proto.RedPacketDataProto")
	proto.RegisterType((*TroopDialogueDataProto)(nil), "proto.TroopDialogueDataProto")
	proto.RegisterType((*TroopDialogueTextDataProto)(nil), "proto.TroopDialogueTextDataProto")
	proto.RegisterType((*CountryOfficialDataProto)(nil), "proto.CountryOfficialDataProto")
	proto.RegisterType((*CountryOfficialNpcDataProto)(nil), "proto.CountryOfficialNpcDataProto")
	proto.RegisterType((*RegionAreaDataProto)(nil), "proto.RegionAreaDataProto")
	proto.RegisterType((*FishingCaptainProbabilityDataProto)(nil), "proto.FishingCaptainProbabilityDataProto")
}
func (m *ConfigGen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigGen) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MingcBaseData) > 0 {
		for _, msg := range m.MingcBaseData {
			dAtA[i] = 0xa
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XuanyuanMiscData != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.XuanyuanMiscData.Size()))
		n1, err := m.XuanyuanMiscData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.XuanyuanRangeData) > 0 {
		for _, msg := range m.XuanyuanRangeData {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.XuanyuanRankPrizeData) > 0 {
		for _, msg := range m.XuanyuanRankPrizeData {
			dAtA[i] = 0x22
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MiscGenConfig != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MiscGenConfig.Size()))
		n2, err := m.MiscGenConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.BaowuData) > 0 {
		for _, msg := range m.BaowuData {
			dAtA[i] = 0x32
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BaozNpcData) > 0 {
		for _, msg := range m.BaozNpcData {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PushData) > 0 {
		for _, msg := range m.PushData {
			dAtA[i] = 0x42
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TitleData) > 0 {
		for _, msg := range m.TitleData {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TitleTaskData) > 0 {
		for _, msg := range m.TitleTaskData {
			dAtA[i] = 0x52
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SecretTowerWordsData) > 0 {
		for _, msg := range m.SecretTowerWordsData {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.GuildGenConfig != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.GuildGenConfig.Size()))
		n3, err := m.GuildGenConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.LocationData) > 0 {
		for _, msg := range m.LocationData {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CountryData) > 0 {
		for _, msg := range m.CountryData {
			dAtA[i] = 0x72
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CountryMiscData != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.CountryMiscData.Size()))
		n4, err := m.CountryMiscData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.FamilyNameData) > 0 {
		for _, msg := range m.FamilyNameData {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.LoginDayData) > 0 {
		for _, msg := range m.LoginDayData {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.HeroLevelFundData) > 0 {
		for _, msg := range m.HeroLevelFundData {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PromotionMiscData != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.PromotionMiscData.Size()))
		n5, err := m.PromotionMiscData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.BlackMarketGoodsData) > 0 {
		for _, msg := range m.BlackMarketGoodsData {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ShopMiscData != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ShopMiscData.Size()))
		n6, err := m.ShopMiscData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.MingcMiscData != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MingcMiscData.Size()))
		n7, err := m.MingcMiscData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.MingcTimeData) > 0 {
		for _, msg := range m.MingcTimeData {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MingcWarBuildingData) > 0 {
		for _, msg := range m.MingcWarBuildingData {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MingcWarMapData) > 0 {
		for _, msg := range m.MingcWarMapData {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MingcWarSceneData) > 0 {
		for _, msg := range m.MingcWarSceneData {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RegionGenConfig != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.RegionGenConfig.Size()))
		n8, err := m.RegionGenConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.OuterCityBuildingData) > 0 {
		for _, msg := range m.OuterCityBuildingData {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DiscountColorData) > 0 {
		for _, msg := range m.DiscountColorData {
			dAtA[i] = 0xf2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MingcWarTroopLastBeatWhenFailData) > 0 {
		for _, msg := range m.MingcWarTroopLastBeatWhenFailData {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MingcWarTouShiBuildingTargetData) > 0 {
		for _, msg := range m.MingcWarTouShiBuildingTargetData {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CaptainData) > 0 {
		for _, msg := range m.CaptainData {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CaptainRarityData) > 0 {
		for _, msg := range m.CaptainRarityData {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NamelessCaptainData) > 0 {
		for _, msg := range m.NamelessCaptainData {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SpellFacadeData) > 0 {
		for _, msg := range m.SpellFacadeData {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BufferData) > 0 {
		for _, msg := range m.BufferData {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GuildRankPrizeData) > 0 {
		for _, msg := range m.GuildRankPrizeData {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ChargePrizeData) > 0 {
		for _, msg := range m.ChargePrizeData {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SpCollectionData) > 0 {
		for _, msg := range m.SpCollectionData {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.StrategyEffectData) > 0 {
		for _, msg := range m.StrategyEffectData {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DailyBargainData) > 0 {
		for _, msg := range m.DailyBargainData {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DurationCardData) > 0 {
		for _, msg := range m.DurationCardData {
			dAtA[i] = 0xea
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CombatMiscConfig != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.CombatMiscConfig.Size()))
		n9, err := m.CombatMiscConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.FreeGiftData) > 0 {
		for _, msg := range m.FreeGiftData {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ChargeObjData) > 0 {
		for _, msg := range m.ChargeObjData {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BuffEffectData) > 0 {
		for _, msg := range m.BuffEffectData {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AssemblyData) > 0 {
		for _, msg := range m.AssemblyData {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.JunTuanNpcData) > 0 {
		for _, msg := range m.JunTuanNpcData {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ProsperityDamageBuffData) > 0 {
		for _, msg := range m.ProsperityDamageBuffData {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BufferTypeData) > 0 {
		for _, msg := range m.BufferTypeData {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.VipContinueDaysData) > 0 {
		for _, msg := range m.VipContinueDaysData {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.VipLevelData) > 0 {
		for _, msg := range m.VipLevelData {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.VipMiscData != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.VipMiscData.Size()))
		n10, err := m.VipMiscData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.PrivacySettingData) > 0 {
		for _, msg := range m.PrivacySettingData {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TimeLimitGiftData) > 0 {
		for _, msg := range m.TimeLimitGiftData {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EventLimitGiftData) > 0 {
		for _, msg := range m.EventLimitGiftData {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.McBuildAddSupportData) > 0 {
		for _, msg := range m.McBuildAddSupportData {
			dAtA[i] = 0xea
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.McBuildGuildMemberPrizeData) > 0 {
		for _, msg := range m.McBuildGuildMemberPrizeData {
			dAtA[i] = 0xf2
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.McBuildMcSupportData) > 0 {
		for _, msg := range m.McBuildMcSupportData {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x4
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.McBuildMiscData != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.McBuildMiscData.Size()))
		n11, err := m.McBuildMiscData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.CaptainFriendshipData) > 0 {
		for _, msg := range m.CaptainFriendshipData {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x4
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RedPacketData) > 0 {
		for _, msg := range m.RedPacketData {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x4
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TroopDialogueData) > 0 {
		for _, msg := range m.TroopDialogueData {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x4
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TroopDialogueTextData) > 0 {
		for _, msg := range m.TroopDialogueTextData {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x4
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CountryOfficialData) > 0 {
		for _, msg := range m.CountryOfficialData {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x4
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CountryOfficialNpcData) > 0 {
		for _, msg := range m.CountryOfficialNpcData {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x4
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RegionAreaData) > 0 {
		for _, msg := range m.RegionAreaData {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x4
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.FishingCaptainProbabilityData) > 0 {
		for _, msg := range m.FishingCaptainProbabilityData {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x4
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ActivityCollectionDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityCollectionDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Desc) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.Exchanges) > 0 {
		for _, msg := range m.Exchanges {
			dAtA[i] = 0x12
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.NameIcon) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.NameIcon)))
		i += copy(dAtA[i:], m.NameIcon)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if m.Sort != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Sort))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if len(m.IconSelect) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.IconSelect)))
		i += copy(dAtA[i:], m.IconSelect)
	}
	if len(m.TimeShow) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.TimeShow)))
		i += copy(dAtA[i:], m.TimeShow)
	}
	return i, nil
}

func (m *ActivityShowDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityShowDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.TimeShow) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.TimeShow)))
		i += copy(dAtA[i:], m.TimeShow)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.PrizeDesc) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.PrizeDesc)))
		i += copy(dAtA[i:], m.PrizeDesc)
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if len(m.IconSelect) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.IconSelect)))
		i += copy(dAtA[i:], m.IconSelect)
	}
	if m.ShowCountdown {
		dAtA[i] = 0x48
		i++
		if m.ShowCountdown {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Sort != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Sort))
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if m.ImagePos != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ImagePos))
	}
	if len(m.NameIcon) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.NameIcon)))
		i += copy(dAtA[i:], m.NameIcon)
	}
	if len(m.LinkName) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.LinkName)))
		i += copy(dAtA[i:], m.LinkName)
	}
	if m.LinkTargetType != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.LinkTargetType))
	}
	if m.LinkTargetSubType != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.LinkTargetSubType))
	}
	if m.LinkTargetSubTypeId != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.LinkTargetSubTypeId))
	}
	if m.SpineId != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SpineId))
	}
	return i, nil
}

func (m *ActivityTaskDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityTaskDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.Target != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Target.Size()))
		n12, err := m.Target.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Link) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Link)))
		i += copy(dAtA[i:], m.Link)
	}
	if m.Prize != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Prize.Size()))
		n13, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *ActivityTaskListModeDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityTaskListModeDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NameIcon) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.NameIcon)))
		i += copy(dAtA[i:], m.NameIcon)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.Tasks) > 0 {
		for _, msg := range m.Tasks {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Sort != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Sort))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if len(m.IconSelect) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.IconSelect)))
		i += copy(dAtA[i:], m.IconSelect)
	}
	if len(m.TimeShow) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.TimeShow)))
		i += copy(dAtA[i:], m.TimeShow)
	}
	return i, nil
}

func (m *AreaDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AreaDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CenterX != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.CenterX))
	}
	if m.CenterY != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.CenterY))
	}
	if m.MinRadius != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MinRadius))
	}
	if m.MaxRadius != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MaxRadius))
	}
	return i, nil
}

func (m *CaptainStarDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptainStarDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Star != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Star))
	}
	if m.Cost != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Cost.Size()))
		n14, err := m.Cost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.Spell) > 0 {
		for _, num := range m.Spell {
			dAtA[i] = 0x18
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if m.Coef != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Coef))
	}
	if m.AddedStat != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AddedStat.Size()))
		n15, err := m.AddedStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *CollectionExchangeDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionExchangeDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if m.Combine != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Combine.Size()))
		n16, err := m.Combine.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Limit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Limit))
	}
	return i, nil
}

func (m *CombatConfigProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombatConfigProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Spell) > 0 {
		for _, msg := range m.Spell {
			dAtA[i] = 0xa
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.State) > 0 {
		for _, msg := range m.State {
			dAtA[i] = 0x12
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PassiveSpell) > 0 {
		for _, msg := range m.PassiveSpell {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SpellIdMap) > 0 {
		for _, msg := range m.SpellIdMap {
			dAtA[i] = 0x22
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Captain) > 0 {
		for _, msg := range m.Captain {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NamelessCaptain) > 0 {
		for _, msg := range m.NamelessCaptain {
			dAtA[i] = 0x32
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Race) > 0 {
		for _, msg := range m.Race {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FramePerSecond != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.FramePerSecond))
	}
	if m.ConfigDenominator != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ConfigDenominator))
	}
	if m.MinAttackDuration != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MinAttackDuration))
	}
	if m.MaxAttackDuration != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MaxAttackDuration))
	}
	if m.MinMoveSpeed != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MinMoveSpeed))
	}
	if m.MaxMoveSpeed != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MaxMoveSpeed))
	}
	if m.MinStat != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MinStat.Size()))
		n17, err := m.MinStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.MaxDuration != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MaxDuration))
	}
	if len(m.ScorePercent) > 0 {
		for _, num := range m.ScorePercent {
			dAtA[i] = 0x80
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if m.CheckMoveDuration != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.CheckMoveDuration))
	}
	if m.CritRate != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.CritRate))
	}
	if m.Coef != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Coef))
	}
	if m.CellLen != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.CellLen))
	}
	if m.MaxRage != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MaxRage))
	}
	if m.AddRagePerHint != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AddRagePerHint))
	}
	if m.AddRageLost1Percent != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AddRageLost1Percent))
	}
	if m.RageRecoverSpeed != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.RageRecoverSpeed))
	}
	if m.WallWaitDuration != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WallWaitDuration))
	}
	if m.WallAttackFixDamageTimes != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WallAttackFixDamageTimes))
	}
	if m.WallBeenHurtLostMaxPercent != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WallBeenHurtLostMaxPercent))
	}
	if m.WallSpell != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WallSpell))
	}
	if m.ShortMoveDistance != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ShortMoveDistance))
	}
	if m.InitAttackerX != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.InitAttackerX))
	}
	if m.InitDefenserX != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.InitDefenserX))
	}
	if m.InitWallX != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.InitWallX))
	}
	if m.WallFlyMinDuration != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WallFlyMinDuration))
	}
	return i, nil
}

func (m *PassiveSpellDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassiveSpellDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if m.Animation != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Animation))
	}
	if m.TriggerRate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TriggerRate))
	}
	if m.TriggerType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TriggerType))
	}
	if m.TriggerTarget != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TriggerTarget.Size()))
		n18, err := m.TriggerTarget.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.TriggerHit != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TriggerHit))
	}
	if len(m.SelfState) > 0 {
		for _, num := range m.SelfState {
			dAtA[i] = 0x38
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.TargetState) > 0 {
		for _, num := range m.TargetState {
			dAtA[i] = 0x40
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if m.Spell != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Spell))
	}
	if m.ExciteEffectType != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ExciteEffectType))
	}
	if m.Rage != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Rage))
	}
	if m.SpriteStat != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SpriteStat.Size()))
		n19, err := m.SpriteStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.BeenHurtEffectIncType) > 0 {
		for _, num := range m.BeenHurtEffectIncType {
			dAtA[i] = 0x68
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.BeenHurtEffectInc) > 0 {
		for _, num := range m.BeenHurtEffectInc {
			dAtA[i] = 0x70
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.BeenHurtEffectDecType) > 0 {
		for _, num := range m.BeenHurtEffectDecType {
			dAtA[i] = 0x78
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.BeenHurtEffectDec) > 0 {
		for _, num := range m.BeenHurtEffectDec {
			dAtA[i] = 0x80
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if m.TargetCooldown != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TargetCooldown))
	}
	if m.RelivePercent != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.RelivePercent))
	}
	return i, nil
}

func (m *SpellDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpellDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Animation != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Animation))
	}
	if m.Cooldown != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Cooldown))
	}
	if m.StrongeDuration != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.StrongeDuration))
	}
	if m.RageSpell {
		dAtA[i] = 0x30
		i++
		if m.RageSpell {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KeepMove {
		dAtA[i] = 0x38
		i++
		if m.KeepMove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FriendSpell {
		dAtA[i] = 0x40
		i++
		if m.FriendSpell {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SelfAsTarget {
		dAtA[i] = 0x48
		i++
		if m.SelfAsTarget {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TargetSubType != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TargetSubType))
	}
	if m.Target != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Target.Size()))
		n20, err := m.Target.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.ReleaseRange != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ReleaseRange))
	}
	if m.HurtRange != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.HurtRange))
	}
	if m.HurtCount != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.HurtCount))
	}
	if m.Coef != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Coef))
	}
	if m.EffectType != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.EffectType))
	}
	if len(m.SelfState) > 0 {
		for _, num := range m.SelfState {
			dAtA[i] = 0x90
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.SelfStateRate) > 0 {
		for _, num := range m.SelfStateRate {
			dAtA[i] = 0x98
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.TargetState) > 0 {
		for _, num := range m.TargetState {
			dAtA[i] = 0xa0
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.TargetStateRate) > 0 {
		for _, num := range m.TargetStateRate {
			dAtA[i] = 0xa8
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if m.SelfRage != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SelfRage))
	}
	if m.TargetRage != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TargetRage))
	}
	if m.FlySpeed != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.FlySpeed))
	}
	if m.HurtType != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.HurtType))
	}
	return i, nil
}

func (m *SpellTargetDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpellTargetDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TargetRace) > 0 {
		for _, num := range m.TargetRace {
			dAtA[i] = 0x8
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if m.TargetEffectType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TargetEffectType))
	}
	if m.TargetUnmovable {
		dAtA[i] = 0x18
		i++
		if m.TargetUnmovable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TargetNotAttackable {
		dAtA[i] = 0x20
		i++
		if m.TargetNotAttackable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TargetSilence {
		dAtA[i] = 0x28
		i++
		if m.TargetSilence {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TargetStun {
		dAtA[i] = 0x30
		i++
		if m.TargetStun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *StateDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Animation != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Animation))
	}
	if m.StackType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.StackType))
	}
	if m.StackMaxTimes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.StackMaxTimes))
	}
	if m.TickTimes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TickTimes))
	}
	if m.TickDuration != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TickDuration))
	}
	if m.ChangeStat != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ChangeStat.Size()))
		n21, err := m.ChangeStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.IsAddStat {
		dAtA[i] = 0x48
		i++
		if m.IsAddStat {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MoveSpeedRate != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MoveSpeedRate))
	}
	if m.AttackSpeedRate != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AttackSpeedRate))
	}
	if m.ShieldRate != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ShieldRate))
	}
	if m.Unmovable {
		dAtA[i] = 0x68
		i++
		if m.Unmovable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NotAttackable {
		dAtA[i] = 0x70
		i++
		if m.NotAttackable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Silence {
		dAtA[i] = 0x78
		i++
		if m.Silence {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Stun {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.Stun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EffectType != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.EffectType))
	}
	if len(m.BeenHurtEffectInc) > 0 {
		for _, num := range m.BeenHurtEffectInc {
			dAtA[i] = 0x98
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if m.DamageCoef != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DamageCoef))
	}
	if m.Rage != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Rage))
	}
	if m.RageRecoverRate != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.RageRecoverRate))
	}
	if len(m.BeenHurtEffectIncType) > 0 {
		for _, num := range m.BeenHurtEffectIncType {
			dAtA[i] = 0xb8
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.BeenHurtEffectDecType) > 0 {
		for _, num := range m.BeenHurtEffectDecType {
			dAtA[i] = 0xc0
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.BeenHurtEffectDec) > 0 {
		for _, num := range m.BeenHurtEffectDec {
			dAtA[i] = 0xc8
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if m.ShieldEffectRate != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ShieldEffectRate))
	}
	if m.DamageHurtType != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DamageHurtType))
	}
	return i, nil
}

func (m *MingcBaseDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MingcBaseDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Model) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Model)))
		i += copy(dAtA[i:], m.Model)
	}
	if m.BaseX != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BaseX))
	}
	if m.BaseY != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BaseY))
	}
	if m.Radius != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Radius))
	}
	if m.Type != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Type))
	}
	if m.Country != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Country))
	}
	if m.ZhouCaptain {
		dAtA[i] = 0x50
		i++
		if m.ZhouCaptain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DefaultYinliang != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DefaultYinliang))
	}
	if m.DailyAddYinliang != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DailyAddYinliang))
	}
	if m.MaxYinliang != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MaxYinliang))
	}
	if m.HostDailyAddYinliang != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.HostDailyAddYinliang))
	}
	if len(m.WarIcon) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.WarIcon)))
		i += copy(dAtA[i:], m.WarIcon)
	}
	if m.AtkMinHufu != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AtkMinHufu))
	}
	if m.AtkMinGuildLevel != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AtkMinGuildLevel))
	}
	if m.AstMaxGuild != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AstMaxGuild))
	}
	if m.BaseMinDistance != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BaseMinDistance))
	}
	return i, nil
}

func (m *XuanyuanMiscDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XuanyuanMiscDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChallengeTimesLimit != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ChallengeTimesLimit))
	}
	return i, nil
}

func (m *XuanyuanRangeDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XuanyuanRangeDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if m.LowRank != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.LowRank))
	}
	if m.HighRank != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.HighRank))
	}
	if m.WinScore != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WinScore))
	}
	if m.LoseScore != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.LoseScore))
	}
	if m.DefenseLostScore != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DefenseLostScore))
	}
	if len(m.CombatScene) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.CombatScene)))
		i += copy(dAtA[i:], m.CombatScene)
	}
	return i, nil
}

func (m *XuanyuanRankPrizeDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XuanyuanRankPrizeDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if m.Rank != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Rank))
	}
	if m.Prize != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Prize.Size()))
		n22, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.ShowPrize != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ShowPrize.Size()))
		n23, err := m.ShowPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *MiscGenConfigProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiscGenConfigProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stronger4Coef) > 0 {
		for _, num := range m.Stronger4Coef {
			dAtA[i] = 0x8
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if m.MiaoBaowuDuration != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MiaoBaowuDuration))
	}
	if m.MiaoBaowuCost != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MiaoBaowuCost.Size()))
		n24, err := m.MiaoBaowuCost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.DailyMiaoBaowuLimit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DailyMiaoBaowuLimit))
	}
	if m.BaowuLogLimit != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BaowuLogLimit))
	}
	if m.FriendMaxCount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.FriendMaxCount))
	}
	if m.BlackMaxCount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BlackMaxCount))
	}
	if m.FirstNpcBaowu != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.FirstNpcBaowu))
	}
	if m.AutoFullSoldoerDuration != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AutoFullSoldoerDuration))
	}
	if m.TaxDuration != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TaxDuration))
	}
	if len(m.FishMaxPoint) > 0 {
		for _, num := range m.FishMaxPoint {
			dAtA[i] = 0x58
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.FishPointCaptainSoul) > 0 {
		for _, num := range m.FishPointCaptainSoul {
			dAtA[i] = 0x60
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if m.DaZhaoSwitchLevelLimit != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DaZhaoSwitchLevelLimit))
	}
	if m.UpdateOuterCityTypeCost != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.UpdateOuterCityTypeCost.Size()))
		n25, err := m.UpdateOuterCityTypeCost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.RandomEventBigRefreshDuration != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.RandomEventBigRefreshDuration))
	}
	if m.RandomEventSmallRefreshDuration != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.RandomEventSmallRefreshDuration))
	}
	if m.SpDuration != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SpDuration))
	}
	if m.BuySpValue != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BuySpValue))
	}
	if m.BuySpCost != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BuySpCost))
	}
	if m.BuySpLimit != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BuySpLimit))
	}
	if m.CaptainResetCost != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.CaptainResetCost.Size()))
		n26, err := m.CaptainResetCost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.SkipFightingHeroLevel != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SkipFightingHeroLevel))
	}
	if m.SkipFightingVipLevel != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SkipFightingVipLevel))
	}
	if m.SkipFightingWaitDuration != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SkipFightingWaitDuration))
	}
	if m.SecretTowerCd != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SecretTowerCd))
	}
	if m.XuanyuanCd != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.XuanyuanCd))
	}
	if m.BaizhanCd != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BaizhanCd))
	}
	if m.HebiCd != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.HebiCd))
	}
	if m.XiongnuCd != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.XiongnuCd))
	}
	if m.MailCd != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MailCd))
	}
	if m.DianquanToGold != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DianquanToGold))
	}
	if m.DianquanToStone != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DianquanToStone))
	}
	if m.SoldierPerGroup != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SoldierPerGroup))
	}
	if m.HeroBaozDuration != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.HeroBaozDuration))
	}
	if m.HeroBaozMaxDistance != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.HeroBaozMaxDistance))
	}
	if m.YuanbaoGiftPercent != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.YuanbaoGiftPercent.Size()))
		n27, err := m.YuanbaoGiftPercent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *BaowuDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaowuDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if m.Group != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Group))
	}
	if m.Level != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Level))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if m.Quality != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Quality))
	}
	if m.GoodsQuality != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.GoodsQuality))
	}
	if m.UnlockDuration != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.UnlockDuration))
	}
	if m.PlunderPrize != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.PlunderPrize.Size()))
		n28, err := m.PlunderPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.UpgradeNeedCount != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.UpgradeNeedCount))
	}
	if m.DecomposeGold != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DecomposeGold))
	}
	if m.DecomposeStone != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DecomposeStone))
	}
	if m.Prestige != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Prestige))
	}
	if m.MiaoDuration != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MiaoDuration))
	}
	return i, nil
}

func (m *BaozNpcDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaozNpcDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if m.Npc != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Npc))
	}
	if m.RequiredHeroLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.RequiredHeroLevel))
	}
	return i, nil
}

func (m *PushDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Type))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if len(m.TickTime) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.TickTime)))
		i += copy(dAtA[i:], m.TickTime)
	}
	return i, nil
}

func (m *TitleDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TitleDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.SpriteStat != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SpriteStat.Size()))
		n29, err := m.SpriteStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if len(m.Task) > 0 {
		for _, num := range m.Task {
			dAtA[i] = 0x28
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if m.TotalStat != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TotalStat.Size()))
		n30, err := m.TotalStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.Quality != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Quality))
	}
	if m.PoltId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.PoltId))
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if m.TitleCost != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TitleCost.Size()))
		n31, err := m.TitleCost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.CountryChangeNameVoteCount != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.CountryChangeNameVoteCount))
	}
	return i, nil
}

func (m *TitleTaskDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TitleTaskDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Target != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Target.Size()))
		n32, err := m.Target.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *SecretTowerWordsDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretTowerWordsDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Words) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Words)))
		i += copy(dAtA[i:], m.Words)
	}
	return i, nil
}

func (m *GuildGenConfigProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuildGenConfigProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeaveAfterJoinDuration != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.LeaveAfterJoinDuration))
	}
	if m.GuildMarkCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.GuildMarkCount))
	}
	if m.GuildMarkMsgCharLimit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.GuildMarkMsgCharLimit))
	}
	if m.SendMinYinliangToMember != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SendMinYinliangToMember))
	}
	if m.SendMaxYinliangToMember != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SendMaxYinliangToMember))
	}
	if m.SendMinYinliangToGuild != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SendMinYinliangToGuild))
	}
	if m.SendMaxYinliangToGuild != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SendMaxYinliangToGuild))
	}
	if m.SendMinSalary != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SendMinSalary))
	}
	if m.SendMaxSalary != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SendMaxSalary))
	}
	if m.ConveneCooldown != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ConveneCooldown))
	}
	if m.WorkshopBuildDuration != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkshopBuildDuration))
	}
	if m.WorkshopHeroBuildDuration != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkshopHeroBuildDuration))
	}
	if m.WorkshopHurtDuration != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkshopHurtDuration))
	}
	if m.WorkshopHurtTotalTimesLimit != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkshopHurtTotalTimesLimit))
	}
	if m.WorkshopHurtHeroTimesLimit != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkshopHurtHeroTimesLimit))
	}
	if m.WorkshopHurtCooldown != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkshopHurtCooldown))
	}
	if m.WorkshopHurtProsperity != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkshopHurtProsperity))
	}
	if m.WorkshopProsperityCapcity != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkshopProsperityCapcity))
	}
	if m.WorkshopPrizeMaxCount != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkshopPrizeMaxCount))
	}
	if m.WorkshopReduceProsperityDuration != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkshopReduceProsperityDuration))
	}
	if m.WorkshopReduceProsperity != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkshopReduceProsperity))
	}
	if m.WorkshopDistanceLimit != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkshopDistanceLimit))
	}
	if m.WorkshopBarrenProsperity != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkshopBarrenProsperity))
	}
	if m.WorkshopGuildBuildMaxTimes != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkshopGuildBuildMaxTimes))
	}
	if m.WorkshopHeroBuildMaxTimes != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkshopHeroBuildMaxTimes))
	}
	if m.WorkshopOutputMaxTimes != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkshopOutputMaxTimes))
	}
	if m.WorkshopOutputRecoveryDuration != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkshopOutputRecoveryDuration))
	}
	if m.GuildChangeCountryCost != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.GuildChangeCountryCost.Size()))
		n33, err := m.GuildChangeCountryCost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.GuildChangeCountryWaitDuration != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.GuildChangeCountryWaitDuration))
	}
	if m.GuildChangeCountryCooldown != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.GuildChangeCountryCooldown))
	}
	if m.TaskOpenLevel != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TaskOpenLevel))
	}
	return i, nil
}

func (m *LocationDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.RecommendCountry) > 0 {
		for _, num := range m.RecommendCountry {
			dAtA[i] = 0x18
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *CountryDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountryDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.DefaultPrestige != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DefaultPrestige))
	}
	if len(m.NpcOfficial) > 0 {
		for _, num := range m.NpcOfficial {
			dAtA[i] = 0x58
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.NpcId) > 0 {
		for _, num := range m.NpcId {
			dAtA[i] = 0x60
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if m.Capital != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Capital))
	}
	return i, nil
}

func (m *CountryMiscDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountryMiscDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NormalChangeCountryGoods != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.NormalChangeCountryGoods))
	}
	if m.NewHeroChangeCountryCd != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.NewHeroChangeCountryCd))
	}
	if m.NormalChangeCountryCd != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.NormalChangeCountryCd))
	}
	if m.NewHeroMaxLevel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.NewHeroMaxLevel))
	}
	if m.ChangeNameCd != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ChangeNameCd))
	}
	if m.ChangeNameCost != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ChangeNameCost.Size()))
		n34, err := m.ChangeNameCost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.ChangeNameVoteDuration != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ChangeNameVoteDuration))
	}
	if m.MaxSearchHeroDefaultCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MaxSearchHeroDefaultCount))
	}
	if m.MaxSearchHeroByNameCount != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MaxSearchHeroByNameCount))
	}
	return i, nil
}

func (m *FamilyNameDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FamilyNameDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.RecommendCountry) > 0 {
		for _, num := range m.RecommendCountry {
			dAtA[i] = 0x20
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *LoginDayDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginDayDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Day != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Day))
	}
	if m.Prize != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Prize.Size()))
		n35, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}

func (m *HeroLevelFundDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroLevelFundDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Level))
	}
	if m.Prize != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Prize.Size()))
		n36, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.Rebate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Rebate))
	}
	return i, nil
}

func (m *PromotionMiscDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PromotionMiscDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroLevelFundCost != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.HeroLevelFundCost.Size()))
		n37, err := m.HeroLevelFundCost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}

func (m *BlackMarketGoodsDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlackMarketGoodsDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if m.ShowPrize != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ShowPrize.Size()))
		n38, err := m.ShowPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.Cost != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Cost.Size()))
		n39, err := m.Cost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.Quality != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Quality))
	}
	return i, nil
}

func (m *ShopMiscDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShopMiscDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RefreshBlackMarketCost) > 0 {
		for _, msg := range m.RefreshBlackMarketCost {
			dAtA[i] = 0xa
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AutoRefreshBlackMarketDuration) > 0 {
		for _, num := range m.AutoRefreshBlackMarketDuration {
			dAtA[i] = 0x10
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *MingcMiscDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MingcMiscDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightPrepareDuration != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.FightPrepareDuration))
	}
	if m.JoinFightDuration != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.JoinFightDuration))
	}
	if m.ApplyAstLimit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ApplyAstLimit))
	}
	if m.StartAfterServerOpen != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.StartAfterServerOpen))
	}
	if m.DestroyProsperityMaxTroop != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DestroyProsperityMaxTroop))
	}
	if m.PerDestroyProsperity != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.PerDestroyProsperity))
	}
	if m.DestroyProsperityDuration != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DestroyProsperityDuration))
	}
	if m.ReliveDuration != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ReliveDuration))
	}
	if m.Speed != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Speed))
	}
	if m.WallLevel != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WallLevel))
	}
	if m.CloseDuCheng {
		dAtA[i] = 0x60
		i++
		if m.CloseDuCheng {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.JoinFightHeroMinLevel != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.JoinFightHeroMinLevel))
	}
	if m.FreeTankSpeed != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.FreeTankSpeed))
	}
	if m.FreeTankPerDestroyProsperity != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.FreeTankPerDestroyProsperity))
	}
	if m.TouShiBuildingTurnDuration != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TouShiBuildingTurnDuration))
	}
	if m.TouShiBuildingPrepareDuration != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TouShiBuildingPrepareDuration))
	}
	if m.TouShiBuildingDestroyProsperity != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TouShiBuildingDestroyProsperity))
	}
	if m.TouShiBuildingBaseHurt != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TouShiBuildingBaseHurt))
	}
	if m.TouShiBuildingHurtPercent != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TouShiBuildingHurtPercent.Size()))
		n40, err := m.TouShiBuildingHurtPercent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.TouShiBuildingBaseHurtMaxTroop != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TouShiBuildingBaseHurtMaxTroop))
	}
	if m.TouShiBuildingBombFlyDuration != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TouShiBuildingBombFlyDuration))
	}
	if m.DurmDuration != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DurmDuration))
	}
	if m.DrumStopDuration != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DrumStopDuration))
	}
	if m.DrumMinBaiZhanLevel != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DrumMinBaiZhanLevel))
	}
	if m.DailyUpdateMingcTime != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DailyUpdateMingcTime))
	}
	if m.StartSelfCapitalAfterServerOpen != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.StartSelfCapitalAfterServerOpen))
	}
	if m.StartOtherCapitalAfterServerOpen != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.StartOtherCapitalAfterServerOpen))
	}
	if m.StartSelfCapitalNoticeAfterServerOpen != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.StartSelfCapitalNoticeAfterServerOpen))
	}
	if m.StartOtherCapitalNoticeAfterServerOpen != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.StartOtherCapitalNoticeAfterServerOpen))
	}
	return i, nil
}

func (m *MingcTimeDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MingcTimeDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.ApplyAtkStart) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.ApplyAtkStart)))
		i += copy(dAtA[i:], m.ApplyAtkStart)
	}
	if m.ApplyAtkDuration != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ApplyAtkDuration))
	}
	if len(m.ApplyAstStart) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.ApplyAstStart)))
		i += copy(dAtA[i:], m.ApplyAstStart)
	}
	if m.ApplyAstDuration != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ApplyAstDuration))
	}
	if len(m.FightStart) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.FightStart)))
		i += copy(dAtA[i:], m.FightStart)
	}
	if m.FightDuration != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.FightDuration))
	}
	return i, nil
}

func (m *MingcWarBuildingDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MingcWarBuildingDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Type))
	}
	if m.Prosperity != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Prosperity))
	}
	if m.WallAtk {
		dAtA[i] = 0x28
		i++
		if m.WallAtk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanBeAtked {
		dAtA[i] = 0x30
		i++
		if m.CanBeAtked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CombatScene) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.CombatScene)))
		i += copy(dAtA[i:], m.CombatScene)
	}
	if len(m.AtkModel) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.AtkModel)))
		i += copy(dAtA[i:], m.AtkModel)
	}
	if len(m.DefModel) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.DefModel)))
		i += copy(dAtA[i:], m.DefModel)
	}
	return i, nil
}

func (m *MingcWarMapDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MingcWarMapDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if m.Mingc != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Mingc))
	}
	if m.StartX != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.StartX))
	}
	if m.StartY != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.StartY))
	}
	if len(m.DestX) > 0 {
		for _, num := range m.DestX {
			dAtA[i] = 0x28
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.DestY) > 0 {
		for _, num := range m.DestY {
			dAtA[i] = 0x30
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *MingcWarSceneDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MingcWarSceneDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.AtkRelivePosX != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AtkRelivePosX))
	}
	if m.AtkRelivePosY != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AtkRelivePosY))
	}
	if m.AtkHomePosX != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AtkHomePosX))
	}
	if m.AtkHomePosY != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AtkHomePosY))
	}
	if len(m.AtkCastlePosX) > 0 {
		for _, num := range m.AtkCastlePosX {
			dAtA[i] = 0x38
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.AtkCastlePosY) > 0 {
		for _, num := range m.AtkCastlePosY {
			dAtA[i] = 0x40
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.AtkGatePosX) > 0 {
		for _, num := range m.AtkGatePosX {
			dAtA[i] = 0x48
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.AtkGatePosY) > 0 {
		for _, num := range m.AtkGatePosY {
			dAtA[i] = 0x50
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if m.DefRelivePosX != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DefRelivePosX))
	}
	if m.DefRelivePosY != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DefRelivePosY))
	}
	if m.DefHomePosX != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DefHomePosX))
	}
	if m.DefHomePosY != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DefHomePosY))
	}
	if len(m.DefCastlePosX) > 0 {
		for _, num := range m.DefCastlePosX {
			dAtA[i] = 0x78
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.DefCastlePosY) > 0 {
		for _, num := range m.DefCastlePosY {
			dAtA[i] = 0x80
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.DefGatePosX) > 0 {
		for _, num := range m.DefGatePosX {
			dAtA[i] = 0x88
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.DefGatePosY) > 0 {
		for _, num := range m.DefGatePosY {
			dAtA[i] = 0x90
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if m.AtkFullProsperity != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AtkFullProsperity))
	}
	if m.DefFullProsperity != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DefFullProsperity))
	}
	if len(m.AtkReliveName) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.AtkReliveName)))
		i += copy(dAtA[i:], m.AtkReliveName)
	}
	if len(m.AtkHomeName) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.AtkHomeName)))
		i += copy(dAtA[i:], m.AtkHomeName)
	}
	if len(m.AtkCastleName) > 0 {
		for _, s := range m.AtkCastleName {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.AtkGateName) > 0 {
		for _, s := range m.AtkGateName {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DefReliveName) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.DefReliveName)))
		i += copy(dAtA[i:], m.DefReliveName)
	}
	if len(m.DefHomeName) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.DefHomeName)))
		i += copy(dAtA[i:], m.DefHomeName)
	}
	if len(m.DefCastleName) > 0 {
		for _, s := range m.DefCastleName {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DefGateName) > 0 {
		for _, s := range m.DefGateName {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.AtkTouShiName) > 0 {
		for _, s := range m.AtkTouShiName {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.AtkTouShiPosX) > 0 {
		for _, num := range m.AtkTouShiPosX {
			dAtA[i] = 0x88
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.AtkTouShiPosY) > 0 {
		for _, num := range m.AtkTouShiPosY {
			dAtA[i] = 0x90
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.DefTouShiName) > 0 {
		for _, s := range m.DefTouShiName {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DefTouShiPosX) > 0 {
		for _, num := range m.DefTouShiPosX {
			dAtA[i] = 0xa0
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.DefTouShiPosY) > 0 {
		for _, num := range m.DefTouShiPosY {
			dAtA[i] = 0xa8
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *RegionGenConfigProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionGenConfigProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UseGoodsMianMaxDuraion != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.UseGoodsMianMaxDuraion))
	}
	if m.InvaseHeroMaxTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.InvaseHeroMaxTimes))
	}
	if m.InvaseHeroRecoveryDuration != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.InvaseHeroRecoveryDuration))
	}
	if m.JunTuanNpcMaxTimes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.JunTuanNpcMaxTimes))
	}
	if m.JunTuanNpcRecoveryDuration != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.JunTuanNpcRecoveryDuration))
	}
	if m.JunTuanWinTimeLimit != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.JunTuanWinTimeLimit))
	}
	return i, nil
}

func (m *OuterCityBuildingDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OuterCityBuildingDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.LockIconId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.LockIconId)))
		i += copy(dAtA[i:], m.LockIconId)
	}
	if len(m.UnlockIconId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.UnlockIconId)))
		i += copy(dAtA[i:], m.UnlockIconId)
	}
	if m.BuildingId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BuildingId))
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	return i, nil
}

func (m *DiscountColorDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscountColorDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Discount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Discount))
	}
	if len(m.Color) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Color)))
		i += copy(dAtA[i:], m.Color)
	}
	return i, nil
}

func (m *MingcWarTroopLastBeatWhenFailDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MingcWarTroopLastBeatWhenFailDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BaiZhanLevel != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BaiZhanLevel))
	}
	if m.SoliderAmount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SoliderAmount))
	}
	if m.HurtPercent != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.HurtPercent.Size()))
		n41, err := m.HurtPercent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.AtkBackHurtPercent != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AtkBackHurtPercent.Size()))
		n42, err := m.AtkBackHurtPercent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}

func (m *MingcWarTouShiBuildingTargetDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MingcWarTouShiBuildingTargetDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if m.Mingc != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Mingc))
	}
	if m.PosX != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.PosX))
	}
	if m.PosY != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.PosY))
	}
	if len(m.TargetX) > 0 {
		for _, num := range m.TargetX {
			dAtA[i] = 0x28
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.TargetY) > 0 {
		for _, num := range m.TargetY {
			dAtA[i] = 0x30
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *CaptainDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptainDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if m.Rarity != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Rarity))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.IconId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.IconId)))
		i += copy(dAtA[i:], m.IconId)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.Race != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Race))
	}
	if m.PrizeIfHas != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.PrizeIfHas.Size()))
		n43, err := m.PrizeIfHas.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if len(m.ObtainWays) > 0 {
		for _, num := range m.ObtainWays {
			dAtA[i] = 0x40
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.Sound) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Sound)))
		i += copy(dAtA[i:], m.Sound)
	}
	if m.BaseSpell != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BaseSpell))
	}
	if len(m.Star) > 0 {
		for _, msg := range m.Star {
			dAtA[i] = 0x62
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Spine) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Spine)))
		i += copy(dAtA[i:], m.Spine)
	}
	if m.FishingObtain {
		dAtA[i] = 0x70
		i++
		if m.FishingObtain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.InitRage != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.InitRage))
	}
	return i, nil
}

func (m *CaptainRarityDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptainRarityDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Coef != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Coef))
	}
	return i, nil
}

func (m *NamelessCaptainDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamelessCaptainDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.IconId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.IconId)))
		i += copy(dAtA[i:], m.IconId)
	}
	if m.Male {
		dAtA[i] = 0x20
		i++
		if m.Male {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Race != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Race))
	}
	if m.BaseSpell != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BaseSpell))
	}
	if len(m.Spell) > 0 {
		for _, num := range m.Spell {
			dAtA[i] = 0x38
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.Spine) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Spine)))
		i += copy(dAtA[i:], m.Spine)
	}
	if m.InitRage != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.InitRage))
	}
	return i, nil
}

func (m *SpellFacadeDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpellFacadeDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.IconId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.IconId)))
		i += copy(dAtA[i:], m.IconId)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.Group != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Group))
	}
	if m.Level != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Level))
	}
	if len(m.SubDesc) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.SubDesc)))
		i += copy(dAtA[i:], m.SubDesc)
	}
	if m.SpellType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SpellType))
	}
	return i, nil
}

func (m *BufferDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufferDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.Type != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Type))
	}
	if m.BuffGoodsId != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BuffGoodsId))
	}
	if len(m.NameDesc) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.NameDesc)))
		i += copy(dAtA[i:], m.NameDesc)
	}
	if len(m.IconId) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.IconId)))
		i += copy(dAtA[i:], m.IconId)
	}
	if m.ShowKeepDuration != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ShowKeepDuration))
	}
	if m.ShowLevel != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ShowLevel))
	}
	return i, nil
}

func (m *GuildRankPrizeDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuildRankPrizeDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rank != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Rank))
	}
	if m.Prize != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Prize.Size()))
		n44, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.CountryDestroyPrize != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.CountryDestroyPrize.Size()))
		n45, err := m.CountryDestroyPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}

func (m *ChargePrizeDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChargePrizeDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if m.Amount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Amount))
	}
	if m.Value != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Value))
	}
	if m.Prize != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Prize.Size()))
		n46, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	return i, nil
}

func (m *SpCollectionDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpCollectionDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if len(m.TimeShow) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.TimeShow)))
		i += copy(dAtA[i:], m.TimeShow)
	}
	if m.StartDuration != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.StartDuration))
	}
	if m.EndDuration != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.EndDuration))
	}
	if m.Sp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Sp))
	}
	if m.RepairVip != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.RepairVip))
	}
	if m.SpPrize != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SpPrize.Size()))
		n47, err := m.SpPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if m.RepairCost != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.RepairCost.Size()))
		n48, err := m.RepairCost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}

func (m *StrategyEffectDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StrategyEffectDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StrategyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.StrategyId))
	}
	if m.HeroLevel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.HeroLevel))
	}
	if m.Cost != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Cost.Size()))
		n49, err := m.Cost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.Prize != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Prize.Size()))
		n50, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.FarmFastHarvestDuration != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.FarmFastHarvestDuration))
	}
	if m.EffectType != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.EffectType))
	}
	if m.TargetReduceSolider != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TargetReduceSolider))
	}
	return i, nil
}

func (m *DailyBargainDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailyBargainDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.GiveYuanbao != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.GiveYuanbao))
	}
	if m.ShowYuanbao != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ShowYuanbao))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Limit))
	}
	if m.ChargeAmount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ChargeAmount))
	}
	if m.Prize != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Prize.Size()))
		n51, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	return i, nil
}

func (m *DurationCardDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DurationCardDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.Duration != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Duration))
	}
	if m.ChargeAmount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ChargeAmount))
	}
	if m.Prize != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Prize.Size()))
		n52, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.DailyPrize != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DailyPrize.Size()))
		n53, err := m.DailyPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.BeforePromptDuration != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BeforePromptDuration))
	}
	return i, nil
}

func (m *CombatMiscConfigProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombatMiscConfigProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Spell) > 0 {
		for _, num := range m.Spell {
			dAtA[i] = 0x8
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.SpellAnimation) > 0 {
		for _, num := range m.SpellAnimation {
			dAtA[i] = 0x10
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.PassiveSpell) > 0 {
		for _, num := range m.PassiveSpell {
			dAtA[i] = 0x18
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.PassiveSpellAnimation) > 0 {
		for _, num := range m.PassiveSpellAnimation {
			dAtA[i] = 0x20
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.State) > 0 {
		for _, num := range m.State {
			dAtA[i] = 0x28
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.StateAnimation) > 0 {
		for _, num := range m.StateAnimation {
			dAtA[i] = 0x30
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if m.MaxRage != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MaxRage))
	}
	if m.WallAttackSpeed != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WallAttackSpeed))
	}
	return i, nil
}

func (m *FreeGiftDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FreeGiftDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.GiftType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.GiftType))
	}
	if m.Daily {
		dAtA[i] = 0x20
		i++
		if m.Daily {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Prize != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Prize.Size()))
		n54, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	return i, nil
}

func (m *ChargeObjDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChargeObjDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if m.ChargeAmount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ChargeAmount))
	}
	if m.Yuanbao != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Yuanbao))
	}
	if m.YuanbaoAddition != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.YuanbaoAddition))
	}
	if m.FirstChargeYuanbao != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.FirstChargeYuanbao))
	}
	if m.VipExp != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.VipExp))
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if m.ProductId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ProductId))
	}
	return i, nil
}

func (m *BuffEffectDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffEffectDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.EffectType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.EffectType))
	}
	if m.Level != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Level))
	}
	if m.KeepDuration != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.KeepDuration))
	}
	if m.StatBuff != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.StatBuff.Size()))
		n55, err := m.StatBuff.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if m.CaptainTrain != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.CaptainTrain.Size()))
		n56, err := m.CaptainTrain.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.FarmHarvest != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.FarmHarvest.Size()))
		n57, err := m.FarmHarvest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if m.Group != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Group))
	}
	if m.Tax != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Tax.Size()))
		n58, err := m.Tax.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if m.NoDuration {
		dAtA[i] = 0x78
		i++
		if m.NoDuration {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PvpBuff {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.PvpBuff {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AdvantageId != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AdvantageId))
	}
	return i, nil
}

func (m *AssemblyDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssemblyDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if m.MemberCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MemberCount))
	}
	if len(m.WaitDuration) > 0 {
		for _, num := range m.WaitDuration {
			dAtA[i] = 0x18
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *JunTuanNpcDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JunTuanNpcDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if m.Npc != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Npc))
	}
	if m.TroopCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.TroopCount))
	}
	if m.Group != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Group))
	}
	if m.Level != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Level))
	}
	if m.RequiredHeroLevel != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.RequiredHeroLevel))
	}
	return i, nil
}

func (m *ProsperityDamageBuffDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProsperityDamageBuffDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.BuffId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BuffId))
	}
	if m.MinPercent != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MinPercent))
	}
	if m.MaxPercent != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MaxPercent))
	}
	return i, nil
}

func (m *BufferTypeDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufferTypeDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.TypeName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.TypeName)))
		i += copy(dAtA[i:], m.TypeName)
	}
	if len(m.TypeDesc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.TypeDesc)))
		i += copy(dAtA[i:], m.TypeDesc)
	}
	if len(m.IconId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.IconId)))
		i += copy(dAtA[i:], m.IconId)
	}
	if m.IsMian {
		dAtA[i] = 0x28
		i++
		if m.IsMian {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BuffGroup != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BuffGroup))
	}
	if m.Sort != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Sort))
	}
	return i, nil
}

func (m *VipContinueDaysDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VipContinueDaysDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Level))
	}
	if len(m.Days) > 0 {
		for _, num := range m.Days {
			dAtA[i] = 0x10
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.Exp) > 0 {
		for _, num := range m.Exp {
			dAtA[i] = 0x28
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *VipLevelDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VipLevelDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Level))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.IconId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.IconId)))
		i += copy(dAtA[i:], m.IconId)
	}
	if m.UpgradeExp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.UpgradeExp))
	}
	if m.DailyExp != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DailyExp))
	}
	if m.DailyPrize != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DailyPrize.Size()))
		n59, err := m.DailyPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if m.LevelPrize != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.LevelPrize.Size()))
		n60, err := m.LevelPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if m.LevelPrizeCost != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.LevelPrizeCost.Size()))
		n61, err := m.LevelPrizeCost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if m.JiuGuanAutoMax {
		dAtA[i] = 0x68
		i++
		if m.JiuGuanAutoMax {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.JiuGuanCostRefreshCount != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.JiuGuanCostRefreshCount))
	}
	if m.JiuGuanCostRefreshInfinite {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.JiuGuanCostRefreshInfinite {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ShowDailyPrizeCost != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ShowDailyPrizeCost.Size()))
		n62, err := m.ShowDailyPrizeCost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if m.ShowLevelPrizeCost != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ShowLevelPrizeCost.Size()))
		n63, err := m.ShowLevelPrizeCost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if m.BuyProsperity {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.BuyProsperity {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CaptainTrainCoef != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.CaptainTrainCoef))
	}
	if m.CaptainTrainCapacity != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.CaptainTrainCapacity))
	}
	if m.JiuGuanQuickConsult {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		if m.JiuGuanQuickConsult {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WallAutoFullSoldier {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		if m.WallAutoFullSoldier {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BuySpMaxTimes != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BuySpMaxTimes))
	}
	if m.WorkerUnlockPos != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkerUnlockPos))
	}
	if m.InvadeMultiLevelMonsterOnceCount != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.InvadeMultiLevelMonsterOnceCount))
	}
	if m.DungeonMaxCostTimesLimit != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DungeonMaxCostTimesLimit))
	}
	if m.GuildPrizeOneKeyCollect {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		if m.GuildPrizeOneKeyCollect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AddBlackMarketRefreshTimes != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AddBlackMarketRefreshTimes))
	}
	if m.FishingCaptainProbability {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		if m.FishingCaptainProbability {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ShowRegionHome {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		if m.ShowRegionHome {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ShowRegionSign {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		if m.ShowRegionSign {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ShowRegionTitle {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		if m.ShowRegionTitle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ShowHeadFrame {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		if m.ShowHeadFrame {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ZhengWuAutoCompleted {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		if m.ZhengWuAutoCompleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WorkshopAutoCompleted {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		if m.WorkshopAutoCompleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CollectDailySp {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		if m.CollectDailySp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *VipMiscDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VipMiscDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CollectVipDailyExpMinHeroLevel != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.CollectVipDailyExpMinHeroLevel))
	}
	if len(m.DungeonTimesCost) > 0 {
		for _, msg := range m.DungeonTimesCost {
			dAtA[i] = 0x12
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DungeonTimesEachBuy) > 0 {
		for _, num := range m.DungeonTimesEachBuy {
			dAtA[i] = 0x20
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *PrivacySettingDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrivacySettingDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.NameType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.NameType)))
		i += copy(dAtA[i:], m.NameType)
	}
	if len(m.RuleTitle) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.RuleTitle)))
		i += copy(dAtA[i:], m.RuleTitle)
	}
	if len(m.RuleDesc) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.RuleDesc)))
		i += copy(dAtA[i:], m.RuleDesc)
	}
	if m.SettingType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.SettingType))
	}
	return i, nil
}

func (m *TimeLimitGiftDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeLimitGiftDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.YuanbaoPrice != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.YuanbaoPrice))
	}
	if m.OldPrice != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.OldPrice))
	}
	if len(m.DiscountIcon) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.DiscountIcon)))
		i += copy(dAtA[i:], m.DiscountIcon)
	}
	if m.Dianquan != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Dianquan))
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.SignIcon) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.SignIcon)))
		i += copy(dAtA[i:], m.SignIcon)
	}
	if len(m.SignName) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.SignName)))
		i += copy(dAtA[i:], m.SignName)
	}
	if len(m.Discount) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Discount)))
		i += copy(dAtA[i:], m.Discount)
	}
	if m.Priority != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Priority))
	}
	if m.BuyLimit != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BuyLimit))
	}
	if m.Prize != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Prize.Size()))
		n64, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if m.Sort != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Sort))
	}
	if m.ShowPrize != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ShowPrize.Size()))
		n65, err := m.ShowPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if m.GuildEventPrizeId != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.GuildEventPrizeId))
	}
	return i, nil
}

func (m *EventLimitGiftDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventLimitGiftDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.YuanbaoPrice != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.YuanbaoPrice))
	}
	if m.OldPrice != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.OldPrice))
	}
	if len(m.SignIcon) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.SignIcon)))
		i += copy(dAtA[i:], m.SignIcon)
	}
	if len(m.SignName) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.SignName)))
		i += copy(dAtA[i:], m.SignName)
	}
	if len(m.DiscountIcon) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.DiscountIcon)))
		i += copy(dAtA[i:], m.DiscountIcon)
	}
	if len(m.Discount) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Discount)))
		i += copy(dAtA[i:], m.Discount)
	}
	if m.Dianquan != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Dianquan))
	}
	if m.Priority != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Priority))
	}
	if m.BuyLimit != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BuyLimit))
	}
	if m.ShowPrize != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ShowPrize.Size()))
		n66, err := m.ShowPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.GuildEventPrizeId != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.GuildEventPrizeId))
	}
	return i, nil
}

func (m *McBuildAddSupportDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McBuildAddSupportDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BaiZhanLevel != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BaiZhanLevel))
	}
	if m.AddSupport != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AddSupport))
	}
	return i, nil
}

func (m *McBuildGuildMemberPrizeDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McBuildGuildMemberPrizeDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinBuildCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MinBuildCount))
	}
	if m.MaxBuildCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MaxBuildCount))
	}
	if m.Prize != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Prize.Size()))
		n67, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	return i, nil
}

func (m *McBuildMcSupportDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McBuildMcSupportDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AddDailyYinliang != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AddDailyYinliang))
	}
	if m.AddMaxYinliang != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AddMaxYinliang))
	}
	if m.AddHostDailyYinliang != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AddHostDailyYinliang))
	}
	if m.Level != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Level))
	}
	if m.UpgradeSupport != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.UpgradeSupport))
	}
	return i, nil
}

func (m *McBuildMiscDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McBuildMiscDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxDailyAddSupport != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MaxDailyAddSupport))
	}
	if m.DailyReduceSupport != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DailyReduceSupport))
	}
	if m.DailyBuildMaxCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.DailyBuildMaxCount))
	}
	if m.BuildMinHeroLevel != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BuildMinHeroLevel))
	}
	if m.BuildCd != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BuildCd))
	}
	if m.MaxRecommendMcGuildCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MaxRecommendMcGuildCount))
	}
	if m.MaxMcBuildLogCount != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MaxMcBuildLogCount))
	}
	return i, nil
}

func (m *CaptainFriendshipDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptainFriendshipDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.Tips) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Tips)))
		i += copy(dAtA[i:], m.Tips)
	}
	if len(m.Captains) > 0 {
		for _, num := range m.Captains {
			dAtA[i] = 0x28
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.EffectDesc) > 0 {
		for _, s := range m.EffectDesc {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.EffectAmount) > 0 {
		for _, num := range m.EffectAmount {
			dAtA[i] = 0x38
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *RedPacketDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedPacketDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if m.Icon != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Icon.Size()))
		n68, err := m.Icon.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.DefaultText) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.DefaultText)))
		i += copy(dAtA[i:], m.DefaultText)
	}
	if m.Cost != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Cost.Size()))
		n69, err := m.Cost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if m.AmountType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AmountType))
	}
	if m.Money != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Money))
	}
	if m.AllGarbbedPrize != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.AllGarbbedPrize.Size()))
		n70, err := m.AllGarbbedPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	if m.ExpiredDuration != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ExpiredDuration))
	}
	if m.MinCount != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MinCount))
	}
	if m.MaxCount != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MaxCount))
	}
	if m.MaxTextLen != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.MaxTextLen))
	}
	return i, nil
}

func (m *TroopDialogueDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TroopDialogueDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if m.BaseTargetType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BaseTargetType))
	}
	if m.BaseTargetSubType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BaseTargetSubType))
	}
	if m.FirstDelay != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.FirstDelay))
	}
	if m.NextDelay != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.NextDelay))
	}
	if m.RandomText {
		dAtA[i] = 0x30
		i++
		if m.RandomText {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Texts) > 0 {
		for _, num := range m.Texts {
			dAtA[i] = 0x38
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *TroopDialogueTextDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TroopDialogueTextDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Head) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Head)))
		i += copy(dAtA[i:], m.Head)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.Duration != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Duration))
	}
	if m.Direction != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Direction))
	}
	return i, nil
}

func (m *CountryOfficialDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountryOfficialDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OfficialType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.OfficialType))
	}
	if m.BuildingEffect != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.BuildingEffect.Size()))
		n71, err := m.BuildingEffect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if m.Buff != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Buff.Size()))
		n72, err := m.Buff.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	if m.Count != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Count))
	}
	if m.ShowSalary != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.ShowSalary.Size()))
		n73, err := m.ShowSalary.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if m.Cd != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Cd))
	}
	if len(m.SubOfficials) > 0 {
		for _, num := range m.SubOfficials {
			dAtA[i] = 0x50
			i++
			i = encodeVarintConfigGen(dAtA, i, uint64(num))
		}
	}
	if len(m.Head) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Head)))
		i += copy(dAtA[i:], m.Head)
	}
	if m.Body != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Body))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.EffectDesc) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.EffectDesc)))
		i += copy(dAtA[i:], m.EffectDesc)
	}
	return i, nil
}

func (m *CountryOfficialNpcDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountryOfficialNpcDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Head) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Head)))
		i += copy(dAtA[i:], m.Head)
	}
	if m.Body != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Body))
	}
	return i, nil
}

func (m *RegionAreaDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionAreaDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Area != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Area.Size()))
		n74, err := m.Area.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if m.WorkshopPrizeCoef != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.WorkshopPrizeCoef))
	}
	return i, nil
}

func (m *FishingCaptainProbabilityDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FishingCaptainProbabilityDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CaptainId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.CaptainId))
	}
	if m.Multiple != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfigGen(dAtA, i, uint64(m.Multiple))
	}
	return i, nil
}

func encodeFixed64ConfigGen(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32ConfigGen(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintConfigGen(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ConfigGen) Size() (n int) {
	var l int
	_ = l
	if len(m.MingcBaseData) > 0 {
		for _, e := range m.MingcBaseData {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if m.XuanyuanMiscData != nil {
		l = m.XuanyuanMiscData.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if len(m.XuanyuanRangeData) > 0 {
		for _, e := range m.XuanyuanRangeData {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.XuanyuanRankPrizeData) > 0 {
		for _, e := range m.XuanyuanRankPrizeData {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if m.MiscGenConfig != nil {
		l = m.MiscGenConfig.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if len(m.BaowuData) > 0 {
		for _, e := range m.BaowuData {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.BaozNpcData) > 0 {
		for _, e := range m.BaozNpcData {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.PushData) > 0 {
		for _, e := range m.PushData {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.TitleData) > 0 {
		for _, e := range m.TitleData {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.TitleTaskData) > 0 {
		for _, e := range m.TitleTaskData {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.SecretTowerWordsData) > 0 {
		for _, e := range m.SecretTowerWordsData {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if m.GuildGenConfig != nil {
		l = m.GuildGenConfig.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if len(m.LocationData) > 0 {
		for _, e := range m.LocationData {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.CountryData) > 0 {
		for _, e := range m.CountryData {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if m.CountryMiscData != nil {
		l = m.CountryMiscData.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if len(m.FamilyNameData) > 0 {
		for _, e := range m.FamilyNameData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.LoginDayData) > 0 {
		for _, e := range m.LoginDayData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.HeroLevelFundData) > 0 {
		for _, e := range m.HeroLevelFundData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if m.PromotionMiscData != nil {
		l = m.PromotionMiscData.Size()
		n += 2 + l + sovConfigGen(uint64(l))
	}
	if len(m.BlackMarketGoodsData) > 0 {
		for _, e := range m.BlackMarketGoodsData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if m.ShopMiscData != nil {
		l = m.ShopMiscData.Size()
		n += 2 + l + sovConfigGen(uint64(l))
	}
	if m.MingcMiscData != nil {
		l = m.MingcMiscData.Size()
		n += 2 + l + sovConfigGen(uint64(l))
	}
	if len(m.MingcTimeData) > 0 {
		for _, e := range m.MingcTimeData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.MingcWarBuildingData) > 0 {
		for _, e := range m.MingcWarBuildingData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.MingcWarMapData) > 0 {
		for _, e := range m.MingcWarMapData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.MingcWarSceneData) > 0 {
		for _, e := range m.MingcWarSceneData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if m.RegionGenConfig != nil {
		l = m.RegionGenConfig.Size()
		n += 2 + l + sovConfigGen(uint64(l))
	}
	if len(m.OuterCityBuildingData) > 0 {
		for _, e := range m.OuterCityBuildingData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.DiscountColorData) > 0 {
		for _, e := range m.DiscountColorData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.MingcWarTroopLastBeatWhenFailData) > 0 {
		for _, e := range m.MingcWarTroopLastBeatWhenFailData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.MingcWarTouShiBuildingTargetData) > 0 {
		for _, e := range m.MingcWarTouShiBuildingTargetData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.CaptainData) > 0 {
		for _, e := range m.CaptainData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.CaptainRarityData) > 0 {
		for _, e := range m.CaptainRarityData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.NamelessCaptainData) > 0 {
		for _, e := range m.NamelessCaptainData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.SpellFacadeData) > 0 {
		for _, e := range m.SpellFacadeData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.BufferData) > 0 {
		for _, e := range m.BufferData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.GuildRankPrizeData) > 0 {
		for _, e := range m.GuildRankPrizeData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.ChargePrizeData) > 0 {
		for _, e := range m.ChargePrizeData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.SpCollectionData) > 0 {
		for _, e := range m.SpCollectionData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.StrategyEffectData) > 0 {
		for _, e := range m.StrategyEffectData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.DailyBargainData) > 0 {
		for _, e := range m.DailyBargainData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.DurationCardData) > 0 {
		for _, e := range m.DurationCardData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if m.CombatMiscConfig != nil {
		l = m.CombatMiscConfig.Size()
		n += 2 + l + sovConfigGen(uint64(l))
	}
	if len(m.FreeGiftData) > 0 {
		for _, e := range m.FreeGiftData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.ChargeObjData) > 0 {
		for _, e := range m.ChargeObjData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.BuffEffectData) > 0 {
		for _, e := range m.BuffEffectData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.AssemblyData) > 0 {
		for _, e := range m.AssemblyData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.JunTuanNpcData) > 0 {
		for _, e := range m.JunTuanNpcData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.ProsperityDamageBuffData) > 0 {
		for _, e := range m.ProsperityDamageBuffData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.BufferTypeData) > 0 {
		for _, e := range m.BufferTypeData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.VipContinueDaysData) > 0 {
		for _, e := range m.VipContinueDaysData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.VipLevelData) > 0 {
		for _, e := range m.VipLevelData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if m.VipMiscData != nil {
		l = m.VipMiscData.Size()
		n += 2 + l + sovConfigGen(uint64(l))
	}
	if len(m.PrivacySettingData) > 0 {
		for _, e := range m.PrivacySettingData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.TimeLimitGiftData) > 0 {
		for _, e := range m.TimeLimitGiftData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.EventLimitGiftData) > 0 {
		for _, e := range m.EventLimitGiftData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.McBuildAddSupportData) > 0 {
		for _, e := range m.McBuildAddSupportData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.McBuildGuildMemberPrizeData) > 0 {
		for _, e := range m.McBuildGuildMemberPrizeData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.McBuildMcSupportData) > 0 {
		for _, e := range m.McBuildMcSupportData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if m.McBuildMiscData != nil {
		l = m.McBuildMiscData.Size()
		n += 2 + l + sovConfigGen(uint64(l))
	}
	if len(m.CaptainFriendshipData) > 0 {
		for _, e := range m.CaptainFriendshipData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.RedPacketData) > 0 {
		for _, e := range m.RedPacketData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.TroopDialogueData) > 0 {
		for _, e := range m.TroopDialogueData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.TroopDialogueTextData) > 0 {
		for _, e := range m.TroopDialogueTextData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.CountryOfficialData) > 0 {
		for _, e := range m.CountryOfficialData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.CountryOfficialNpcData) > 0 {
		for _, e := range m.CountryOfficialNpcData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.RegionAreaData) > 0 {
		for _, e := range m.RegionAreaData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.FishingCaptainProbabilityData) > 0 {
		for _, e := range m.FishingCaptainProbabilityData {
			l = e.Size()
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	return n
}

func (m *ActivityCollectionDataProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if len(m.Exchanges) > 0 {
		for _, e := range m.Exchanges {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.NameIcon)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Sort != 0 {
		n += 1 + sovConfigGen(uint64(m.Sort))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.IconSelect)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.TimeShow)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *ActivityShowDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.TimeShow)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.PrizeDesc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.IconSelect)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.ShowCountdown {
		n += 2
	}
	if m.Sort != 0 {
		n += 1 + sovConfigGen(uint64(m.Sort))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.ImagePos != 0 {
		n += 1 + sovConfigGen(uint64(m.ImagePos))
	}
	l = len(m.NameIcon)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.LinkName)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.LinkTargetType != 0 {
		n += 2 + sovConfigGen(uint64(m.LinkTargetType))
	}
	if m.LinkTargetSubType != 0 {
		n += 2 + sovConfigGen(uint64(m.LinkTargetSubType))
	}
	if m.LinkTargetSubTypeId != 0 {
		n += 2 + sovConfigGen(uint64(m.LinkTargetSubTypeId))
	}
	if m.SpineId != 0 {
		n += 2 + sovConfigGen(uint64(m.SpineId))
	}
	return n
}

func (m *ActivityTaskDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *ActivityTaskListModeDataProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.NameIcon)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if len(m.Tasks) > 0 {
		for _, e := range m.Tasks {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if m.Sort != 0 {
		n += 1 + sovConfigGen(uint64(m.Sort))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.IconSelect)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.TimeShow)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *AreaDataProto) Size() (n int) {
	var l int
	_ = l
	if m.CenterX != 0 {
		n += 1 + sovConfigGen(uint64(m.CenterX))
	}
	if m.CenterY != 0 {
		n += 1 + sovConfigGen(uint64(m.CenterY))
	}
	if m.MinRadius != 0 {
		n += 1 + sovConfigGen(uint64(m.MinRadius))
	}
	if m.MaxRadius != 0 {
		n += 1 + sovConfigGen(uint64(m.MaxRadius))
	}
	return n
}

func (m *CaptainStarDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Star != 0 {
		n += 1 + sovConfigGen(uint64(m.Star))
	}
	if m.Cost != nil {
		l = m.Cost.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if len(m.Spell) > 0 {
		for _, e := range m.Spell {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if m.Coef != 0 {
		n += 1 + sovConfigGen(uint64(m.Coef))
	}
	if m.AddedStat != nil {
		l = m.AddedStat.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *CollectionExchangeDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	if m.Combine != nil {
		l = m.Combine.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovConfigGen(uint64(m.Limit))
	}
	return n
}

func (m *CombatConfigProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Spell) > 0 {
		for _, e := range m.Spell {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.State) > 0 {
		for _, e := range m.State {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.PassiveSpell) > 0 {
		for _, e := range m.PassiveSpell {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.SpellIdMap) > 0 {
		for _, e := range m.SpellIdMap {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.Captain) > 0 {
		for _, e := range m.Captain {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.NamelessCaptain) > 0 {
		for _, e := range m.NamelessCaptain {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.Race) > 0 {
		for _, e := range m.Race {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if m.FramePerSecond != 0 {
		n += 1 + sovConfigGen(uint64(m.FramePerSecond))
	}
	if m.ConfigDenominator != 0 {
		n += 1 + sovConfigGen(uint64(m.ConfigDenominator))
	}
	if m.MinAttackDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.MinAttackDuration))
	}
	if m.MaxAttackDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.MaxAttackDuration))
	}
	if m.MinMoveSpeed != 0 {
		n += 1 + sovConfigGen(uint64(m.MinMoveSpeed))
	}
	if m.MaxMoveSpeed != 0 {
		n += 1 + sovConfigGen(uint64(m.MaxMoveSpeed))
	}
	if m.MinStat != nil {
		l = m.MinStat.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.MaxDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.MaxDuration))
	}
	if len(m.ScorePercent) > 0 {
		for _, e := range m.ScorePercent {
			n += 2 + sovConfigGen(uint64(e))
		}
	}
	if m.CheckMoveDuration != 0 {
		n += 2 + sovConfigGen(uint64(m.CheckMoveDuration))
	}
	if m.CritRate != 0 {
		n += 2 + sovConfigGen(uint64(m.CritRate))
	}
	if m.Coef != 0 {
		n += 2 + sovConfigGen(uint64(m.Coef))
	}
	if m.CellLen != 0 {
		n += 2 + sovConfigGen(uint64(m.CellLen))
	}
	if m.MaxRage != 0 {
		n += 2 + sovConfigGen(uint64(m.MaxRage))
	}
	if m.AddRagePerHint != 0 {
		n += 2 + sovConfigGen(uint64(m.AddRagePerHint))
	}
	if m.AddRageLost1Percent != 0 {
		n += 2 + sovConfigGen(uint64(m.AddRageLost1Percent))
	}
	if m.RageRecoverSpeed != 0 {
		n += 2 + sovConfigGen(uint64(m.RageRecoverSpeed))
	}
	if m.WallWaitDuration != 0 {
		n += 2 + sovConfigGen(uint64(m.WallWaitDuration))
	}
	if m.WallAttackFixDamageTimes != 0 {
		n += 2 + sovConfigGen(uint64(m.WallAttackFixDamageTimes))
	}
	if m.WallBeenHurtLostMaxPercent != 0 {
		n += 2 + sovConfigGen(uint64(m.WallBeenHurtLostMaxPercent))
	}
	if m.WallSpell != 0 {
		n += 2 + sovConfigGen(uint64(m.WallSpell))
	}
	if m.ShortMoveDistance != 0 {
		n += 2 + sovConfigGen(uint64(m.ShortMoveDistance))
	}
	if m.InitAttackerX != 0 {
		n += 2 + sovConfigGen(uint64(m.InitAttackerX))
	}
	if m.InitDefenserX != 0 {
		n += 2 + sovConfigGen(uint64(m.InitDefenserX))
	}
	if m.InitWallX != 0 {
		n += 2 + sovConfigGen(uint64(m.InitWallX))
	}
	if m.WallFlyMinDuration != 0 {
		n += 2 + sovConfigGen(uint64(m.WallFlyMinDuration))
	}
	return n
}

func (m *PassiveSpellDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	if m.Animation != 0 {
		n += 1 + sovConfigGen(uint64(m.Animation))
	}
	if m.TriggerRate != 0 {
		n += 1 + sovConfigGen(uint64(m.TriggerRate))
	}
	if m.TriggerType != 0 {
		n += 1 + sovConfigGen(uint64(m.TriggerType))
	}
	if m.TriggerTarget != nil {
		l = m.TriggerTarget.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.TriggerHit != 0 {
		n += 1 + sovConfigGen(uint64(m.TriggerHit))
	}
	if len(m.SelfState) > 0 {
		for _, e := range m.SelfState {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.TargetState) > 0 {
		for _, e := range m.TargetState {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if m.Spell != 0 {
		n += 1 + sovConfigGen(uint64(m.Spell))
	}
	if m.ExciteEffectType != 0 {
		n += 1 + sovConfigGen(uint64(m.ExciteEffectType))
	}
	if m.Rage != 0 {
		n += 1 + sovConfigGen(uint64(m.Rage))
	}
	if m.SpriteStat != nil {
		l = m.SpriteStat.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if len(m.BeenHurtEffectIncType) > 0 {
		for _, e := range m.BeenHurtEffectIncType {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.BeenHurtEffectInc) > 0 {
		for _, e := range m.BeenHurtEffectInc {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.BeenHurtEffectDecType) > 0 {
		for _, e := range m.BeenHurtEffectDecType {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.BeenHurtEffectDec) > 0 {
		for _, e := range m.BeenHurtEffectDec {
			n += 2 + sovConfigGen(uint64(e))
		}
	}
	if m.TargetCooldown != 0 {
		n += 2 + sovConfigGen(uint64(m.TargetCooldown))
	}
	if m.RelivePercent != 0 {
		n += 2 + sovConfigGen(uint64(m.RelivePercent))
	}
	return n
}

func (m *SpellDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Animation != 0 {
		n += 1 + sovConfigGen(uint64(m.Animation))
	}
	if m.Cooldown != 0 {
		n += 1 + sovConfigGen(uint64(m.Cooldown))
	}
	if m.StrongeDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.StrongeDuration))
	}
	if m.RageSpell {
		n += 2
	}
	if m.KeepMove {
		n += 2
	}
	if m.FriendSpell {
		n += 2
	}
	if m.SelfAsTarget {
		n += 2
	}
	if m.TargetSubType != 0 {
		n += 1 + sovConfigGen(uint64(m.TargetSubType))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.ReleaseRange != 0 {
		n += 1 + sovConfigGen(uint64(m.ReleaseRange))
	}
	if m.HurtRange != 0 {
		n += 1 + sovConfigGen(uint64(m.HurtRange))
	}
	if m.HurtCount != 0 {
		n += 1 + sovConfigGen(uint64(m.HurtCount))
	}
	if m.Coef != 0 {
		n += 1 + sovConfigGen(uint64(m.Coef))
	}
	if m.EffectType != 0 {
		n += 2 + sovConfigGen(uint64(m.EffectType))
	}
	if len(m.SelfState) > 0 {
		for _, e := range m.SelfState {
			n += 2 + sovConfigGen(uint64(e))
		}
	}
	if len(m.SelfStateRate) > 0 {
		for _, e := range m.SelfStateRate {
			n += 2 + sovConfigGen(uint64(e))
		}
	}
	if len(m.TargetState) > 0 {
		for _, e := range m.TargetState {
			n += 2 + sovConfigGen(uint64(e))
		}
	}
	if len(m.TargetStateRate) > 0 {
		for _, e := range m.TargetStateRate {
			n += 2 + sovConfigGen(uint64(e))
		}
	}
	if m.SelfRage != 0 {
		n += 2 + sovConfigGen(uint64(m.SelfRage))
	}
	if m.TargetRage != 0 {
		n += 2 + sovConfigGen(uint64(m.TargetRage))
	}
	if m.FlySpeed != 0 {
		n += 2 + sovConfigGen(uint64(m.FlySpeed))
	}
	if m.HurtType != 0 {
		n += 2 + sovConfigGen(uint64(m.HurtType))
	}
	return n
}

func (m *SpellTargetDataProto) Size() (n int) {
	var l int
	_ = l
	if len(m.TargetRace) > 0 {
		for _, e := range m.TargetRace {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if m.TargetEffectType != 0 {
		n += 1 + sovConfigGen(uint64(m.TargetEffectType))
	}
	if m.TargetUnmovable {
		n += 2
	}
	if m.TargetNotAttackable {
		n += 2
	}
	if m.TargetSilence {
		n += 2
	}
	if m.TargetStun {
		n += 2
	}
	return n
}

func (m *StateDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Animation != 0 {
		n += 1 + sovConfigGen(uint64(m.Animation))
	}
	if m.StackType != 0 {
		n += 1 + sovConfigGen(uint64(m.StackType))
	}
	if m.StackMaxTimes != 0 {
		n += 1 + sovConfigGen(uint64(m.StackMaxTimes))
	}
	if m.TickTimes != 0 {
		n += 1 + sovConfigGen(uint64(m.TickTimes))
	}
	if m.TickDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.TickDuration))
	}
	if m.ChangeStat != nil {
		l = m.ChangeStat.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.IsAddStat {
		n += 2
	}
	if m.MoveSpeedRate != 0 {
		n += 1 + sovConfigGen(uint64(m.MoveSpeedRate))
	}
	if m.AttackSpeedRate != 0 {
		n += 1 + sovConfigGen(uint64(m.AttackSpeedRate))
	}
	if m.ShieldRate != 0 {
		n += 1 + sovConfigGen(uint64(m.ShieldRate))
	}
	if m.Unmovable {
		n += 2
	}
	if m.NotAttackable {
		n += 2
	}
	if m.Silence {
		n += 2
	}
	if m.Stun {
		n += 3
	}
	if m.EffectType != 0 {
		n += 2 + sovConfigGen(uint64(m.EffectType))
	}
	if len(m.BeenHurtEffectInc) > 0 {
		for _, e := range m.BeenHurtEffectInc {
			n += 2 + sovConfigGen(uint64(e))
		}
	}
	if m.DamageCoef != 0 {
		n += 2 + sovConfigGen(uint64(m.DamageCoef))
	}
	if m.Rage != 0 {
		n += 2 + sovConfigGen(uint64(m.Rage))
	}
	if m.RageRecoverRate != 0 {
		n += 2 + sovConfigGen(uint64(m.RageRecoverRate))
	}
	if len(m.BeenHurtEffectIncType) > 0 {
		for _, e := range m.BeenHurtEffectIncType {
			n += 2 + sovConfigGen(uint64(e))
		}
	}
	if len(m.BeenHurtEffectDecType) > 0 {
		for _, e := range m.BeenHurtEffectDecType {
			n += 2 + sovConfigGen(uint64(e))
		}
	}
	if len(m.BeenHurtEffectDec) > 0 {
		for _, e := range m.BeenHurtEffectDec {
			n += 2 + sovConfigGen(uint64(e))
		}
	}
	if m.ShieldEffectRate != 0 {
		n += 2 + sovConfigGen(uint64(m.ShieldEffectRate))
	}
	if m.DamageHurtType != 0 {
		n += 2 + sovConfigGen(uint64(m.DamageHurtType))
	}
	return n
}

func (m *MingcBaseDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.BaseX != 0 {
		n += 1 + sovConfigGen(uint64(m.BaseX))
	}
	if m.BaseY != 0 {
		n += 1 + sovConfigGen(uint64(m.BaseY))
	}
	if m.Radius != 0 {
		n += 1 + sovConfigGen(uint64(m.Radius))
	}
	if m.Type != 0 {
		n += 1 + sovConfigGen(uint64(m.Type))
	}
	if m.Country != 0 {
		n += 1 + sovConfigGen(uint64(m.Country))
	}
	if m.ZhouCaptain {
		n += 2
	}
	if m.DefaultYinliang != 0 {
		n += 1 + sovConfigGen(uint64(m.DefaultYinliang))
	}
	if m.DailyAddYinliang != 0 {
		n += 1 + sovConfigGen(uint64(m.DailyAddYinliang))
	}
	if m.MaxYinliang != 0 {
		n += 1 + sovConfigGen(uint64(m.MaxYinliang))
	}
	if m.HostDailyAddYinliang != 0 {
		n += 1 + sovConfigGen(uint64(m.HostDailyAddYinliang))
	}
	l = len(m.WarIcon)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.AtkMinHufu != 0 {
		n += 2 + sovConfigGen(uint64(m.AtkMinHufu))
	}
	if m.AtkMinGuildLevel != 0 {
		n += 2 + sovConfigGen(uint64(m.AtkMinGuildLevel))
	}
	if m.AstMaxGuild != 0 {
		n += 2 + sovConfigGen(uint64(m.AstMaxGuild))
	}
	if m.BaseMinDistance != 0 {
		n += 2 + sovConfigGen(uint64(m.BaseMinDistance))
	}
	return n
}

func (m *XuanyuanMiscDataProto) Size() (n int) {
	var l int
	_ = l
	if m.ChallengeTimesLimit != 0 {
		n += 1 + sovConfigGen(uint64(m.ChallengeTimesLimit))
	}
	return n
}

func (m *XuanyuanRangeDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	if m.LowRank != 0 {
		n += 1 + sovConfigGen(uint64(m.LowRank))
	}
	if m.HighRank != 0 {
		n += 1 + sovConfigGen(uint64(m.HighRank))
	}
	if m.WinScore != 0 {
		n += 1 + sovConfigGen(uint64(m.WinScore))
	}
	if m.LoseScore != 0 {
		n += 1 + sovConfigGen(uint64(m.LoseScore))
	}
	if m.DefenseLostScore != 0 {
		n += 1 + sovConfigGen(uint64(m.DefenseLostScore))
	}
	l = len(m.CombatScene)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *XuanyuanRankPrizeDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	if m.Rank != 0 {
		n += 1 + sovConfigGen(uint64(m.Rank))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.ShowPrize != nil {
		l = m.ShowPrize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *MiscGenConfigProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Stronger4Coef) > 0 {
		for _, e := range m.Stronger4Coef {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if m.MiaoBaowuDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.MiaoBaowuDuration))
	}
	if m.MiaoBaowuCost != nil {
		l = m.MiaoBaowuCost.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.DailyMiaoBaowuLimit != 0 {
		n += 1 + sovConfigGen(uint64(m.DailyMiaoBaowuLimit))
	}
	if m.BaowuLogLimit != 0 {
		n += 1 + sovConfigGen(uint64(m.BaowuLogLimit))
	}
	if m.FriendMaxCount != 0 {
		n += 1 + sovConfigGen(uint64(m.FriendMaxCount))
	}
	if m.BlackMaxCount != 0 {
		n += 1 + sovConfigGen(uint64(m.BlackMaxCount))
	}
	if m.FirstNpcBaowu != 0 {
		n += 1 + sovConfigGen(uint64(m.FirstNpcBaowu))
	}
	if m.AutoFullSoldoerDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.AutoFullSoldoerDuration))
	}
	if m.TaxDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.TaxDuration))
	}
	if len(m.FishMaxPoint) > 0 {
		for _, e := range m.FishMaxPoint {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.FishPointCaptainSoul) > 0 {
		for _, e := range m.FishPointCaptainSoul {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if m.DaZhaoSwitchLevelLimit != 0 {
		n += 1 + sovConfigGen(uint64(m.DaZhaoSwitchLevelLimit))
	}
	if m.UpdateOuterCityTypeCost != nil {
		l = m.UpdateOuterCityTypeCost.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.RandomEventBigRefreshDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.RandomEventBigRefreshDuration))
	}
	if m.RandomEventSmallRefreshDuration != 0 {
		n += 2 + sovConfigGen(uint64(m.RandomEventSmallRefreshDuration))
	}
	if m.SpDuration != 0 {
		n += 2 + sovConfigGen(uint64(m.SpDuration))
	}
	if m.BuySpValue != 0 {
		n += 2 + sovConfigGen(uint64(m.BuySpValue))
	}
	if m.BuySpCost != 0 {
		n += 2 + sovConfigGen(uint64(m.BuySpCost))
	}
	if m.BuySpLimit != 0 {
		n += 2 + sovConfigGen(uint64(m.BuySpLimit))
	}
	if m.CaptainResetCost != nil {
		l = m.CaptainResetCost.Size()
		n += 2 + l + sovConfigGen(uint64(l))
	}
	if m.SkipFightingHeroLevel != 0 {
		n += 2 + sovConfigGen(uint64(m.SkipFightingHeroLevel))
	}
	if m.SkipFightingVipLevel != 0 {
		n += 2 + sovConfigGen(uint64(m.SkipFightingVipLevel))
	}
	if m.SkipFightingWaitDuration != 0 {
		n += 2 + sovConfigGen(uint64(m.SkipFightingWaitDuration))
	}
	if m.SecretTowerCd != 0 {
		n += 2 + sovConfigGen(uint64(m.SecretTowerCd))
	}
	if m.XuanyuanCd != 0 {
		n += 2 + sovConfigGen(uint64(m.XuanyuanCd))
	}
	if m.BaizhanCd != 0 {
		n += 2 + sovConfigGen(uint64(m.BaizhanCd))
	}
	if m.HebiCd != 0 {
		n += 2 + sovConfigGen(uint64(m.HebiCd))
	}
	if m.XiongnuCd != 0 {
		n += 2 + sovConfigGen(uint64(m.XiongnuCd))
	}
	if m.MailCd != 0 {
		n += 2 + sovConfigGen(uint64(m.MailCd))
	}
	if m.DianquanToGold != 0 {
		n += 2 + sovConfigGen(uint64(m.DianquanToGold))
	}
	if m.DianquanToStone != 0 {
		n += 2 + sovConfigGen(uint64(m.DianquanToStone))
	}
	if m.SoldierPerGroup != 0 {
		n += 2 + sovConfigGen(uint64(m.SoldierPerGroup))
	}
	if m.HeroBaozDuration != 0 {
		n += 2 + sovConfigGen(uint64(m.HeroBaozDuration))
	}
	if m.HeroBaozMaxDistance != 0 {
		n += 2 + sovConfigGen(uint64(m.HeroBaozMaxDistance))
	}
	if m.YuanbaoGiftPercent != nil {
		l = m.YuanbaoGiftPercent.Size()
		n += 2 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *BaowuDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	if m.Group != 0 {
		n += 1 + sovConfigGen(uint64(m.Group))
	}
	if m.Level != 0 {
		n += 1 + sovConfigGen(uint64(m.Level))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Quality != 0 {
		n += 1 + sovConfigGen(uint64(m.Quality))
	}
	if m.GoodsQuality != 0 {
		n += 1 + sovConfigGen(uint64(m.GoodsQuality))
	}
	if m.UnlockDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.UnlockDuration))
	}
	if m.PlunderPrize != nil {
		l = m.PlunderPrize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.UpgradeNeedCount != 0 {
		n += 1 + sovConfigGen(uint64(m.UpgradeNeedCount))
	}
	if m.DecomposeGold != 0 {
		n += 1 + sovConfigGen(uint64(m.DecomposeGold))
	}
	if m.DecomposeStone != 0 {
		n += 1 + sovConfigGen(uint64(m.DecomposeStone))
	}
	if m.Prestige != 0 {
		n += 2 + sovConfigGen(uint64(m.Prestige))
	}
	if m.MiaoDuration != 0 {
		n += 2 + sovConfigGen(uint64(m.MiaoDuration))
	}
	return n
}

func (m *BaozNpcDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	if m.Npc != 0 {
		n += 1 + sovConfigGen(uint64(m.Npc))
	}
	if m.RequiredHeroLevel != 0 {
		n += 1 + sovConfigGen(uint64(m.RequiredHeroLevel))
	}
	return n
}

func (m *PushDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovConfigGen(uint64(m.Type))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.TickTime)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *TitleDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.SpriteStat != nil {
		l = m.SpriteStat.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if len(m.Task) > 0 {
		for _, e := range m.Task {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if m.TotalStat != nil {
		l = m.TotalStat.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Quality != 0 {
		n += 1 + sovConfigGen(uint64(m.Quality))
	}
	if m.PoltId != 0 {
		n += 1 + sovConfigGen(uint64(m.PoltId))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.TitleCost != nil {
		l = m.TitleCost.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.CountryChangeNameVoteCount != 0 {
		n += 1 + sovConfigGen(uint64(m.CountryChangeNameVoteCount))
	}
	return n
}

func (m *TitleTaskDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *SecretTowerWordsDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Words)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *GuildGenConfigProto) Size() (n int) {
	var l int
	_ = l
	if m.LeaveAfterJoinDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.LeaveAfterJoinDuration))
	}
	if m.GuildMarkCount != 0 {
		n += 1 + sovConfigGen(uint64(m.GuildMarkCount))
	}
	if m.GuildMarkMsgCharLimit != 0 {
		n += 1 + sovConfigGen(uint64(m.GuildMarkMsgCharLimit))
	}
	if m.SendMinYinliangToMember != 0 {
		n += 1 + sovConfigGen(uint64(m.SendMinYinliangToMember))
	}
	if m.SendMaxYinliangToMember != 0 {
		n += 1 + sovConfigGen(uint64(m.SendMaxYinliangToMember))
	}
	if m.SendMinYinliangToGuild != 0 {
		n += 1 + sovConfigGen(uint64(m.SendMinYinliangToGuild))
	}
	if m.SendMaxYinliangToGuild != 0 {
		n += 1 + sovConfigGen(uint64(m.SendMaxYinliangToGuild))
	}
	if m.SendMinSalary != 0 {
		n += 1 + sovConfigGen(uint64(m.SendMinSalary))
	}
	if m.SendMaxSalary != 0 {
		n += 1 + sovConfigGen(uint64(m.SendMaxSalary))
	}
	if m.ConveneCooldown != 0 {
		n += 1 + sovConfigGen(uint64(m.ConveneCooldown))
	}
	if m.WorkshopBuildDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.WorkshopBuildDuration))
	}
	if m.WorkshopHeroBuildDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.WorkshopHeroBuildDuration))
	}
	if m.WorkshopHurtDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.WorkshopHurtDuration))
	}
	if m.WorkshopHurtTotalTimesLimit != 0 {
		n += 2 + sovConfigGen(uint64(m.WorkshopHurtTotalTimesLimit))
	}
	if m.WorkshopHurtHeroTimesLimit != 0 {
		n += 2 + sovConfigGen(uint64(m.WorkshopHurtHeroTimesLimit))
	}
	if m.WorkshopHurtCooldown != 0 {
		n += 2 + sovConfigGen(uint64(m.WorkshopHurtCooldown))
	}
	if m.WorkshopHurtProsperity != 0 {
		n += 2 + sovConfigGen(uint64(m.WorkshopHurtProsperity))
	}
	if m.WorkshopProsperityCapcity != 0 {
		n += 2 + sovConfigGen(uint64(m.WorkshopProsperityCapcity))
	}
	if m.WorkshopPrizeMaxCount != 0 {
		n += 2 + sovConfigGen(uint64(m.WorkshopPrizeMaxCount))
	}
	if m.WorkshopReduceProsperityDuration != 0 {
		n += 2 + sovConfigGen(uint64(m.WorkshopReduceProsperityDuration))
	}
	if m.WorkshopReduceProsperity != 0 {
		n += 2 + sovConfigGen(uint64(m.WorkshopReduceProsperity))
	}
	if m.WorkshopDistanceLimit != 0 {
		n += 2 + sovConfigGen(uint64(m.WorkshopDistanceLimit))
	}
	if m.WorkshopBarrenProsperity != 0 {
		n += 2 + sovConfigGen(uint64(m.WorkshopBarrenProsperity))
	}
	if m.WorkshopGuildBuildMaxTimes != 0 {
		n += 2 + sovConfigGen(uint64(m.WorkshopGuildBuildMaxTimes))
	}
	if m.WorkshopHeroBuildMaxTimes != 0 {
		n += 2 + sovConfigGen(uint64(m.WorkshopHeroBuildMaxTimes))
	}
	if m.WorkshopOutputMaxTimes != 0 {
		n += 2 + sovConfigGen(uint64(m.WorkshopOutputMaxTimes))
	}
	if m.WorkshopOutputRecoveryDuration != 0 {
		n += 2 + sovConfigGen(uint64(m.WorkshopOutputRecoveryDuration))
	}
	if m.GuildChangeCountryCost != nil {
		l = m.GuildChangeCountryCost.Size()
		n += 2 + l + sovConfigGen(uint64(l))
	}
	if m.GuildChangeCountryWaitDuration != 0 {
		n += 2 + sovConfigGen(uint64(m.GuildChangeCountryWaitDuration))
	}
	if m.GuildChangeCountryCooldown != 0 {
		n += 2 + sovConfigGen(uint64(m.GuildChangeCountryCooldown))
	}
	if m.TaskOpenLevel != 0 {
		n += 2 + sovConfigGen(uint64(m.TaskOpenLevel))
	}
	return n
}

func (m *LocationDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if len(m.RecommendCountry) > 0 {
		for _, e := range m.RecommendCountry {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	return n
}

func (m *CountryDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.DefaultPrestige != 0 {
		n += 1 + sovConfigGen(uint64(m.DefaultPrestige))
	}
	if len(m.NpcOfficial) > 0 {
		for _, e := range m.NpcOfficial {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.NpcId) > 0 {
		for _, e := range m.NpcId {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if m.Capital != 0 {
		n += 1 + sovConfigGen(uint64(m.Capital))
	}
	return n
}

func (m *CountryMiscDataProto) Size() (n int) {
	var l int
	_ = l
	if m.NormalChangeCountryGoods != 0 {
		n += 1 + sovConfigGen(uint64(m.NormalChangeCountryGoods))
	}
	if m.NewHeroChangeCountryCd != 0 {
		n += 1 + sovConfigGen(uint64(m.NewHeroChangeCountryCd))
	}
	if m.NormalChangeCountryCd != 0 {
		n += 1 + sovConfigGen(uint64(m.NormalChangeCountryCd))
	}
	if m.NewHeroMaxLevel != 0 {
		n += 1 + sovConfigGen(uint64(m.NewHeroMaxLevel))
	}
	if m.ChangeNameCd != 0 {
		n += 1 + sovConfigGen(uint64(m.ChangeNameCd))
	}
	if m.ChangeNameCost != nil {
		l = m.ChangeNameCost.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.ChangeNameVoteDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.ChangeNameVoteDuration))
	}
	if m.MaxSearchHeroDefaultCount != 0 {
		n += 1 + sovConfigGen(uint64(m.MaxSearchHeroDefaultCount))
	}
	if m.MaxSearchHeroByNameCount != 0 {
		n += 1 + sovConfigGen(uint64(m.MaxSearchHeroByNameCount))
	}
	return n
}

func (m *FamilyNameDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if len(m.RecommendCountry) > 0 {
		for _, e := range m.RecommendCountry {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	return n
}

func (m *LoginDayDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Day != 0 {
		n += 1 + sovConfigGen(uint64(m.Day))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *HeroLevelFundDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovConfigGen(uint64(m.Level))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Rebate != 0 {
		n += 1 + sovConfigGen(uint64(m.Rebate))
	}
	return n
}

func (m *PromotionMiscDataProto) Size() (n int) {
	var l int
	_ = l
	if m.HeroLevelFundCost != nil {
		l = m.HeroLevelFundCost.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *BlackMarketGoodsDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	if m.ShowPrize != nil {
		l = m.ShowPrize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Cost != nil {
		l = m.Cost.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Quality != 0 {
		n += 1 + sovConfigGen(uint64(m.Quality))
	}
	return n
}

func (m *ShopMiscDataProto) Size() (n int) {
	var l int
	_ = l
	if len(m.RefreshBlackMarketCost) > 0 {
		for _, e := range m.RefreshBlackMarketCost {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.AutoRefreshBlackMarketDuration) > 0 {
		for _, e := range m.AutoRefreshBlackMarketDuration {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	return n
}

func (m *MingcMiscDataProto) Size() (n int) {
	var l int
	_ = l
	if m.FightPrepareDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.FightPrepareDuration))
	}
	if m.JoinFightDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.JoinFightDuration))
	}
	if m.ApplyAstLimit != 0 {
		n += 1 + sovConfigGen(uint64(m.ApplyAstLimit))
	}
	if m.StartAfterServerOpen != 0 {
		n += 1 + sovConfigGen(uint64(m.StartAfterServerOpen))
	}
	if m.DestroyProsperityMaxTroop != 0 {
		n += 1 + sovConfigGen(uint64(m.DestroyProsperityMaxTroop))
	}
	if m.PerDestroyProsperity != 0 {
		n += 1 + sovConfigGen(uint64(m.PerDestroyProsperity))
	}
	if m.DestroyProsperityDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.DestroyProsperityDuration))
	}
	if m.ReliveDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.ReliveDuration))
	}
	if m.Speed != 0 {
		n += 1 + sovConfigGen(uint64(m.Speed))
	}
	if m.WallLevel != 0 {
		n += 1 + sovConfigGen(uint64(m.WallLevel))
	}
	if m.CloseDuCheng {
		n += 2
	}
	if m.JoinFightHeroMinLevel != 0 {
		n += 1 + sovConfigGen(uint64(m.JoinFightHeroMinLevel))
	}
	if m.FreeTankSpeed != 0 {
		n += 1 + sovConfigGen(uint64(m.FreeTankSpeed))
	}
	if m.FreeTankPerDestroyProsperity != 0 {
		n += 1 + sovConfigGen(uint64(m.FreeTankPerDestroyProsperity))
	}
	if m.TouShiBuildingTurnDuration != 0 {
		n += 2 + sovConfigGen(uint64(m.TouShiBuildingTurnDuration))
	}
	if m.TouShiBuildingPrepareDuration != 0 {
		n += 2 + sovConfigGen(uint64(m.TouShiBuildingPrepareDuration))
	}
	if m.TouShiBuildingDestroyProsperity != 0 {
		n += 2 + sovConfigGen(uint64(m.TouShiBuildingDestroyProsperity))
	}
	if m.TouShiBuildingBaseHurt != 0 {
		n += 2 + sovConfigGen(uint64(m.TouShiBuildingBaseHurt))
	}
	if m.TouShiBuildingHurtPercent != nil {
		l = m.TouShiBuildingHurtPercent.Size()
		n += 2 + l + sovConfigGen(uint64(l))
	}
	if m.TouShiBuildingBaseHurtMaxTroop != 0 {
		n += 2 + sovConfigGen(uint64(m.TouShiBuildingBaseHurtMaxTroop))
	}
	if m.TouShiBuildingBombFlyDuration != 0 {
		n += 2 + sovConfigGen(uint64(m.TouShiBuildingBombFlyDuration))
	}
	if m.DurmDuration != 0 {
		n += 2 + sovConfigGen(uint64(m.DurmDuration))
	}
	if m.DrumStopDuration != 0 {
		n += 2 + sovConfigGen(uint64(m.DrumStopDuration))
	}
	if m.DrumMinBaiZhanLevel != 0 {
		n += 2 + sovConfigGen(uint64(m.DrumMinBaiZhanLevel))
	}
	if m.DailyUpdateMingcTime != 0 {
		n += 2 + sovConfigGen(uint64(m.DailyUpdateMingcTime))
	}
	if m.StartSelfCapitalAfterServerOpen != 0 {
		n += 2 + sovConfigGen(uint64(m.StartSelfCapitalAfterServerOpen))
	}
	if m.StartOtherCapitalAfterServerOpen != 0 {
		n += 2 + sovConfigGen(uint64(m.StartOtherCapitalAfterServerOpen))
	}
	if m.StartSelfCapitalNoticeAfterServerOpen != 0 {
		n += 2 + sovConfigGen(uint64(m.StartSelfCapitalNoticeAfterServerOpen))
	}
	if m.StartOtherCapitalNoticeAfterServerOpen != 0 {
		n += 2 + sovConfigGen(uint64(m.StartOtherCapitalNoticeAfterServerOpen))
	}
	return n
}

func (m *MingcTimeDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.ApplyAtkStart)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.ApplyAtkDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.ApplyAtkDuration))
	}
	l = len(m.ApplyAstStart)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.ApplyAstDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.ApplyAstDuration))
	}
	l = len(m.FightStart)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.FightDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.FightDuration))
	}
	return n
}

func (m *MingcWarBuildingDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovConfigGen(uint64(m.Type))
	}
	if m.Prosperity != 0 {
		n += 1 + sovConfigGen(uint64(m.Prosperity))
	}
	if m.WallAtk {
		n += 2
	}
	if m.CanBeAtked {
		n += 2
	}
	l = len(m.CombatScene)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.AtkModel)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.DefModel)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *MingcWarMapDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	if m.Mingc != 0 {
		n += 1 + sovConfigGen(uint64(m.Mingc))
	}
	if m.StartX != 0 {
		n += 1 + sovConfigGen(uint64(m.StartX))
	}
	if m.StartY != 0 {
		n += 1 + sovConfigGen(uint64(m.StartY))
	}
	if len(m.DestX) > 0 {
		for _, e := range m.DestX {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.DestY) > 0 {
		for _, e := range m.DestY {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	return n
}

func (m *MingcWarSceneDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.AtkRelivePosX != 0 {
		n += 1 + sovConfigGen(uint64(m.AtkRelivePosX))
	}
	if m.AtkRelivePosY != 0 {
		n += 1 + sovConfigGen(uint64(m.AtkRelivePosY))
	}
	if m.AtkHomePosX != 0 {
		n += 1 + sovConfigGen(uint64(m.AtkHomePosX))
	}
	if m.AtkHomePosY != 0 {
		n += 1 + sovConfigGen(uint64(m.AtkHomePosY))
	}
	if len(m.AtkCastlePosX) > 0 {
		for _, e := range m.AtkCastlePosX {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.AtkCastlePosY) > 0 {
		for _, e := range m.AtkCastlePosY {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.AtkGatePosX) > 0 {
		for _, e := range m.AtkGatePosX {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.AtkGatePosY) > 0 {
		for _, e := range m.AtkGatePosY {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if m.DefRelivePosX != 0 {
		n += 1 + sovConfigGen(uint64(m.DefRelivePosX))
	}
	if m.DefRelivePosY != 0 {
		n += 1 + sovConfigGen(uint64(m.DefRelivePosY))
	}
	if m.DefHomePosX != 0 {
		n += 1 + sovConfigGen(uint64(m.DefHomePosX))
	}
	if m.DefHomePosY != 0 {
		n += 1 + sovConfigGen(uint64(m.DefHomePosY))
	}
	if len(m.DefCastlePosX) > 0 {
		for _, e := range m.DefCastlePosX {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.DefCastlePosY) > 0 {
		for _, e := range m.DefCastlePosY {
			n += 2 + sovConfigGen(uint64(e))
		}
	}
	if len(m.DefGatePosX) > 0 {
		for _, e := range m.DefGatePosX {
			n += 2 + sovConfigGen(uint64(e))
		}
	}
	if len(m.DefGatePosY) > 0 {
		for _, e := range m.DefGatePosY {
			n += 2 + sovConfigGen(uint64(e))
		}
	}
	if m.AtkFullProsperity != 0 {
		n += 2 + sovConfigGen(uint64(m.AtkFullProsperity))
	}
	if m.DefFullProsperity != 0 {
		n += 2 + sovConfigGen(uint64(m.DefFullProsperity))
	}
	l = len(m.AtkReliveName)
	if l > 0 {
		n += 2 + l + sovConfigGen(uint64(l))
	}
	l = len(m.AtkHomeName)
	if l > 0 {
		n += 2 + l + sovConfigGen(uint64(l))
	}
	if len(m.AtkCastleName) > 0 {
		for _, s := range m.AtkCastleName {
			l = len(s)
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.AtkGateName) > 0 {
		for _, s := range m.AtkGateName {
			l = len(s)
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	l = len(m.DefReliveName)
	if l > 0 {
		n += 2 + l + sovConfigGen(uint64(l))
	}
	l = len(m.DefHomeName)
	if l > 0 {
		n += 2 + l + sovConfigGen(uint64(l))
	}
	if len(m.DefCastleName) > 0 {
		for _, s := range m.DefCastleName {
			l = len(s)
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.DefGateName) > 0 {
		for _, s := range m.DefGateName {
			l = len(s)
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.AtkTouShiName) > 0 {
		for _, s := range m.AtkTouShiName {
			l = len(s)
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.AtkTouShiPosX) > 0 {
		for _, e := range m.AtkTouShiPosX {
			n += 2 + sovConfigGen(uint64(e))
		}
	}
	if len(m.AtkTouShiPosY) > 0 {
		for _, e := range m.AtkTouShiPosY {
			n += 2 + sovConfigGen(uint64(e))
		}
	}
	if len(m.DefTouShiName) > 0 {
		for _, s := range m.DefTouShiName {
			l = len(s)
			n += 2 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.DefTouShiPosX) > 0 {
		for _, e := range m.DefTouShiPosX {
			n += 2 + sovConfigGen(uint64(e))
		}
	}
	if len(m.DefTouShiPosY) > 0 {
		for _, e := range m.DefTouShiPosY {
			n += 2 + sovConfigGen(uint64(e))
		}
	}
	return n
}

func (m *RegionGenConfigProto) Size() (n int) {
	var l int
	_ = l
	if m.UseGoodsMianMaxDuraion != 0 {
		n += 1 + sovConfigGen(uint64(m.UseGoodsMianMaxDuraion))
	}
	if m.InvaseHeroMaxTimes != 0 {
		n += 1 + sovConfigGen(uint64(m.InvaseHeroMaxTimes))
	}
	if m.InvaseHeroRecoveryDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.InvaseHeroRecoveryDuration))
	}
	if m.JunTuanNpcMaxTimes != 0 {
		n += 1 + sovConfigGen(uint64(m.JunTuanNpcMaxTimes))
	}
	if m.JunTuanNpcRecoveryDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.JunTuanNpcRecoveryDuration))
	}
	if m.JunTuanWinTimeLimit != 0 {
		n += 1 + sovConfigGen(uint64(m.JunTuanWinTimeLimit))
	}
	return n
}

func (m *OuterCityBuildingDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.LockIconId)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.UnlockIconId)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.BuildingId != 0 {
		n += 1 + sovConfigGen(uint64(m.BuildingId))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *DiscountColorDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Discount != 0 {
		n += 1 + sovConfigGen(uint64(m.Discount))
	}
	l = len(m.Color)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *MingcWarTroopLastBeatWhenFailDataProto) Size() (n int) {
	var l int
	_ = l
	if m.BaiZhanLevel != 0 {
		n += 1 + sovConfigGen(uint64(m.BaiZhanLevel))
	}
	if m.SoliderAmount != 0 {
		n += 1 + sovConfigGen(uint64(m.SoliderAmount))
	}
	if m.HurtPercent != nil {
		l = m.HurtPercent.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.AtkBackHurtPercent != nil {
		l = m.AtkBackHurtPercent.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *MingcWarTouShiBuildingTargetDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	if m.Mingc != 0 {
		n += 1 + sovConfigGen(uint64(m.Mingc))
	}
	if m.PosX != 0 {
		n += 1 + sovConfigGen(uint64(m.PosX))
	}
	if m.PosY != 0 {
		n += 1 + sovConfigGen(uint64(m.PosY))
	}
	if len(m.TargetX) > 0 {
		for _, e := range m.TargetX {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.TargetY) > 0 {
		for _, e := range m.TargetY {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	return n
}

func (m *CaptainDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	if m.Rarity != 0 {
		n += 1 + sovConfigGen(uint64(m.Rarity))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.IconId)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Race != 0 {
		n += 1 + sovConfigGen(uint64(m.Race))
	}
	if m.PrizeIfHas != nil {
		l = m.PrizeIfHas.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if len(m.ObtainWays) > 0 {
		for _, e := range m.ObtainWays {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	l = len(m.Sound)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.BaseSpell != 0 {
		n += 1 + sovConfigGen(uint64(m.BaseSpell))
	}
	if len(m.Star) > 0 {
		for _, e := range m.Star {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	l = len(m.Spine)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.FishingObtain {
		n += 2
	}
	if m.InitRage != 0 {
		n += 1 + sovConfigGen(uint64(m.InitRage))
	}
	return n
}

func (m *CaptainRarityDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Coef != 0 {
		n += 1 + sovConfigGen(uint64(m.Coef))
	}
	return n
}

func (m *NamelessCaptainDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.IconId)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Male {
		n += 2
	}
	if m.Race != 0 {
		n += 1 + sovConfigGen(uint64(m.Race))
	}
	if m.BaseSpell != 0 {
		n += 1 + sovConfigGen(uint64(m.BaseSpell))
	}
	if len(m.Spell) > 0 {
		for _, e := range m.Spell {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	l = len(m.Spine)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.InitRage != 0 {
		n += 1 + sovConfigGen(uint64(m.InitRage))
	}
	return n
}

func (m *SpellFacadeDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.IconId)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Group != 0 {
		n += 1 + sovConfigGen(uint64(m.Group))
	}
	if m.Level != 0 {
		n += 1 + sovConfigGen(uint64(m.Level))
	}
	l = len(m.SubDesc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.SpellType != 0 {
		n += 1 + sovConfigGen(uint64(m.SpellType))
	}
	return n
}

func (m *BufferDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovConfigGen(uint64(m.Type))
	}
	if m.BuffGoodsId != 0 {
		n += 1 + sovConfigGen(uint64(m.BuffGoodsId))
	}
	l = len(m.NameDesc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.IconId)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.ShowKeepDuration != 0 {
		n += 2 + sovConfigGen(uint64(m.ShowKeepDuration))
	}
	if m.ShowLevel != 0 {
		n += 2 + sovConfigGen(uint64(m.ShowLevel))
	}
	return n
}

func (m *GuildRankPrizeDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Rank != 0 {
		n += 1 + sovConfigGen(uint64(m.Rank))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.CountryDestroyPrize != nil {
		l = m.CountryDestroyPrize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *ChargePrizeDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	if m.Amount != 0 {
		n += 1 + sovConfigGen(uint64(m.Amount))
	}
	if m.Value != 0 {
		n += 1 + sovConfigGen(uint64(m.Value))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *SpCollectionDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.TimeShow)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.StartDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.StartDuration))
	}
	if m.EndDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.EndDuration))
	}
	if m.Sp != 0 {
		n += 1 + sovConfigGen(uint64(m.Sp))
	}
	if m.RepairVip != 0 {
		n += 1 + sovConfigGen(uint64(m.RepairVip))
	}
	if m.SpPrize != nil {
		l = m.SpPrize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.RepairCost != nil {
		l = m.RepairCost.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *StrategyEffectDataProto) Size() (n int) {
	var l int
	_ = l
	if m.StrategyId != 0 {
		n += 1 + sovConfigGen(uint64(m.StrategyId))
	}
	if m.HeroLevel != 0 {
		n += 1 + sovConfigGen(uint64(m.HeroLevel))
	}
	if m.Cost != nil {
		l = m.Cost.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.FarmFastHarvestDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.FarmFastHarvestDuration))
	}
	if m.EffectType != 0 {
		n += 1 + sovConfigGen(uint64(m.EffectType))
	}
	if m.TargetReduceSolider != 0 {
		n += 1 + sovConfigGen(uint64(m.TargetReduceSolider))
	}
	return n
}

func (m *DailyBargainDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.GiveYuanbao != 0 {
		n += 1 + sovConfigGen(uint64(m.GiveYuanbao))
	}
	if m.ShowYuanbao != 0 {
		n += 1 + sovConfigGen(uint64(m.ShowYuanbao))
	}
	if m.Limit != 0 {
		n += 1 + sovConfigGen(uint64(m.Limit))
	}
	if m.ChargeAmount != 0 {
		n += 1 + sovConfigGen(uint64(m.ChargeAmount))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *DurationCardDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovConfigGen(uint64(m.Duration))
	}
	if m.ChargeAmount != 0 {
		n += 1 + sovConfigGen(uint64(m.ChargeAmount))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.DailyPrize != nil {
		l = m.DailyPrize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.BeforePromptDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.BeforePromptDuration))
	}
	return n
}

func (m *CombatMiscConfigProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Spell) > 0 {
		for _, e := range m.Spell {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.SpellAnimation) > 0 {
		for _, e := range m.SpellAnimation {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.PassiveSpell) > 0 {
		for _, e := range m.PassiveSpell {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.PassiveSpellAnimation) > 0 {
		for _, e := range m.PassiveSpellAnimation {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.State) > 0 {
		for _, e := range m.State {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.StateAnimation) > 0 {
		for _, e := range m.StateAnimation {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if m.MaxRage != 0 {
		n += 1 + sovConfigGen(uint64(m.MaxRage))
	}
	if m.WallAttackSpeed != 0 {
		n += 1 + sovConfigGen(uint64(m.WallAttackSpeed))
	}
	return n
}

func (m *FreeGiftDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.GiftType != 0 {
		n += 1 + sovConfigGen(uint64(m.GiftType))
	}
	if m.Daily {
		n += 2
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *ChargeObjDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.ChargeAmount != 0 {
		n += 1 + sovConfigGen(uint64(m.ChargeAmount))
	}
	if m.Yuanbao != 0 {
		n += 1 + sovConfigGen(uint64(m.Yuanbao))
	}
	if m.YuanbaoAddition != 0 {
		n += 1 + sovConfigGen(uint64(m.YuanbaoAddition))
	}
	if m.FirstChargeYuanbao != 0 {
		n += 1 + sovConfigGen(uint64(m.FirstChargeYuanbao))
	}
	if m.VipExp != 0 {
		n += 1 + sovConfigGen(uint64(m.VipExp))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.ProductId != 0 {
		n += 1 + sovConfigGen(uint64(m.ProductId))
	}
	return n
}

func (m *BuffEffectDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.EffectType != 0 {
		n += 1 + sovConfigGen(uint64(m.EffectType))
	}
	if m.Level != 0 {
		n += 1 + sovConfigGen(uint64(m.Level))
	}
	if m.KeepDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.KeepDuration))
	}
	if m.StatBuff != nil {
		l = m.StatBuff.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.CaptainTrain != nil {
		l = m.CaptainTrain.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.FarmHarvest != nil {
		l = m.FarmHarvest.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Group != 0 {
		n += 1 + sovConfigGen(uint64(m.Group))
	}
	if m.Tax != nil {
		l = m.Tax.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.NoDuration {
		n += 2
	}
	if m.PvpBuff {
		n += 3
	}
	if m.AdvantageId != 0 {
		n += 2 + sovConfigGen(uint64(m.AdvantageId))
	}
	return n
}

func (m *AssemblyDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	if m.MemberCount != 0 {
		n += 1 + sovConfigGen(uint64(m.MemberCount))
	}
	if len(m.WaitDuration) > 0 {
		for _, e := range m.WaitDuration {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	return n
}

func (m *JunTuanNpcDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	if m.Npc != 0 {
		n += 1 + sovConfigGen(uint64(m.Npc))
	}
	if m.TroopCount != 0 {
		n += 1 + sovConfigGen(uint64(m.TroopCount))
	}
	if m.Group != 0 {
		n += 1 + sovConfigGen(uint64(m.Group))
	}
	if m.Level != 0 {
		n += 1 + sovConfigGen(uint64(m.Level))
	}
	if m.RequiredHeroLevel != 0 {
		n += 1 + sovConfigGen(uint64(m.RequiredHeroLevel))
	}
	return n
}

func (m *ProsperityDamageBuffDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.BuffId != 0 {
		n += 1 + sovConfigGen(uint64(m.BuffId))
	}
	if m.MinPercent != 0 {
		n += 1 + sovConfigGen(uint64(m.MinPercent))
	}
	if m.MaxPercent != 0 {
		n += 1 + sovConfigGen(uint64(m.MaxPercent))
	}
	return n
}

func (m *BufferTypeDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.TypeName)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.TypeDesc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.IconId)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.IsMian {
		n += 2
	}
	if m.BuffGroup != 0 {
		n += 1 + sovConfigGen(uint64(m.BuffGroup))
	}
	if m.Sort != 0 {
		n += 1 + sovConfigGen(uint64(m.Sort))
	}
	return n
}

func (m *VipContinueDaysDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovConfigGen(uint64(m.Level))
	}
	if len(m.Days) > 0 {
		for _, e := range m.Days {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.Exp) > 0 {
		for _, e := range m.Exp {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	return n
}

func (m *VipLevelDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovConfigGen(uint64(m.Level))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.IconId)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.UpgradeExp != 0 {
		n += 1 + sovConfigGen(uint64(m.UpgradeExp))
	}
	if m.DailyExp != 0 {
		n += 1 + sovConfigGen(uint64(m.DailyExp))
	}
	if m.DailyPrize != nil {
		l = m.DailyPrize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.LevelPrize != nil {
		l = m.LevelPrize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.LevelPrizeCost != nil {
		l = m.LevelPrizeCost.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.JiuGuanAutoMax {
		n += 2
	}
	if m.JiuGuanCostRefreshCount != 0 {
		n += 2 + sovConfigGen(uint64(m.JiuGuanCostRefreshCount))
	}
	if m.JiuGuanCostRefreshInfinite {
		n += 3
	}
	if m.ShowDailyPrizeCost != nil {
		l = m.ShowDailyPrizeCost.Size()
		n += 2 + l + sovConfigGen(uint64(l))
	}
	if m.ShowLevelPrizeCost != nil {
		l = m.ShowLevelPrizeCost.Size()
		n += 2 + l + sovConfigGen(uint64(l))
	}
	if m.BuyProsperity {
		n += 3
	}
	if m.CaptainTrainCoef != 0 {
		n += 2 + sovConfigGen(uint64(m.CaptainTrainCoef))
	}
	if m.CaptainTrainCapacity != 0 {
		n += 2 + sovConfigGen(uint64(m.CaptainTrainCapacity))
	}
	if m.JiuGuanQuickConsult {
		n += 3
	}
	if m.WallAutoFullSoldier {
		n += 3
	}
	if m.BuySpMaxTimes != 0 {
		n += 2 + sovConfigGen(uint64(m.BuySpMaxTimes))
	}
	if m.WorkerUnlockPos != 0 {
		n += 2 + sovConfigGen(uint64(m.WorkerUnlockPos))
	}
	if m.InvadeMultiLevelMonsterOnceCount != 0 {
		n += 2 + sovConfigGen(uint64(m.InvadeMultiLevelMonsterOnceCount))
	}
	if m.DungeonMaxCostTimesLimit != 0 {
		n += 2 + sovConfigGen(uint64(m.DungeonMaxCostTimesLimit))
	}
	if m.GuildPrizeOneKeyCollect {
		n += 3
	}
	if m.AddBlackMarketRefreshTimes != 0 {
		n += 2 + sovConfigGen(uint64(m.AddBlackMarketRefreshTimes))
	}
	if m.FishingCaptainProbability {
		n += 3
	}
	if m.ShowRegionHome {
		n += 3
	}
	if m.ShowRegionSign {
		n += 3
	}
	if m.ShowRegionTitle {
		n += 3
	}
	if m.ShowHeadFrame {
		n += 3
	}
	if m.ZhengWuAutoCompleted {
		n += 3
	}
	if m.WorkshopAutoCompleted {
		n += 3
	}
	if m.CollectDailySp {
		n += 3
	}
	return n
}

func (m *VipMiscDataProto) Size() (n int) {
	var l int
	_ = l
	if m.CollectVipDailyExpMinHeroLevel != 0 {
		n += 1 + sovConfigGen(uint64(m.CollectVipDailyExpMinHeroLevel))
	}
	if len(m.DungeonTimesCost) > 0 {
		for _, e := range m.DungeonTimesCost {
			l = e.Size()
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.DungeonTimesEachBuy) > 0 {
		for _, e := range m.DungeonTimesEachBuy {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	return n
}

func (m *PrivacySettingDataProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.NameType)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.RuleTitle)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.RuleDesc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.SettingType != 0 {
		n += 1 + sovConfigGen(uint64(m.SettingType))
	}
	return n
}

func (m *TimeLimitGiftDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.YuanbaoPrice != 0 {
		n += 1 + sovConfigGen(uint64(m.YuanbaoPrice))
	}
	if m.OldPrice != 0 {
		n += 1 + sovConfigGen(uint64(m.OldPrice))
	}
	l = len(m.DiscountIcon)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Dianquan != 0 {
		n += 1 + sovConfigGen(uint64(m.Dianquan))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.SignIcon)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.SignName)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Discount)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovConfigGen(uint64(m.Priority))
	}
	if m.BuyLimit != 0 {
		n += 2 + sovConfigGen(uint64(m.BuyLimit))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 2 + l + sovConfigGen(uint64(l))
	}
	if m.Sort != 0 {
		n += 2 + sovConfigGen(uint64(m.Sort))
	}
	if m.ShowPrize != nil {
		l = m.ShowPrize.Size()
		n += 2 + l + sovConfigGen(uint64(l))
	}
	if m.GuildEventPrizeId != 0 {
		n += 2 + sovConfigGen(uint64(m.GuildEventPrizeId))
	}
	return n
}

func (m *EventLimitGiftDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.YuanbaoPrice != 0 {
		n += 1 + sovConfigGen(uint64(m.YuanbaoPrice))
	}
	if m.OldPrice != 0 {
		n += 1 + sovConfigGen(uint64(m.OldPrice))
	}
	l = len(m.SignIcon)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.SignName)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.DiscountIcon)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Discount)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Dianquan != 0 {
		n += 1 + sovConfigGen(uint64(m.Dianquan))
	}
	if m.Priority != 0 {
		n += 1 + sovConfigGen(uint64(m.Priority))
	}
	if m.BuyLimit != 0 {
		n += 2 + sovConfigGen(uint64(m.BuyLimit))
	}
	if m.ShowPrize != nil {
		l = m.ShowPrize.Size()
		n += 2 + l + sovConfigGen(uint64(l))
	}
	if m.GuildEventPrizeId != 0 {
		n += 2 + sovConfigGen(uint64(m.GuildEventPrizeId))
	}
	return n
}

func (m *McBuildAddSupportDataProto) Size() (n int) {
	var l int
	_ = l
	if m.BaiZhanLevel != 0 {
		n += 1 + sovConfigGen(uint64(m.BaiZhanLevel))
	}
	if m.AddSupport != 0 {
		n += 1 + sovConfigGen(uint64(m.AddSupport))
	}
	return n
}

func (m *McBuildGuildMemberPrizeDataProto) Size() (n int) {
	var l int
	_ = l
	if m.MinBuildCount != 0 {
		n += 1 + sovConfigGen(uint64(m.MinBuildCount))
	}
	if m.MaxBuildCount != 0 {
		n += 1 + sovConfigGen(uint64(m.MaxBuildCount))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *McBuildMcSupportDataProto) Size() (n int) {
	var l int
	_ = l
	if m.AddDailyYinliang != 0 {
		n += 1 + sovConfigGen(uint64(m.AddDailyYinliang))
	}
	if m.AddMaxYinliang != 0 {
		n += 1 + sovConfigGen(uint64(m.AddMaxYinliang))
	}
	if m.AddHostDailyYinliang != 0 {
		n += 1 + sovConfigGen(uint64(m.AddHostDailyYinliang))
	}
	if m.Level != 0 {
		n += 1 + sovConfigGen(uint64(m.Level))
	}
	if m.UpgradeSupport != 0 {
		n += 1 + sovConfigGen(uint64(m.UpgradeSupport))
	}
	return n
}

func (m *McBuildMiscDataProto) Size() (n int) {
	var l int
	_ = l
	if m.MaxDailyAddSupport != 0 {
		n += 1 + sovConfigGen(uint64(m.MaxDailyAddSupport))
	}
	if m.DailyReduceSupport != 0 {
		n += 1 + sovConfigGen(uint64(m.DailyReduceSupport))
	}
	if m.DailyBuildMaxCount != 0 {
		n += 1 + sovConfigGen(uint64(m.DailyBuildMaxCount))
	}
	if m.BuildMinHeroLevel != 0 {
		n += 1 + sovConfigGen(uint64(m.BuildMinHeroLevel))
	}
	if m.BuildCd != 0 {
		n += 1 + sovConfigGen(uint64(m.BuildCd))
	}
	if m.MaxRecommendMcGuildCount != 0 {
		n += 1 + sovConfigGen(uint64(m.MaxRecommendMcGuildCount))
	}
	if m.MaxMcBuildLogCount != 0 {
		n += 1 + sovConfigGen(uint64(m.MaxMcBuildLogCount))
	}
	return n
}

func (m *CaptainFriendshipDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Tips)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if len(m.Captains) > 0 {
		for _, e := range m.Captains {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	if len(m.EffectDesc) > 0 {
		for _, s := range m.EffectDesc {
			l = len(s)
			n += 1 + l + sovConfigGen(uint64(l))
		}
	}
	if len(m.EffectAmount) > 0 {
		for _, e := range m.EffectAmount {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	return n
}

func (m *RedPacketDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	if m.Icon != nil {
		l = m.Icon.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.DefaultText)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Cost != nil {
		l = m.Cost.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.AmountType != 0 {
		n += 1 + sovConfigGen(uint64(m.AmountType))
	}
	if m.Money != 0 {
		n += 1 + sovConfigGen(uint64(m.Money))
	}
	if m.AllGarbbedPrize != nil {
		l = m.AllGarbbedPrize.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.ExpiredDuration != 0 {
		n += 1 + sovConfigGen(uint64(m.ExpiredDuration))
	}
	if m.MinCount != 0 {
		n += 1 + sovConfigGen(uint64(m.MinCount))
	}
	if m.MaxCount != 0 {
		n += 1 + sovConfigGen(uint64(m.MaxCount))
	}
	if m.MaxTextLen != 0 {
		n += 1 + sovConfigGen(uint64(m.MaxTextLen))
	}
	return n
}

func (m *TroopDialogueDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	if m.BaseTargetType != 0 {
		n += 1 + sovConfigGen(uint64(m.BaseTargetType))
	}
	if m.BaseTargetSubType != 0 {
		n += 1 + sovConfigGen(uint64(m.BaseTargetSubType))
	}
	if m.FirstDelay != 0 {
		n += 1 + sovConfigGen(uint64(m.FirstDelay))
	}
	if m.NextDelay != 0 {
		n += 1 + sovConfigGen(uint64(m.NextDelay))
	}
	if m.RandomText {
		n += 2
	}
	if len(m.Texts) > 0 {
		for _, e := range m.Texts {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	return n
}

func (m *TroopDialogueTextDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovConfigGen(uint64(m.Duration))
	}
	if m.Direction != 0 {
		n += 1 + sovConfigGen(uint64(m.Direction))
	}
	return n
}

func (m *CountryOfficialDataProto) Size() (n int) {
	var l int
	_ = l
	if m.OfficialType != 0 {
		n += 1 + sovConfigGen(uint64(m.OfficialType))
	}
	if m.BuildingEffect != nil {
		l = m.BuildingEffect.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Buff != nil {
		l = m.Buff.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovConfigGen(uint64(m.Count))
	}
	if m.ShowSalary != nil {
		l = m.ShowSalary.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Cd != 0 {
		n += 1 + sovConfigGen(uint64(m.Cd))
	}
	if len(m.SubOfficials) > 0 {
		for _, e := range m.SubOfficials {
			n += 1 + sovConfigGen(uint64(e))
		}
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Body != 0 {
		n += 1 + sovConfigGen(uint64(m.Body))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.EffectDesc)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	return n
}

func (m *CountryOfficialNpcDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Body != 0 {
		n += 1 + sovConfigGen(uint64(m.Body))
	}
	return n
}

func (m *RegionAreaDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConfigGen(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.Area != nil {
		l = m.Area.Size()
		n += 1 + l + sovConfigGen(uint64(l))
	}
	if m.WorkshopPrizeCoef != 0 {
		n += 1 + sovConfigGen(uint64(m.WorkshopPrizeCoef))
	}
	return n
}

func (m *FishingCaptainProbabilityDataProto) Size() (n int) {
	var l int
	_ = l
	if m.CaptainId != 0 {
		n += 1 + sovConfigGen(uint64(m.CaptainId))
	}
	if m.Multiple != 0 {
		n += 1 + sovConfigGen(uint64(m.Multiple))
	}
	return n
}

func sovConfigGen(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozConfigGen(x uint64) (n int) {
	return sovConfigGen(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ConfigGen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigGen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigGen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MingcBaseData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MingcBaseData = append(m.MingcBaseData, &MingcBaseDataProto{})
			if err := m.MingcBaseData[len(m.MingcBaseData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XuanyuanMiscData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.XuanyuanMiscData == nil {
				m.XuanyuanMiscData = &XuanyuanMiscDataProto{}
			}
			if err := m.XuanyuanMiscData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XuanyuanRangeData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XuanyuanRangeData = append(m.XuanyuanRangeData, &XuanyuanRangeDataProto{})
			if err := m.XuanyuanRangeData[len(m.XuanyuanRangeData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XuanyuanRankPrizeData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XuanyuanRankPrizeData = append(m.XuanyuanRankPrizeData, &XuanyuanRankPrizeDataProto{})
			if err := m.XuanyuanRankPrizeData[len(m.XuanyuanRankPrizeData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiscGenConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MiscGenConfig == nil {
				m.MiscGenConfig = &MiscGenConfigProto{}
			}
			if err := m.MiscGenConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaowuData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaowuData = append(m.BaowuData, &BaowuDataProto{})
			if err := m.BaowuData[len(m.BaowuData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaozNpcData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaozNpcData = append(m.BaozNpcData, &BaozNpcDataProto{})
			if err := m.BaozNpcData[len(m.BaozNpcData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PushData = append(m.PushData, &PushDataProto{})
			if err := m.PushData[len(m.PushData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TitleData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TitleData = append(m.TitleData, &TitleDataProto{})
			if err := m.TitleData[len(m.TitleData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TitleTaskData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TitleTaskData = append(m.TitleTaskData, &TitleTaskDataProto{})
			if err := m.TitleTaskData[len(m.TitleTaskData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretTowerWordsData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretTowerWordsData = append(m.SecretTowerWordsData, &SecretTowerWordsDataProto{})
			if err := m.SecretTowerWordsData[len(m.SecretTowerWordsData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildGenConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GuildGenConfig == nil {
				m.GuildGenConfig = &GuildGenConfigProto{}
			}
			if err := m.GuildGenConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocationData = append(m.LocationData, &LocationDataProto{})
			if err := m.LocationData[len(m.LocationData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryData = append(m.CountryData, &CountryDataProto{})
			if err := m.CountryData[len(m.CountryData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryMiscData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CountryMiscData == nil {
				m.CountryMiscData = &CountryMiscDataProto{}
			}
			if err := m.CountryMiscData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyNameData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FamilyNameData = append(m.FamilyNameData, &FamilyNameDataProto{})
			if err := m.FamilyNameData[len(m.FamilyNameData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginDayData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoginDayData = append(m.LoginDayData, &LoginDayDataProto{})
			if err := m.LoginDayData[len(m.LoginDayData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroLevelFundData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeroLevelFundData = append(m.HeroLevelFundData, &HeroLevelFundDataProto{})
			if err := m.HeroLevelFundData[len(m.HeroLevelFundData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionMiscData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PromotionMiscData == nil {
				m.PromotionMiscData = &PromotionMiscDataProto{}
			}
			if err := m.PromotionMiscData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlackMarketGoodsData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlackMarketGoodsData = append(m.BlackMarketGoodsData, &BlackMarketGoodsDataProto{})
			if err := m.BlackMarketGoodsData[len(m.BlackMarketGoodsData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopMiscData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShopMiscData == nil {
				m.ShopMiscData = &ShopMiscDataProto{}
			}
			if err := m.ShopMiscData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MingcMiscData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MingcMiscData == nil {
				m.MingcMiscData = &MingcMiscDataProto{}
			}
			if err := m.MingcMiscData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MingcTimeData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MingcTimeData = append(m.MingcTimeData, &MingcTimeDataProto{})
			if err := m.MingcTimeData[len(m.MingcTimeData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MingcWarBuildingData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MingcWarBuildingData = append(m.MingcWarBuildingData, &MingcWarBuildingDataProto{})
			if err := m.MingcWarBuildingData[len(m.MingcWarBuildingData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MingcWarMapData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MingcWarMapData = append(m.MingcWarMapData, &MingcWarMapDataProto{})
			if err := m.MingcWarMapData[len(m.MingcWarMapData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MingcWarSceneData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MingcWarSceneData = append(m.MingcWarSceneData, &MingcWarSceneDataProto{})
			if err := m.MingcWarSceneData[len(m.MingcWarSceneData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionGenConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionGenConfig == nil {
				m.RegionGenConfig = &RegionGenConfigProto{}
			}
			if err := m.RegionGenConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OuterCityBuildingData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OuterCityBuildingData = append(m.OuterCityBuildingData, &OuterCityBuildingDataProto{})
			if err := m.OuterCityBuildingData[len(m.OuterCityBuildingData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountColorData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiscountColorData = append(m.DiscountColorData, &DiscountColorDataProto{})
			if err := m.DiscountColorData[len(m.DiscountColorData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MingcWarTroopLastBeatWhenFailData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MingcWarTroopLastBeatWhenFailData = append(m.MingcWarTroopLastBeatWhenFailData, &MingcWarTroopLastBeatWhenFailDataProto{})
			if err := m.MingcWarTroopLastBeatWhenFailData[len(m.MingcWarTroopLastBeatWhenFailData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MingcWarTouShiBuildingTargetData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MingcWarTouShiBuildingTargetData = append(m.MingcWarTouShiBuildingTargetData, &MingcWarTouShiBuildingTargetDataProto{})
			if err := m.MingcWarTouShiBuildingTargetData[len(m.MingcWarTouShiBuildingTargetData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaptainData = append(m.CaptainData, &CaptainDataProto{})
			if err := m.CaptainData[len(m.CaptainData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainRarityData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaptainRarityData = append(m.CaptainRarityData, &CaptainRarityDataProto{})
			if err := m.CaptainRarityData[len(m.CaptainRarityData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamelessCaptainData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamelessCaptainData = append(m.NamelessCaptainData, &NamelessCaptainDataProto{})
			if err := m.NamelessCaptainData[len(m.NamelessCaptainData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpellFacadeData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpellFacadeData = append(m.SpellFacadeData, &SpellFacadeDataProto{})
			if err := m.SpellFacadeData[len(m.SpellFacadeData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BufferData = append(m.BufferData, &BufferDataProto{})
			if err := m.BufferData[len(m.BufferData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildRankPrizeData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildRankPrizeData = append(m.GuildRankPrizeData, &GuildRankPrizeDataProto{})
			if err := m.GuildRankPrizeData[len(m.GuildRankPrizeData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargePrizeData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChargePrizeData = append(m.ChargePrizeData, &ChargePrizeDataProto{})
			if err := m.ChargePrizeData[len(m.ChargePrizeData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpCollectionData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpCollectionData = append(m.SpCollectionData, &SpCollectionDataProto{})
			if err := m.SpCollectionData[len(m.SpCollectionData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrategyEffectData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StrategyEffectData = append(m.StrategyEffectData, &StrategyEffectDataProto{})
			if err := m.StrategyEffectData[len(m.StrategyEffectData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyBargainData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DailyBargainData = append(m.DailyBargainData, &DailyBargainDataProto{})
			if err := m.DailyBargainData[len(m.DailyBargainData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationCardData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DurationCardData = append(m.DurationCardData, &DurationCardDataProto{})
			if err := m.DurationCardData[len(m.DurationCardData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CombatMiscConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CombatMiscConfig == nil {
				m.CombatMiscConfig = &CombatMiscConfigProto{}
			}
			if err := m.CombatMiscConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeGiftData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FreeGiftData = append(m.FreeGiftData, &FreeGiftDataProto{})
			if err := m.FreeGiftData[len(m.FreeGiftData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargeObjData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChargeObjData = append(m.ChargeObjData, &ChargeObjDataProto{})
			if err := m.ChargeObjData[len(m.ChargeObjData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffEffectData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuffEffectData = append(m.BuffEffectData, &BuffEffectDataProto{})
			if err := m.BuffEffectData[len(m.BuffEffectData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssemblyData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssemblyData = append(m.AssemblyData, &AssemblyDataProto{})
			if err := m.AssemblyData[len(m.AssemblyData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JunTuanNpcData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JunTuanNpcData = append(m.JunTuanNpcData, &JunTuanNpcDataProto{})
			if err := m.JunTuanNpcData[len(m.JunTuanNpcData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProsperityDamageBuffData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProsperityDamageBuffData = append(m.ProsperityDamageBuffData, &ProsperityDamageBuffDataProto{})
			if err := m.ProsperityDamageBuffData[len(m.ProsperityDamageBuffData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferTypeData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BufferTypeData = append(m.BufferTypeData, &BufferTypeDataProto{})
			if err := m.BufferTypeData[len(m.BufferTypeData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipContinueDaysData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VipContinueDaysData = append(m.VipContinueDaysData, &VipContinueDaysDataProto{})
			if err := m.VipContinueDaysData[len(m.VipContinueDaysData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipLevelData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VipLevelData = append(m.VipLevelData, &VipLevelDataProto{})
			if err := m.VipLevelData[len(m.VipLevelData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipMiscData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VipMiscData == nil {
				m.VipMiscData = &VipMiscDataProto{}
			}
			if err := m.VipMiscData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivacySettingData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivacySettingData = append(m.PrivacySettingData, &PrivacySettingDataProto{})
			if err := m.PrivacySettingData[len(m.PrivacySettingData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 59:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeLimitGiftData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeLimitGiftData = append(m.TimeLimitGiftData, &TimeLimitGiftDataProto{})
			if err := m.TimeLimitGiftData[len(m.TimeLimitGiftData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventLimitGiftData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventLimitGiftData = append(m.EventLimitGiftData, &EventLimitGiftDataProto{})
			if err := m.EventLimitGiftData[len(m.EventLimitGiftData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McBuildAddSupportData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McBuildAddSupportData = append(m.McBuildAddSupportData, &McBuildAddSupportDataProto{})
			if err := m.McBuildAddSupportData[len(m.McBuildAddSupportData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 62:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McBuildGuildMemberPrizeData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McBuildGuildMemberPrizeData = append(m.McBuildGuildMemberPrizeData, &McBuildGuildMemberPrizeDataProto{})
			if err := m.McBuildGuildMemberPrizeData[len(m.McBuildGuildMemberPrizeData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 64:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McBuildMcSupportData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McBuildMcSupportData = append(m.McBuildMcSupportData, &McBuildMcSupportDataProto{})
			if err := m.McBuildMcSupportData[len(m.McBuildMcSupportData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 65:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McBuildMiscData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.McBuildMiscData == nil {
				m.McBuildMiscData = &McBuildMiscDataProto{}
			}
			if err := m.McBuildMiscData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 66:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainFriendshipData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaptainFriendshipData = append(m.CaptainFriendshipData, &CaptainFriendshipDataProto{})
			if err := m.CaptainFriendshipData[len(m.CaptainFriendshipData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 67:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedPacketData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedPacketData = append(m.RedPacketData, &RedPacketDataProto{})
			if err := m.RedPacketData[len(m.RedPacketData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 68:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TroopDialogueData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TroopDialogueData = append(m.TroopDialogueData, &TroopDialogueDataProto{})
			if err := m.TroopDialogueData[len(m.TroopDialogueData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 69:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TroopDialogueTextData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TroopDialogueTextData = append(m.TroopDialogueTextData, &TroopDialogueTextDataProto{})
			if err := m.TroopDialogueTextData[len(m.TroopDialogueTextData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryOfficialData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryOfficialData = append(m.CountryOfficialData, &CountryOfficialDataProto{})
			if err := m.CountryOfficialData[len(m.CountryOfficialData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 71:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryOfficialNpcData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryOfficialNpcData = append(m.CountryOfficialNpcData, &CountryOfficialNpcDataProto{})
			if err := m.CountryOfficialNpcData[len(m.CountryOfficialNpcData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 73:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionAreaData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionAreaData = append(m.RegionAreaData, &RegionAreaDataProto{})
			if err := m.RegionAreaData[len(m.RegionAreaData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 74:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FishingCaptainProbabilityData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FishingCaptainProbabilityData = append(m.FishingCaptainProbabilityData, &FishingCaptainProbabilityDataProto{})
			if err := m.FishingCaptainProbabilityData[len(m.FishingCaptainProbabilityData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityCollectionDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivityCollectionDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivityCollectionDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exchanges = append(m.Exchanges, &CollectionExchangeDataProto{})
			if err := m.Exchanges[len(m.Exchanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconSelect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconSelect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeShow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeShow = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityShowDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivityShowDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivityShowDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeShow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeShow = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrizeDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrizeDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconSelect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconSelect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowCountdown", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShowCountdown = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePos", wireType)
			}
			m.ImagePos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImagePos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkTargetType", wireType)
			}
			m.LinkTargetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkTargetType |= (TaskTargetType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkTargetSubType", wireType)
			}
			m.LinkTargetSubType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkTargetSubType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkTargetSubTypeId", wireType)
			}
			m.LinkTargetSubTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkTargetSubTypeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpineId", wireType)
			}
			m.SpineId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpineId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityTaskDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivityTaskDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivityTaskDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &TaskTargetProto{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityTaskListModeDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivityTaskListModeDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivityTaskListModeDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tasks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tasks = append(m.Tasks, &ActivityTaskDataProto{})
			if err := m.Tasks[len(m.Tasks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconSelect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconSelect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeShow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeShow = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AreaDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AreaDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AreaDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CenterX", wireType)
			}
			m.CenterX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CenterX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CenterY", wireType)
			}
			m.CenterY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CenterY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinRadius", wireType)
			}
			m.MinRadius = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinRadius |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRadius", wireType)
			}
			m.MaxRadius = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRadius |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptainStarDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptainStarDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptainStarDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &CostProto{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Spell = append(m.Spell, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Spell = append(m.Spell, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Spell", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coef", wireType)
			}
			m.Coef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddedStat == nil {
				m.AddedStat = &SpriteStatProto{}
			}
			if err := m.AddedStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionExchangeDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionExchangeDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionExchangeDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combine", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Combine == nil {
				m.Combine = &GoodsCombineDataProto{}
			}
			if err := m.Combine.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombatConfigProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombatConfigProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombatConfigProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spell", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spell = append(m.Spell, &SpellDataProto{})
			if err := m.Spell[len(m.Spell)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State, &StateDataProto{})
			if err := m.State[len(m.State)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassiveSpell", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PassiveSpell = append(m.PassiveSpell, &PassiveSpellDataProto{})
			if err := m.PassiveSpell[len(m.PassiveSpell)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpellIdMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpellIdMap = append(m.SpellIdMap, &SpellIdProto{})
			if err := m.SpellIdMap[len(m.SpellIdMap)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Captain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Captain = append(m.Captain, &CaptainDataProto{})
			if err := m.Captain[len(m.Captain)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamelessCaptain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamelessCaptain = append(m.NamelessCaptain, &NamelessCaptainDataProto{})
			if err := m.NamelessCaptain[len(m.NamelessCaptain)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Race", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Race = append(m.Race, &RaceDataProto{})
			if err := m.Race[len(m.Race)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FramePerSecond", wireType)
			}
			m.FramePerSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FramePerSecond |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigDenominator", wireType)
			}
			m.ConfigDenominator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigDenominator |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAttackDuration", wireType)
			}
			m.MinAttackDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinAttackDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAttackDuration", wireType)
			}
			m.MaxAttackDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAttackDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinMoveSpeed", wireType)
			}
			m.MinMoveSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinMoveSpeed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMoveSpeed", wireType)
			}
			m.MaxMoveSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMoveSpeed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinStat == nil {
				m.MinStat = &SpriteStatProto{}
			}
			if err := m.MinStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDuration", wireType)
			}
			m.MaxDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ScorePercent = append(m.ScorePercent, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ScorePercent = append(m.ScorePercent, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ScorePercent", wireType)
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckMoveDuration", wireType)
			}
			m.CheckMoveDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckMoveDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CritRate", wireType)
			}
			m.CritRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CritRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coef", wireType)
			}
			m.Coef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellLen", wireType)
			}
			m.CellLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRage", wireType)
			}
			m.MaxRage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddRagePerHint", wireType)
			}
			m.AddRagePerHint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddRagePerHint |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddRageLost1Percent", wireType)
			}
			m.AddRageLost1Percent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddRageLost1Percent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RageRecoverSpeed", wireType)
			}
			m.RageRecoverSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RageRecoverSpeed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallWaitDuration", wireType)
			}
			m.WallWaitDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WallWaitDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallAttackFixDamageTimes", wireType)
			}
			m.WallAttackFixDamageTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WallAttackFixDamageTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallBeenHurtLostMaxPercent", wireType)
			}
			m.WallBeenHurtLostMaxPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WallBeenHurtLostMaxPercent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallSpell", wireType)
			}
			m.WallSpell = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WallSpell |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortMoveDistance", wireType)
			}
			m.ShortMoveDistance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShortMoveDistance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitAttackerX", wireType)
			}
			m.InitAttackerX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitAttackerX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitDefenserX", wireType)
			}
			m.InitDefenserX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitDefenserX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitWallX", wireType)
			}
			m.InitWallX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitWallX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallFlyMinDuration", wireType)
			}
			m.WallFlyMinDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WallFlyMinDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassiveSpellDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassiveSpellDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassiveSpellDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Animation", wireType)
			}
			m.Animation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Animation |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerRate", wireType)
			}
			m.TriggerRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerType", wireType)
			}
			m.TriggerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerType |= (SpellTriggerType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerTarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TriggerTarget == nil {
				m.TriggerTarget = &SpellTargetDataProto{}
			}
			if err := m.TriggerTarget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerHit", wireType)
			}
			m.TriggerHit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerHit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SelfState = append(m.SelfState, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SelfState = append(m.SelfState, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfState", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TargetState = append(m.TargetState, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TargetState = append(m.TargetState, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetState", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spell", wireType)
			}
			m.Spell = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Spell |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExciteEffectType", wireType)
			}
			m.ExciteEffectType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExciteEffectType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rage", wireType)
			}
			m.Rage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpriteStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpriteStat == nil {
				m.SpriteStat = &SpriteStatProto{}
			}
			if err := m.SpriteStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BeenHurtEffectIncType = append(m.BeenHurtEffectIncType, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BeenHurtEffectIncType = append(m.BeenHurtEffectIncType, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BeenHurtEffectIncType", wireType)
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BeenHurtEffectInc = append(m.BeenHurtEffectInc, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BeenHurtEffectInc = append(m.BeenHurtEffectInc, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BeenHurtEffectInc", wireType)
			}
		case 15:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BeenHurtEffectDecType = append(m.BeenHurtEffectDecType, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BeenHurtEffectDecType = append(m.BeenHurtEffectDecType, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BeenHurtEffectDecType", wireType)
			}
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BeenHurtEffectDec = append(m.BeenHurtEffectDec, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BeenHurtEffectDec = append(m.BeenHurtEffectDec, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BeenHurtEffectDec", wireType)
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetCooldown", wireType)
			}
			m.TargetCooldown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetCooldown |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelivePercent", wireType)
			}
			m.RelivePercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelivePercent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpellDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpellDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpellDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Animation", wireType)
			}
			m.Animation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Animation |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cooldown", wireType)
			}
			m.Cooldown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cooldown |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrongeDuration", wireType)
			}
			m.StrongeDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StrongeDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RageSpell", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RageSpell = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepMove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeepMove = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendSpell", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FriendSpell = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfAsTarget", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SelfAsTarget = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetSubType", wireType)
			}
			m.TargetSubType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetSubType |= (SpellTargetSubType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &SpellTargetDataProto{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseRange", wireType)
			}
			m.ReleaseRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReleaseRange |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtRange", wireType)
			}
			m.HurtRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HurtRange |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtCount", wireType)
			}
			m.HurtCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HurtCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coef", wireType)
			}
			m.Coef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectType", wireType)
			}
			m.EffectType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SelfState = append(m.SelfState, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SelfState = append(m.SelfState, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfState", wireType)
			}
		case 19:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SelfStateRate = append(m.SelfStateRate, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SelfStateRate = append(m.SelfStateRate, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfStateRate", wireType)
			}
		case 20:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TargetState = append(m.TargetState, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TargetState = append(m.TargetState, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetState", wireType)
			}
		case 21:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TargetStateRate = append(m.TargetStateRate, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TargetStateRate = append(m.TargetStateRate, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetStateRate", wireType)
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfRage", wireType)
			}
			m.SelfRage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfRage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetRage", wireType)
			}
			m.TargetRage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetRage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlySpeed", wireType)
			}
			m.FlySpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlySpeed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtType", wireType)
			}
			m.HurtType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HurtType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpellTargetDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpellTargetDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpellTargetDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v Race
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Race(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TargetRace = append(m.TargetRace, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Race
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Race(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TargetRace = append(m.TargetRace, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetRace", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetEffectType", wireType)
			}
			m.TargetEffectType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetEffectType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetUnmovable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TargetUnmovable = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetNotAttackable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TargetNotAttackable = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetSilence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TargetSilence = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetStun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TargetStun = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Animation", wireType)
			}
			m.Animation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Animation |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StackType", wireType)
			}
			m.StackType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StackType |= (StateStackType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StackMaxTimes", wireType)
			}
			m.StackMaxTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StackMaxTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TickTimes", wireType)
			}
			m.TickTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TickTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TickDuration", wireType)
			}
			m.TickDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TickDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeStat == nil {
				m.ChangeStat = &SpriteStatProto{}
			}
			if err := m.ChangeStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAddStat", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAddStat = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveSpeedRate", wireType)
			}
			m.MoveSpeedRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveSpeedRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackSpeedRate", wireType)
			}
			m.AttackSpeedRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackSpeedRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShieldRate", wireType)
			}
			m.ShieldRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShieldRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unmovable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unmovable = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotAttackable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotAttackable = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Silence = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stun = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectType", wireType)
			}
			m.EffectType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BeenHurtEffectInc = append(m.BeenHurtEffectInc, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BeenHurtEffectInc = append(m.BeenHurtEffectInc, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BeenHurtEffectInc", wireType)
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DamageCoef", wireType)
			}
			m.DamageCoef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DamageCoef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rage", wireType)
			}
			m.Rage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RageRecoverRate", wireType)
			}
			m.RageRecoverRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RageRecoverRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BeenHurtEffectIncType = append(m.BeenHurtEffectIncType, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BeenHurtEffectIncType = append(m.BeenHurtEffectIncType, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BeenHurtEffectIncType", wireType)
			}
		case 24:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BeenHurtEffectDecType = append(m.BeenHurtEffectDecType, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BeenHurtEffectDecType = append(m.BeenHurtEffectDecType, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BeenHurtEffectDecType", wireType)
			}
		case 25:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BeenHurtEffectDec = append(m.BeenHurtEffectDec, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BeenHurtEffectDec = append(m.BeenHurtEffectDec, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BeenHurtEffectDec", wireType)
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShieldEffectRate", wireType)
			}
			m.ShieldEffectRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShieldEffectRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DamageHurtType", wireType)
			}
			m.DamageHurtType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DamageHurtType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MingcBaseDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MingcBaseDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MingcBaseDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseX", wireType)
			}
			m.BaseX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseY", wireType)
			}
			m.BaseY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			m.Radius = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Radius |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MincType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			m.Country = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Country |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZhouCaptain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ZhouCaptain = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultYinliang", wireType)
			}
			m.DefaultYinliang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultYinliang |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyAddYinliang", wireType)
			}
			m.DailyAddYinliang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailyAddYinliang |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxYinliang", wireType)
			}
			m.MaxYinliang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxYinliang |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostDailyAddYinliang", wireType)
			}
			m.HostDailyAddYinliang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostDailyAddYinliang |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WarIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkMinHufu", wireType)
			}
			m.AtkMinHufu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AtkMinHufu |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkMinGuildLevel", wireType)
			}
			m.AtkMinGuildLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AtkMinGuildLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AstMaxGuild", wireType)
			}
			m.AstMaxGuild = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AstMaxGuild |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseMinDistance", wireType)
			}
			m.BaseMinDistance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseMinDistance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XuanyuanMiscDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XuanyuanMiscDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XuanyuanMiscDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTimesLimit", wireType)
			}
			m.ChallengeTimesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeTimesLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XuanyuanRangeDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XuanyuanRangeDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XuanyuanRangeDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowRank", wireType)
			}
			m.LowRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowRank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighRank", wireType)
			}
			m.HighRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighRank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinScore", wireType)
			}
			m.WinScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoseScore", wireType)
			}
			m.LoseScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoseScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenseLostScore", wireType)
			}
			m.DefenseLostScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefenseLostScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CombatScene", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CombatScene = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XuanyuanRankPrizeDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XuanyuanRankPrizeDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XuanyuanRankPrizeDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowPrize == nil {
				m.ShowPrize = &PrizeProto{}
			}
			if err := m.ShowPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiscGenConfigProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiscGenConfigProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiscGenConfigProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Stronger4Coef = append(m.Stronger4Coef, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Stronger4Coef = append(m.Stronger4Coef, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Stronger4Coef", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiaoBaowuDuration", wireType)
			}
			m.MiaoBaowuDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MiaoBaowuDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiaoBaowuCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MiaoBaowuCost == nil {
				m.MiaoBaowuCost = &CostProto{}
			}
			if err := m.MiaoBaowuCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyMiaoBaowuLimit", wireType)
			}
			m.DailyMiaoBaowuLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailyMiaoBaowuLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaowuLogLimit", wireType)
			}
			m.BaowuLogLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaowuLogLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendMaxCount", wireType)
			}
			m.FriendMaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FriendMaxCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlackMaxCount", wireType)
			}
			m.BlackMaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlackMaxCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstNpcBaowu", wireType)
			}
			m.FirstNpcBaowu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstNpcBaowu |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoFullSoldoerDuration", wireType)
			}
			m.AutoFullSoldoerDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoFullSoldoerDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaxDuration", wireType)
			}
			m.TaxDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaxDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FishMaxPoint = append(m.FishMaxPoint, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FishMaxPoint = append(m.FishMaxPoint, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FishMaxPoint", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FishPointCaptainSoul = append(m.FishPointCaptainSoul, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FishPointCaptainSoul = append(m.FishPointCaptainSoul, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FishPointCaptainSoul", wireType)
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaZhaoSwitchLevelLimit", wireType)
			}
			m.DaZhaoSwitchLevelLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DaZhaoSwitchLevelLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateOuterCityTypeCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateOuterCityTypeCost == nil {
				m.UpdateOuterCityTypeCost = &CostProto{}
			}
			if err := m.UpdateOuterCityTypeCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomEventBigRefreshDuration", wireType)
			}
			m.RandomEventBigRefreshDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomEventBigRefreshDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomEventSmallRefreshDuration", wireType)
			}
			m.RandomEventSmallRefreshDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomEventSmallRefreshDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpDuration", wireType)
			}
			m.SpDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuySpValue", wireType)
			}
			m.BuySpValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuySpValue |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuySpCost", wireType)
			}
			m.BuySpCost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuySpCost |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuySpLimit", wireType)
			}
			m.BuySpLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuySpLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainResetCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CaptainResetCost == nil {
				m.CaptainResetCost = &CostProto{}
			}
			if err := m.CaptainResetCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipFightingHeroLevel", wireType)
			}
			m.SkipFightingHeroLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkipFightingHeroLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipFightingVipLevel", wireType)
			}
			m.SkipFightingVipLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkipFightingVipLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipFightingWaitDuration", wireType)
			}
			m.SkipFightingWaitDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkipFightingWaitDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretTowerCd", wireType)
			}
			m.SecretTowerCd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecretTowerCd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XuanyuanCd", wireType)
			}
			m.XuanyuanCd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XuanyuanCd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaizhanCd", wireType)
			}
			m.BaizhanCd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaizhanCd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HebiCd", wireType)
			}
			m.HebiCd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HebiCd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XiongnuCd", wireType)
			}
			m.XiongnuCd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XiongnuCd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailCd", wireType)
			}
			m.MailCd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MailCd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DianquanToGold", wireType)
			}
			m.DianquanToGold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DianquanToGold |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DianquanToStone", wireType)
			}
			m.DianquanToStone = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DianquanToStone |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldierPerGroup", wireType)
			}
			m.SoldierPerGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoldierPerGroup |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroBaozDuration", wireType)
			}
			m.HeroBaozDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroBaozDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroBaozMaxDistance", wireType)
			}
			m.HeroBaozMaxDistance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroBaozMaxDistance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YuanbaoGiftPercent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.YuanbaoGiftPercent == nil {
				m.YuanbaoGiftPercent = &AmountProto{}
			}
			if err := m.YuanbaoGiftPercent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaowuDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaowuDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaowuDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (Quality(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsQuality", wireType)
			}
			m.GoodsQuality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoodsQuality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockDuration", wireType)
			}
			m.UnlockDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnlockDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlunderPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlunderPrize == nil {
				m.PlunderPrize = &PrizeProto{}
			}
			if err := m.PlunderPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeNeedCount", wireType)
			}
			m.UpgradeNeedCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradeNeedCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecomposeGold", wireType)
			}
			m.DecomposeGold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecomposeGold |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecomposeStone", wireType)
			}
			m.DecomposeStone = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecomposeStone |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prestige", wireType)
			}
			m.Prestige = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prestige |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiaoDuration", wireType)
			}
			m.MiaoDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MiaoDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaozNpcDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaozNpcDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaozNpcDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Npc", wireType)
			}
			m.Npc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Npc |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredHeroLevel", wireType)
			}
			m.RequiredHeroLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredHeroLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (SettingType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TickTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TickTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TitleDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TitleDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TitleDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpriteStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpriteStat == nil {
				m.SpriteStat = &SpriteStatProto{}
			}
			if err := m.SpriteStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Task = append(m.Task, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Task = append(m.Task, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalStat == nil {
				m.TotalStat = &SpriteStatProto{}
			}
			if err := m.TotalStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (Quality(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoltId", wireType)
			}
			m.PoltId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoltId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TitleCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TitleCost == nil {
				m.TitleCost = &CostProto{}
			}
			if err := m.TitleCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryChangeNameVoteCount", wireType)
			}
			m.CountryChangeNameVoteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountryChangeNameVoteCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TitleTaskDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TitleTaskDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TitleTaskDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &TaskTargetProto{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretTowerWordsDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretTowerWordsDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretTowerWordsDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Words", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Words = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuildGenConfigProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuildGenConfigProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuildGenConfigProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaveAfterJoinDuration", wireType)
			}
			m.LeaveAfterJoinDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaveAfterJoinDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildMarkCount", wireType)
			}
			m.GuildMarkCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildMarkCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildMarkMsgCharLimit", wireType)
			}
			m.GuildMarkMsgCharLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildMarkMsgCharLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendMinYinliangToMember", wireType)
			}
			m.SendMinYinliangToMember = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendMinYinliangToMember |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendMaxYinliangToMember", wireType)
			}
			m.SendMaxYinliangToMember = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendMaxYinliangToMember |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendMinYinliangToGuild", wireType)
			}
			m.SendMinYinliangToGuild = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendMinYinliangToGuild |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendMaxYinliangToGuild", wireType)
			}
			m.SendMaxYinliangToGuild = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendMaxYinliangToGuild |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendMinSalary", wireType)
			}
			m.SendMinSalary = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendMinSalary |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendMaxSalary", wireType)
			}
			m.SendMaxSalary = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendMaxSalary |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConveneCooldown", wireType)
			}
			m.ConveneCooldown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConveneCooldown |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopBuildDuration", wireType)
			}
			m.WorkshopBuildDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopBuildDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopHeroBuildDuration", wireType)
			}
			m.WorkshopHeroBuildDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopHeroBuildDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopHurtDuration", wireType)
			}
			m.WorkshopHurtDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopHurtDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopHurtTotalTimesLimit", wireType)
			}
			m.WorkshopHurtTotalTimesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopHurtTotalTimesLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopHurtHeroTimesLimit", wireType)
			}
			m.WorkshopHurtHeroTimesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopHurtHeroTimesLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopHurtCooldown", wireType)
			}
			m.WorkshopHurtCooldown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopHurtCooldown |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopHurtProsperity", wireType)
			}
			m.WorkshopHurtProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopHurtProsperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopProsperityCapcity", wireType)
			}
			m.WorkshopProsperityCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopProsperityCapcity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopPrizeMaxCount", wireType)
			}
			m.WorkshopPrizeMaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopPrizeMaxCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopReduceProsperityDuration", wireType)
			}
			m.WorkshopReduceProsperityDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopReduceProsperityDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopReduceProsperity", wireType)
			}
			m.WorkshopReduceProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopReduceProsperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopDistanceLimit", wireType)
			}
			m.WorkshopDistanceLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopDistanceLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopBarrenProsperity", wireType)
			}
			m.WorkshopBarrenProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopBarrenProsperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopGuildBuildMaxTimes", wireType)
			}
			m.WorkshopGuildBuildMaxTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopGuildBuildMaxTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopHeroBuildMaxTimes", wireType)
			}
			m.WorkshopHeroBuildMaxTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopHeroBuildMaxTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopOutputMaxTimes", wireType)
			}
			m.WorkshopOutputMaxTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopOutputMaxTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopOutputRecoveryDuration", wireType)
			}
			m.WorkshopOutputRecoveryDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopOutputRecoveryDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildChangeCountryCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GuildChangeCountryCost == nil {
				m.GuildChangeCountryCost = &CostProto{}
			}
			if err := m.GuildChangeCountryCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildChangeCountryWaitDuration", wireType)
			}
			m.GuildChangeCountryWaitDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildChangeCountryWaitDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildChangeCountryCooldown", wireType)
			}
			m.GuildChangeCountryCooldown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildChangeCountryCooldown |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskOpenLevel", wireType)
			}
			m.TaskOpenLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskOpenLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RecommendCountry = append(m.RecommendCountry, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RecommendCountry = append(m.RecommendCountry, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendCountry", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountryDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountryDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountryDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultPrestige", wireType)
			}
			m.DefaultPrestige = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultPrestige |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType == 0 {
				var v CountryOfficialType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (CountryOfficialType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NpcOfficial = append(m.NpcOfficial, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v CountryOfficialType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (CountryOfficialType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NpcOfficial = append(m.NpcOfficial, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NpcOfficial", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NpcId = append(m.NpcId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NpcId = append(m.NpcId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NpcId", wireType)
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capital", wireType)
			}
			m.Capital = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Capital |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountryMiscDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountryMiscDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountryMiscDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalChangeCountryGoods", wireType)
			}
			m.NormalChangeCountryGoods = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NormalChangeCountryGoods |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewHeroChangeCountryCd", wireType)
			}
			m.NewHeroChangeCountryCd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewHeroChangeCountryCd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalChangeCountryCd", wireType)
			}
			m.NormalChangeCountryCd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NormalChangeCountryCd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewHeroMaxLevel", wireType)
			}
			m.NewHeroMaxLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewHeroMaxLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeNameCd", wireType)
			}
			m.ChangeNameCd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeNameCd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeNameCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeNameCost == nil {
				m.ChangeNameCost = &CostProto{}
			}
			if err := m.ChangeNameCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeNameVoteDuration", wireType)
			}
			m.ChangeNameVoteDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeNameVoteDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSearchHeroDefaultCount", wireType)
			}
			m.MaxSearchHeroDefaultCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSearchHeroDefaultCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSearchHeroByNameCount", wireType)
			}
			m.MaxSearchHeroByNameCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSearchHeroByNameCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FamilyNameDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FamilyNameDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FamilyNameDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RecommendCountry = append(m.RecommendCountry, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RecommendCountry = append(m.RecommendCountry, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendCountry", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginDayDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginDayDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginDayDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Day", wireType)
			}
			m.Day = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Day |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroLevelFundDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroLevelFundDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroLevelFundDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rebate", wireType)
			}
			m.Rebate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rebate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PromotionMiscDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PromotionMiscDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PromotionMiscDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroLevelFundCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeroLevelFundCost == nil {
				m.HeroLevelFundCost = &CostProto{}
			}
			if err := m.HeroLevelFundCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlackMarketGoodsDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlackMarketGoodsDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlackMarketGoodsDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowPrize == nil {
				m.ShowPrize = &PrizeProto{}
			}
			if err := m.ShowPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &CostProto{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (Quality(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShopMiscDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShopMiscDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShopMiscDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshBlackMarketCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshBlackMarketCost = append(m.RefreshBlackMarketCost, &CostProto{})
			if err := m.RefreshBlackMarketCost[len(m.RefreshBlackMarketCost)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AutoRefreshBlackMarketDuration = append(m.AutoRefreshBlackMarketDuration, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AutoRefreshBlackMarketDuration = append(m.AutoRefreshBlackMarketDuration, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRefreshBlackMarketDuration", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MingcMiscDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MingcMiscDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MingcMiscDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightPrepareDuration", wireType)
			}
			m.FightPrepareDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightPrepareDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinFightDuration", wireType)
			}
			m.JoinFightDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinFightDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyAstLimit", wireType)
			}
			m.ApplyAstLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyAstLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartAfterServerOpen", wireType)
			}
			m.StartAfterServerOpen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartAfterServerOpen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestroyProsperityMaxTroop", wireType)
			}
			m.DestroyProsperityMaxTroop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestroyProsperityMaxTroop |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerDestroyProsperity", wireType)
			}
			m.PerDestroyProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerDestroyProsperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestroyProsperityDuration", wireType)
			}
			m.DestroyProsperityDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestroyProsperityDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliveDuration", wireType)
			}
			m.ReliveDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReliveDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			m.Speed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Speed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallLevel", wireType)
			}
			m.WallLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WallLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseDuCheng", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CloseDuCheng = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinFightHeroMinLevel", wireType)
			}
			m.JoinFightHeroMinLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinFightHeroMinLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeTankSpeed", wireType)
			}
			m.FreeTankSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeTankSpeed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeTankPerDestroyProsperity", wireType)
			}
			m.FreeTankPerDestroyProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeTankPerDestroyProsperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TouShiBuildingTurnDuration", wireType)
			}
			m.TouShiBuildingTurnDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TouShiBuildingTurnDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TouShiBuildingPrepareDuration", wireType)
			}
			m.TouShiBuildingPrepareDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TouShiBuildingPrepareDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TouShiBuildingDestroyProsperity", wireType)
			}
			m.TouShiBuildingDestroyProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TouShiBuildingDestroyProsperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TouShiBuildingBaseHurt", wireType)
			}
			m.TouShiBuildingBaseHurt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TouShiBuildingBaseHurt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TouShiBuildingHurtPercent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TouShiBuildingHurtPercent == nil {
				m.TouShiBuildingHurtPercent = &AmountProto{}
			}
			if err := m.TouShiBuildingHurtPercent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TouShiBuildingBaseHurtMaxTroop", wireType)
			}
			m.TouShiBuildingBaseHurtMaxTroop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TouShiBuildingBaseHurtMaxTroop |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TouShiBuildingBombFlyDuration", wireType)
			}
			m.TouShiBuildingBombFlyDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TouShiBuildingBombFlyDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurmDuration", wireType)
			}
			m.DurmDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurmDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrumStopDuration", wireType)
			}
			m.DrumStopDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrumStopDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrumMinBaiZhanLevel", wireType)
			}
			m.DrumMinBaiZhanLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrumMinBaiZhanLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyUpdateMingcTime", wireType)
			}
			m.DailyUpdateMingcTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailyUpdateMingcTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartSelfCapitalAfterServerOpen", wireType)
			}
			m.StartSelfCapitalAfterServerOpen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartSelfCapitalAfterServerOpen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartOtherCapitalAfterServerOpen", wireType)
			}
			m.StartOtherCapitalAfterServerOpen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartOtherCapitalAfterServerOpen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartSelfCapitalNoticeAfterServerOpen", wireType)
			}
			m.StartSelfCapitalNoticeAfterServerOpen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartSelfCapitalNoticeAfterServerOpen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartOtherCapitalNoticeAfterServerOpen", wireType)
			}
			m.StartOtherCapitalNoticeAfterServerOpen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartOtherCapitalNoticeAfterServerOpen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MingcTimeDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MingcTimeDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MingcTimeDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyAtkStart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplyAtkStart = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyAtkDuration", wireType)
			}
			m.ApplyAtkDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyAtkDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyAstStart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplyAstStart = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyAstDuration", wireType)
			}
			m.ApplyAstDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyAstDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightStart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FightStart = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightDuration", wireType)
			}
			m.FightDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MingcWarBuildingDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MingcWarBuildingDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MingcWarBuildingDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MingcWarBuildingType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prosperity", wireType)
			}
			m.Prosperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prosperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallAtk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WallAtk = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanBeAtked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanBeAtked = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CombatScene", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CombatScene = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AtkModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MingcWarMapDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MingcWarMapDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MingcWarMapDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mingc", wireType)
			}
			m.Mingc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mingc |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartX", wireType)
			}
			m.StartX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartY", wireType)
			}
			m.StartY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DestX = append(m.DestX, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DestX = append(m.DestX, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DestX", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DestY = append(m.DestY, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DestY = append(m.DestY, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DestY", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MingcWarSceneDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MingcWarSceneDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MingcWarSceneDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkRelivePosX", wireType)
			}
			m.AtkRelivePosX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AtkRelivePosX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkRelivePosY", wireType)
			}
			m.AtkRelivePosY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AtkRelivePosY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkHomePosX", wireType)
			}
			m.AtkHomePosX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AtkHomePosX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkHomePosY", wireType)
			}
			m.AtkHomePosY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AtkHomePosY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AtkCastlePosX = append(m.AtkCastlePosX, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AtkCastlePosX = append(m.AtkCastlePosX, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkCastlePosX", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AtkCastlePosY = append(m.AtkCastlePosY, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AtkCastlePosY = append(m.AtkCastlePosY, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkCastlePosY", wireType)
			}
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AtkGatePosX = append(m.AtkGatePosX, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AtkGatePosX = append(m.AtkGatePosX, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkGatePosX", wireType)
			}
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AtkGatePosY = append(m.AtkGatePosY, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AtkGatePosY = append(m.AtkGatePosY, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkGatePosY", wireType)
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefRelivePosX", wireType)
			}
			m.DefRelivePosX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefRelivePosX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefRelivePosY", wireType)
			}
			m.DefRelivePosY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefRelivePosY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefHomePosX", wireType)
			}
			m.DefHomePosX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefHomePosX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefHomePosY", wireType)
			}
			m.DefHomePosY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefHomePosY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DefCastlePosX = append(m.DefCastlePosX, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DefCastlePosX = append(m.DefCastlePosX, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DefCastlePosX", wireType)
			}
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DefCastlePosY = append(m.DefCastlePosY, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DefCastlePosY = append(m.DefCastlePosY, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DefCastlePosY", wireType)
			}
		case 17:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DefGatePosX = append(m.DefGatePosX, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DefGatePosX = append(m.DefGatePosX, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DefGatePosX", wireType)
			}
		case 18:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DefGatePosY = append(m.DefGatePosY, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DefGatePosY = append(m.DefGatePosY, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DefGatePosY", wireType)
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkFullProsperity", wireType)
			}
			m.AtkFullProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AtkFullProsperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefFullProsperity", wireType)
			}
			m.DefFullProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefFullProsperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkReliveName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AtkReliveName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkHomeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AtkHomeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkCastleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AtkCastleName = append(m.AtkCastleName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkGateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AtkGateName = append(m.AtkGateName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefReliveName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefReliveName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefHomeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefHomeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefCastleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefCastleName = append(m.DefCastleName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefGateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefGateName = append(m.DefGateName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkTouShiName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AtkTouShiName = append(m.AtkTouShiName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 33:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AtkTouShiPosX = append(m.AtkTouShiPosX, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AtkTouShiPosX = append(m.AtkTouShiPosX, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkTouShiPosX", wireType)
			}
		case 34:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AtkTouShiPosY = append(m.AtkTouShiPosY, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AtkTouShiPosY = append(m.AtkTouShiPosY, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkTouShiPosY", wireType)
			}
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefTouShiName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefTouShiName = append(m.DefTouShiName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 36:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DefTouShiPosX = append(m.DefTouShiPosX, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DefTouShiPosX = append(m.DefTouShiPosX, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DefTouShiPosX", wireType)
			}
		case 37:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DefTouShiPosY = append(m.DefTouShiPosY, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DefTouShiPosY = append(m.DefTouShiPosY, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DefTouShiPosY", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionGenConfigProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionGenConfigProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionGenConfigProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseGoodsMianMaxDuraion", wireType)
			}
			m.UseGoodsMianMaxDuraion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseGoodsMianMaxDuraion |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvaseHeroMaxTimes", wireType)
			}
			m.InvaseHeroMaxTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvaseHeroMaxTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvaseHeroRecoveryDuration", wireType)
			}
			m.InvaseHeroRecoveryDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvaseHeroRecoveryDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JunTuanNpcMaxTimes", wireType)
			}
			m.JunTuanNpcMaxTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JunTuanNpcMaxTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JunTuanNpcRecoveryDuration", wireType)
			}
			m.JunTuanNpcRecoveryDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JunTuanNpcRecoveryDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JunTuanWinTimeLimit", wireType)
			}
			m.JunTuanWinTimeLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JunTuanWinTimeLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OuterCityBuildingDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OuterCityBuildingDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OuterCityBuildingDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockIconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockIconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockIconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnlockIconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingId", wireType)
			}
			m.BuildingId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscountColorDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscountColorDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscountColorDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discount", wireType)
			}
			m.Discount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Discount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Color = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MingcWarTroopLastBeatWhenFailDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MingcWarTroopLastBeatWhenFailDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MingcWarTroopLastBeatWhenFailDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaiZhanLevel", wireType)
			}
			m.BaiZhanLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaiZhanLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoliderAmount", wireType)
			}
			m.SoliderAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoliderAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtPercent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HurtPercent == nil {
				m.HurtPercent = &AmountProto{}
			}
			if err := m.HurtPercent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkBackHurtPercent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AtkBackHurtPercent == nil {
				m.AtkBackHurtPercent = &AmountProto{}
			}
			if err := m.AtkBackHurtPercent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MingcWarTouShiBuildingTargetDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MingcWarTouShiBuildingTargetDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MingcWarTouShiBuildingTargetDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mingc", wireType)
			}
			m.Mingc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mingc |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosX", wireType)
			}
			m.PosX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PosX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosY", wireType)
			}
			m.PosY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PosY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TargetX = append(m.TargetX, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TargetX = append(m.TargetX, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetX", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TargetY = append(m.TargetY, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TargetY = append(m.TargetY, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetY", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptainDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptainDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptainDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rarity", wireType)
			}
			m.Rarity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rarity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Race", wireType)
			}
			m.Race = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Race |= (Race(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrizeIfHas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrizeIfHas == nil {
				m.PrizeIfHas = &PrizeProto{}
			}
			if err := m.PrizeIfHas.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ObtainWays = append(m.ObtainWays, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ObtainWays = append(m.ObtainWays, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ObtainWays", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sound", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sound = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseSpell", wireType)
			}
			m.BaseSpell = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseSpell |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Star = append(m.Star, &CaptainStarDataProto{})
			if err := m.Star[len(m.Star)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spine", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spine = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FishingObtain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FishingObtain = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitRage", wireType)
			}
			m.InitRage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitRage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptainRarityDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptainRarityDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptainRarityDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coef", wireType)
			}
			m.Coef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamelessCaptainDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamelessCaptainDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamelessCaptainDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Male", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Male = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Race", wireType)
			}
			m.Race = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Race |= (Race(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseSpell", wireType)
			}
			m.BaseSpell = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseSpell |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Spell = append(m.Spell, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Spell = append(m.Spell, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Spell", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spine", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spine = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitRage", wireType)
			}
			m.InitRage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitRage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpellFacadeDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpellFacadeDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpellFacadeDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpellType", wireType)
			}
			m.SpellType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpellType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufferDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufferDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufferDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffGoodsId", wireType)
			}
			m.BuffGoodsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffGoodsId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowKeepDuration", wireType)
			}
			m.ShowKeepDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShowKeepDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowLevel", wireType)
			}
			m.ShowLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShowLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuildRankPrizeDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuildRankPrizeDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuildRankPrizeDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryDestroyPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CountryDestroyPrize == nil {
				m.CountryDestroyPrize = &PrizeProto{}
			}
			if err := m.CountryDestroyPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChargePrizeDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChargePrizeDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChargePrizeDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpCollectionDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpCollectionDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpCollectionDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeShow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeShow = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDuration", wireType)
			}
			m.StartDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDuration", wireType)
			}
			m.EndDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sp", wireType)
			}
			m.Sp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairVip", wireType)
			}
			m.RepairVip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepairVip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpPrize == nil {
				m.SpPrize = &PrizeProto{}
			}
			if err := m.SpPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RepairCost == nil {
				m.RepairCost = &CostProto{}
			}
			if err := m.RepairCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StrategyEffectDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StrategyEffectDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StrategyEffectDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrategyId", wireType)
			}
			m.StrategyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StrategyId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroLevel", wireType)
			}
			m.HeroLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &CombineCostProto{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FarmFastHarvestDuration", wireType)
			}
			m.FarmFastHarvestDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FarmFastHarvestDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectType", wireType)
			}
			m.EffectType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectType |= (StrategyEffectType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetReduceSolider", wireType)
			}
			m.TargetReduceSolider = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetReduceSolider |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailyBargainDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DailyBargainDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DailyBargainDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiveYuanbao", wireType)
			}
			m.GiveYuanbao = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiveYuanbao |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowYuanbao", wireType)
			}
			m.ShowYuanbao = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShowYuanbao |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargeAmount", wireType)
			}
			m.ChargeAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChargeAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DurationCardDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DurationCardDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DurationCardDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargeAmount", wireType)
			}
			m.ChargeAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChargeAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DailyPrize == nil {
				m.DailyPrize = &PrizeProto{}
			}
			if err := m.DailyPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeforePromptDuration", wireType)
			}
			m.BeforePromptDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeforePromptDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombatMiscConfigProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombatMiscConfigProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombatMiscConfigProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Spell = append(m.Spell, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Spell = append(m.Spell, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Spell", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SpellAnimation = append(m.SpellAnimation, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SpellAnimation = append(m.SpellAnimation, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SpellAnimation", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PassiveSpell = append(m.PassiveSpell, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PassiveSpell = append(m.PassiveSpell, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PassiveSpell", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PassiveSpellAnimation = append(m.PassiveSpellAnimation, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PassiveSpellAnimation = append(m.PassiveSpellAnimation, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PassiveSpellAnimation", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.State = append(m.State, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.State = append(m.State, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StateAnimation = append(m.StateAnimation, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StateAnimation = append(m.StateAnimation, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StateAnimation", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRage", wireType)
			}
			m.MaxRage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallAttackSpeed", wireType)
			}
			m.WallAttackSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WallAttackSpeed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FreeGiftDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FreeGiftDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FreeGiftDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftType", wireType)
			}
			m.GiftType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftType |= (GiftType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Daily", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Daily = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChargeObjDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChargeObjDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChargeObjDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargeAmount", wireType)
			}
			m.ChargeAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChargeAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yuanbao", wireType)
			}
			m.Yuanbao = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Yuanbao |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YuanbaoAddition", wireType)
			}
			m.YuanbaoAddition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YuanbaoAddition |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstChargeYuanbao", wireType)
			}
			m.FirstChargeYuanbao = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstChargeYuanbao |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipExp", wireType)
			}
			m.VipExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffEffectDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffEffectDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffEffectDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectType", wireType)
			}
			m.EffectType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectType |= (BuffEffectType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepDuration", wireType)
			}
			m.KeepDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatBuff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StatBuff == nil {
				m.StatBuff = &SpriteStatProto{}
			}
			if err := m.StatBuff.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainTrain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CaptainTrain == nil {
				m.CaptainTrain = &AmountProto{}
			}
			if err := m.CaptainTrain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FarmHarvest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FarmHarvest == nil {
				m.FarmHarvest = &AmountProto{}
			}
			if err := m.FarmHarvest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tax", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tax == nil {
				m.Tax = &AmountProto{}
			}
			if err := m.Tax.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoDuration", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoDuration = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PvpBuff", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PvpBuff = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvantageId", wireType)
			}
			m.AdvantageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdvantageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssemblyDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssemblyDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssemblyDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberCount", wireType)
			}
			m.MemberCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WaitDuration = append(m.WaitDuration, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WaitDuration = append(m.WaitDuration, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitDuration", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JunTuanNpcDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JunTuanNpcDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JunTuanNpcDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Npc", wireType)
			}
			m.Npc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Npc |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TroopCount", wireType)
			}
			m.TroopCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TroopCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredHeroLevel", wireType)
			}
			m.RequiredHeroLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredHeroLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProsperityDamageBuffDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProsperityDamageBuffDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProsperityDamageBuffDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffId", wireType)
			}
			m.BuffId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPercent", wireType)
			}
			m.MinPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinPercent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPercent", wireType)
			}
			m.MaxPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPercent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufferTypeDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufferTypeDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufferTypeDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMian", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMian = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffGroup", wireType)
			}
			m.BuffGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffGroup |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VipContinueDaysDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VipContinueDaysDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VipContinueDaysDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Days = append(m.Days, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Days = append(m.Days, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Days", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Exp = append(m.Exp, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Exp = append(m.Exp, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VipLevelDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VipLevelDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VipLevelDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeExp", wireType)
			}
			m.UpgradeExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradeExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyExp", wireType)
			}
			m.DailyExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailyExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DailyPrize == nil {
				m.DailyPrize = &PrizeProto{}
			}
			if err := m.DailyPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LevelPrize == nil {
				m.LevelPrize = &PrizeProto{}
			}
			if err := m.LevelPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelPrizeCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LevelPrizeCost == nil {
				m.LevelPrizeCost = &CostProto{}
			}
			if err := m.LevelPrizeCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JiuGuanAutoMax", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.JiuGuanAutoMax = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JiuGuanCostRefreshCount", wireType)
			}
			m.JiuGuanCostRefreshCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JiuGuanCostRefreshCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JiuGuanCostRefreshInfinite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.JiuGuanCostRefreshInfinite = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowDailyPrizeCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowDailyPrizeCost == nil {
				m.ShowDailyPrizeCost = &CostProto{}
			}
			if err := m.ShowDailyPrizeCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowLevelPrizeCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowLevelPrizeCost == nil {
				m.ShowLevelPrizeCost = &CostProto{}
			}
			if err := m.ShowLevelPrizeCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyProsperity", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BuyProsperity = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainTrainCoef", wireType)
			}
			m.CaptainTrainCoef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainTrainCoef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainTrainCapacity", wireType)
			}
			m.CaptainTrainCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainTrainCapacity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JiuGuanQuickConsult", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.JiuGuanQuickConsult = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallAutoFullSoldier", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WallAutoFullSoldier = bool(v != 0)
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuySpMaxTimes", wireType)
			}
			m.BuySpMaxTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuySpMaxTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerUnlockPos", wireType)
			}
			m.WorkerUnlockPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkerUnlockPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvadeMultiLevelMonsterOnceCount", wireType)
			}
			m.InvadeMultiLevelMonsterOnceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvadeMultiLevelMonsterOnceCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DungeonMaxCostTimesLimit", wireType)
			}
			m.DungeonMaxCostTimesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DungeonMaxCostTimesLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildPrizeOneKeyCollect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GuildPrizeOneKeyCollect = bool(v != 0)
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddBlackMarketRefreshTimes", wireType)
			}
			m.AddBlackMarketRefreshTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddBlackMarketRefreshTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FishingCaptainProbability", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FishingCaptainProbability = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowRegionHome", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShowRegionHome = bool(v != 0)
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowRegionSign", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShowRegionSign = bool(v != 0)
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowRegionTitle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShowRegionTitle = bool(v != 0)
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowHeadFrame", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShowHeadFrame = bool(v != 0)
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZhengWuAutoCompleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ZhengWuAutoCompleted = bool(v != 0)
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopAutoCompleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WorkshopAutoCompleted = bool(v != 0)
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectDailySp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CollectDailySp = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VipMiscDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VipMiscDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VipMiscDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectVipDailyExpMinHeroLevel", wireType)
			}
			m.CollectVipDailyExpMinHeroLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectVipDailyExpMinHeroLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DungeonTimesCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DungeonTimesCost = append(m.DungeonTimesCost, &CostProto{})
			if err := m.DungeonTimesCost[len(m.DungeonTimesCost)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DungeonTimesEachBuy = append(m.DungeonTimesEachBuy, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DungeonTimesEachBuy = append(m.DungeonTimesEachBuy, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DungeonTimesEachBuy", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrivacySettingDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrivacySettingDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrivacySettingDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettingType", wireType)
			}
			m.SettingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettingType |= (PrivacySettingType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeLimitGiftDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeLimitGiftDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeLimitGiftDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YuanbaoPrice", wireType)
			}
			m.YuanbaoPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YuanbaoPrice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldPrice", wireType)
			}
			m.OldPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldPrice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiscountIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dianquan", wireType)
			}
			m.Dianquan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dianquan |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Discount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyLimit", wireType)
			}
			m.BuyLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowPrize == nil {
				m.ShowPrize = &PrizeProto{}
			}
			if err := m.ShowPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildEventPrizeId", wireType)
			}
			m.GuildEventPrizeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildEventPrizeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventLimitGiftDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventLimitGiftDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventLimitGiftDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YuanbaoPrice", wireType)
			}
			m.YuanbaoPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YuanbaoPrice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldPrice", wireType)
			}
			m.OldPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldPrice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiscountIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Discount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dianquan", wireType)
			}
			m.Dianquan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dianquan |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyLimit", wireType)
			}
			m.BuyLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowPrize == nil {
				m.ShowPrize = &PrizeProto{}
			}
			if err := m.ShowPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildEventPrizeId", wireType)
			}
			m.GuildEventPrizeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildEventPrizeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McBuildAddSupportDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McBuildAddSupportDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McBuildAddSupportDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaiZhanLevel", wireType)
			}
			m.BaiZhanLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaiZhanLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddSupport", wireType)
			}
			m.AddSupport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddSupport |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McBuildGuildMemberPrizeDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McBuildGuildMemberPrizeDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McBuildGuildMemberPrizeDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinBuildCount", wireType)
			}
			m.MinBuildCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinBuildCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBuildCount", wireType)
			}
			m.MaxBuildCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBuildCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McBuildMcSupportDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McBuildMcSupportDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McBuildMcSupportDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddDailyYinliang", wireType)
			}
			m.AddDailyYinliang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddDailyYinliang |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddMaxYinliang", wireType)
			}
			m.AddMaxYinliang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddMaxYinliang |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddHostDailyYinliang", wireType)
			}
			m.AddHostDailyYinliang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddHostDailyYinliang |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeSupport", wireType)
			}
			m.UpgradeSupport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradeSupport |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McBuildMiscDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McBuildMiscDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McBuildMiscDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDailyAddSupport", wireType)
			}
			m.MaxDailyAddSupport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDailyAddSupport |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyReduceSupport", wireType)
			}
			m.DailyReduceSupport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailyReduceSupport |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyBuildMaxCount", wireType)
			}
			m.DailyBuildMaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailyBuildMaxCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildMinHeroLevel", wireType)
			}
			m.BuildMinHeroLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildMinHeroLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildCd", wireType)
			}
			m.BuildCd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildCd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRecommendMcGuildCount", wireType)
			}
			m.MaxRecommendMcGuildCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRecommendMcGuildCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMcBuildLogCount", wireType)
			}
			m.MaxMcBuildLogCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMcBuildLogCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptainFriendshipDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptainFriendshipDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptainFriendshipDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tips", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tips = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Captains = append(m.Captains, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Captains = append(m.Captains, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Captains", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EffectDesc = append(m.EffectDesc, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EffectAmount = append(m.EffectAmount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EffectAmount = append(m.EffectAmount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectAmount", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedPacketDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedPacketDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedPacketDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Icon == nil {
				m.Icon = &IconProto{}
			}
			if err := m.Icon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &CostProto{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountType", wireType)
			}
			m.AmountType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AmountType |= (AmountType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllGarbbedPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllGarbbedPrize == nil {
				m.AllGarbbedPrize = &PrizeProto{}
			}
			if err := m.AllGarbbedPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredDuration", wireType)
			}
			m.ExpiredDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiredDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCount", wireType)
			}
			m.MinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCount", wireType)
			}
			m.MaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTextLen", wireType)
			}
			m.MaxTextLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTextLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TroopDialogueDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TroopDialogueDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TroopDialogueDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseTargetType", wireType)
			}
			m.BaseTargetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseTargetType |= (BaseTargetType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseTargetSubType", wireType)
			}
			m.BaseTargetSubType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseTargetSubType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstDelay", wireType)
			}
			m.FirstDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstDelay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextDelay", wireType)
			}
			m.NextDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextDelay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomText", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RandomText = bool(v != 0)
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Texts = append(m.Texts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Texts = append(m.Texts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Texts", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TroopDialogueTextDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TroopDialogueTextDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TroopDialogueTextDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountryOfficialDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountryOfficialDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountryOfficialDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfficialType", wireType)
			}
			m.OfficialType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OfficialType |= (CountryOfficialType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingEffect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BuildingEffect == nil {
				m.BuildingEffect = &DomesticEffectProto{}
			}
			if err := m.BuildingEffect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Buff == nil {
				m.Buff = &BuffEffectDataProto{}
			}
			if err := m.Buff.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowSalary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowSalary == nil {
				m.ShowSalary = &PrizeProto{}
			}
			if err := m.ShowSalary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cd", wireType)
			}
			m.Cd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType == 0 {
				var v CountryOfficialType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (CountryOfficialType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SubOfficials = append(m.SubOfficials, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfigGen
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v CountryOfficialType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfigGen
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (CountryOfficialType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SubOfficials = append(m.SubOfficials, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SubOfficials", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			m.Body = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Body |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EffectDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountryOfficialNpcDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountryOfficialNpcDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountryOfficialNpcDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			m.Body = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Body |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionAreaDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionAreaDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionAreaDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfigGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Area == nil {
				m.Area = &AreaDataProto{}
			}
			if err := m.Area.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopPrizeCoef", wireType)
			}
			m.WorkshopPrizeCoef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopPrizeCoef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FishingCaptainProbabilityDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FishingCaptainProbabilityDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FishingCaptainProbabilityDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainId", wireType)
			}
			m.CaptainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiple", wireType)
			}
			m.Multiple = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Multiple |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfigGen(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfigGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipConfigGen(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowConfigGen
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConfigGen
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthConfigGen
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowConfigGen
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipConfigGen(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthConfigGen = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowConfigGen   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/shared_proto/config_gen.proto", fileDescriptorConfigGen)
}

var fileDescriptorConfigGen = []byte{
	// 11569 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0xbd, 0x4b, 0x8c, 0x24, 0x47,
	0x92, 0x18, 0xba, 0xf5, 0xcf, 0xb4, 0xaa, 0xac, 0x4f, 0xd4, 0x2f, 0xab, 0xaa, 0x3f, 0xd5, 0xd9,
	0xdd, 0x64, 0x73, 0xc8, 0xe9, 0x1e, 0x36, 0xc9, 0xe1, 0x0c, 0x87, 0xc3, 0x99, 0xfa, 0xb0, 0x3f,
	0x9c, 0xae, 0x66, 0x6f, 0x56, 0xef, 0x90, 0x3d, 0xfb, 0x9e, 0x02, 0x9e, 0x11, 0x9e, 0x99, 0xc1,
	0xca, 0x8c, 0xc8, 0x89, 0x88, 0xac, 0x0f, 0x05, 0x2c, 0x04, 0x49, 0x67, 0x5d, 0xb4, 0xfa, 0x40,
	0x8b, 0xdd, 0xd3, 0x5e, 0x04, 0xad, 0x80, 0x3d, 0x68, 0x57, 0x07, 0xe9, 0x22, 0x40, 0x10, 0x04,
	0x48, 0x0b, 0x48, 0x3a, 0x49, 0x80, 0x20, 0x2d, 0x56, 0x58, 0x01, 0x3a, 0xac, 0x20, 0x40, 0xd0,
	0xe7, 0x28, 0x98, 0x99, 0xbb, 0x87, 0x47, 0x64, 0x64, 0x75, 0x91, 0xbb, 0xa7, 0xaa, 0x34, 0x33,
	0xb7, 0xf0, 0x70, 0x37, 0x37, 0x37, 0x33, 0x37, 0xb7, 0x80, 0x8f, 0x3a, 0x41, 0xda, 0x1d, 0xb6,
	0xee, 0x7b, 0x51, 0xff, 0x41, 0x2f, 0xe8, 0x74, 0xd3, 0x81, 0x38, 0x7b, 0xd0, 0x17, 0x3d, 0xf9,
	0xe1, 0x83, 0x41, 0xeb, 0x41, 0xd2, 0x15, 0xb1, 0xf4, 0xdd, 0x41, 0x1c, 0xa5, 0xd1, 0x03, 0x2f,
	0x0a, 0xdb, 0x41, 0xc7, 0xed, 0xc8, 0xf0, 0x3e, 0x01, 0x9c, 0x19, 0xfa, 0xb3, 0xfd, 0xfe, 0xd5,
	0x59, 0xb4, 0x44, 0x22, 0xef, 0x7f, 0xf3, 0x56, 0xc3, 0x76, 0x5b, 0xb5, 0xfa, 0xf0, 0x9b, 0x74,
	0x77, 0x18, 0xa6, 0xf1, 0x85, 0x6a, 0xf8, 0x83, 0xab, 0x37, 0xf4, 0xa3, 0xbe, 0x4c, 0xd2, 0xc0,
	0x53, 0x2d, 0x3f, 0xb8, 0x7a, 0xcb, 0x4e, 0x14, 0xf9, 0xc9, 0x37, 0x6f, 0xd6, 0x0f, 0xc2, 0x8e,
	0x7e, 0xda, 0x0f, 0xbf, 0x61, 0x33, 0xf7, 0x4c, 0xc4, 0xdf, 0xbc, 0xe9, 0x20, 0x8e, 0xfa, 0x51,
	0x1a, 0x44, 0x6a, 0x26, 0xb7, 0xbf, 0x7f, 0xf5, 0xa6, 0xb1, 0xec, 0x64, 0xed, 0xbe, 0xc1, 0x74,
	0x24, 0x32, 0x4d, 0x83, 0xb0, 0xf3, 0xcd, 0x47, 0x27, 0x19, 0xc8, 0x5e, 0xef, 0x9b, 0x0b, 0x4d,
	0x2a, 0x92, 0x13, 0x6e, 0xd5, 0xf8, 0xdd, 0xb7, 0xa0, 0x7a, 0x40, 0xc2, 0xfb, 0x58, 0x86, 0xce,
	0x1e, 0x2c, 0xf1, 0xc8, 0xa1, 0x30, 0xba, 0xbe, 0x48, 0x45, 0x7d, 0x62, 0x77, 0xea, 0xde, 0xfc,
	0xc3, 0x2d, 0x26, 0xbf, 0x7f, 0x84, 0xd8, 0x7d, 0x91, 0xc8, 0x43, 0x91, 0x8a, 0x17, 0x08, 0x6a,
	0xd6, 0xfa, 0x36, 0xcc, 0xf9, 0x0c, 0x9c, 0xf3, 0xa1, 0x08, 0x2f, 0x86, 0x22, 0x74, 0xfb, 0x41,
	0xe2, 0x31, 0x97, 0xc9, 0xdd, 0x89, 0x7b, 0xf3, 0x0f, 0xaf, 0x29, 0x2e, 0x5f, 0x2a, 0x82, 0xa3,
	0x20, 0xf1, 0x32, 0x46, 0xcb, 0xe7, 0x05, 0xb0, 0x73, 0x04, 0xab, 0x86, 0x57, 0x2c, 0xc2, 0x8e,
	0xea, 0xd2, 0x14, 0x75, 0xe9, 0x7a, 0x81, 0x59, 0x13, 0x09, 0x32, 0x6e, 0x2b, 0xe7, 0x45, 0xb8,
	0xf3, 0x0b, 0xa8, 0xdb, 0xec, 0x4e, 0xdc, 0x41, 0x1c, 0x7c, 0xad, 0x78, 0x4e, 0x13, 0xcf, 0x5b,
	0xa3, 0x3c, 0x4f, 0x5e, 0x20, 0x51, 0xc6, 0x77, 0xfd, 0xbc, 0x0c, 0xc7, 0x23, 0x97, 0x78, 0xa8,
	0x01, 0x5c, 0x56, 0x06, 0xf5, 0x19, 0x7a, 0xe7, 0x6c, 0xe4, 0x12, 0xef, 0xb1, 0x0c, 0x79, 0xac,
	0xcd, 0xc8, 0x59, 0x30, 0xe7, 0x7d, 0x80, 0x96, 0x88, 0xce, 0x86, 0xdc, 0xa1, 0x59, 0xea, 0xd0,
	0xba, 0x6a, 0xbd, 0x8f, 0x88, 0xac, 0x13, 0xd5, 0x96, 0xfe, 0xed, 0xfc, 0x08, 0x6a, 0x2d, 0x11,
	0x7d, 0xed, 0x86, 0x03, 0x35, 0xd4, 0x73, 0xd4, 0x70, 0x33, 0x6b, 0xf8, 0xf5, 0xf3, 0x81, 0x35,
	0xca, 0xf3, 0xad, 0x0c, 0xe2, 0xbc, 0x0b, 0xd5, 0xc1, 0x30, 0xe9, 0x72, 0xc3, 0x0a, 0x35, 0x5c,
	0x53, 0x0d, 0x5f, 0x0c, 0x93, 0x6e, 0xd6, 0xaa, 0x32, 0x50, 0x3f, 0xb1, 0x97, 0x69, 0x90, 0xf6,
	0xd4, 0xb0, 0x55, 0x73, 0xbd, 0x7c, 0x89, 0x08, 0xab, 0x97, 0xa9, 0xfe, 0x8d, 0xc3, 0xc3, 0xad,
	0x50, 0xf4, 0xb8, 0x29, 0xe4, 0x04, 0x8b, 0x9a, 0xbe, 0x14, 0xc9, 0x89, 0x25, 0x58, 0xa9, 0x0d,
	0x73, 0xbe, 0x80, 0xcd, 0x44, 0x7a, 0xb1, 0x4c, 0xdd, 0x34, 0x3a, 0x93, 0xb1, 0x7b, 0x16, 0xc5,
	0x7e, 0xc2, 0xac, 0xe6, 0x89, 0xd5, 0xae, 0x62, 0x75, 0x4c, 0x54, 0x2f, 0x91, 0xe8, 0x0b, 0xa4,
	0xc9, 0x38, 0xae, 0x25, 0x25, 0x28, 0xe7, 0x10, 0x96, 0x3b, 0xc3, 0xa0, 0xe7, 0xdb, 0x73, 0xb7,
	0x40, 0x73, 0xb7, 0xad, 0x38, 0x3e, 0x46, 0x74, 0x61, 0xf2, 0x16, 0x3b, 0x39, 0xa0, 0xf3, 0x63,
	0xa8, 0xf5, 0x22, 0x4f, 0xa0, 0xe2, 0xe0, 0x4e, 0xd5, 0xa8, 0x53, 0x75, 0xc5, 0xe2, 0x99, 0xc2,
	0x65, 0x9d, 0x59, 0xe8, 0x59, 0x20, 0xe7, 0x23, 0x58, 0x50, 0x4a, 0x99, 0x5b, 0x2f, 0xe6, 0x66,
	0xf1, 0x80, 0x51, 0xd6, 0x2c, 0x7a, 0x19, 0xc4, 0x79, 0x0c, 0x2b, 0xba, 0x6d, 0xb6, 0xe2, 0x96,
	0xe8, 0x0d, 0x76, 0xf2, 0x0c, 0xf2, 0x0b, 0x6e, 0xc9, 0xcb, 0x43, 0x71, 0x24, 0xda, 0xa2, 0x1f,
	0xf4, 0x2e, 0xdc, 0x50, 0xf4, 0xd5, 0x0c, 0x2f, 0x53, 0x47, 0xf4, 0x48, 0x3c, 0x22, 0xf4, 0x73,
	0xd1, 0xb7, 0xa6, 0x79, 0xb1, 0x9d, 0x03, 0x3a, 0x9f, 0xc0, 0x62, 0x2f, 0xea, 0x04, 0x38, 0x0c,
	0xea, 0x65, 0x56, 0x0a, 0x43, 0xd1, 0x09, 0xc2, 0x43, 0x71, 0x91, 0x1b, 0x8a, 0x0c, 0xe4, 0x3c,
	0x87, 0xb5, 0xae, 0x8c, 0x23, 0xb7, 0x27, 0x4f, 0x65, 0xcf, 0x6d, 0x0f, 0x43, 0x9f, 0xb9, 0x38,
	0xb9, 0x65, 0xff, 0x44, 0xc6, 0xd1, 0x33, 0xa4, 0x78, 0x34, 0x0c, 0x7d, 0x6b, 0xd9, 0x77, 0x8b,
	0x70, 0xd4, 0x22, 0x46, 0xa7, 0x5b, 0x03, 0xb4, 0x4a, 0x03, 0xa4, 0xd9, 0xbd, 0xd0, 0x14, 0xf9,
	0x21, 0x5a, 0x19, 0x14, 0xe1, 0x28, 0x87, 0xad, 0x9e, 0xf0, 0x4e, 0xdc, 0xbe, 0x88, 0x4f, 0x64,
	0xea, 0xd2, 0xc6, 0xc6, 0x2c, 0xd7, 0x72, 0x72, 0xb8, 0x8f, 0x54, 0x47, 0x44, 0xf4, 0x18, 0x69,
	0x2c, 0x39, 0x6c, 0x95, 0xa0, 0x70, 0xdc, 0x92, 0x6e, 0x34, 0xb0, 0xba, 0xb8, 0x4e, 0x5d, 0xd4,
	0xe3, 0x76, 0xdc, 0x8d, 0x06, 0xf9, 0xde, 0x2d, 0x24, 0x16, 0x28, 0x53, 0xde, 0x19, 0x83, 0x8d,
	0x82, 0x0a, 0x0a, 0x3b, 0x5e, 0x9e, 0x03, 0x2b, 0xef, 0x51, 0x16, 0x69, 0xa0, 0xe7, 0x7f, 0x73,
	0x54, 0xff, 0xbf, 0x0c, 0xfa, 0x23, 0xfa, 0x5f, 0xc3, 0x70, 0x78, 0xcc, 0xe6, 0xeb, 0xb6, 0x70,
	0x8d, 0x04, 0x61, 0x87, 0x59, 0xd5, 0x73, 0xc3, 0x43, 0xac, 0xbe, 0x10, 0xf1, 0xbe, 0xa2, 0xb1,
	0x86, 0xa7, 0x5f, 0x82, 0x72, 0x9e, 0x80, 0x93, 0x31, 0xee, 0x8b, 0x01, 0xf3, 0xdc, 0x22, 0x9e,
	0x3b, 0x05, 0x9e, 0x47, 0x62, 0x60, 0x89, 0x79, 0x3f, 0x0f, 0x45, 0x01, 0xcb, 0x38, 0x25, 0x9e,
	0x0c, 0xd5, 0xab, 0x6e, 0xe7, 0x04, 0x4c, 0xf3, 0x3a, 0x46, 0x02, 0x4b, 0x22, 0xfa, 0x45, 0x38,
	0xae, 0x3f, 0xde, 0xf9, 0x6d, 0x0d, 0xb2, 0x93, 0x5b, 0x7f, 0x4d, 0xc2, 0x17, 0x54, 0xc8, 0x52,
	0x9c, 0x87, 0xe2, 0x06, 0x15, 0x0d, 0x53, 0x19, 0xbb, 0x5e, 0x90, 0x5e, 0x14, 0x06, 0xef, 0x5a,
	0x6e, 0x83, 0xfa, 0x1c, 0xc9, 0x0e, 0x82, 0xf4, 0x62, 0x74, 0xf4, 0xd6, 0xa3, 0x32, 0x1c, 0xae,
	0x02, 0x3f, 0x48, 0x68, 0xc5, 0xbb, 0x5e, 0xd4, 0x8b, 0x62, 0x66, 0x7b, 0x23, 0xf7, 0xce, 0x87,
	0x8a, 0xe2, 0x00, 0x09, 0xac, 0x77, 0xf6, 0x8b, 0x70, 0xe7, 0xaf, 0x4e, 0xc0, 0xbd, 0x6c, 0x10,
	0xd3, 0x38, 0x8a, 0x06, 0x6e, 0x4f, 0x24, 0xa9, 0xdb, 0x92, 0x22, 0x75, 0xcf, 0xba, 0x32, 0x74,
	0xdb, 0x22, 0xe8, 0xf1, 0x43, 0x76, 0xe9, 0x21, 0xdf, 0x2d, 0x0c, 0xec, 0x4b, 0x6c, 0xf4, 0x4c,
	0x24, 0xe9, 0xbe, 0x14, 0xe9, 0x17, 0x5d, 0x19, 0x3e, 0x12, 0x41, 0x2f, 0x7b, 0xe8, 0xad, 0xfe,
	0xeb, 0xe8, 0x9c, 0xdf, 0x80, 0x37, 0xac, 0x3e, 0x44, 0x43, 0x37, 0xe9, 0x06, 0xd9, 0xb0, 0xa5,
	0x22, 0xee, 0xc8, 0x94, 0x7b, 0x70, 0x8b, 0x7a, 0xf0, 0x4e, 0xb1, 0x07, 0xd1, 0xf0, 0xb8, 0x1b,
	0xe8, 0x61, 0x7a, 0x49, 0xf4, 0x59, 0x07, 0x76, 0xfb, 0xaf, 0x21, 0x23, 0xa5, 0x2d, 0x06, 0xa9,
	0x08, 0x94, 0xca, 0x6f, 0xe4, 0x95, 0x36, 0xa3, 0x6c, 0xa5, 0x9d, 0x41, 0x70, 0x3e, 0x74, 0xdb,
	0x58, 0xc4, 0x38, 0xdf, 0xc4, 0xe2, 0x76, 0x6e, 0x3e, 0x14, 0x8b, 0x26, 0x11, 0x58, 0xf3, 0xe1,
	0x15, 0xe1, 0xce, 0x31, 0xac, 0xa3, 0xce, 0xee, 0xc9, 0x24, 0x71, 0x73, 0x7d, 0xba, 0x43, 0x0c,
	0x6f, 0x2a, 0x86, 0xcf, 0x15, 0xcd, 0x48, 0xdf, 0x56, 0xc3, 0x51, 0x0c, 0x0a, 0x36, 0x59, 0x98,
	0x6e, 0x5b, 0x78, 0xc2, 0x57, 0xab, 0xe4, 0x8d, 0xdc, 0x8a, 0x3b, 0x46, 0xfc, 0x23, 0x42, 0x5b,
	0x2b, 0x2e, 0xc9, 0x43, 0x9d, 0x0f, 0x61, 0x1e, 0x1d, 0x15, 0xa9, 0x84, 0xee, 0x4d, 0x62, 0xb1,
	0xa1, 0xf5, 0x24, 0x61, 0xb2, 0xd6, 0xd0, 0x32, 0x00, 0xe7, 0x57, 0x61, 0x9d, 0xf7, 0xe6, 0xa2,
	0xbd, 0x76, 0x8f, 0x58, 0xdc, 0xb0, 0x37, 0xe8, 0x12, 0x63, 0xcd, 0xe9, 0x8c, 0x20, 0x68, 0xb7,
	0xec, 0xe2, 0x1c, 0xda, 0xec, 0xde, 0xca, 0xbd, 0xd4, 0x01, 0xe1, 0x0b, 0xbc, 0x96, 0xbc, 0x3c,
	0x14, 0x2d, 0xdd, 0x64, 0x80, 0x6b, 0xa9, 0x27, 0xbd, 0x6c, 0xdb, 0xff, 0x0e, 0x71, 0xba, 0x66,
	0x86, 0xe7, 0xc0, 0xe0, 0x2d, 0x4b, 0x37, 0x29, 0x80, 0x9d, 0x17, 0xb0, 0x96, 0xa4, 0xb1, 0x48,
	0x65, 0xe7, 0xc2, 0x95, 0xed, 0xb6, 0xf4, 0x94, 0xdc, 0xbe, 0x9d, 0x7b, 0xcd, 0x63, 0x45, 0xf2,
	0x29, 0x51, 0x58, 0xaf, 0x99, 0x8c, 0x20, 0xb0, 0x77, 0xbe, 0xc0, 0xad, 0xbc, 0x25, 0xe2, 0x8e,
	0x91, 0x86, 0x77, 0x72, 0xbd, 0x3b, 0x44, 0x82, 0x7d, 0xc6, 0x5b, 0xbd, 0xf3, 0x0b, 0x60, 0xe2,
	0x35, 0x8c, 0xd9, 0xb6, 0xf1, 0x44, 0xac, 0xf6, 0xe3, 0xef, 0xe6, 0x79, 0x29, 0x82, 0x03, 0x11,
	0xfb, 0x36, 0xaf, 0x02, 0x18, 0x79, 0x79, 0x51, 0xbf, 0x25, 0x52, 0xde, 0xa6, 0x94, 0xb6, 0xbc,
	0x9f, 0xf3, 0x0f, 0x0e, 0x88, 0x00, 0x77, 0x25, 0x5b, 0x5d, 0x2e, 0x7b, 0x05, 0x30, 0xee, 0x98,
	0xed, 0x58, 0x4a, 0xb7, 0x13, 0xb4, 0xd5, 0x78, 0x3d, 0xc8, 0x59, 0x1a, 0x8f, 0x62, 0x29, 0x1f,
	0x07, 0x6d, 0x6b, 0xa4, 0x16, 0xda, 0x16, 0x08, 0xb7, 0x3b, 0x25, 0x0a, 0x51, 0xeb, 0x2b, 0x66,
	0xf0, 0xbd, 0xdc, 0x76, 0xc7, 0x82, 0xf0, 0x79, 0xeb, 0x2b, 0x6b, 0xbb, 0xf3, 0x6c, 0x18, 0x9a,
	0x4c, 0x28, 0xae, 0xb9, 0x49, 0x7b, 0x37, 0x67, 0x32, 0xa1, 0x78, 0x17, 0x27, 0x6c, 0xb1, 0x95,
	0x03, 0xa2, 0xf1, 0x28, 0x92, 0x44, 0xf6, 0x5b, 0x3d, 0xa5, 0x06, 0x1e, 0xe6, 0xde, 0x63, 0x4f,
	0xe1, 0xac, 0xf7, 0x10, 0x16, 0xc8, 0xf9, 0x14, 0x56, 0xbe, 0x1a, 0x86, 0x6e, 0x8a, 0x8e, 0x8d,
	0xf1, 0x03, 0xde, 0xcb, 0xf5, 0xe2, 0xb3, 0x61, 0xf8, 0x72, 0x28, 0xc2, 0x9c, 0x2b, 0xb0, 0xf8,
	0x55, 0x0e, 0xe8, 0x78, 0xb0, 0x33, 0x88, 0xa3, 0x64, 0x20, 0x95, 0x3a, 0xea, 0x8b, 0x8e, 0x74,
	0xe9, 0xed, 0x88, 0xe1, 0xfb, 0xc4, 0xf0, 0x4e, 0x66, 0x30, 0x29, 0xca, 0x43, 0x22, 0xc4, 0xd7,
	0xcc, 0x58, 0xd7, 0x07, 0x63, 0xd0, 0x7a, 0xc0, 0x64, 0xec, 0xa6, 0x17, 0x03, 0xb5, 0xfa, 0x3e,
	0x18, 0x19, 0x30, 0x19, 0xbf, 0xbc, 0x18, 0xc8, 0xc2, 0x80, 0x65, 0x40, 0xe7, 0x25, 0x6c, 0x9c,
	0x06, 0xb8, 0xf8, 0xc2, 0x34, 0x08, 0x87, 0xc8, 0xe6, 0x42, 0xd9, 0x60, 0xdf, 0xcf, 0xe9, 0xbb,
	0x9f, 0x07, 0x83, 0x03, 0x45, 0x73, 0x28, 0x2e, 0x2c, 0x13, 0x6c, 0xf5, 0x74, 0x14, 0x83, 0xf2,
	0x84, 0x5c, 0xd9, 0xf0, 0x24, 0x6e, 0x1f, 0xe6, 0xe6, 0xe1, 0xe7, 0xc1, 0x80, 0x4c, 0x4b, 0x6b,
	0x1e, 0x4e, 0x2d, 0x10, 0xfa, 0x62, 0xd8, 0x3e, 0xb3, 0xbf, 0x7e, 0x40, 0x62, 0xbd, 0x99, 0x35,
	0xcf, 0x5b, 0x5f, 0xf3, 0xa7, 0x19, 0x04, 0x55, 0xc0, 0x20, 0x0e, 0x4e, 0x85, 0x77, 0xe1, 0xaa,
	0x78, 0x00, 0xf3, 0xf8, 0x61, 0x4e, 0x05, 0xbc, 0x60, 0x92, 0x63, 0xa6, 0xb0, 0x54, 0xc0, 0x60,
	0x04, 0x81, 0x76, 0x0e, 0xd9, 0x71, 0xbd, 0xa0, 0x1f, 0xa4, 0xd6, 0x22, 0xf9, 0x51, 0x6e, 0x8f,
	0x41, 0xcb, 0xed, 0x19, 0x52, 0xe4, 0x57, 0xca, 0x4a, 0x5a, 0x84, 0xa3, 0x32, 0x96, 0xa7, 0x32,
	0x4c, 0x47, 0x18, 0x7e, 0x9c, 0xeb, 0xe2, 0xa7, 0x48, 0x53, 0xc2, 0xd1, 0x91, 0x23, 0x08, 0xe7,
	0xd7, 0x61, 0xab, 0xef, 0xf1, 0x96, 0xed, 0x0a, 0xdf, 0x77, 0x93, 0xe1, 0x60, 0x10, 0xc5, 0x8a,
	0xed, 0x8f, 0x73, 0x26, 0xcf, 0x91, 0x47, 0x3b, 0xf0, 0x9e, 0xef, 0x1f, 0x33, 0x91, 0x65, 0xf2,
	0xf4, 0xcb, 0x70, 0x4e, 0x08, 0xbb, 0x86, 0x39, 0xef, 0x22, 0x7d, 0xd9, 0x6f, 0xc9, 0xd8, 0x56,
	0xfc, 0x9f, 0xd0, 0x33, 0xde, 0xcc, 0x3f, 0x83, 0xb6, 0x93, 0x23, 0xa2, 0x2d, 0x6c, 0x02, 0x3b,
	0xfd, 0xf1, 0x14, 0xce, 0x97, 0x50, 0x37, 0xcf, 0xeb, 0x7b, 0xf9, 0x77, 0xf9, 0x69, 0xde, 0xf6,
	0x65, 0x2e, 0x47, 0xde, 0xc8, 0xab, 0xac, 0xf5, 0x4b, 0x50, 0x64, 0xfb, 0x1a, 0xce, 0x46, 0xba,
	0xf6, 0x72, 0x26, 0xa6, 0xe6, 0x99, 0x77, 0xf1, 0xfa, 0x79, 0xa8, 0xf3, 0x0a, 0x36, 0xb5, 0x79,
	0xd0, 0x8e, 0x03, 0x19, 0xfa, 0x49, 0x37, 0x50, 0xa6, 0xf4, 0x7e, 0x6e, 0xb8, 0x95, 0x1d, 0xf0,
	0xc8, 0x10, 0x59, 0xc3, 0xed, 0x95, 0xe1, 0x50, 0x9b, 0x52, 0x88, 0x49, 0x78, 0x27, 0xda, 0xec,
	0x3a, 0xc8, 0x69, 0xd3, 0xa6, 0xf4, 0x5f, 0x10, 0xd2, 0xd2, 0xa6, 0xb1, 0x0d, 0x43, 0xa3, 0x88,
	0x4d, 0x49, 0x3f, 0x10, 0xbd, 0xa8, 0x33, 0x54, 0x93, 0x74, 0x98, 0x17, 0x58, 0xa4, 0x38, 0x54,
	0x04, 0xb6, 0xc0, 0x16, 0xe1, 0x68, 0x4f, 0x17, 0xd8, 0xa5, 0xf2, 0x5c, 0x75, 0xed, 0xd3, 0xdc,
	0xdb, 0xe6, 0x78, 0xbe, 0x94, 0xe7, 0xb6, 0x70, 0xa5, 0x65, 0x38, 0x34, 0xb8, 0xb4, 0xd3, 0x1d,
	0xb5, 0xdb, 0x81, 0x17, 0x08, 0xa5, 0x32, 0x1e, 0xe5, 0x14, 0x90, 0x72, 0xbc, 0x3f, 0x57, 0x24,
	0x96, 0x02, 0xf2, 0x46, 0x31, 0xce, 0xff, 0x0f, 0x5b, 0x23, 0x4c, 0x8d, 0x42, 0x7f, 0x4c, 0x8c,
	0x1b, 0xe5, 0x8c, 0x73, 0x8a, 0x7d, 0xc3, 0x2b, 0x45, 0xa2, 0xee, 0x55, 0x8e, 0x8a, 0x88, 0xa5,
	0x60, 0xae, 0x4f, 0x73, 0xba, 0x97, 0xfd, 0x94, 0xbd, 0x58, 0x0a, 0x4b, 0xf7, 0xc6, 0x39, 0xa0,
	0x13, 0xc3, 0x6e, 0x3b, 0x48, 0xba, 0xa8, 0xa0, 0xb4, 0x28, 0x0d, 0xe2, 0xa8, 0x25, 0x5a, 0x41,
	0xcf, 0x98, 0xb1, 0x9f, 0x11, 0xd7, 0xb7, 0xf4, 0x3e, 0xcc, 0xe4, 0x4a, 0xa4, 0x5e, 0x64, 0xc4,
	0xd9, 0x43, 0xae, 0xb7, 0x2f, 0xa3, 0x69, 0xfc, 0xfe, 0x24, 0xec, 0xec, 0x79, 0x69, 0x70, 0x1a,
	0xa4, 0x17, 0x25, 0x16, 0x95, 0xe3, 0xc0, 0xb4, 0x2f, 0x13, 0xaf, 0x3e, 0xb1, 0x3b, 0x71, 0xaf,
	0xda, 0xa4, 0xff, 0x9d, 0x9f, 0x42, 0x55, 0x9e, 0x7b, 0x5d, 0x11, 0x76, 0x64, 0x52, 0x9f, 0x2c,
	0x0c, 0x9e, 0x66, 0xf1, 0xa9, 0xa2, 0xb0, 0xa2, 0x56, 0xa6, 0x91, 0xb3, 0x08, 0x93, 0x81, 0x5f,
	0x9f, 0xda, 0x9d, 0xb8, 0x37, 0xd3, 0x9c, 0x0c, 0x7c, 0x67, 0x07, 0xaa, 0x14, 0x18, 0x09, 0xbc,
	0x28, 0xac, 0x4f, 0xd3, 0xa3, 0x2a, 0x08, 0x78, 0xea, 0x45, 0xa1, 0xb3, 0x06, 0x33, 0x01, 0xee,
	0x74, 0x14, 0xf7, 0xab, 0x36, 0xf9, 0x07, 0x76, 0x2c, 0x89, 0xe2, 0xb4, 0x3e, 0x4b, 0x4c, 0xe8,
	0x7f, 0x84, 0x61, 0xab, 0xfa, 0x1c, 0x77, 0x16, 0xff, 0x47, 0x18, 0x71, 0xad, 0x30, 0x0c, 0xff,
	0x77, 0x6e, 0xc2, 0x3c, 0xfe, 0x75, 0x13, 0x89, 0x9d, 0xad, 0x57, 0x09, 0x05, 0x08, 0x3a, 0x26,
	0x08, 0xf6, 0x87, 0x14, 0x7c, 0xd2, 0x8d, 0xce, 0xea, 0xc0, 0xfd, 0x41, 0xc0, 0x71, 0x37, 0x3a,
	0x6b, 0xfc, 0x83, 0x69, 0x58, 0xd7, 0x43, 0x86, 0x80, 0x6c, 0xb0, 0xf8, 0xb5, 0x26, 0xcc, 0x6b,
	0xe9, 0xfe, 0x4c, 0x5a, 0xfd, 0xc9, 0xb1, 0x9e, 0xce, 0xb3, 0x36, 0xa3, 0x3d, 0x63, 0x8d, 0xf6,
	0x75, 0x00, 0xa5, 0x56, 0x11, 0x33, 0x4b, 0x98, 0x2a, 0x41, 0x0e, 0x11, 0xad, 0xdf, 0x6f, 0x6e,
	0xfc, 0xfb, 0x55, 0x46, 0xde, 0xef, 0x2e, 0x45, 0x44, 0xce, 0x5c, 0x12, 0x67, 0x3f, 0x3a, 0x0b,
	0x69, 0x0c, 0x2a, 0xcd, 0x1a, 0x42, 0x0f, 0x34, 0xd0, 0x8c, 0x31, 0x58, 0x63, 0x6c, 0x66, 0x63,
	0xde, 0x9e, 0x8d, 0x1d, 0xa8, 0xd2, 0x3f, 0xee, 0x20, 0x4a, 0x28, 0xc6, 0x37, 0xd3, 0xac, 0x10,
	0xe0, 0x45, 0x94, 0xe4, 0x67, 0xb7, 0x56, 0x98, 0xdd, 0x1d, 0xa8, 0xf6, 0x82, 0xf0, 0x84, 0x02,
	0x63, 0xf5, 0x45, 0x46, 0x22, 0x00, 0x1d, 0x2a, 0xe7, 0x27, 0xb0, 0x4c, 0x48, 0xe5, 0x71, 0xa2,
	0x61, 0x53, 0x5f, 0xde, 0x9d, 0xb8, 0xb7, 0x98, 0x45, 0x46, 0x45, 0x72, 0xc2, 0x8e, 0x23, 0x9a,
	0x30, 0xcd, 0x45, 0x24, 0xcf, 0x7e, 0x3b, 0x0f, 0x60, 0xcd, 0x66, 0x90, 0x0c, 0x5b, 0xcc, 0x64,
	0x85, 0xba, 0xb8, 0x92, 0x51, 0x1f, 0x0f, 0x5b, 0xd4, 0xe0, 0x7d, 0xd8, 0x2c, 0x6b, 0xe0, 0x06,
	0x7e, 0xdd, 0xa1, 0x36, 0xab, 0x23, 0x6d, 0x9e, 0xfa, 0xce, 0x16, 0x54, 0x92, 0x41, 0x10, 0x12,
	0xd9, 0x2a, 0x91, 0xcd, 0xd1, 0xef, 0xa7, 0x7e, 0xe3, 0x9f, 0x4e, 0x64, 0xd2, 0x92, 0x0b, 0xc3,
	0x5e, 0x49, 0x5a, 0x1c, 0x98, 0x46, 0xcd, 0x4a, 0x4b, 0xa5, 0xda, 0xa4, 0xff, 0x9d, 0xfb, 0x30,
	0xcb, 0xbd, 0x23, 0xf1, 0xc9, 0xdc, 0xbd, 0x6c, 0x28, 0x78, 0xbd, 0x29, 0x2a, 0xe4, 0x81, 0x7d,
	0xd6, 0x42, 0x85, 0xff, 0x3b, 0x6f, 0xc2, 0x0c, 0x89, 0x10, 0xc9, 0xd3, 0xfc, 0xc3, 0x95, 0xcc,
	0x08, 0xfa, 0x5a, 0x72, 0x6b, 0xc6, 0x37, 0x7e, 0x73, 0x12, 0xae, 0xdb, 0xdd, 0x7f, 0x16, 0x24,
	0xe9, 0x51, 0x64, 0xf9, 0xa4, 0xf9, 0xd9, 0x9d, 0x18, 0xb7, 0x76, 0x27, 0x6d, 0x69, 0x79, 0x08,
	0x33, 0xa9, 0x48, 0x4e, 0x12, 0x75, 0xe0, 0xa0, 0xbd, 0x93, 0xd2, 0x61, 0x6a, 0x32, 0xa9, 0x91,
	0xc5, 0xe9, 0x92, 0xf5, 0x3e, 0x93, 0x1f, 0x31, 0x6b, 0xa1, 0xf0, 0x12, 0xfa, 0x56, 0x6b, 0x24,
	0xb7, 0x50, 0xab, 0x05, 0x1d, 0xf0, 0xd7, 0x26, 0xa0, 0x96, 0x53, 0xe6, 0x28, 0x02, 0x9e, 0x0c,
	0x53, 0x19, 0xbb, 0xe7, 0x6a, 0x4e, 0xe7, 0xf8, 0xf7, 0x97, 0x16, 0xea, 0x82, 0xc6, 0xc1, 0xa0,
	0x5e, 0xe1, 0xe2, 0xee, 0x53, 0xa0, 0xc2, 0x0f, 0x86, 0x89, 0x52, 0x88, 0xd5, 0x7e, 0x10, 0x36,
	0x09, 0x40, 0x68, 0x71, 0xae, 0xd1, 0xd3, 0x0a, 0x2d, 0xce, 0x19, 0xdd, 0xf8, 0x83, 0x09, 0x58,
	0x53, 0x7a, 0xfd, 0x38, 0x15, 0x71, 0x4e, 0x6b, 0x27, 0xa9, 0x88, 0x55, 0x47, 0xe8, 0x7f, 0xe7,
	0x0e, 0x4c, 0x7b, 0x51, 0x92, 0xaa, 0x13, 0xa3, 0x65, 0xa3, 0xb0, 0x13, 0x25, 0x2e, 0x84, 0x75,
	0xea, 0x30, 0x43, 0x31, 0x06, 0x9a, 0x9a, 0x99, 0xfd, 0xc9, 0xe5, 0x5f, 0x69, 0x32, 0x00, 0x79,
	0x7a, 0x91, 0x6c, 0xeb, 0x09, 0xc0, 0xff, 0x9d, 0x0f, 0x00, 0x84, 0xef, 0x4b, 0xdf, 0x4d, 0x52,
	0x91, 0xaa, 0x73, 0x99, 0x0d, 0xe3, 0xa1, 0xc7, 0x41, 0x2a, 0x8f, 0x53, 0xa1, 0xf8, 0x57, 0x89,
	0x12, 0x7f, 0x37, 0xfe, 0x32, 0xec, 0x5c, 0xb2, 0x51, 0x8c, 0x2c, 0x8c, 0xef, 0xc3, 0x1c, 0x7a,
	0xa8, 0x41, 0x28, 0x0b, 0xc7, 0x5d, 0x14, 0xe2, 0x3d, 0x60, 0x54, 0x26, 0x30, 0x9a, 0x18, 0x85,
	0x8f, 0x0c, 0x6a, 0x35, 0xae, 0xfc, 0xa3, 0xf1, 0x9f, 0xe6, 0x61, 0x85, 0xfd, 0x60, 0xcb, 0x07,
	0x76, 0xde, 0xd6, 0xef, 0x3d, 0x91, 0x3b, 0x78, 0xa1, 0x28, 0x8c, 0x25, 0x8b, 0x3c, 0x14, 0x48,
	0x9c, 0x8a, 0x54, 0xaa, 0xcd, 0xcf, 0x10, 0x23, 0xcc, 0x26, 0xc6, 0xdf, 0xce, 0x1e, 0xd4, 0x06,
	0x22, 0x49, 0x82, 0x53, 0xe9, 0x66, 0x23, 0x9b, 0xbd, 0xc3, 0x0b, 0xc6, 0x15, 0x1e, 0xb4, 0x30,
	0xb0, 0xc0, 0xce, 0x07, 0xb0, 0xc0, 0xe1, 0xa2, 0xc0, 0x77, 0xfb, 0x62, 0xa0, 0xce, 0xd4, 0x56,
	0xed, 0x3e, 0x3e, 0xf5, 0x55, 0x8c, 0x27, 0xe1, 0x5f, 0x47, 0x62, 0xe0, 0xbc, 0x0b, 0x73, 0xca,
	0x8e, 0xa8, 0xcf, 0x5c, 0x1e, 0x40, 0xd3, 0x74, 0xce, 0x67, 0xb0, 0x5c, 0x8c, 0x76, 0xa9, 0x03,
	0xb3, 0xd7, 0x06, 0xba, 0x96, 0x0a, 0x81, 0x2e, 0xe7, 0x1e, 0x4c, 0xc7, 0xc2, 0x93, 0xea, 0xdc,
	0x4c, 0x1f, 0x7f, 0x35, 0x85, 0x67, 0x8d, 0x11, 0x51, 0x38, 0xf7, 0x60, 0xb9, 0x1d, 0xa3, 0x0e,
	0x19, 0xc8, 0xd8, 0x4d, 0xa4, 0x17, 0x85, 0x3e, 0x2d, 0xc8, 0x99, 0xe6, 0x22, 0xc1, 0x5f, 0xc8,
	0xf8, 0x98, 0xa0, 0xce, 0x77, 0xc1, 0x51, 0x19, 0x01, 0xbe, 0x0c, 0xa3, 0x7e, 0x10, 0x8a, 0x34,
	0x8a, 0x69, 0x75, 0xce, 0x34, 0x57, 0x18, 0x73, 0x98, 0x21, 0x9c, 0xfb, 0xb0, 0x8a, 0xcb, 0x4b,
	0xa4, 0xa9, 0xf0, 0x4e, 0x5c, 0x1d, 0x32, 0x51, 0xfb, 0xd9, 0x4a, 0x3f, 0x08, 0xf7, 0x08, 0xa3,
	0x43, 0x2c, 0x44, 0x2f, 0xce, 0x47, 0xe8, 0xe7, 0x15, 0xbd, 0x38, 0x2f, 0xd0, 0xdf, 0x81, 0x45,
	0xe4, 0xdf, 0x8f, 0x78, 0x72, 0xa5, 0xaf, 0xf6, 0xbe, 0x85, 0x7e, 0x10, 0x1e, 0x45, 0x34, 0x7d,
	0xd2, 0x27, 0x2a, 0x71, 0x6e, 0x53, 0xd5, 0x14, 0x95, 0x38, 0xcf, 0xa8, 0xde, 0x85, 0x0a, 0xf2,
	0xa2, 0x95, 0xb4, 0x78, 0xe9, 0x4a, 0x9a, 0xeb, 0xd3, 0x7a, 0x4f, 0x9d, 0x5b, 0x80, 0x2c, 0xb2,
	0x7e, 0x2e, 0x11, 0xdb, 0xf9, 0xbe, 0x38, 0x37, 0x3d, 0x7c, 0x13, 0x6a, 0x89, 0x17, 0xc5, 0x34,
	0xb4, 0xa8, 0x74, 0xe8, 0xd8, 0x89, 0xd7, 0xf5, 0x02, 0x21, 0x5e, 0x30, 0x1c, 0x5f, 0xdd, 0xeb,
	0x4a, 0xef, 0x84, 0xbb, 0x69, 0x58, 0xaa, 0x8d, 0x92, 0x50, 0xd8, 0x57, 0xc3, 0x78, 0x07, 0xaa,
	0x5e, 0x1c, 0xa4, 0x6e, 0x8c, 0xeb, 0x80, 0xb7, 0xc6, 0x0a, 0x02, 0x9a, 0x28, 0xf3, 0x5a, 0x57,
	0xac, 0x5a, 0xba, 0x82, 0xb4, 0x60, 0xaf, 0xe7, 0xf6, 0x64, 0x58, 0x5f, 0xd3, 0x5a, 0xb0, 0xd7,
	0x7b, 0x26, 0x43, 0x44, 0xb1, 0x9a, 0xeb, 0x48, 0x3a, 0x9a, 0x99, 0x69, 0xce, 0x91, 0x92, 0xeb,
	0x48, 0xe7, 0x2d, 0x58, 0x41, 0xf7, 0x35, 0x26, 0xdb, 0x42, 0xc6, 0x6e, 0x37, 0x08, 0x53, 0x3a,
	0x7d, 0x99, 0x69, 0x2e, 0x0a, 0xdf, 0x47, 0x9a, 0x17, 0x32, 0x7e, 0x12, 0x84, 0xa9, 0xf3, 0x1e,
	0x6c, 0x18, 0xd2, 0x5e, 0x94, 0xa4, 0xef, 0x9a, 0x77, 0xde, 0xe4, 0x9d, 0x5b, 0xd1, 0x3f, 0x43,
	0x9c, 0x7e, 0xed, 0x77, 0xc0, 0xa1, 0x06, 0xb1, 0xf4, 0xa2, 0x53, 0x94, 0x3e, 0x9a, 0x9f, 0x3a,
	0x35, 0x58, 0x46, 0x4c, 0x93, 0x11, 0x3c, 0x47, 0xef, 0x80, 0x73, 0x26, 0x7a, 0x3d, 0xf7, 0x4c,
	0x04, 0x69, 0x36, 0x46, 0x5b, 0x4c, 0x8d, 0x98, 0x2f, 0x44, 0x90, 0x9a, 0x21, 0xfa, 0x04, 0xae,
	0x11, 0xb5, 0x12, 0xa7, 0x76, 0x70, 0xae, 0x63, 0x3f, 0xb8, 0x8f, 0x24, 0xf5, 0x6d, 0x6a, 0x57,
	0x47, 0x1a, 0x96, 0xab, 0x47, 0xc1, 0x39, 0x07, 0x75, 0x5e, 0x22, 0xde, 0x39, 0x80, 0x9b, 0xd4,
	0xbe, 0x25, 0x65, 0xe8, 0x76, 0x87, 0x71, 0x4a, 0xaf, 0xe5, 0xe2, 0x50, 0xe9, 0x37, 0xdb, 0x21,
	0x16, 0xdb, 0x48, 0xb6, 0x2f, 0x65, 0xf8, 0x64, 0x18, 0xa7, 0xf8, 0x7a, 0x47, 0xe2, 0x5c, 0xbf,
	0xe0, 0x75, 0x00, 0x62, 0xc2, 0xba, 0xe7, 0x1a, 0x6f, 0x21, 0x08, 0x61, 0xd5, 0x72, 0x1f, 0x56,
	0x93, 0x2e, 0x3a, 0xd3, 0x3c, 0xed, 0x41, 0x92, 0x8a, 0xd0, 0x93, 0xf5, 0xeb, 0x3c, 0xed, 0x84,
	0xa2, 0x69, 0x57, 0x08, 0xe7, 0x0d, 0x58, 0x0a, 0xc2, 0x20, 0x55, 0xef, 0x44, 0xbb, 0xdd, 0x0d,
	0xa2, 0xad, 0x21, 0x78, 0x4f, 0x41, 0xbf, 0x34, 0x74, 0xbe, 0x6c, 0xcb, 0x30, 0x21, 0xba, 0x9b,
	0x19, 0xdd, 0xa1, 0x82, 0x7e, 0xe9, 0xdc, 0x80, 0x79, 0xa2, 0xa3, 0x3e, 0x9e, 0xd7, 0x77, 0xb9,
	0x7f, 0x08, 0xfa, 0x42, 0xf4, 0x7a, 0x5f, 0x3a, 0xef, 0xc2, 0x3a, 0xa1, 0xda, 0xbd, 0x0b, 0x17,
	0x97, 0x87, 0x19, 0xf4, 0x5b, 0x44, 0x49, 0xd3, 0xf1, 0xa8, 0x77, 0x71, 0x14, 0x84, 0x7a, 0xd8,
	0x1b, 0x7f, 0x6f, 0x16, 0xd6, 0x4b, 0xb5, 0xea, 0xc8, 0xc6, 0x72, 0x0d, 0xaa, 0x22, 0x0c, 0xfa,
	0xcc, 0x90, 0x77, 0xe6, 0x0c, 0x80, 0xab, 0x2b, 0x8d, 0x83, 0x4e, 0x47, 0xc6, 0x2c, 0xe4, 0xbc,
	0x8b, 0xcc, 0x2b, 0x18, 0xc9, 0xf9, 0x47, 0x19, 0x09, 0x99, 0x95, 0xd3, 0x64, 0x9b, 0x6e, 0xda,
	0x8a, 0xf9, 0x25, 0xe3, 0xc9, 0x3a, 0xd5, 0x6d, 0xc9, 0xd2, 0xdc, 0x87, 0x45, 0xd3, 0x96, 0xcd,
	0xb9, 0x99, 0x5c, 0xd8, 0x81, 0x5b, 0x17, 0x8e, 0x4e, 0x6a, 0x9a, 0x03, 0x9b, 0x76, 0x37, 0x41,
	0xb3, 0x74, 0xbb, 0x81, 0xf6, 0x85, 0x40, 0x81, 0x9e, 0x04, 0xa8, 0x21, 0x20, 0x91, 0xbd, 0xb6,
	0xcb, 0xdb, 0xd5, 0x9c, 0x59, 0xfb, 0x55, 0x84, 0xd2, 0x7e, 0xe5, 0xdc, 0x85, 0x05, 0x6d, 0xec,
	0x12, 0x51, 0xc5, 0x10, 0xcd, 0x33, 0x9c, 0xc9, 0xd6, 0xf4, 0x06, 0xc9, 0xca, 0x56, 0xed, 0x84,
	0xef, 0x80, 0x23, 0xcf, 0xbd, 0x20, 0x95, 0x3a, 0x4e, 0x4b, 0xc3, 0xc0, 0xfa, 0x75, 0x99, 0x31,
	0x1c, 0x8d, 0xa5, 0x57, 0x76, 0x70, 0x47, 0x50, 0xae, 0xc3, 0x4c, 0x93, 0xfe, 0x77, 0x3e, 0x84,
	0xf9, 0x84, 0xf4, 0x1b, 0x6b, 0xbe, 0x85, 0x4b, 0x35, 0x1f, 0x24, 0x06, 0xe0, 0x7c, 0x0c, 0x5b,
	0xd9, 0xc2, 0x50, 0x4f, 0x0f, 0x42, 0x8f, 0x7b, 0x50, 0x33, 0x2f, 0xb1, 0xde, 0x52, 0xeb, 0x82,
	0xfb, 0xf1, 0x34, 0xf4, 0xa8, 0x2b, 0xef, 0xc1, 0x5a, 0x59, 0x6b, 0x4a, 0x0f, 0xe0, 0x86, 0x2b,
	0x23, 0x0d, 0x4b, 0x1f, 0xe9, 0x4b, 0xf5, 0xc8, 0xa5, 0x71, 0x8f, 0x3c, 0x94, 0xe3, 0x1f, 0xe9,
	0x4b, 0xcf, 0xd2, 0xc8, 0x2b, 0x23, 0x0d, 0x9d, 0x37, 0x61, 0x49, 0xcd, 0x8e, 0x17, 0x45, 0x3d,
	0x72, 0xd5, 0x58, 0x25, 0x2f, 0x32, 0xf8, 0x40, 0x41, 0xd1, 0xa5, 0x8b, 0x65, 0x0f, 0xad, 0x0c,
	0xad, 0x1b, 0x58, 0x29, 0xd7, 0x18, 0xaa, 0xd4, 0x41, 0xe3, 0x5f, 0xcf, 0xc2, 0xe2, 0x6b, 0x56,
	0x45, 0x99, 0x1f, 0x92, 0x5b, 0x29, 0x53, 0xc5, 0x95, 0xb2, 0x0d, 0x15, 0xd3, 0xbb, 0x69, 0xb5,
	0x15, 0xe8, 0x7e, 0xbd, 0x05, 0xcb, 0x49, 0x1a, 0x47, 0x94, 0x63, 0xa4, 0xd7, 0xee, 0x0c, 0xd1,
	0x2c, 0x29, 0xb8, 0xd1, 0x97, 0xd7, 0x01, 0x48, 0x17, 0xb3, 0x9c, 0xcd, 0x92, 0x47, 0x5a, 0x45,
	0x08, 0xab, 0xaa, 0x1d, 0xa8, 0x9e, 0x48, 0x39, 0x20, 0x4d, 0x45, 0xa6, 0x7c, 0xa5, 0x59, 0x41,
	0x00, 0xea, 0x27, 0x5c, 0xac, 0x1c, 0x76, 0x53, 0xad, 0x2b, 0x84, 0x9f, 0x67, 0x18, 0xb7, 0xbf,
	0x03, 0x8b, 0xb4, 0x16, 0x44, 0xa2, 0x17, 0x1c, 0x3b, 0xbd, 0x0b, 0x08, 0xdd, 0x4b, 0xd4, 0x92,
	0xda, 0x33, 0x03, 0x6e, 0x9c, 0x45, 0xa0, 0x55, 0xbd, 0x35, 0xba, 0x2e, 0x95, 0x03, 0xd8, 0xac,
	0xa5, 0x39, 0x1f, 0xf2, 0x3d, 0xe3, 0xa0, 0xcd, 0xbf, 0x7e, 0x45, 0x6b, 0x2f, 0xed, 0x36, 0xe0,
	0x4c, 0x49, 0x91, 0x48, 0xce, 0xc8, 0xd2, 0x96, 0x84, 0x02, 0x52, 0xb2, 0x15, 0x8e, 0x10, 0x49,
	0x0f, 0x53, 0xb0, 0x15, 0x51, 0x45, 0x48, 0x1e, 0x4d, 0x6e, 0x3d, 0x19, 0x11, 0x0a, 0x4d, 0x2e,
	0xbd, 0xd9, 0x95, 0x97, 0xac, 0x5d, 0xf9, 0x26, 0xcc, 0xdb, 0x2b, 0x97, 0x65, 0x0b, 0x64, 0xb6,
	0x66, 0xf3, 0x1a, 0xc4, 0x29, 0xd3, 0x20, 0xdf, 0x81, 0xa5, 0x8c, 0x84, 0x75, 0xe5, 0xaa, 0xa1,
	0xab, 0x19, 0xba, 0x66, 0x99, 0xb6, 0x59, 0x2b, 0xd7, 0x36, 0xf7, 0x61, 0xc5, 0x26, 0x63, 0xa6,
	0xeb, 0x86, 0x76, 0xc9, 0xa2, 0x25, 0xb6, 0x3b, 0x40, 0xfd, 0x61, 0x13, 0x82, 0xcd, 0x83, 0x0a,
	0x02, 0xc8, 0x86, 0x40, 0x2d, 0xc9, 0xcc, 0x08, 0xbd, 0xa9, 0xb4, 0x24, 0x81, 0x9a, 0x2a, 0x7a,
	0x81, 0xfb, 0x8b, 0xbd, 0xf7, 0x57, 0xda, 0xbd, 0x0b, 0xde, 0xf3, 0x77, 0x80, 0x86, 0x90, 0xc7,
	0x87, 0xb7, 0xfa, 0x0a, 0x02, 0x70, 0x74, 0x1a, 0xbf, 0x3d, 0x09, 0x6b, 0x65, 0xd3, 0xea, 0x7c,
	0xcf, 0x7a, 0xa6, 0x27, 0xc9, 0xab, 0x58, 0x7c, 0x38, 0x6f, 0xd9, 0xc0, 0xf4, 0x1e, 0xa6, 0x13,
	0x9e, 0x44, 0x55, 0xaa, 0x5a, 0xd8, 0x13, 0xc2, 0xbb, 0xd2, 0x32, 0x63, 0x2c, 0x55, 0xfa, 0x16,
	0x28, 0x98, 0x3b, 0x0c, 0xfb, 0xd1, 0xa9, 0x68, 0xf5, 0x78, 0x83, 0xaa, 0xe8, 0xb1, 0xf9, 0x35,
	0x0d, 0x76, 0x1e, 0xc2, 0xba, 0x22, 0x0d, 0x23, 0xbd, 0x71, 0x13, 0xfd, 0x34, 0xd1, 0xaf, 0x32,
	0xf2, 0x79, 0xa4, 0x76, 0x6f, 0x6a, 0x73, 0x17, 0x16, 0xf5, 0xf8, 0x07, 0x3d, 0x89, 0x16, 0xc1,
	0x0c, 0x07, 0x88, 0xd4, 0xc0, 0x33, 0xd0, 0x1a, 0xd9, 0x24, 0x1d, 0x86, 0x6a, 0xc9, 0x82, 0x9e,
	0x9c, 0x61, 0xd8, 0xf8, 0x5f, 0x73, 0xb0, 0x98, 0x77, 0x8b, 0xfe, 0x02, 0xd4, 0xcd, 0xfb, 0x00,
	0x09, 0x59, 0x54, 0xd6, 0x9e, 0x9b, 0xf3, 0xc1, 0x8e, 0x11, 0x4b, 0x2b, 0xb3, 0x9a, 0xe8, 0x7f,
	0xd1, 0x22, 0xe1, 0x56, 0x68, 0x3f, 0xb1, 0x01, 0xc6, 0x7a, 0xa8, 0x46, 0xe0, 0x23, 0x71, 0xce,
	0x56, 0xd7, 0x75, 0x80, 0x34, 0x40, 0xe6, 0x44, 0xc2, 0x5b, 0x6a, 0x15, 0x21, 0x8c, 0xbe, 0x0d,
	0x35, 0x42, 0x1b, 0x65, 0x36, 0xc7, 0xeb, 0x14, 0x81, 0x46, 0x93, 0x7d, 0x08, 0xf3, 0xec, 0xd4,
	0xf2, 0xa6, 0x56, 0xb9, 0x7c, 0x53, 0x63, 0x52, 0xda, 0xd4, 0xd0, 0x1c, 0x4a, 0xf8, 0xc0, 0x06,
	0x1b, 0xb2, 0x82, 0xaa, 0x06, 0xc9, 0x9e, 0x4f, 0x9e, 0x33, 0xbe, 0x44, 0xe6, 0x46, 0xf0, 0xaa,
	0xe0, 0xcd, 0xb6, 0xd6, 0xd7, 0x8e, 0x44, 0x93, 0x97, 0xe4, 0x8a, 0xb2, 0x3a, 0x2d, 0x4a, 0xde,
	0x76, 0x97, 0x18, 0x91, 0xd1, 0xde, 0x84, 0xf9, 0xa4, 0x1b, 0xc8, 0x9e, 0xa2, 0x62, 0xbd, 0x03,
	0x0c, 0x22, 0x82, 0x6b, 0x50, 0xcd, 0x84, 0xac, 0xc6, 0x5d, 0x32, 0x00, 0x14, 0x95, 0x82, 0x5c,
	0x2d, 0xb2, 0xa8, 0x84, 0x39, 0x89, 0xaa, 0xc3, 0x9c, 0x16, 0xa5, 0x25, 0xc2, 0xeb, 0x9f, 0x1c,
	0xac, 0x18, 0x86, 0x14, 0xd8, 0xab, 0x34, 0xe9, 0xff, 0xd7, 0xab, 0xa5, 0x71, 0xfb, 0xf7, 0xea,
	0x65, 0xfb, 0xf7, 0x4d, 0x98, 0x57, 0x06, 0x38, 0xe9, 0x41, 0xf6, 0x42, 0x80, 0x41, 0x07, 0xa8,
	0x0d, 0xb5, 0x81, 0xb2, 0x6e, 0x19, 0x28, 0xdf, 0x81, 0x95, 0x9c, 0x87, 0x40, 0x83, 0xc4, 0x2a,
	0x66, 0xc9, 0x72, 0x10, 0x68, 0xa4, 0x2e, 0xb5, 0x49, 0x36, 0x5f, 0x67, 0x93, 0x5c, 0x6a, 0x5e,
	0xd4, 0xbf, 0xad, 0x79, 0xb1, 0x75, 0x99, 0x79, 0xf1, 0x0e, 0x38, 0x6a, 0xee, 0x55, 0x0b, 0x7a,
	0x3b, 0x76, 0x4c, 0x96, 0x19, 0xc3, 0xc4, 0xf4, 0x7a, 0xf7, 0x60, 0x59, 0x8d, 0x5f, 0xa6, 0x11,
	0xd9, 0x03, 0x59, 0x64, 0xf8, 0x13, 0xad, 0x17, 0xff, 0x74, 0x1a, 0x9c, 0xd1, 0x94, 0xe6, 0x2b,
	0xad, 0xfd, 0x35, 0x98, 0xe9, 0x47, 0xbe, 0xec, 0xa9, 0x98, 0x27, 0xff, 0x70, 0xd6, 0x61, 0x96,
	0x52, 0xa7, 0xcf, 0x95, 0x81, 0x31, 0x83, 0xbf, 0xbe, 0x34, 0xe0, 0x0b, 0xb5, 0x96, 0x09, 0xfc,
	0xca, 0xd9, 0x80, 0x59, 0x15, 0x33, 0xe3, 0xf5, 0xab, 0x7e, 0x39, 0xb7, 0x61, 0x9a, 0x3a, 0x3d,
	0x47, 0x3a, 0x63, 0x29, 0xcb, 0x5a, 0xa2, 0x21, 0x6c, 0x12, 0x12, 0x25, 0x55, 0x1d, 0xf3, 0xa8,
	0x20, 0x84, 0xfe, 0x89, 0x46, 0xc6, 0xd7, 0xdd, 0x68, 0x68, 0x22, 0x23, 0xc0, 0x46, 0x06, 0xc2,
	0x74, 0xd0, 0xe3, 0x2d, 0x58, 0xf6, 0x65, 0x5b, 0x0c, 0x7b, 0xa9, 0x7b, 0x11, 0x84, 0xbd, 0x40,
	0x84, 0x1d, 0xbd, 0xee, 0x14, 0xfc, 0x95, 0x02, 0xe3, 0xd8, 0x73, 0x22, 0x09, 0x2e, 0x77, 0x43,
	0xcc, 0xcb, 0x8f, 0x53, 0x45, 0xf6, 0x7c, 0xdf, 0x50, 0x2b, 0x5f, 0xdf, 0xd0, 0xd5, 0x8c, 0xaf,
	0x6f, 0x48, 0x3e, 0x80, 0xcd, 0x2e, 0x3a, 0x88, 0x25, 0x5c, 0xd9, 0x16, 0x58, 0x43, 0xf4, 0x61,
	0x91, 0xf3, 0x16, 0x54, 0xce, 0x44, 0xcc, 0xf1, 0xdb, 0x25, 0x1a, 0xf3, 0xb9, 0x33, 0x11, 0x53,
	0xf8, 0x76, 0x17, 0x16, 0x44, 0x7a, 0x42, 0x8e, 0x57, 0x77, 0xd8, 0x1e, 0xd2, 0x12, 0x9d, 0x69,
	0x82, 0x48, 0x4f, 0x8e, 0x82, 0xf0, 0xc9, 0xb0, 0x3d, 0x74, 0xbe, 0x0b, 0xab, 0x9a, 0x82, 0x4f,
	0x82, 0xe9, 0x8c, 0x5f, 0x2d, 0xd8, 0x65, 0x26, 0xa4, 0x33, 0x5d, 0x3a, 0xcc, 0x77, 0x1a, 0x50,
	0x13, 0xca, 0x85, 0x25, 0x72, 0x65, 0xa4, 0xce, 0x0b, 0xf2, 0x59, 0x89, 0x10, 0x17, 0x1c, 0xcd,
	0x29, 0xb9, 0x7b, 0xda, 0x21, 0xe5, 0x48, 0xc2, 0x12, 0x22, 0xd0, 0xd7, 0x53, 0xe0, 0xc6, 0xcf,
	0x60, 0xbd, 0x34, 0xe7, 0x1d, 0x37, 0x3d, 0xaf, 0x2b, 0x7a, 0x3d, 0x19, 0x6a, 0x77, 0x9b, 0x0f,
	0xd7, 0x95, 0xf0, 0xad, 0x1a, 0x24, 0x69, 0x75, 0x3a, 0x3b, 0x6f, 0xfc, 0xd9, 0x04, 0x6c, 0x94,
	0x27, 0xbd, 0x8f, 0x08, 0xee, 0x16, 0x54, 0x7a, 0xd1, 0x19, 0x25, 0x4f, 0xe9, 0x90, 0x6e, 0x2f,
	0x3a, 0x6b, 0x8a, 0xf0, 0x84, 0xec, 0x85, 0xa0, 0xd3, 0x65, 0xdc, 0x94, 0xb2, 0x17, 0x82, 0x4e,
	0x57, 0x23, 0xcf, 0x82, 0xd0, 0xa5, 0xc8, 0x8b, 0x36, 0x95, 0xcf, 0x82, 0xf0, 0x18, 0x7f, 0xe3,
	0xce, 0xd3, 0x8b, 0x12, 0xa9, 0xb0, 0x2c, 0xd0, 0x55, 0x84, 0x30, 0x1a, 0xe5, 0x85, 0xfd, 0x66,
	0x8e, 0x03, 0x30, 0xd9, 0xac, 0x92, 0x17, 0xc6, 0xa0, 0xf3, 0xcf, 0xd4, 0xb7, 0x60, 0x41, 0xa5,
	0x03, 0x51, 0x22, 0xa6, 0x8a, 0x7d, 0xcf, 0x33, 0x8c, 0x52, 0x2c, 0x1b, 0xbf, 0x35, 0x01, 0xdb,
	0xe3, 0x13, 0xf2, 0xcb, 0x16, 0xab, 0xf5, 0xbe, 0xf4, 0x7f, 0x76, 0x8e, 0x30, 0x75, 0xf9, 0x39,
	0x82, 0xf3, 0x3d, 0x00, 0x3a, 0x71, 0x62, 0xea, 0x99, 0x71, 0xd4, 0x55, 0x24, 0xa2, 0xdf, 0x8d,
	0x7f, 0x56, 0x43, 0x15, 0x52, 0xcc, 0xed, 0x77, 0xde, 0x82, 0x45, 0xe5, 0x37, 0xc4, 0xef, 0xb3,
	0x1a, 0x9f, 0xb0, 0x6c, 0x4d, 0x8d, 0x21, 0x6d, 0x4e, 0xd1, 0x3f, 0x11, 0xb9, 0x2a, 0xf9, 0x5f,
	0x6f, 0xd8, 0x93, 0x3a, 0xfa, 0x27, 0x22, 0xce, 0xfe, 0xd7, 0xbb, 0xf6, 0x0f, 0x60, 0xc9, 0xa2,
	0xa7, 0x60, 0xf9, 0xd4, 0x98, 0x60, 0x79, 0xcd, 0xb4, 0x46, 0x98, 0xf3, 0x1e, 0x6c, 0xf0, 0xa2,
	0xb3, 0xda, 0xb3, 0xb8, 0xf1, 0x1c, 0xaf, 0x12, 0xf6, 0x48, 0xb7, 0x21, 0x71, 0xc3, 0xbd, 0x5c,
	0x51, 0x46, 0x1d, 0x45, 0xad, 0x0c, 0x12, 0x02, 0x3f, 0x8b, 0x3a, 0x4c, 0x47, 0xd1, 0x51, 0x72,
	0x6d, 0x70, 0xd9, 0xb0, 0x6d, 0x3f, 0xab, 0xa3, 0xa3, 0x08, 0x3f, 0x12, 0xe7, 0x6c, 0xe0, 0x23,
	0xc7, 0x9e, 0x36, 0x71, 0x98, 0x70, 0x4e, 0x71, 0xe4, 0xbc, 0xe8, 0x8c, 0xae, 0x1d, 0xc4, 0x49,
	0x4a, 0x47, 0xe0, 0xf4, 0x30, 0xa5, 0xe9, 0x6a, 0x04, 0x7e, 0x3e, 0xf0, 0xa8, 0x9b, 0xce, 0x8f,
	0x60, 0x5b, 0x0c, 0xd3, 0xc8, 0x6d, 0x0f, 0x7b, 0x3d, 0x37, 0x41, 0x87, 0x4e, 0xc6, 0xd9, 0x38,
	0x72, 0x20, 0x60, 0x13, 0x29, 0x1e, 0x0d, 0x7b, 0xbd, 0x63, 0xc6, 0x9b, 0xd1, 0xbc, 0x85, 0x96,
	0xfe, 0x79, 0x31, 0xe8, 0x3a, 0x9f, 0x5a, 0xc1, 0xc9, 0x7b, 0xb0, 0xd8, 0x0e, 0x92, 0x2e, 0x47,
	0xb4, 0xa2, 0x20, 0x4c, 0xe9, 0xc2, 0x81, 0x8a, 0x4e, 0x22, 0xe6, 0x48, 0x9c, 0xbf, 0x40, 0xb8,
	0xf3, 0x43, 0xd8, 0x24, 0x4a, 0xa2, 0x32, 0xa7, 0xe3, 0x49, 0x34, 0xec, 0xd5, 0x17, 0x4c, 0x93,
	0x35, 0x24, 0x21, 0x7a, 0x7d, 0x28, 0x12, 0x0d, 0x7b, 0xce, 0x47, 0xb0, 0xed, 0x0b, 0xf7, 0xeb,
	0xae, 0x88, 0xdc, 0xe4, 0x2c, 0x48, 0xbd, 0xae, 0x4a, 0x43, 0xe2, 0x11, 0x67, 0x35, 0xba, 0xe1,
	0x8b, 0x5f, 0x74, 0x45, 0x74, 0x4c, 0x78, 0xd2, 0x54, 0x3c, 0xf4, 0xcf, 0x61, 0x67, 0x38, 0xf0,
	0xd1, 0x01, 0xb1, 0xd2, 0x87, 0xe9, 0x3c, 0x90, 0xa4, 0x63, 0x71, 0x8c, 0x74, 0x6c, 0x72, 0x23,
	0x93, 0x4b, 0x8c, 0x9b, 0x0b, 0xc9, 0xc9, 0x13, 0xb8, 0x15, 0x8b, 0xd0, 0x8f, 0xfa, 0x2e, 0xe7,
	0xfb, 0xb4, 0x82, 0x8e, 0x1b, 0xcb, 0x76, 0x2c, 0x93, 0x6e, 0x31, 0x8a, 0x7b, 0x9d, 0x09, 0x29,
	0xe7, 0x67, 0x3f, 0xe8, 0x34, 0x99, 0xca, 0x0c, 0xdd, 0x33, 0xb8, 0x9d, 0xe3, 0x94, 0xf4, 0x45,
	0xaf, 0x37, 0xca, 0x8b, 0x15, 0xf6, 0x4d, 0x8b, 0xd7, 0x31, 0x12, 0x16, 0xb9, 0xa1, 0x09, 0x38,
	0x28, 0x06, 0x7d, 0x21, 0x19, 0x18, 0x82, 0x5d, 0x58, 0x68, 0x0d, 0xd1, 0x43, 0x72, 0x4f, 0x45,
	0x6f, 0xa8, 0x03, 0xbe, 0xd0, 0x1a, 0x5e, 0x1c, 0x0f, 0x7e, 0x8e, 0x10, 0xb4, 0x5c, 0x15, 0x05,
	0x0d, 0x0d, 0xeb, 0xeb, 0x2a, 0x11, 0xd0, 0xab, 0x67, 0x1c, 0x78, 0xe0, 0xd7, 0x2c, 0x0e, 0x3c,
	0xd8, 0x9f, 0x80, 0x63, 0x12, 0x77, 0x65, 0x42, 0x11, 0x8f, 0x24, 0x55, 0xa9, 0xfa, 0xa3, 0x63,
	0xbc, 0xac, 0x53, 0x75, 0x91, 0x94, 0x9e, 0xf0, 0x21, 0xd4, 0x93, 0x93, 0x60, 0xe0, 0xb6, 0x83,
	0x4e, 0x97, 0xb2, 0xbc, 0xb2, 0xcb, 0x0e, 0xca, 0x5e, 0x5b, 0x47, 0xfc, 0x23, 0x85, 0x36, 0xf7,
	0x1c, 0x70, 0xdf, 0xcc, 0x37, 0x34, 0xb9, 0x6a, 0xca, 0x57, 0x5c, 0xb3, 0xdb, 0xe9, 0x5c, 0x35,
	0xe7, 0xc7, 0xb0, 0x93, 0x6f, 0x96, 0x8f, 0x0a, 0xb3, 0x1f, 0x59, 0xb7, 0x9b, 0xe6, 0xa2, 0xc3,
	0xe8, 0x8f, 0xd8, 0xd7, 0x6e, 0x3c, 0x5f, 0x79, 0x97, 0x35, 0xeb, 0x32, 0xcd, 0x81, 0x8f, 0x73,
	0x63, 0x2e, 0x57, 0x79, 0xbe, 0xb2, 0xcd, 0x40, 0x83, 0x0e, 0x7c, 0xdc, 0x36, 0x5a, 0x22, 0xf8,
	0xba, 0xcb, 0xf8, 0x1d, 0x35, 0xf0, 0x0c, 0x39, 0xf0, 0x9d, 0x4d, 0x98, 0xeb, 0xca, 0x56, 0x80,
	0x38, 0x8e, 0xfe, 0xce, 0xe2, 0x4f, 0x6e, 0x77, 0x1e, 0x44, 0x61, 0x27, 0x1c, 0x22, 0x8e, 0x23,
	0xbe, 0x55, 0x05, 0xe1, 0x76, 0x7d, 0x11, 0xf4, 0x10, 0xc7, 0x11, 0xde, 0x59, 0xfc, 0x79, 0xe0,
	0x93, 0x15, 0x18, 0x88, 0xf0, 0x97, 0xd8, 0xa1, 0x34, 0x72, 0x3b, 0x51, 0xcf, 0x57, 0xb1, 0xdd,
	0x45, 0x0d, 0x7f, 0x19, 0x3d, 0x8e, 0x78, 0x27, 0xb7, 0x29, 0x93, 0x34, 0x0a, 0xa5, 0x0a, 0xf1,
	0x2e, 0x65, 0xa4, 0xc7, 0x08, 0x46, 0x5a, 0xd4, 0x30, 0x81, 0x8c, 0x29, 0xce, 0xdf, 0x89, 0xa3,
	0xe1, 0x40, 0x05, 0x79, 0x97, 0x14, 0xe2, 0x85, 0x8c, 0x1f, 0x23, 0x18, 0x77, 0x42, 0x9a, 0x5b,
	0xba, 0x9f, 0x65, 0x06, 0xbc, 0xc1, 0x3b, 0x21, 0x62, 0xf6, 0x45, 0xf4, 0xb5, 0x19, 0xe8, 0xf7,
	0x60, 0x23, 0xa3, 0xa6, 0xf3, 0x12, 0x6d, 0x54, 0xdc, 0x66, 0xe5, 0xac, 0x5b, 0x1c, 0x89, 0x73,
	0x13, 0xe7, 0x3e, 0x84, 0x35, 0x1c, 0xde, 0x96, 0x88, 0x38, 0x1d, 0x4f, 0x07, 0xd5, 0xee, 0x92,
	0x38, 0x3a, 0xfa, 0xc4, 0xba, 0x8f, 0xfa, 0x54, 0x65, 0xe1, 0x29, 0xfa, 0xc7, 0x41, 0x3b, 0xd5,
	0xd1, 0xb6, 0xff, 0x33, 0x05, 0x8b, 0xf9, 0x1b, 0x66, 0x23, 0xbb, 0xea, 0x1a, 0xcc, 0xf0, 0xbb,
	0xf2, 0xb6, 0xc4, 0x3f, 0xe8, 0xe8, 0x92, 0x04, 0x50, 0x1f, 0x5d, 0x92, 0xc4, 0x69, 0x73, 0x79,
	0xba, 0xe4, 0xbc, 0x7b, 0xa6, 0xe4, 0xbc, 0x7b, 0xd6, 0x3a, 0xef, 0xbe, 0x07, 0x73, 0xbf, 0x1c,
	0x8a, 0x5e, 0x90, 0x5e, 0x28, 0xeb, 0x77, 0x51, 0xbd, 0xc3, 0xaf, 0x32, 0xb4, 0xa9, 0xd1, 0xe8,
	0xe1, 0xf2, 0xd5, 0x1b, 0x4d, 0xcf, 0x7b, 0xc3, 0x02, 0x01, 0x15, 0xb5, 0xf3, 0x26, 0x2c, 0x0d,
	0xc3, 0x5e, 0x64, 0x3b, 0xc2, 0xbc, 0x1f, 0x2c, 0x32, 0xd8, 0x8c, 0xfe, 0xf7, 0xa1, 0x36, 0xe8,
	0x0d, 0x43, 0x5f, 0x67, 0x07, 0xd2, 0x3e, 0x50, 0xba, 0xf7, 0x2f, 0x28, 0x3a, 0x02, 0xe1, 0x1c,
	0x0f, 0x07, 0x9d, 0x58, 0xf8, 0xd2, 0x0d, 0xd1, 0x83, 0xe5, 0xed, 0x8c, 0x4d, 0xe9, 0x65, 0x85,
	0x79, 0x2e, 0xa5, 0xcf, 0x3b, 0xda, 0x5d, 0x58, 0xf4, 0xa5, 0x17, 0xf5, 0x07, 0x68, 0x3f, 0x91,
	0x44, 0xb2, 0xc5, 0x5b, 0x33, 0x50, 0x12, 0xc8, 0x37, 0x61, 0x29, 0x23, 0x63, 0x71, 0x5c, 0x52,
	0x92, 0xab, 0xc1, 0x2c, 0x8d, 0xdb, 0x50, 0x19, 0xc4, 0x32, 0x49, 0x83, 0x8e, 0x54, 0x3a, 0xd4,
	0xfc, 0xc6, 0xf1, 0xa1, 0x6d, 0xbe, 0xa0, 0x2e, 0x17, 0x10, 0x68, 0x0e, 0x21, 0x7c, 0x58, 0x2e,
	0xde, 0x10, 0x1c, 0x99, 0xfa, 0x65, 0x98, 0x0a, 0x07, 0x9e, 0x9a, 0x78, 0xfc, 0x17, 0x2d, 0x96,
	0x58, 0xfe, 0x72, 0x18, 0xc4, 0xd2, 0xb7, 0xb5, 0x17, 0x0b, 0xc1, 0x8a, 0x46, 0x19, 0xcd, 0xd5,
	0xf8, 0xcd, 0x09, 0xa8, 0xe5, 0xee, 0x13, 0x8e, 0x3c, 0xe3, 0x0d, 0xe5, 0xf1, 0x4c, 0xd2, 0x9c,
	0x3b, 0xe6, 0x26, 0x1f, 0x25, 0xb3, 0x5a, 0x4e, 0xcf, 0x1a, 0xcc, 0xd0, 0xad, 0x40, 0xed, 0x75,
	0xd1, 0x0f, 0x76, 0x85, 0xc2, 0x14, 0x05, 0x9f, 0x65, 0x4e, 0xff, 0xe4, 0xec, 0x08, 0x15, 0x25,
	0x51, 0xb2, 0x57, 0xd1, 0x41, 0x92, 0xc6, 0xef, 0x4c, 0xc1, 0x62, 0xfe, 0xca, 0xe2, 0x55, 0x93,
	0x5d, 0x48, 0x94, 0xa7, 0x2c, 0x51, 0x2e, 0x1c, 0x0f, 0x4c, 0x5f, 0xf9, 0x78, 0x60, 0x03, 0xa6,
	0x53, 0x91, 0x9c, 0xd0, 0xc9, 0x37, 0x9b, 0x07, 0xf4, 0xdb, 0xf9, 0x00, 0x20, 0x8d, 0x52, 0xd1,
	0x63, 0x7e, 0xb3, 0x97, 0xa7, 0x2c, 0x10, 0x25, 0xb1, 0xbb, 0xfa, 0xf2, 0xd9, 0x84, 0xb9, 0x41,
	0xd4, 0x4b, 0xdd, 0x40, 0x9f, 0x61, 0xcf, 0xe2, 0xcf, 0xa7, 0x7e, 0x96, 0x0b, 0x53, 0xb5, 0x73,
	0x61, 0x1e, 0xe8, 0x6b, 0x9f, 0xb4, 0xdb, 0xc1, 0x98, 0xdd, 0x8e, 0x6f, 0x7c, 0xd2, 0x36, 0xb7,
	0x0f, 0x37, 0x74, 0x2a, 0xa3, 0x8a, 0x31, 0x51, 0xfa, 0xcd, 0x69, 0x94, 0xca, 0xdc, 0x22, 0xd9,
	0x56, 0x54, 0x07, 0x44, 0xf4, 0x5c, 0xf4, 0xe5, 0xcf, 0xa3, 0x54, 0xd2, 0x72, 0x69, 0x74, 0xc1,
	0x19, 0xbd, 0x17, 0x7a, 0xa5, 0x39, 0xca, 0x92, 0x8f, 0xa6, 0xae, 0x92, 0x7c, 0xd4, 0xd8, 0x83,
	0xad, 0xb1, 0xd7, 0x46, 0xcb, 0x74, 0x21, 0x5d, 0x3e, 0xd5, 0xd9, 0x42, 0xf4, 0xa3, 0xf1, 0xef,
	0x17, 0x61, 0xb5, 0xe4, 0xa2, 0xa8, 0xf3, 0x43, 0xd8, 0xea, 0x49, 0x71, 0x2a, 0x5d, 0xd1, 0x46,
	0xdb, 0xec, 0xab, 0xc8, 0x3e, 0x1e, 0x64, 0xa6, 0x1b, 0x44, 0xb0, 0x87, 0xf8, 0xcf, 0xa2, 0xec,
	0x88, 0x10, 0xb7, 0x30, 0x95, 0xb7, 0x2c, 0xe2, 0x13, 0x35, 0x6a, 0xbc, 0x0c, 0xf9, 0xf6, 0xe9,
	0x91, 0x88, 0x4f, 0x58, 0xb1, 0xfc, 0x00, 0xb6, 0x2c, 0xca, 0x7e, 0xd2, 0xc1, 0x41, 0x8f, 0x5d,
	0x3b, 0xaf, 0x64, 0xdd, 0x34, 0x39, 0x4a, 0x3a, 0x07, 0x5d, 0x11, 0xb3, 0x39, 0xf3, 0x31, 0xec,
	0x24, 0x64, 0xb4, 0x07, 0xa1, 0xf1, 0xc3, 0x71, 0x17, 0xe4, 0x54, 0x69, 0xe5, 0x18, 0x6c, 0x22,
	0xc9, 0x51, 0x10, 0x6a, 0x67, 0xfc, 0x65, 0xc4, 0xb9, 0xcf, 0x59, 0x6b, 0xcb, 0xe7, 0xb7, 0x5a,
	0xcf, 0x58, 0xad, 0xb3, 0x08, 0x80, 0x69, 0xfd, 0x11, 0x6c, 0x97, 0x3e, 0x9b, 0x7d, 0x6e, 0x76,
	0x1e, 0x36, 0x46, 0x1e, 0xcd, 0xee, 0xb7, 0x69, 0x5b, 0x78, 0x32, 0xb7, 0x9d, 0xb3, 0xda, 0xda,
	0x0f, 0xe6, 0xb6, 0x64, 0xd3, 0xa8, 0xe7, 0x26, 0xa2, 0x27, 0x4c, 0x08, 0xa5, 0xa6, 0x1e, 0x76,
	0x4c, 0xc0, 0x8c, 0x4e, 0x9c, 0x6b, 0xba, 0xaa, 0x45, 0x27, 0xce, 0x15, 0xdd, 0x5b, 0xb0, 0xec,
	0x45, 0xe1, 0xa9, 0x0c, 0x65, 0x76, 0xfc, 0xc5, 0x7e, 0xc4, 0x92, 0x82, 0x9b, 0xf3, 0xaf, 0xef,
	0xc3, 0xe6, 0x59, 0x14, 0x9f, 0xd0, 0x45, 0x4f, 0xce, 0xe7, 0x2e, 0xa4, 0x6f, 0xac, 0x6b, 0x34,
	0xe5, 0x6d, 0x1b, 0x51, 0xf8, 0x09, 0x5c, 0x33, 0xed, 0xd8, 0x4c, 0xc8, 0x37, 0xe6, 0x78, 0xcc,
	0x96, 0xa6, 0x41, 0xdd, 0x9b, 0x67, 0xf0, 0x3e, 0x6c, 0x64, 0x0c, 0x86, 0x71, 0x5a, 0x34, 0xe4,
	0xd7, 0x4c, 0xd3, 0x61, 0x9c, 0x59, 0x7f, 0x87, 0x70, 0x33, 0xdf, 0x8a, 0x95, 0x92, 0x1d, 0xa9,
	0xe0, 0x7d, 0x67, 0xc7, 0x6e, 0xfe, 0x12, 0x89, 0xb2, 0x88, 0x05, 0xea, 0x82, 0x3c, 0x17, 0x7a,
	0x03, 0x9b, 0xc9, 0x8a, 0x4a, 0x10, 0xb0, 0x98, 0xe0, 0x2b, 0x58, 0x3c, 0x46, 0xfa, 0x6f, 0x46,
	0xda, 0x19, 0xed, 0xbf, 0x19, 0xee, 0x1f, 0x40, 0x3d, 0xdf, 0x2a, 0xbb, 0x97, 0xa2, 0x6c, 0xff,
	0x0d, 0xbb, 0x5d, 0x76, 0xa9, 0xc5, 0xf9, 0x04, 0xcc, 0x2b, 0x59, 0x8d, 0xd0, 0xa7, 0x43, 0xef,
	0x4a, 0xf9, 0x05, 0x66, 0xbc, 0xb3, 0x86, 0x07, 0x4c, 0x80, 0x66, 0xbe, 0xd5, 0x3e, 0xf8, 0x5a,
	0x5a, 0xde, 0xee, 0x7a, 0x7e, 0xa6, 0xc9, 0x92, 0x30, 0x5e, 0xef, 0x11, 0xdc, 0x36, 0x0d, 0x63,
	0xe9, 0x0f, 0x3d, 0x69, 0x3f, 0xdf, 0xcc, 0x1a, 0xbb, 0x0a, 0xbb, 0x9a, 0xb4, 0x49, 0x94, 0xd6,
	0xa5, 0x1c, 0x3d, 0x83, 0x1f, 0xc3, 0xf6, 0x78, 0x76, 0xca, 0x71, 0xa8, 0x8f, 0xe3, 0x92, 0x13,
	0x57, 0x6d, 0x8f, 0xaa, 0x29, 0xab, 0xe7, 0x5f, 0x42, 0x9b, 0xa4, 0x5a, 0xab, 0x64, 0x4f, 0x6d,
	0x89, 0x38, 0x96, 0xa1, 0xfd, 0xd4, 0xad, 0xfc, 0x53, 0xf7, 0x89, 0xc0, 0x7a, 0xaa, 0x2d, 0x2f,
	0xac, 0xd6, 0xd4, 0xd5, 0x07, 0x73, 0x24, 0xb2, 0x9d, 0x97, 0x17, 0x5a, 0xd6, 0x7c, 0xd1, 0x41,
	0x9f, 0x8f, 0xfc, 0x14, 0xae, 0x97, 0x2d, 0x98, 0x8c, 0xc5, 0xce, 0x98, 0x15, 0x63, 0x38, 0xfc,
	0x10, 0x0c, 0x12, 0xfd, 0xea, 0xc1, 0x30, 0xb5, 0x5a, 0x5f, 0xcb, 0x0b, 0xcf, 0xe7, 0x84, 0x37,
	0x4d, 0x9f, 0xc2, 0xad, 0x62, 0x53, 0x15, 0x97, 0xb7, 0x66, 0x90, 0x5d, 0x99, 0x1b, 0x79, 0x16,
	0x2a, 0x4c, 0x9f, 0xcd, 0xdf, 0xcf, 0xb4, 0x66, 0x57, 0xbb, 0xa8, 0xd9, 0x54, 0x71, 0x1f, 0xbe,
	0x31, 0x66, 0x1f, 0xde, 0xa0, 0x26, 0xbc, 0xa5, 0xaa, 0x8b, 0x02, 0xb4, 0x29, 0x7f, 0x06, 0x8d,
	0x52, 0x66, 0x79, 0x97, 0x90, 0xbd, 0xa4, 0x1b, 0xa3, 0x3c, 0x72, 0x8e, 0xe1, 0x1e, 0x5c, 0x1f,
	0xd3, 0x31, 0xb5, 0x2e, 0xd9, 0x83, 0xda, 0x2e, 0xeb, 0x8a, 0x5a, 0x9d, 0x6f, 0xc0, 0x12, 0xd5,
	0x83, 0x88, 0x06, 0x32, 0x54, 0x36, 0x24, 0xbb, 0x52, 0x35, 0x04, 0x7f, 0x3e, 0x90, 0x21, 0xdb,
	0x8f, 0x5d, 0x58, 0x19, 0xa9, 0x9f, 0x70, 0x25, 0x33, 0xe0, 0x01, 0xac, 0xe0, 0xb8, 0xf7, 0xfb,
	0xa8, 0xc5, 0x75, 0xb4, 0x3c, 0x4b, 0x19, 0x5d, 0x36, 0x48, 0xd5, 0xb3, 0xc6, 0x9f, 0x4d, 0xc0,
	0x72, 0xb1, 0xd8, 0xc2, 0xb7, 0x36, 0x0a, 0xad, 0x20, 0xbb, 0xb1, 0xd2, 0x67, 0x72, 0x41, 0xf6,
	0x17, 0xda, 0x58, 0xdf, 0x83, 0x85, 0x70, 0xe0, 0x99, 0x4b, 0x1f, 0x14, 0x60, 0x5a, 0x34, 0xb7,
	0x32, 0x0a, 0x77, 0x3d, 0xd0, 0x1e, 0xe6, 0xb3, 0xe8, 0x70, 0xe0, 0x69, 0xa0, 0xb3, 0x05, 0xb3,
	0xc8, 0x22, 0xf0, 0xad, 0x50, 0xd3, 0x4c, 0x38, 0xf0, 0x9e, 0xfa, 0x64, 0x1f, 0x8b, 0x41, 0x90,
	0x8a, 0x9e, 0x0a, 0x24, 0xe9, 0x9f, 0x8d, 0xbf, 0x33, 0x0d, 0x6b, 0x65, 0xb5, 0x21, 0x9c, 0x1f,
	0xc3, 0x4e, 0x18, 0xc5, 0x7d, 0xd1, 0x2b, 0x4e, 0x2f, 0xb9, 0x57, 0x6a, 0x30, 0xea, 0x4c, 0x92,
	0x9b, 0x5c, 0x4a, 0x76, 0xc5, 0xdd, 0x39, 0x94, 0x67, 0xbc, 0xf0, 0x8a, 0xf2, 0xe1, 0x2b, 0x1b,
	0x66, 0x23, 0x94, 0x67, 0xb8, 0xea, 0xf2, 0xb2, 0xe1, 0xa3, 0xe6, 0x2c, 0x7f, 0xb4, 0xa7, 0xef,
	0x62, 0xac, 0x97, 0x3c, 0xf7, 0xc0, 0x77, 0xde, 0x06, 0xc7, 0x3c, 0x14, 0x57, 0x2a, 0x4b, 0x14,
	0x5b, 0x30, 0x4b, 0xea, 0x61, 0x47, 0xe2, 0x9c, 0xc3, 0x22, 0x77, 0x60, 0xd1, 0xb6, 0x4b, 0x3d,
	0x5f, 0x4d, 0xcd, 0x82, 0x67, 0x0c, 0xd1, 0x03, 0xb4, 0x32, 0x96, 0x73, 0x54, 0xb8, 0xe8, 0x66,
	0xc7, 0x2c, 0xba, 0x45, 0xab, 0x25, 0x2e, 0xb6, 0x1f, 0xc2, 0xd6, 0x88, 0xe5, 0x5b, 0x38, 0x8e,
	0xdd, 0xf0, 0x72, 0x56, 0xaf, 0x59, 0x5b, 0x3f, 0x85, 0xeb, 0x64, 0x73, 0x48, 0x11, 0x7b, 0x5d,
	0x7e, 0x21, 0x2d, 0x49, 0xbc, 0x83, 0xb0, 0x19, 0xb2, 0xd5, 0x17, 0xe7, 0xc7, 0x44, 0x83, 0xaf,
	0x76, 0xc8, 0x14, 0xbc, 0x8b, 0xfc, 0x64, 0x94, 0x43, 0xeb, 0x42, 0xbf, 0x04, 0x72, 0x60, 0xfb,
	0xa4, 0x9e, 0xe3, 0xb0, 0x7f, 0xc1, 0x9d, 0x47, 0xdb, 0xfb, 0x37, 0x60, 0xb5, 0xa4, 0xd8, 0xc7,
	0xb7, 0x5e, 0x0b, 0xa5, 0x2b, 0x71, 0xfa, 0x92, 0x95, 0xf8, 0x1c, 0xd7, 0x7c, 0xa1, 0x50, 0x08,
	0xba, 0xa2, 0xbe, 0xb8, 0x50, 0x8f, 0xc7, 0x7f, 0xb3, 0xc8, 0xfe, 0xe4, 0x6b, 0x6e, 0x08, 0x44,
	0xb0, 0x51, 0x5e, 0x32, 0x24, 0x0b, 0x62, 0x4c, 0xd8, 0x41, 0x8c, 0xab, 0x32, 0xa6, 0x43, 0x3c,
	0xd9, 0xca, 0x32, 0xef, 0xd4, 0xaf, 0xc6, 0xaf, 0xc3, 0x46, 0x79, 0x51, 0x11, 0x67, 0x6f, 0xb4,
	0xc0, 0x09, 0x09, 0xd6, 0xc4, 0x18, 0xc1, 0xca, 0xd7, 0x34, 0x41, 0x78, 0xe3, 0x1f, 0x4e, 0xc0,
	0xd6, 0xd8, 0xfa, 0x22, 0x23, 0x93, 0x94, 0x3f, 0xd5, 0x98, 0x7c, 0xfd, 0xa9, 0x86, 0xc9, 0xc2,
	0x9f, 0xba, 0x34, 0x0b, 0xdf, 0xf2, 0x36, 0xa7, 0x2f, 0xf5, 0x36, 0x1b, 0xbf, 0x3f, 0x01, 0x2b,
	0x23, 0xf5, 0x4b, 0x70, 0x6f, 0xd3, 0xa1, 0xe0, 0x5c, 0x49, 0x15, 0x35, 0x1a, 0x53, 0xe5, 0x7b,
	0x9b, 0x6a, 0x62, 0xbd, 0x3e, 0x2d, 0xb7, 0xe7, 0xd0, 0xa0, 0x53, 0x80, 0x52, 0x8e, 0xd6, 0xa9,
	0x8a, 0x16, 0xb9, 0x1b, 0x48, 0xdd, 0x1c, 0xe1, 0x65, 0x42, 0x23, 0xff, 0xb9, 0xa6, 0xce, 0x86,
	0xf3, 0x7d, 0x7e, 0x1f, 0x36, 0x28, 0x92, 0x8a, 0x2a, 0x7d, 0x20, 0x62, 0x59, 0xf4, 0xe5, 0xd6,
	0x08, 0xfb, 0x82, 0x91, 0x76, 0xc6, 0x36, 0x39, 0x7e, 0xdc, 0xb4, 0x78, 0xc6, 0x83, 0x28, 0x0a,
	0xbe, 0xda, 0x51, 0x57, 0x31, 0x18, 0xf4, 0x2e, 0x5c, 0x91, 0xa4, 0x39, 0x2f, 0xae, 0x46, 0xe0,
	0xbd, 0x84, 0xef, 0xd1, 0x52, 0x4c, 0x38, 0x15, 0x71, 0xaa, 0x9c, 0xcb, 0x44, 0xc6, 0xa7, 0x32,
	0xa6, 0xfd, 0x54, 0xe9, 0xbd, 0x35, 0x42, 0x93, 0x6b, 0x79, 0x4c, 0x48, 0xdc, 0x55, 0xd1, 0x9b,
	0xf0, 0x65, 0x92, 0xc6, 0xd1, 0x85, 0x6d, 0x5b, 0x92, 0x75, 0x13, 0x47, 0xd1, 0x40, 0xa9, 0xc2,
	0x2d, 0x45, 0x93, 0x59, 0x66, 0x68, 0xe0, 0x20, 0x01, 0x8e, 0xc2, 0x40, 0xc6, 0xee, 0x28, 0x13,
	0xe5, 0xb5, 0xad, 0x0d, 0x64, 0x7c, 0x58, 0x6c, 0x8d, 0x36, 0x75, 0xc9, 0x63, 0x0b, 0x3a, 0x71,
	0xf4, 0xa9, 0x56, 0x96, 0xf8, 0x92, 0x4a, 0x1e, 0x34, 0x6d, 0x54, 0xfe, 0x3d, 0x83, 0x0d, 0x21,
	0x67, 0x81, 0x4a, 0xdf, 0xca, 0x02, 0x95, 0xbe, 0xc9, 0x31, 0xe6, 0xd5, 0x0e, 0x59, 0x8e, 0x71,
	0xb6, 0x23, 0xd0, 0xc1, 0xa6, 0x3f, 0x74, 0xbd, 0xae, 0x54, 0x87, 0xdc, 0x95, 0xe6, 0x02, 0x41,
	0x0f, 0x87, 0x07, 0x08, 0x43, 0x4f, 0xdb, 0x9a, 0x49, 0xde, 0x6b, 0x02, 0x6d, 0xbd, 0xf0, 0xee,
	0xba, 0x6e, 0xe6, 0x93, 0x76, 0x9c, 0x80, 0xad, 0x18, 0x3a, 0xce, 0x8a, 0xa5, 0x74, 0x53, 0x11,
	0xaa, 0x7c, 0x17, 0x1d, 0xfd, 0x43, 0xf0, 0x4b, 0x11, 0x72, 0xb2, 0x8b, 0xf3, 0x08, 0x76, 0x33,
	0xba, 0x31, 0xa3, 0xcc, 0x3e, 0xdb, 0x35, 0xdd, 0xf0, 0x45, 0xd9, 0x68, 0xef, 0xc3, 0x8d, 0xd1,
	0x9a, 0x28, 0xc3, 0x38, 0x2c, 0x1e, 0xbb, 0x6c, 0xa7, 0xf9, 0xfa, 0x26, 0xc3, 0x38, 0x8b, 0x40,
	0x3c, 0x81, 0x5b, 0x23, 0x3c, 0x46, 0x04, 0x9f, 0x9d, 0xb7, 0xeb, 0x79, 0x36, 0xc5, 0x15, 0xf0,
	0x0c, 0x6e, 0x8f, 0x70, 0x2a, 0x79, 0x31, 0x76, 0xe6, 0x6e, 0xe6, 0x79, 0x8d, 0xbe, 0xdb, 0x47,
	0xb0, 0x3d, 0xc2, 0x8d, 0x4e, 0xe3, 0xd1, 0xc9, 0xd3, 0x9e, 0x5d, 0x9e, 0xc9, 0xbe, 0x48, 0x28,
	0xf1, 0xc3, 0x79, 0x09, 0xd7, 0x47, 0xda, 0xb2, 0x6f, 0xa8, 0x82, 0xe7, 0xeb, 0x63, 0x83, 0xe7,
	0x5b, 0x79, 0x96, 0xe4, 0x32, 0xaa, 0x04, 0xf6, 0x67, 0x70, 0x67, 0x7c, 0x8f, 0xac, 0xa5, 0xc5,
	0x7e, 0xdb, 0x8d, 0xf2, 0xbe, 0x99, 0xf5, 0xf5, 0x14, 0x1a, 0xa3, 0xdc, 0xa2, 0x7e, 0x8b, 0x12,
	0xcc, 0xcd, 0xc0, 0x6f, 0x96, 0x0d, 0xfc, 0x7e, 0xd4, 0x6f, 0x3d, 0xea, 0x65, 0x8b, 0xe6, 0x36,
	0xd4, 0xfc, 0x61, 0xdc, 0x2f, 0x9e, 0xf8, 0x2c, 0x20, 0xd0, 0x10, 0xbd, 0x03, 0x8e, 0x1f, 0x0f,
	0xfb, 0x6e, 0x92, 0x46, 0x83, 0x91, 0x1b, 0x03, 0x88, 0x39, 0x4e, 0xa3, 0x81, 0x15, 0x4b, 0xd8,
	0x24, 0x6a, 0x14, 0xfc, 0x96, 0x08, 0x5c, 0x3a, 0xd4, 0xe1, 0x15, 0xb0, 0xad, 0x0e, 0x92, 0xe3,
	0x61, 0xff, 0x28, 0x08, 0xf7, 0x45, 0xf0, 0x8b, 0xae, 0x08, 0xcd, 0xf9, 0x15, 0x9f, 0x3e, 0xab,
	0xb3, 0xca, 0xac, 0xd2, 0x94, 0xf2, 0xc5, 0xd6, 0x08, 0xfd, 0x6b, 0x84, 0x35, 0x85, 0xa6, 0x9c,
	0x23, 0xb8, 0xc3, 0x2a, 0x8e, 0x32, 0x27, 0x95, 0xe1, 0x5a, 0xa2, 0xef, 0xf8, 0xf4, 0xe7, 0x26,
	0xd1, 0x1e, 0xcb, 0x5e, 0xfb, 0x80, 0x29, 0x8b, 0xaa, 0xef, 0x73, 0xb8, 0xcb, 0xec, 0xa2, 0xb4,
	0x2b, 0xe3, 0x4b, 0xf8, 0xb1, 0x17, 0xb4, 0x4b, 0xc4, 0x9f, 0x23, 0xed, 0x18, 0x86, 0xbf, 0x80,
	0xb7, 0x4b, 0xfa, 0x17, 0x46, 0x69, 0xe0, 0xc9, 0x12, 0xb6, 0xec, 0x15, 0xdd, 0x2d, 0x76, 0xf3,
	0x39, 0xd1, 0x17, 0x79, 0xff, 0x7f, 0xf0, 0x4e, 0x59, 0x67, 0xc7, 0x32, 0x67, 0xef, 0xe9, 0x8d,
	0x91, 0x3e, 0x97, 0x72, 0x6f, 0xfc, 0xde, 0xa4, 0xda, 0xe1, 0x72, 0x05, 0xbd, 0xca, 0x4c, 0x3c,
	0x32, 0xe7, 0x26, 0x2d, 0x73, 0x2e, 0xdb, 0x9f, 0xd2, 0x13, 0x97, 0x1e, 0xa7, 0xac, 0x3d, 0xb5,
	0x3f, 0xa5, 0x27, 0xc7, 0x08, 0x44, 0xb9, 0xca, 0xe8, 0x8c, 0x5c, 0x4d, 0xab, 0xb4, 0x1b, 0x45,
	0x5a, 0xbe, 0xeb, 0x31, 0xd7, 0x19, 0x9b, 0x6b, 0x92, 0x16, 0xb9, 0x26, 0xd6, 0x66, 0x3a, 0x6b,
	0x73, 0x4d, 0x52, 0xfb, 0xd4, 0x98, 0x95, 0x35, 0x73, 0xe4, 0x0c, 0x13, 0x20, 0x10, 0xb3, 0xbb,
	0x0b, 0x8b, 0x85, 0x7d, 0xd9, 0xa4, 0x19, 0x58, 0x7b, 0x72, 0xe3, 0x6f, 0x4f, 0xc2, 0xd6, 0xd8,
	0xa2, 0x65, 0x23, 0xa3, 0xf6, 0x20, 0x77, 0xa2, 0xb1, 0x33, 0xa6, 0xe8, 0x99, 0x75, 0xb4, 0x71,
	0x03, 0xc0, 0xd2, 0x83, 0xbc, 0xdb, 0x5b, 0x10, 0xce, 0x7f, 0xa2, 0x6b, 0x3a, 0x27, 0x2a, 0xcb,
	0x75, 0x8e, 0xaf, 0xe4, 0x9c, 0x38, 0xbb, 0xb0, 0xe0, 0x89, 0xd0, 0x6d, 0x49, 0x44, 0x4a, 0x5f,
	0x27, 0xb8, 0x7a, 0x22, 0xdc, 0x97, 0x7b, 0x08, 0xb9, 0x42, 0x9a, 0x8d, 0xb3, 0x03, 0x55, 0x4a,
	0x91, 0xa2, 0xa4, 0x36, 0x75, 0x91, 0x54, 0xa4, 0x27, 0x47, 0x94, 0xd7, 0xb6, 0x03, 0x55, 0x5f,
	0xb6, 0x15, 0x52, 0xdd, 0x34, 0xf7, 0x65, 0x9b, 0x90, 0x8d, 0xdf, 0x9d, 0x80, 0xb5, 0xb2, 0xca,
	0x6b, 0x65, 0x81, 0x73, 0x5a, 0xf4, 0xfa, 0x10, 0x91, 0x7e, 0x38, 0x9b, 0x30, 0xc7, 0x42, 0x7e,
	0xae, 0x2d, 0x68, 0xfa, 0xf9, 0x65, 0x86, 0xb8, 0x50, 0x12, 0xc3, 0x88, 0x57, 0xe8, 0xea, 0xe2,
	0xd6, 0xe1, 0x9e, 0x5b, 0xc7, 0x26, 0x33, 0x08, 0xf9, 0xd2, 0xa0, 0x2e, 0xe8, 0x3e, 0xa0, 0x85,
	0x7a, 0xd5, 0xf8, 0xaf, 0x00, 0x1b, 0xe5, 0x45, 0xdd, 0xae, 0x24, 0xf2, 0x6f, 0xc2, 0x32, 0x8e,
	0x8f, 0xbe, 0xbd, 0x10, 0x25, 0xa6, 0xbf, 0x35, 0x91, 0x9e, 0x34, 0xf9, 0xfa, 0x42, 0x94, 0x7c,
	0x59, 0x42, 0xa8, 0xfb, 0x9f, 0x23, 0x7c, 0xe5, 0xdc, 0x86, 0x45, 0x24, 0xec, 0x46, 0x7d, 0xcd,
	0x6f, 0x46, 0xa5, 0x99, 0xa5, 0x27, 0x4f, 0xa2, 0x3e, 0x73, 0x2b, 0x12, 0x69, 0x0b, 0xcb, 0x22,
	0x7a, 0xe5, 0xbc, 0xcd, 0x8f, 0xf4, 0x44, 0x92, 0xf6, 0x34, 0xaf, 0xec, 0x16, 0x0d, 0x3e, 0xf6,
	0x80, 0x50, 0xc4, 0x71, 0x94, 0xf8, 0xc2, 0xba, 0x4d, 0x93, 0x23, 0x7e, 0xe5, 0xbc, 0xc9, 0x8f,
	0xef, 0xa0, 0xc2, 0x66, 0xbe, 0xd5, 0x2c, 0x15, 0x5e, 0xa4, 0x27, 0x8f, 0x45, 0xaa, 0xdf, 0x3a,
	0x4f, 0x78, 0x41, 0x05, 0x3e, 0x47, 0x08, 0x91, 0xe3, 0x32, 0x8a, 0x52, 0x6e, 0x1c, 0xe7, 0xf5,
	0x29, 0x68, 0x3b, 0x3f, 0x8e, 0x05, 0xc2, 0x0b, 0x15, 0xe6, 0xce, 0x11, 0xd2, 0x38, 0x22, 0xa1,
	0x35, 0x8e, 0x2a, 0xeb, 0xd0, 0x97, 0x6d, 0x7b, 0x1c, 0x73, 0x44, 0x17, 0xca, 0xf8, 0xb2, 0x88,
	0x68, 0x1c, 0x91, 0x28, 0x37, 0x8e, 0xd9, 0x85, 0x19, 0x7c, 0x6c, 0x7e, 0x1c, 0x0b, 0xc4, 0x17,
	0xd6, 0x25, 0x99, 0x1c, 0x31, 0x8d, 0x23, 0x12, 0x5b, 0xe3, 0xb8, 0x92, 0x0d, 0x8f, 0x2f, 0xdb,
	0xf6, 0x38, 0xe6, 0x08, 0x2f, 0xac, 0xcb, 0x0c, 0x16, 0xe1, 0x2b, 0x74, 0x29, 0x70, 0xc0, 0x29,
	0xe9, 0x69, 0x24, 0xaa, 0xbd, 0x22, 0xd2, 0x93, 0x47, 0xc3, 0x5e, 0xcf, 0x32, 0x99, 0xee, 0xc3,
	0x2a, 0x32, 0x2e, 0xd2, 0x73, 0x20, 0x7b, 0xc5, 0x97, 0xed, 0x02, 0x3d, 0x2a, 0xe3, 0x4c, 0x8c,
	0xc9, 0xc9, 0x5f, 0x57, 0xca, 0x58, 0x4b, 0x31, 0x15, 0x3f, 0x68, 0x40, 0xcd, 0x08, 0x28, 0x51,
	0x6d, 0xb0, 0x6e, 0x51, 0xf2, 0x49, 0x34, 0x8a, 0x97, 0x1a, 0x2a, 0xa2, 0xda, 0xdc, 0x9d, 0x52,
	0xbc, 0x78, 0x94, 0x6c, 0x5e, 0xf4, 0xf2, 0x44, 0x55, 0x27, 0x2a, 0x2d, 0x3f, 0x9a, 0x97, 0x25,
	0x16, 0x44, 0xb5, 0xc5, 0xfd, 0x32, 0x52, 0xa1, 0x79, 0x99, 0x09, 0x27, 0xaa, 0x6d, 0xee, 0x97,
	0x9a, 0x6f, 0x9b, 0x97, 0xdd, 0xaf, 0x1d, 0xee, 0x97, 0x99, 0x3d, 0x9b, 0x57, 0xd6, 0xaf, 0x6b,
	0xdc, 0x2f, 0x35, 0x1f, 0x44, 0xa3, 0x96, 0xbd, 0x36, 0xdb, 0x88, 0x6c, 0xd7, 0xbc, 0x24, 0xd7,
	0x10, 0x24, 0xc2, 0x77, 0x60, 0xc5, 0x26, 0x64, 0x69, 0xb8, 0x95, 0x5b, 0x80, 0x4c, 0x4d, 0xf2,
	0x50, 0x42, 0x7d, 0x41, 0x85, 0x06, 0x4b, 0xa8, 0xcd, 0xe2, 0xca, 0x75, 0xe2, 0xb6, 0x79, 0xa3,
	0x7c, 0x27, 0x6c, 0x42, 0xee, 0xc4, 0x9d, 0x9c, 0xf4, 0xe6, 0x3b, 0x51, 0xa4, 0xbe, 0xa8, 0xdf,
	0x2d, 0xa7, 0x7e, 0xd5, 0xf8, 0xdf, 0x93, 0xb0, 0x56, 0x56, 0xf0, 0x12, 0xad, 0xf6, 0x21, 0x25,
	0x3e, 0x44, 0x7e, 0xe2, 0xf6, 0x03, 0x11, 0xba, 0xfa, 0x5e, 0xb0, 0x75, 0x16, 0x3a, 0x4c, 0x24,
	0x85, 0x33, 0x8e, 0x02, 0x11, 0x1e, 0x71, 0x16, 0x1e, 0xee, 0xe2, 0xef, 0xc2, 0x7a, 0x10, 0x9e,
	0x92, 0x41, 0xad, 0xe3, 0x7b, 0x1c, 0x89, 0xe7, 0xbd, 0xc4, 0x61, 0xa4, 0x0a, 0xf1, 0x71, 0x14,
	0x7e, 0x0f, 0xae, 0xdb, 0x4d, 0x46, 0x23, 0xf0, 0xac, 0xbe, 0xb7, 0xb3, 0xa6, 0x23, 0xd1, 0xf7,
	0x87, 0xb0, 0x91, 0xab, 0xac, 0x96, 0x3d, 0x96, 0x35, 0xba, 0x93, 0x95, 0x50, 0x33, 0x8f, 0xdd,
	0x87, 0x1b, 0xb9, 0x36, 0xa3, 0xcf, 0x65, 0x35, 0xbf, 0x9d, 0xb5, 0x1d, 0x79, 0xee, 0xfb, 0xb0,
	0x69, 0x78, 0x9c, 0x05, 0xa1, 0x9b, 0xd5, 0xf1, 0x52, 0xea, 0x7f, 0x55, 0x35, 0xfe, 0x22, 0x08,
	0x4d, 0x01, 0xaf, 0xc6, 0xdf, 0x9f, 0x80, 0xed, 0xf1, 0x95, 0x41, 0x47, 0x76, 0xb9, 0x5d, 0x58,
	0xa0, 0xd4, 0x18, 0x2a, 0x30, 0x11, 0xf8, 0x6a, 0xb7, 0x03, 0x84, 0x3d, 0xf5, 0xa2, 0xf0, 0x29,
	0x5d, 0x09, 0x57, 0xe9, 0x33, 0x9a, 0x86, 0xad, 0xbc, 0x05, 0x86, 0x2a, 0xaa, 0x9b, 0x30, 0x6f,
	0x9c, 0x94, 0xc0, 0x57, 0x23, 0x03, 0x1a, 0xf4, 0xd4, 0x2f, 0x4b, 0xfe, 0x69, 0x7c, 0x06, 0x1b,
	0xe5, 0xd5, 0x46, 0x9d, 0x6d, 0xa8, 0xe8, 0x7a, 0xa3, 0xaa, 0xb3, 0xe6, 0x37, 0x5a, 0x10, 0x54,
	0xbc, 0x54, 0x1f, 0xbd, 0xd3, 0x8f, 0xc6, 0xff, 0x9c, 0x80, 0x37, 0xae, 0x56, 0x55, 0x14, 0xdf,
	0xa8, 0xe0, 0xb1, 0xf0, 0x23, 0x16, 0x5a, 0xb6, 0xab, 0x72, 0x17, 0x16, 0x93, 0xa8, 0x17, 0xf8,
	0x32, 0x76, 0x45, 0xdf, 0x3a, 0x76, 0xaf, 0x29, 0x28, 0xfb, 0x84, 0xce, 0x07, 0xb0, 0x90, 0x73,
	0x1c, 0xa7, 0xc6, 0x3a, 0x8e, 0xf3, 0x5d, 0xcb, 0x55, 0xfc, 0x14, 0xd6, 0x71, 0x49, 0xb7, 0x84,
	0x77, 0x92, 0x77, 0x3c, 0xa7, 0xc7, 0x67, 0x6d, 0x89, 0xf4, 0x64, 0x5f, 0x78, 0x27, 0x96, 0xc7,
	0xd9, 0xf8, 0x83, 0x09, 0xb8, 0x7b, 0xa5, 0x4a, 0xa6, 0x57, 0xb4, 0xc3, 0x56, 0x61, 0xc6, 0xb6,
	0x6a, 0xa6, 0x07, 0xb8, 0xf2, 0x15, 0x50, 0x5b, 0x30, 0x08, 0x7c, 0xe5, 0x5c, 0x87, 0x8a, 0xba,
	0x4f, 0x65, 0x5b, 0x60, 0x73, 0x0c, 0xfb, 0xd2, 0x42, 0xdb, 0x56, 0x98, 0x42, 0xbf, 0x6a, 0xfc,
	0xe1, 0x14, 0x2c, 0x17, 0xcb, 0x32, 0x8c, 0x74, 0x91, 0xae, 0x46, 0xd0, 0x06, 0x35, 0xa9, 0xaf,
	0x46, 0xd0, 0xae, 0xa4, 0xe3, 0xcd, 0x53, 0x56, 0xbc, 0x79, 0x13, 0xe6, 0xb4, 0x78, 0x72, 0xfa,
	0xcf, 0x6c, 0xc0, 0x82, 0x59, 0x96, 0x74, 0x76, 0x53, 0x95, 0x7b, 0x98, 0x25, 0xbb, 0xdc, 0xbe,
	0xea, 0xa6, 0xaa, 0x3c, 0xbc, 0x07, 0x0b, 0x7c, 0x5e, 0x1b, 0xb4, 0xdd, 0xae, 0x48, 0xc8, 0x54,
	0x2e, 0x0d, 0x97, 0x72, 0xbd, 0xa3, 0xa7, 0xed, 0x27, 0x22, 0x71, 0x6e, 0xc3, 0x7c, 0xd4, 0xa2,
	0x9c, 0xd0, 0x33, 0x71, 0x91, 0x58, 0xe6, 0x14, 0x30, 0xf8, 0x0b, 0x71, 0x91, 0x50, 0x54, 0x2a,
	0x1a, 0x86, 0xbe, 0x32, 0xa0, 0xf9, 0x07, 0xe7, 0x45, 0x26, 0xfa, 0x3a, 0xe9, 0xbc, 0xce, 0x8b,
	0x4c, 0xd4, 0x75, 0xd2, 0x07, 0xaa, 0x46, 0xca, 0x42, 0xbe, 0x42, 0x69, 0x49, 0x39, 0x15, 0x55,
	0x40, 0x85, 0x62, 0x5f, 0x41, 0x28, 0x55, 0x09, 0x23, 0xfe, 0xc1, 0x3e, 0x0e, 0x17, 0xed, 0xe2,
	0x1e, 0xe9, 0xeb, 0x4f, 0x0a, 0xfa, 0x39, 0x01, 0xa9, 0x40, 0x52, 0x18, 0xa8, 0x1b, 0x88, 0x4b,
	0xaa, 0x40, 0x52, 0x18, 0xd0, 0xfd, 0xc3, 0xc6, 0x0b, 0xd8, 0x28, 0x2f, 0x48, 0x7b, 0xd5, 0x53,
	0x01, 0xca, 0x83, 0x9f, 0xca, 0xae, 0x75, 0x36, 0xfe, 0xef, 0x04, 0xd4, 0xc7, 0x55, 0xea, 0xb8,
	0x12, 0x53, 0x6b, 0xea, 0xa7, 0x8a, 0x53, 0xdf, 0x17, 0xe6, 0xf2, 0x20, 0xfd, 0x6f, 0xa6, 0x7e,
	0x66, 0xdc, 0xd4, 0xe7, 0xa7, 0x62, 0xb6, 0x38, 0x15, 0xa6, 0xe8, 0xcc, 0x5c, 0xb1, 0xe8, 0x8c,
	0x19, 0xf3, 0x8a, 0x3d, 0xe6, 0xb9, 0xc1, 0xac, 0x16, 0x06, 0xf3, 0x8f, 0x26, 0xd4, 0x95, 0xcc,
	0x42, 0xf1, 0xdc, 0x3f, 0xf7, 0x6b, 0x93, 0xc4, 0x4f, 0x5b, 0x12, 0x6f, 0x52, 0x37, 0x67, 0x4a,
	0x53, 0x37, 0x67, 0xed, 0x53, 0x8f, 0x2d, 0xa8, 0x24, 0xc3, 0x16, 0xd7, 0xf0, 0x62, 0x1f, 0x71,
	0x2e, 0x19, 0xb6, 0x0e, 0x55, 0x81, 0x2f, 0xae, 0xee, 0x42, 0x6e, 0x2d, 0x7b, 0xc8, 0x55, 0x82,
	0xd0, 0x55, 0xaa, 0xbf, 0x3e, 0x09, 0x4b, 0x85, 0x4a, 0xbe, 0x63, 0x5f, 0x65, 0xea, 0xf5, 0x89,
	0xa1, 0xf4, 0x10, 0x55, 0x34, 0x8d, 0xdc, 0xe3, 0x06, 0xd4, 0xa8, 0x14, 0x29, 0x1b, 0x0f, 0x81,
	0xaf, 0x56, 0x0a, 0xd5, 0x15, 0x26, 0x7b, 0xe1, 0x69, 0x56, 0x9f, 0x8d, 0x18, 0x5a, 0x15, 0xbc,
	0xa8, 0xff, 0xd6, 0x98, 0x2d, 0xe6, 0xc6, 0x8c, 0x2e, 0x97, 0x45, 0x67, 0x2e, 0xdd, 0xda, 0x2e,
	0x04, 0x35, 0x97, 0x11, 0xf3, 0x33, 0x29, 0x07, 0xf6, 0xed, 0x6f, 0xa2, 0xe6, 0xc1, 0x73, 0xd4,
	0x30, 0x74, 0xa3, 0x33, 0x3e, 0xaa, 0xfe, 0xed, 0x09, 0xd8, 0x1c, 0x53, 0x8d, 0xd8, 0xdc, 0x4c,
	0x99, 0x28, 0xbb, 0x99, 0xf2, 0xba, 0x63, 0xa6, 0x4f, 0xb3, 0x7a, 0x83, 0x59, 0xd8, 0xf4, 0xd2,
	0x2b, 0x2d, 0xba, 0xc2, 0xa0, 0x89, 0x9e, 0x06, 0x5f, 0xcb, 0xc6, 0x3f, 0x99, 0x80, 0xb5, 0xb2,
	0xf2, 0xc6, 0x65, 0x0a, 0x38, 0xb7, 0xf5, 0xa9, 0x5f, 0x28, 0x37, 0x9c, 0x5b, 0xaf, 0x52, 0x7e,
	0xe9, 0x47, 0xf6, 0x1a, 0xd3, 0xaf, 0x79, 0x8d, 0x31, 0xd3, 0x4d, 0x62, 0x31, 0x9b, 0xbf, 0x5e,
	0xc7, 0x59, 0x88, 0x73, 0x56, 0x16, 0x62, 0xe3, 0x5f, 0x4c, 0xc2, 0x7a, 0x69, 0x49, 0xe5, 0xab,
	0x6a, 0x20, 0xca, 0x37, 0x9e, 0xb2, 0xf2, 0x8d, 0x2f, 0xad, 0x73, 0x87, 0x66, 0x00, 0x05, 0x20,
	0x0a, 0x96, 0x5b, 0x8d, 0xa0, 0xf6, 0x15, 0x12, 0x19, 0xfa, 0xc5, 0x40, 0xd4, 0xbc, 0x0c, 0xb3,
	0xec, 0xab, 0x45, 0x98, 0x4c, 0x06, 0xea, 0x80, 0x63, 0x32, 0x19, 0x50, 0x0d, 0x01, 0x39, 0x10,
	0x41, 0xec, 0x9e, 0x06, 0x03, 0xbd, 0x98, 0x18, 0xf2, 0xf3, 0x60, 0xe0, 0xbc, 0x03, 0x95, 0x44,
	0xa5, 0x0d, 0x91, 0xe2, 0x28, 0x1d, 0xd1, 0xb9, 0x84, 0x33, 0x87, 0x9c, 0x77, 0x61, 0x5e, 0x31,
	0xbb, 0x34, 0x39, 0x53, 0x3d, 0x91, 0xce, 0x0f, 0xff, 0xe3, 0x24, 0x6c, 0x8e, 0xa9, 0x26, 0x4d,
	0xb7, 0x2c, 0x74, 0x2d, 0x6a, 0x33, 0xa6, 0xa0, 0x41, 0x4f, 0x69, 0xc7, 0xb2, 0xb2, 0x7e, 0x55,
	0x41, 0x12, 0x73, 0x46, 0xe9, 0xbc, 0x9d, 0x3b, 0x3b, 0xdc, 0xb4, 0x6a, 0x3a, 0x07, 0xa1, 0x2c,
	0x1e, 0x21, 0x5e, 0x59, 0x70, 0x7e, 0x04, 0xdb, 0x6d, 0x11, 0xf7, 0xdd, 0xb6, 0x48, 0x52, 0xb7,
	0x2b, 0xe2, 0x53, 0x39, 0x1a, 0xfb, 0xdb, 0x44, 0x8a, 0x47, 0x22, 0x49, 0x9f, 0x30, 0xde, 0x0c,
	0xff, 0x47, 0xf9, 0x7b, 0xba, 0xd5, 0x7c, 0xa5, 0x84, 0xdc, 0x38, 0x50, 0x44, 0xce, 0xbe, 0xc2,
	0x9b, 0xdd, 0x4b, 0x57, 0xe9, 0x53, 0xca, 0x06, 0x54, 0x07, 0x48, 0xea, 0x5e, 0x3a, 0x67, 0x4e,
	0x1d, 0x33, 0xaa, 0xf1, 0xa7, 0x13, 0xb0, 0x5e, 0x5a, 0x5c, 0xfb, 0x4a, 0x72, 0x7a, 0x0b, 0x16,
	0x3a, 0xe8, 0xdb, 0xaa, 0x4c, 0x7d, 0x5d, 0xd1, 0x05, 0x61, 0xaf, 0x18, 0x84, 0x24, 0xa4, 0x85,
	0x34, 0x09, 0x5b, 0x67, 0xf3, 0x08, 0xd3, 0x24, 0xa6, 0xac, 0xd8, 0x8c, 0x55, 0x56, 0xcc, 0xb9,
	0x0d, 0xaa, 0x80, 0xb5, 0x36, 0x6c, 0x67, 0x4d, 0xd6, 0x43, 0xdc, 0x91, 0xca, 0xae, 0x35, 0x93,
	0x32, 0xf7, 0x9a, 0x43, 0xf5, 0x7f, 0x3c, 0x09, 0xeb, 0xa5, 0x85, 0xbf, 0xbf, 0xf5, 0x7a, 0x2c,
	0xdb, 0xc0, 0xd0, 0x21, 0xc8, 0x2f, 0x40, 0xf3, 0xfb, 0x2f, 0xf6, 0x7d, 0x9c, 0x87, 0x30, 0xcf,
	0x47, 0x14, 0x4c, 0x5e, 0x19, 0x6b, 0xfa, 0x11, 0x15, 0xaf, 0xbe, 0xf7, 0x61, 0xa3, 0x25, 0xdb,
	0x54, 0xbb, 0x2a, 0x8e, 0xfa, 0x83, 0xb4, 0x78, 0xd3, 0x60, 0x8d, 0xb1, 0x2f, 0x08, 0x69, 0x82,
	0xc9, 0xff, 0x76, 0x12, 0xd6, 0x4b, 0xcb, 0x9c, 0x67, 0x56, 0xc6, 0x44, 0xd1, 0xca, 0x78, 0x1b,
	0xb8, 0xb0, 0xbe, 0x6b, 0x57, 0x03, 0xd2, 0x34, 0x8b, 0x84, 0xda, 0x33, 0xd5, 0x07, 0xde, 0x2c,
	0xab, 0xe7, 0xa6, 0xee, 0xac, 0xe5, 0xaa, 0xb6, 0x7d, 0x04, 0x9b, 0x39, 0x42, 0x8b, 0x7b, 0x96,
	0x9f, 0xb1, 0x6e, 0x37, 0xc9, 0x1e, 0x52, 0xd7, 0x15, 0xe6, 0xac, 0x38, 0x2c, 0x97, 0x93, 0x7b,
	0x9b, 0xca, 0x18, 0xa4, 0xd2, 0xe2, 0x36, 0x6b, 0xf5, 0x15, 0x51, 0x19, 0x1b, 0xbb, 0xb0, 0xd6,
	0x5c, 0xbe, 0xb0, 0xd6, 0x77, 0x60, 0xc5, 0x2e, 0x4e, 0xc5, 0xc7, 0xa6, 0xac, 0x2f, 0x97, 0xb2,
	0x8a, 0x54, 0x74, 0x70, 0xda, 0xf8, 0xdd, 0x09, 0x58, 0x19, 0x29, 0xf9, 0x7e, 0x25, 0x49, 0x7c,
	0x07, 0xaa, 0x74, 0x7d, 0x86, 0xb4, 0xc3, 0x54, 0xee, 0xd6, 0x35, 0x32, 0x23, 0x9d, 0x50, 0xe9,
	0xa8, 0xff, 0x70, 0x65, 0xd1, 0xfc, 0x2b, 0xe3, 0x92, 0x7f, 0x64, 0x42, 0x36, 0xf3, 0x9a, 0x45,
	0xf3, 0x87, 0x93, 0xe0, 0x8c, 0x16, 0x96, 0xbf, 0xea, 0xa5, 0x73, 0xde, 0x15, 0xa7, 0xec, 0xdc,
	0xfc, 0x91, 0x35, 0x30, 0x5d, 0xb2, 0x06, 0xea, 0x30, 0xa7, 0x95, 0x05, 0xaf, 0x21, 0xfd, 0xd3,
	0x79, 0x0b, 0x96, 0xf5, 0x1d, 0x22, 0xe1, 0xfb, 0x81, 0xa5, 0x4f, 0x97, 0x14, 0x7c, 0x4f, 0x81,
	0x9d, 0xef, 0xc1, 0x1a, 0xdf, 0xc8, 0x54, 0xcf, 0xd3, 0x1c, 0x79, 0xd2, 0x1c, 0xc2, 0xf1, 0xab,
	0x69, 0x2d, 0xb4, 0x09, 0x73, 0xa7, 0xc1, 0xc0, 0x95, 0xe7, 0x7a, 0x97, 0x9b, 0x3d, 0x0d, 0x06,
	0x9f, 0x9e, 0x0f, 0xcc, 0xe2, 0xaf, 0x5a, 0x8b, 0x9f, 0x6a, 0xc8, 0x46, 0xfe, 0xd0, 0xa3, 0x6b,
	0x09, 0xea, 0x80, 0x5e, 0x41, 0x9e, 0xfa, 0x8d, 0xbf, 0x32, 0x0d, 0xab, 0x25, 0xd5, 0xf4, 0xbf,
	0x75, 0x4e, 0xd2, 0xf7, 0xf3, 0xbb, 0x42, 0xbe, 0x42, 0x47, 0xf6, 0xa0, 0x91, 0x1d, 0xc1, 0x98,
	0xce, 0x15, 0xdb, 0x74, 0xbe, 0x0d, 0xb5, 0xbc, 0x05, 0xc9, 0xcb, 0x7f, 0xe1, 0xc4, 0xb6, 0x1e,
	0xdf, 0x83, 0x2a, 0xca, 0x3e, 0x55, 0xd5, 0x57, 0x1b, 0xf5, 0xb8, 0x5b, 0x1d, 0x15, 0x24, 0xc4,
	0x5e, 0x38, 0x1f, 0x42, 0x4d, 0xdf, 0x38, 0x4c, 0x63, 0x74, 0xdd, 0xe6, 0xc7, 0xc6, 0x09, 0xf4,
	0xf7, 0x48, 0x5e, 0x22, 0x9d, 0xf3, 0x01, 0x2c, 0xd0, 0x9e, 0xa9, 0xb6, 0x4b, 0x55, 0xb5, 0xaa,
	0x34, 0x3e, 0x81, 0x74, 0x6a, 0xd7, 0xcc, 0x1c, 0x86, 0x9a, 0xed, 0x30, 0xdc, 0x81, 0xa9, 0x54,
	0x9c, 0xab, 0xcb, 0xa4, 0x65, 0x3c, 0x10, 0x8d, 0xc6, 0x43, 0x18, 0xe5, 0x73, 0xcb, 0x2b, 0x4d,
	0x08, 0xcd, 0x8d, 0x23, 0x5c, 0xeb, 0x83, 0xd3, 0x01, 0x0f, 0x00, 0x97, 0xd2, 0x98, 0x1b, 0x9c,
	0x0e, 0xe8, 0x3d, 0x6f, 0xc1, 0x82, 0xf0, 0x4f, 0x45, 0x98, 0x8a, 0x0e, 0x95, 0xa8, 0x5d, 0x51,
	0x07, 0x1d, 0x1a, 0xf6, 0xd4, 0x6f, 0x44, 0xb0, 0x32, 0xf2, 0x31, 0x84, 0x91, 0xf9, 0xbf, 0x05,
	0x0b, 0xaa, 0xd0, 0xbb, 0x7d, 0x65, 0x62, 0x9e, 0x61, 0x07, 0x6a, 0x47, 0xa8, 0xe5, 0x73, 0x5e,
	0x2d, 0xed, 0x78, 0x66, 0x65, 0xb9, 0x36, 0xfe, 0xd1, 0x04, 0xac, 0x96, 0x7c, 0x3b, 0xe1, 0x0a,
	0x97, 0xa4, 0xa8, 0xe8, 0x59, 0x14, 0x0d, 0x54, 0x27, 0xa6, 0x74, 0xd1, 0xb3, 0x28, 0x1a, 0x1c,
	0x68, 0x4b, 0x9a, 0x87, 0x79, 0xba, 0xd4, 0x2f, 0x9b, 0xb1, 0x85, 0x6b, 0xcc, 0x8d, 0xab, 0xd9,
	0x71, 0x37, 0xae, 0x7e, 0x67, 0x02, 0xae, 0x5f, 0xfa, 0x85, 0x86, 0xb1, 0x47, 0x5e, 0xf6, 0xc6,
	0xbb, 0x09, 0x73, 0xe4, 0x73, 0x05, 0x3a, 0x39, 0x72, 0x16, 0x7f, 0x72, 0xc4, 0xaf, 0x1f, 0x84,
	0x26, 0x6e, 0xa5, 0x0a, 0xba, 0xf5, 0x83, 0x50, 0x87, 0xb8, 0x90, 0xc0, 0xaa, 0xff, 0x37, 0xa7,
	0x08, 0x4c, 0xbd, 0xbf, 0xc6, 0x3f, 0x9f, 0xe0, 0xb5, 0x5c, 0xf8, 0xd0, 0xc3, 0x48, 0xb7, 0xd0,
	0x3e, 0xbf, 0x18, 0xa8, 0xa8, 0xfb, 0xa4, 0xb2, 0xcf, 0x2f, 0x06, 0x1c, 0x72, 0xd7, 0x48, 0x6b,
	0x65, 0x13, 0xb2, 0xe8, 0xef, 0xe5, 0xa3, 0x42, 0x88, 0xe0, 0xf0, 0xb3, 0x3a, 0x47, 0x9d, 0x0d,
	0x28, 0xd8, 0x4c, 0xee, 0x3f, 0xb9, 0x98, 0x34, 0x2b, 0xda, 0xfd, 0x47, 0xff, 0x92, 0x66, 0x46,
	0x97, 0xf6, 0x9d, 0xcb, 0x4a, 0xfb, 0x36, 0xfe, 0x12, 0xd4, 0xc7, 0x7d, 0x62, 0x62, 0x4c, 0x5e,
	0xe1, 0x06, 0x4c, 0xfb, 0xe2, 0x22, 0xb1, 0x76, 0x6e, 0xfa, 0xed, 0xac, 0xc1, 0x14, 0x2a, 0xc9,
	0x6c, 0x23, 0xc5, 0x9f, 0x8d, 0x3f, 0x5a, 0x80, 0x95, 0x91, 0xaf, 0x4e, 0x8c, 0xe1, 0xfc, 0x8d,
	0x02, 0x05, 0x37, 0x61, 0x5e, 0xdf, 0x5b, 0xc4, 0xc7, 0xaa, 0x98, 0xad, 0x02, 0xa1, 0x7e, 0xde,
	0x81, 0x2a, 0x9b, 0x42, 0x99, 0xea, 0xae, 0x10, 0x00, 0x91, 0x05, 0x3b, 0xa9, 0x7a, 0x15, 0x3b,
	0xe9, 0x21, 0xcc, 0x73, 0xc2, 0xe3, 0x6b, 0xee, 0x57, 0x02, 0x51, 0x71, 0x9b, 0x8f, 0x60, 0xd9,
	0x6a, 0xc3, 0xee, 0xcd, 0xfc, 0xb8, 0xf4, 0xdb, 0xac, 0x1d, 0xe5, 0x03, 0xbe, 0x05, 0x2b, 0x5f,
	0x05, 0x43, 0xb7, 0x33, 0x14, 0xa1, 0x4b, 0x89, 0x81, 0x7d, 0x71, 0xae, 0xca, 0x02, 0x2d, 0x7e,
	0x15, 0x0c, 0x1f, 0x0f, 0x45, 0xb8, 0x37, 0x4c, 0xa3, 0x23, 0x71, 0xee, 0x7c, 0x0c, 0x3b, 0x86,
	0x14, 0x9f, 0x61, 0x72, 0x08, 0x79, 0xe9, 0x72, 0x9a, 0xd4, 0xa6, 0x6a, 0x84, 0xcc, 0x55, 0xda,
	0x20, 0xaf, 0xe3, 0x7d, 0xb8, 0x51, 0xde, 0x3a, 0x08, 0xdb, 0x41, 0x18, 0xa4, 0x5c, 0x17, 0xa8,
	0xd2, 0xdc, 0x1e, 0x65, 0xf0, 0x54, 0x51, 0x38, 0x07, 0xb0, 0x4e, 0xf6, 0xbc, 0x35, 0xaa, 0xfc,
	0xb6, 0xce, 0x98, 0xb7, 0xa5, 0x90, 0xc5, 0xa1, 0x19, 0x5d, 0x7a, 0x63, 0xcd, 0x64, 0x64, 0xc8,
	0x56, 0x2f, 0x63, 0xf2, 0x2c, 0x3f, 0x6c, 0x77, 0x61, 0xb1, 0x35, 0xbc, 0x28, 0x9e, 0x10, 0x56,
	0x9a, 0xb5, 0xd6, 0xd0, 0x4e, 0xc0, 0x7a, 0x27, 0xbb, 0x05, 0x4f, 0x7b, 0x12, 0xd7, 0xb8, 0xe0,
	0x8b, 0x2d, 0xcb, 0xf6, 0x26, 0x44, 0x25, 0x2e, 0xde, 0x87, 0x8d, 0x02, 0xb5, 0x18, 0x08, 0xba,
	0x47, 0xc3, 0xe9, 0x50, 0x6b, 0xb9, 0x16, 0x0a, 0xe7, 0xbc, 0x07, 0x1b, 0x66, 0x60, 0x7f, 0x39,
	0x0c, 0xbc, 0x13, 0xd7, 0x8b, 0xc2, 0x64, 0xd8, 0xe3, 0x4a, 0xa9, 0x95, 0xe6, 0xaa, 0x1a, 0xd0,
	0x5f, 0x45, 0xdc, 0x01, 0xa3, 0xb0, 0x11, 0x1b, 0x8c, 0xb9, 0x8a, 0x10, 0x81, 0x8c, 0x29, 0xef,
	0xa9, 0xd2, 0x5c, 0x25, 0xab, 0xd1, 0x2a, 0x06, 0x11, 0xc8, 0xd8, 0x79, 0x13, 0x96, 0xd5, 0xad,
	0xff, 0xec, 0x80, 0x47, 0xdd, 0x72, 0xa7, 0x9b, 0xff, 0xe6, 0x6c, 0x07, 0xcd, 0xd1, 0x28, 0x3e,
	0x91, 0xb1, 0xab, 0xce, 0x45, 0x06, 0x91, 0xbe, 0x0b, 0xb2, 0xc4, 0x88, 0x5f, 0x23, 0xf8, 0x8b,
	0x28, 0x71, 0x3e, 0x87, 0xbb, 0x41, 0x78, 0x8a, 0x2b, 0xac, 0x3f, 0xec, 0xa5, 0x81, 0x9a, 0x96,
	0x7e, 0x14, 0x26, 0xa9, 0x8c, 0xdd, 0x28, 0xf4, 0x74, 0x2a, 0x36, 0x5f, 0x04, 0xd9, 0x65, 0xe2,
	0x23, 0xa4, 0xa5, 0x39, 0x39, 0x62, 0xca, 0xcf, 0x43, 0x8f, 0x53, 0xb2, 0x9d, 0x4f, 0xe0, 0x9a,
	0x3f, 0x0c, 0x3b, 0x32, 0x0a, 0xd5, 0x5d, 0xa2, 0x24, 0xcd, 0x5d, 0xa2, 0xe2, 0x0c, 0xa8, 0xba,
	0xa2, 0xa1, 0x0b, 0x45, 0x49, 0x6a, 0x5d, 0xa1, 0xfa, 0x18, 0x76, 0xf8, 0xc6, 0x06, 0x8b, 0x46,
	0x14, 0x4a, 0xf7, 0x44, 0x5e, 0xe8, 0x2f, 0x58, 0x51, 0xc2, 0x53, 0xa5, 0xb9, 0x49, 0x24, 0x24,
	0x0f, 0x9f, 0x87, 0xf2, 0x67, 0x52, 0x7f, 0x6e, 0x01, 0xc5, 0x5c, 0xf8, 0x7e, 0x3e, 0xad, 0x56,
	0x4b, 0x3a, 0x8f, 0x98, 0xba, 0xf0, 0x21, 0x7c, 0xdf, 0xca, 0xa7, 0x55, 0x92, 0xce, 0xc3, 0xf7,
	0x09, 0xec, 0x5c, 0xf2, 0xe9, 0x08, 0x4a, 0x5f, 0xaa, 0x34, 0xb7, 0xc6, 0x7e, 0x0a, 0xc2, 0xb9,
	0x07, 0x14, 0x90, 0x73, 0xd5, 0x57, 0x2c, 0xba, 0x51, 0x5f, 0xd2, 0x7d, 0xfa, 0x4a, 0x93, 0x3e,
	0x14, 0xc0, 0x87, 0x8e, 0x4f, 0xa2, 0xbe, 0x2c, 0x52, 0x26, 0x41, 0x27, 0xa4, 0x7b, 0xf4, 0x39,
	0xca, 0xe3, 0xa0, 0x13, 0xd2, 0x8d, 0x7e, 0x8b, 0x92, 0xaf, 0x17, 0xdf, 0xe1, 0x1a, 0x75, 0x19,
	0x29, 0xdd, 0x43, 0xa5, 0x0b, 0x81, 0x48, 0xdb, 0x95, 0xc2, 0x77, 0xa9, 0xe6, 0x33, 0xdd, 0xb4,
	0x57, 0x5f, 0x24, 0x78, 0x22, 0x85, 0xff, 0x08, 0x81, 0xce, 0x07, 0xb0, 0xf9, 0x75, 0x57, 0x86,
	0x1d, 0xf7, 0x6c, 0xc8, 0x82, 0xe8, 0x45, 0xfd, 0x41, 0x4f, 0xa6, 0xd2, 0xaf, 0xbf, 0x41, 0xf4,
	0x6b, 0x84, 0xfe, 0x62, 0x88, 0x82, 0x78, 0xa0, 0x71, 0xb9, 0xdb, 0x56, 0x85, 0x66, 0x6f, 0x52,
	0x33, 0x73, 0xdb, 0x2a, 0xdf, 0xee, 0x1e, 0x2c, 0xab, 0x49, 0x54, 0x0a, 0x24, 0x19, 0xd4, 0xef,
	0xf1, 0xcb, 0x2a, 0x38, 0x69, 0x8a, 0xe3, 0x41, 0xe3, 0x3f, 0x4c, 0xc0, 0x72, 0xf1, 0x33, 0x44,
	0xce, 0x33, 0xb8, 0xa3, 0x9b, 0x9f, 0xd2, 0xc7, 0x60, 0x94, 0xda, 0xe7, 0x82, 0x4a, 0x99, 0xb5,
	0xc1, 0xbb, 0xcd, 0x0d, 0x45, 0xfb, 0xf3, 0x60, 0x70, 0xa8, 0xf6, 0x83, 0xa3, 0x20, 0xcc, 0xca,
	0x54, 0x7c, 0x02, 0x8e, 0x96, 0x52, 0x16, 0x4e, 0x55, 0xce, 0xbd, 0x3c, 0x9b, 0x7b, 0x59, 0xd1,
	0x92, 0x7c, 0xa8, 0xfa, 0x18, 0x1b, 0xf9, 0xf6, 0x52, 0x78, 0x5d, 0xb7, 0x35, 0xb4, 0xaf, 0x0b,
	0xac, 0xda, 0xad, 0x3e, 0x15, 0x5e, 0x77, 0x7f, 0x78, 0x81, 0x26, 0xc5, 0xe6, 0x98, 0xcf, 0x23,
	0x8d, 0xfb, 0xc4, 0x05, 0x45, 0x8b, 0x8d, 0xd3, 0xa7, 0xa2, 0xc5, 0x64, 0xe3, 0x5f, 0x07, 0x88,
	0x87, 0x3d, 0xa9, 0xc4, 0x81, 0x0d, 0x88, 0x2a, 0x42, 0x58, 0x10, 0x76, 0x80, 0x7e, 0xb8, 0x56,
	0x2c, 0xb3, 0x82, 0x00, 0xb2, 0x3c, 0x3e, 0x86, 0x05, 0xfd, 0x05, 0x27, 0x13, 0xc6, 0xce, 0xc2,
	0x4d, 0xf9, 0x2e, 0x72, 0xc1, 0xdd, 0x24, 0xfb, 0xd1, 0xf8, 0xbd, 0x69, 0xd8, 0x28, 0xff, 0x26,
	0xd3, 0x95, 0x1c, 0x9d, 0xdb, 0x50, 0xd3, 0xde, 0xdc, 0x20, 0x0e, 0x3c, 0x1d, 0xa7, 0x5d, 0x50,
	0xc0, 0x17, 0x08, 0xc3, 0xee, 0x47, 0xac, 0x07, 0x3c, 0x53, 0xdf, 0x29, 0xa2, 0x55, 0xef, 0x11,
	0x07, 0xf3, 0xa5, 0x48, 0xab, 0x3e, 0xc3, 0x82, 0x06, 0x52, 0xc9, 0x2d, 0x3a, 0xa4, 0xe5, 0xd2,
	0x18, 0xca, 0x20, 0x32, 0xbf, 0x4b, 0xbf, 0x65, 0x52, 0x7e, 0xab, 0x5c, 0x1b, 0x9d, 0x60, 0x19,
	0x9d, 0x3b, 0x50, 0xc5, 0xd5, 0xca, 0x8f, 0xe6, 0xaf, 0x77, 0x54, 0x10, 0xa0, 0x3f, 0xc3, 0x41,
	0x48, 0x7a, 0xed, 0x85, 0x0c, 0x49, 0xe6, 0xa0, 0x7d, 0x70, 0xac, 0xa2, 0xff, 0xe6, 0xe0, 0x98,
	0x2a, 0x25, 0x04, 0x11, 0x6d, 0x68, 0x8b, 0xba, 0x52, 0x02, 0xff, 0x46, 0xa6, 0xa8, 0xfd, 0x59,
	0x89, 0x72, 0xfe, 0x4c, 0xa5, 0x35, 0xbc, 0x60, 0xa5, 0x69, 0xdc, 0xfa, 0xb5, 0xd7, 0x47, 0xb6,
	0xc9, 0x3c, 0x5c, 0xb7, 0xbe, 0xfc, 0x90, 0xbf, 0x78, 0xb1, 0x71, 0x85, 0x8b, 0x17, 0x0f, 0x60,
	0x8d, 0x75, 0x34, 0xd7, 0xcb, 0x51, 0x27, 0x91, 0xbe, 0x4a, 0xf5, 0x5d, 0x21, 0x1c, 0x15, 0xc8,
	0x21, 0xf2, 0xa7, 0x7e, 0xe3, 0x7f, 0x4c, 0xc1, 0xe6, 0x98, 0x2f, 0x6e, 0x7d, 0xeb, 0x20, 0x9c,
	0x99, 0xac, 0xe9, 0xb2, 0xc9, 0xb2, 0x43, 0xf7, 0x23, 0xd2, 0x36, 0xfb, 0x3a, 0x69, 0x9b, 0x2b,
	0x48, 0x5b, 0x6e, 0xba, 0x2b, 0x97, 0x4d, 0x77, 0xb5, 0x30, 0xdd, 0x23, 0x72, 0x0a, 0xe3, 0xe4,
	0x34, 0xc9, 0x0a, 0x0e, 0x14, 0x64, 0xc2, 0xc8, 0xf0, 0x42, 0x41, 0x86, 0x6d, 0x79, 0xa9, 0x5d,
	0x26, 0x2f, 0x4e, 0x41, 0x5e, 0xf2, 0x53, 0xbe, 0xfa, 0xe7, 0x98, 0xf2, 0xb5, 0x71, 0x53, 0xee,
	0xc1, 0xf6, 0xf8, 0x8f, 0xa1, 0x5d, 0x31, 0xc3, 0xe1, 0x26, 0xcc, 0x5b, 0xdf, 0x5b, 0x53, 0x7e,
	0x2b, 0x08, 0xc3, 0xaf, 0xf1, 0x5b, 0x13, 0xb0, 0xfb, 0xba, 0xcf, 0xa1, 0x51, 0x9d, 0xcf, 0x20,
	0x54, 0x57, 0x6b, 0x6d, 0x67, 0xbb, 0xd6, 0x0f, 0x42, 0x6a, 0x6b, 0x2a, 0x79, 0xa1, 0xc5, 0x62,
	0xd3, 0xa9, 0xd4, 0xc9, 0xbe, 0x38, 0xb7, 0xe8, 0xae, 0x7a, 0x1a, 0xd0, 0xf8, 0x6f, 0x13, 0xb0,
	0x35, 0xf6, 0x23, 0x6a, 0x94, 0x1f, 0xec, 0xfb, 0x6a, 0x23, 0x33, 0xc5, 0x05, 0x75, 0xd6, 0xb1,
	0xef, 0xd3, 0xbe, 0x65, 0x0a, 0x0b, 0xde, 0x03, 0x84, 0xe5, 0x0a, 0x09, 0x28, 0x77, 0x77, 0x51,
	0xf8, 0x76, 0xf9, 0x00, 0xdc, 0xd6, 0x91, 0xd2, 0xaa, 0x5e, 0x68, 0x1a, 0xa8, 0x6b, 0x2f, 0xc2,
	0xf7, 0x9f, 0xe8, 0xe2, 0x85, 0xa6, 0x99, 0x71, 0xd7, 0xe6, 0xf2, 0x17, 0xcc, 0x96, 0xb4, 0x07,
	0xa6, 0x67, 0x41, 0x5d, 0x66, 0x51, 0x60, 0x3d, 0x13, 0xff, 0x7d, 0x12, 0xd6, 0xca, 0x3e, 0xee,
	0xe6, 0xbc, 0x0b, 0xeb, 0x94, 0x3f, 0x65, 0xea, 0x28, 0xe6, 0x67, 0xd3, 0xe9, 0x8b, 0x73, 0x5d,
	0x45, 0x51, 0xf1, 0x72, 0xbe, 0x07, 0x9c, 0x64, 0x6f, 0xce, 0x32, 0x54, 0x0b, 0x9e, 0x0d, 0x2e,
	0xf4, 0xa8, 0x8e, 0x32, 0x54, 0x8b, 0x77, 0x61, 0x5d, 0x7d, 0x47, 0xd4, 0xdc, 0x9f, 0xe6, 0x09,
	0x9c, 0xb1, 0x9a, 0xe8, 0x8b, 0xd3, 0x3c, 0x8b, 0x0f, 0x60, 0x4d, 0x7f, 0xaa, 0x2e, 0x2c, 0x89,
	0x56, 0xb4, 0xf8, 0x4d, 0x2c, 0x93, 0x61, 0x0b, 0x2a, 0x4a, 0x34, 0x74, 0x6c, 0x77, 0x8e, 0x7e,
	0x1f, 0xf8, 0x68, 0xf3, 0x52, 0x68, 0xd8, 0xdc, 0x1d, 0xec, 0x7b, 0xea, 0x4a, 0xb8, 0x7d, 0x11,
	0xb2, 0xde, 0x17, 0xe7, 0x4d, 0x4d, 0x72, 0xe4, 0x3d, 0xce, 0x24, 0xea, 0x21, 0x6c, 0xd0, 0x47,
	0x2d, 0xf4, 0xd7, 0xf3, 0x7a, 0x51, 0x27, 0x77, 0x01, 0x12, 0x07, 0x49, 0x0d, 0xee, 0xb3, 0xa8,
	0xc3, 0x57, 0x1f, 0xff, 0xdd, 0x04, 0x6c, 0x8f, 0xff, 0xfc, 0xdd, 0xb7, 0x0e, 0x37, 0x3a, 0x30,
	0x9d, 0x06, 0x83, 0x44, 0x47, 0x58, 0xf0, 0x7f, 0xe7, 0x06, 0x54, 0x94, 0x21, 0x9c, 0x58, 0xae,
	0xbf, 0x81, 0x59, 0x05, 0x66, 0xd5, 0xd7, 0x82, 0xa6, 0xee, 0x55, 0x75, 0x2c, 0xf2, 0x90, 0xb3,
	0x92, 0x6b, 0x8a, 0x40, 0xc5, 0x7e, 0xb3, 0xdc, 0x84, 0x05, 0x46, 0x70, 0x88, 0xae, 0xf1, 0xaf,
	0xa6, 0xc0, 0x19, 0xfd, 0x00, 0xdf, 0xc8, 0xcb, 0xdc, 0x51, 0xdb, 0x41, 0xfe, 0xf3, 0x3b, 0xa8,
	0x4a, 0xd5, 0xa9, 0x9d, 0x3e, 0xa5, 0x19, 0x7b, 0x90, 0x6f, 0x07, 0x90, 0x6e, 0xc1, 0x82, 0xbe,
	0xb7, 0x4a, 0xdf, 0x87, 0x9a, 0x31, 0x29, 0x98, 0x08, 0x7b, 0x29, 0xcf, 0x53, 0x73, 0xd3, 0x70,
	0xf6, 0xd2, 0x9b, 0x86, 0x0f, 0x61, 0x9e, 0xdf, 0xcf, 0xb5, 0x0a, 0xa3, 0xae, 0xe4, 0x82, 0x90,
	0x1c, 0xa6, 0x15, 0xe6, 0x7f, 0xae, 0xd0, 0x1a, 0x4a, 0x5d, 0xdb, 0x83, 0x7f, 0x38, 0x3f, 0x86,
	0x15, 0x74, 0x0f, 0x3b, 0x22, 0x6e, 0xb5, 0xa4, 0xff, 0xba, 0x00, 0xc6, 0x92, 0xe8, 0xf5, 0x1e,
	0x33, 0x29, 0x2b, 0xeb, 0xb7, 0x60, 0x59, 0x9e, 0x0f, 0x28, 0x0e, 0x57, 0x28, 0x19, 0xb8, 0xa4,
	0xe0, 0xf6, 0xa7, 0x47, 0xfa, 0xe4, 0x18, 0x67, 0xc5, 0x6e, 0x2a, 0x7d, 0x74, 0x88, 0x87, 0x5c,
	0x98, 0x28, 0x5b, 0x4a, 0x6a, 0xf3, 0xe9, 0xeb, 0x05, 0xb4, 0xcb, 0x45, 0x54, 0xe9, 0x63, 0x85,
	0x3d, 0x19, 0xaa, 0x0d, 0x08, 0xfa, 0xe2, 0x1c, 0x87, 0xec, 0x99, 0x0c, 0x1b, 0x7f, 0x6b, 0x12,
	0x36, 0xca, 0xbf, 0x83, 0x38, 0x32, 0xa3, 0x3f, 0x81, 0x65, 0x4a, 0x6a, 0xb1, 0x3f, 0x4e, 0x36,
	0x99, 0x0f, 0x75, 0x8b, 0x44, 0xda, 0x1f, 0x27, 0x6b, 0xe5, 0x7e, 0xd3, 0x72, 0xb6, 0x18, 0x98,
	0x7a, 0xf3, 0xaa, 0xdc, 0x53, 0x46, 0xad, 0x0b, 0xcb, 0xd3, 0x85, 0x8b, 0x18, 0x75, 0xa4, 0xec,
	0x09, 0x9d, 0x39, 0x06, 0x04, 0x3a, 0x44, 0x08, 0x1a, 0xd7, 0x21, 0x7d, 0x88, 0x91, 0xf0, 0xaa,
	0x82, 0x28, 0x42, 0x18, 0x7d, 0x13, 0xe6, 0x55, 0xd1, 0x40, 0x12, 0x1a, 0x75, 0x9b, 0x81, 0x41,
	0x24, 0x33, 0x75, 0x98, 0x41, 0x4c, 0x62, 0x27, 0xe2, 0x10, 0xa0, 0xf1, 0x37, 0x26, 0x60, 0x7b,
	0xfc, 0xb7, 0x1c, 0xcb, 0x96, 0x2e, 0xba, 0x72, 0x7a, 0xe9, 0xe2, 0xff, 0xa5, 0xdf, 0x32, 0xb3,
	0x4f, 0x20, 0xa7, 0x0b, 0x27, 0x90, 0xd7, 0xa0, 0xea, 0x07, 0x31, 0xe7, 0x23, 0xe8, 0x77, 0x31,
	0x80, 0xc6, 0x1f, 0x4f, 0x41, 0x7d, 0xdc, 0x37, 0x20, 0x9d, 0x9f, 0x40, 0xcd, 0x7c, 0xe6, 0xd1,
	0x9a, 0x97, 0x4b, 0xae, 0xfd, 0x37, 0x17, 0x22, 0xeb, 0x97, 0x73, 0x00, 0x4b, 0x26, 0xf3, 0x92,
	0x57, 0xbb, 0x3a, 0x75, 0xd7, 0x2c, 0x0e, 0xa3, 0xbe, 0x4c, 0xd2, 0xc0, 0xe3, 0x93, 0x0c, 0xf3,
	0x2d, 0x5d, 0x6e, 0xc2, 0x40, 0xe7, 0x3e, 0x4c, 0x53, 0x34, 0x7e, 0x3a, 0xd7, 0xb2, 0xec, 0xb3,
	0xc5, 0x44, 0xc7, 0x39, 0x98, 0xd9, 0x0e, 0xc0, 0x3f, 0x70, 0x85, 0x92, 0xdd, 0xa3, 0xea, 0xe4,
	0x8c, 0xfd, 0x60, 0x1b, 0x59, 0x47, 0xaa, 0x6e, 0x4e, 0x99, 0xa3, 0xb0, 0x08, 0x93, 0x9e, 0xbe,
	0xb7, 0x39, 0xe9, 0xf9, 0xce, 0x01, 0xd4, 0x50, 0xe2, 0xf4, 0x6b, 0x27, 0x74, 0xad, 0xe0, 0xf5,
	0xa5, 0x11, 0x16, 0x92, 0x61, 0x4b, 0x03, 0x13, 0x33, 0xcf, 0xf3, 0xf9, 0x79, 0x6e, 0x45, 0xbe,
	0xbe, 0x52, 0x40, 0xff, 0x1b, 0xbd, 0x56, 0xb3, 0xf4, 0x5a, 0x41, 0x05, 0x73, 0xee, 0x90, 0xa5,
	0x82, 0x1b, 0x01, 0xec, 0x5c, 0xf2, 0x31, 0xce, 0xab, 0x6e, 0x17, 0xd4, 0xbf, 0xa9, 0x92, 0xfe,
	0x4d, 0x67, 0xfd, 0x6b, 0xfc, 0xcd, 0x09, 0x58, 0x2d, 0xf9, 0x44, 0xe7, 0x95, 0x9e, 0x71, 0x0f,
	0xa6, 0x45, 0x2c, 0x85, 0x12, 0x10, 0xfd, 0x9d, 0xab, 0xfc, 0xa7, 0x3e, 0x89, 0xc2, 0xb9, 0x0f,
	0xab, 0x85, 0xd2, 0x35, 0xd6, 0x17, 0xd5, 0x56, 0x72, 0x55, 0x6b, 0x0e, 0x22, 0xd9, 0x6e, 0xb8,
	0xd0, 0x78, 0xfd, 0x17, 0x3e, 0x71, 0xd1, 0xeb, 0x98, 0x8f, 0xe9, 0x6b, 0x55, 0x41, 0x9e, 0xfa,
	0xb8, 0xc4, 0x28, 0x4c, 0x36, 0xe8, 0xe9, 0xaf, 0x09, 0x98, 0xdf, 0xfb, 0xbb, 0xff, 0xf2, 0x4f,
	0x6e, 0x4c, 0xfc, 0x9b, 0x3f, 0xb9, 0x31, 0xf1, 0xc7, 0x7f, 0x72, 0x63, 0xe2, 0xef, 0xfe, 0x97,
	0x1b, 0xbf, 0xf2, 0x64, 0xe2, 0x17, 0x0b, 0x49, 0x57, 0xd0, 0xe7, 0x66, 0x91, 0x79, 0x6b, 0x96,
	0xfe, 0xbc, 0xf7, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x25, 0x02, 0x3a, 0x37, 0xb3, 0x8b, 0x00,
	0x00,
}
