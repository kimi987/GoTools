// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/shared_proto/mingc_war.proto
// DO NOT EDIT!

package shared_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 名城战阶段
type MingcWarState int32

const (
	MingcWarState_MC_T_INVALID   MingcWarState = 0
	MingcWarState_MC_T_APPLY_ATK MingcWarState = 1
	MingcWarState_MC_T_APPLY_AST MingcWarState = 2
	MingcWarState_MC_T_FIGHT     MingcWarState = 3
	MingcWarState_MC_T_FIGHT_END MingcWarState = 4
	MingcWarState_MC_T_NOT_START MingcWarState = 5
)

var MingcWarState_name = map[int32]string{
	0: "MC_T_INVALID",
	1: "MC_T_APPLY_ATK",
	2: "MC_T_APPLY_AST",
	3: "MC_T_FIGHT",
	4: "MC_T_FIGHT_END",
	5: "MC_T_NOT_START",
}
var MingcWarState_value = map[string]int32{
	"MC_T_INVALID":   0,
	"MC_T_APPLY_ATK": 1,
	"MC_T_APPLY_AST": 2,
	"MC_T_FIGHT":     3,
	"MC_T_FIGHT_END": 4,
	"MC_T_NOT_START": 5,
}

func (x MingcWarState) String() string {
	return proto.EnumName(MingcWarState_name, int32(x))
}
func (MingcWarState) EnumDescriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{0} }

// 名城战战斗阶段
type MingcWarFightState int32

const (
	MingcWarFightState_MC_F_INVALID       MingcWarFightState = 0
	MingcWarFightState_MC_F_FIGHT_PREPARE MingcWarFightState = 1
	MingcWarFightState_MC_F_FIGHT_RUNNING MingcWarFightState = 2
)

var MingcWarFightState_name = map[int32]string{
	0: "MC_F_INVALID",
	1: "MC_F_FIGHT_PREPARE",
	2: "MC_F_FIGHT_RUNNING",
}
var MingcWarFightState_value = map[string]int32{
	"MC_F_INVALID":       0,
	"MC_F_FIGHT_PREPARE": 1,
	"MC_F_FIGHT_RUNNING": 2,
}

func (x MingcWarFightState) String() string {
	return proto.EnumName(MingcWarFightState_name, int32(x))
}
func (MingcWarFightState) EnumDescriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{1} }

// 据点类型
type MingcWarBuildingType int32

const (
	MingcWarBuildingType_MC_B_INVALID MingcWarBuildingType = 0
	MingcWarBuildingType_MC_B_RELIVE  MingcWarBuildingType = 1
	MingcWarBuildingType_MC_B_HOME    MingcWarBuildingType = 2
	MingcWarBuildingType_MC_B_CASTLE  MingcWarBuildingType = 3
	MingcWarBuildingType_MC_B_GATE    MingcWarBuildingType = 4
	MingcWarBuildingType_MC_B_TOU_SHI MingcWarBuildingType = 5
)

var MingcWarBuildingType_name = map[int32]string{
	0: "MC_B_INVALID",
	1: "MC_B_RELIVE",
	2: "MC_B_HOME",
	3: "MC_B_CASTLE",
	4: "MC_B_GATE",
	5: "MC_B_TOU_SHI",
}
var MingcWarBuildingType_value = map[string]int32{
	"MC_B_INVALID": 0,
	"MC_B_RELIVE":  1,
	"MC_B_HOME":    2,
	"MC_B_CASTLE":  3,
	"MC_B_GATE":    4,
	"MC_B_TOU_SHI": 5,
}

func (x MingcWarBuildingType) String() string {
	return proto.EnumName(MingcWarBuildingType_name, int32(x))
}
func (MingcWarBuildingType) EnumDescriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{2} }

// 队伍行为类型
type MingcWarTroopState int32

const (
	MingcWarTroopState_MC_TP_INVALID MingcWarTroopState = 0
	MingcWarTroopState_MC_TP_STATION MingcWarTroopState = 1
	MingcWarTroopState_MC_TP_MOVING  MingcWarTroopState = 2
	MingcWarTroopState_MC_TP_RELIVE  MingcWarTroopState = 3
	MingcWarTroopState_MC_TP_WAIT    MingcWarTroopState = 4
)

var MingcWarTroopState_name = map[int32]string{
	0: "MC_TP_INVALID",
	1: "MC_TP_STATION",
	2: "MC_TP_MOVING",
	3: "MC_TP_RELIVE",
	4: "MC_TP_WAIT",
}
var MingcWarTroopState_value = map[string]int32{
	"MC_TP_INVALID": 0,
	"MC_TP_STATION": 1,
	"MC_TP_MOVING":  2,
	"MC_TP_RELIVE":  3,
	"MC_TP_WAIT":    4,
}

func (x MingcWarTroopState) String() string {
	return proto.EnumName(MingcWarTroopState_name, int32(x))
}
func (MingcWarTroopState) EnumDescriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{3} }

// 参战联盟类型
type MingcWarGuildType int32

const (
	MingcWarGuildType_MC_G_INVALID MingcWarGuildType = 0
	MingcWarGuildType_MC_G_ATK     MingcWarGuildType = 1
	MingcWarGuildType_MC_G_AST_ATK MingcWarGuildType = 2
	MingcWarGuildType_MC_G_DEF     MingcWarGuildType = 3
	MingcWarGuildType_MC_G_AST_DEF MingcWarGuildType = 4
)

var MingcWarGuildType_name = map[int32]string{
	0: "MC_G_INVALID",
	1: "MC_G_ATK",
	2: "MC_G_AST_ATK",
	3: "MC_G_DEF",
	4: "MC_G_AST_DEF",
}
var MingcWarGuildType_value = map[string]int32{
	"MC_G_INVALID": 0,
	"MC_G_ATK":     1,
	"MC_G_AST_ATK": 2,
	"MC_G_DEF":     3,
	"MC_G_AST_DEF": 4,
}

func (x MingcWarGuildType) String() string {
	return proto.EnumName(MingcWarGuildType_name, int32(x))
}
func (MingcWarGuildType) EnumDescriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{4} }

// 部队形态
type MingcWarModeType int32

const (
	MingcWarModeType_MC_MT_INVALID   MingcWarModeType = 0
	MingcWarModeType_MC_MT_NORMAL    MingcWarModeType = 1
	MingcWarModeType_MC_MT_FREE_TANK MingcWarModeType = 2
)

var MingcWarModeType_name = map[int32]string{
	0: "MC_MT_INVALID",
	1: "MC_MT_NORMAL",
	2: "MC_MT_FREE_TANK",
}
var MingcWarModeType_value = map[string]int32{
	"MC_MT_INVALID":   0,
	"MC_MT_NORMAL":    1,
	"MC_MT_FREE_TANK": 2,
}

func (x MingcWarModeType) String() string {
	return proto.EnumName(MingcWarModeType_name, int32(x))
}
func (MingcWarModeType) EnumDescriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{5} }

// 名城战中的自己联盟相关数据
type McWarGuildProto struct {
	ApplyMcId       int32                          `protobuf:"varint,1,opt,name=apply_mc_id,json=applyMcId,proto3" json:"apply_mc_id,omitempty"`
	ApplyMcValue    int32                          `protobuf:"varint,2,opt,name=apply_mc_value,json=applyMcValue,proto3" json:"apply_mc_value,omitempty"`
	ReqAstGuild     []*McWarGuildApplyAstListProto `protobuf:"bytes,4,rep,name=req_ast_guild,json=reqAstGuild" json:"req_ast_guild,omitempty"`
	ApplyAstAtkMcId []int32                        `protobuf:"varint,5,rep,name=apply_ast_atk_mc_id,json=applyAstAtkMcId" json:"apply_ast_atk_mc_id,omitempty"`
	ApplyAstDefMcId []int32                        `protobuf:"varint,6,rep,name=apply_ast_def_mc_id,json=applyAstDefMcId" json:"apply_ast_def_mc_id,omitempty"`
}

func (m *McWarGuildProto) Reset()                    { *m = McWarGuildProto{} }
func (m *McWarGuildProto) String() string            { return proto.CompactTextString(m) }
func (*McWarGuildProto) ProtoMessage()               {}
func (*McWarGuildProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{0} }

func (m *McWarGuildProto) GetApplyMcId() int32 {
	if m != nil {
		return m.ApplyMcId
	}
	return 0
}

func (m *McWarGuildProto) GetApplyMcValue() int32 {
	if m != nil {
		return m.ApplyMcValue
	}
	return 0
}

func (m *McWarGuildProto) GetReqAstGuild() []*McWarGuildApplyAstListProto {
	if m != nil {
		return m.ReqAstGuild
	}
	return nil
}

func (m *McWarGuildProto) GetApplyAstAtkMcId() []int32 {
	if m != nil {
		return m.ApplyAstAtkMcId
	}
	return nil
}

func (m *McWarGuildProto) GetApplyAstDefMcId() []int32 {
	if m != nil {
		return m.ApplyAstDefMcId
	}
	return nil
}

type McWarGuildApplyAstListProto struct {
	McId  int32                 `protobuf:"varint,1,opt,name=mc_id,json=mcId,proto3" json:"mc_id,omitempty"`
	Guild []*GuildSnapshotProto `protobuf:"bytes,3,rep,name=guild" json:"guild,omitempty"`
}

func (m *McWarGuildApplyAstListProto) Reset()         { *m = McWarGuildApplyAstListProto{} }
func (m *McWarGuildApplyAstListProto) String() string { return proto.CompactTextString(m) }
func (*McWarGuildApplyAstListProto) ProtoMessage()    {}
func (*McWarGuildApplyAstListProto) Descriptor() ([]byte, []int) {
	return fileDescriptorMingcWar, []int{1}
}

func (m *McWarGuildApplyAstListProto) GetMcId() int32 {
	if m != nil {
		return m.McId
	}
	return 0
}

func (m *McWarGuildApplyAstListProto) GetGuild() []*GuildSnapshotProto {
	if m != nil {
		return m.Guild
	}
	return nil
}

// 名城战
type McWarProto struct {
	Id        int32            `protobuf:"varint,8,opt,name=id,proto3" json:"id,omitempty"`
	State     MingcWarState    `protobuf:"varint,1,opt,name=state,proto3,enum=proto.MingcWarState" json:"state,omitempty"`
	StartTime int32            `protobuf:"varint,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   int32            `protobuf:"varint,3,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	Mc        []*McWarMcProto  `protobuf:"bytes,4,rep,name=mc" json:"mc,omitempty"`
	Atk       *McApplyAtkProto `protobuf:"bytes,5,opt,name=atk" json:"atk,omitempty"`
	Ast       *McApplyAstProto `protobuf:"bytes,6,opt,name=ast" json:"ast,omitempty"`
	Fight     *McFightProto    `protobuf:"bytes,7,opt,name=fight" json:"fight,omitempty"`
}

func (m *McWarProto) Reset()                    { *m = McWarProto{} }
func (m *McWarProto) String() string            { return proto.CompactTextString(m) }
func (*McWarProto) ProtoMessage()               {}
func (*McWarProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{2} }

func (m *McWarProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *McWarProto) GetState() MingcWarState {
	if m != nil {
		return m.State
	}
	return MingcWarState_MC_T_INVALID
}

func (m *McWarProto) GetStartTime() int32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *McWarProto) GetEndTime() int32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *McWarProto) GetMc() []*McWarMcProto {
	if m != nil {
		return m.Mc
	}
	return nil
}

func (m *McWarProto) GetAtk() *McApplyAtkProto {
	if m != nil {
		return m.Atk
	}
	return nil
}

func (m *McWarProto) GetAst() *McApplyAstProto {
	if m != nil {
		return m.Ast
	}
	return nil
}

func (m *McWarProto) GetFight() *McFightProto {
	if m != nil {
		return m.Fight
	}
	return nil
}

// 名城战中的名城相关数据
type McWarMcProto struct {
	Id            int32              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ApplyAtkCount int32              `protobuf:"varint,2,opt,name=apply_atk_count,json=applyAtkCount,proto3" json:"apply_atk_count,omitempty"`
	AtkGuild      *GuildBasicProto   `protobuf:"bytes,3,opt,name=atk_guild,json=atkGuild" json:"atk_guild,omitempty"`
	DefGuild      *GuildBasicProto   `protobuf:"bytes,9,opt,name=def_guild,json=defGuild" json:"def_guild,omitempty"`
	Country       int32              `protobuf:"varint,8,opt,name=country,proto3" json:"country,omitempty"`
	AstAtkGuild   []*GuildBasicProto `protobuf:"bytes,4,rep,name=ast_atk_guild,json=astAtkGuild" json:"ast_atk_guild,omitempty"`
	AstDefGuild   []*GuildBasicProto `protobuf:"bytes,5,rep,name=ast_def_guild,json=astDefGuild" json:"ast_def_guild,omitempty"`
	Ended         bool               `protobuf:"varint,6,opt,name=ended,proto3" json:"ended,omitempty"`
	AtkWin        bool               `protobuf:"varint,7,opt,name=atk_win,json=atkWin,proto3" json:"atk_win,omitempty"`
}

func (m *McWarMcProto) Reset()                    { *m = McWarMcProto{} }
func (m *McWarMcProto) String() string            { return proto.CompactTextString(m) }
func (*McWarMcProto) ProtoMessage()               {}
func (*McWarMcProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{3} }

func (m *McWarMcProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *McWarMcProto) GetApplyAtkCount() int32 {
	if m != nil {
		return m.ApplyAtkCount
	}
	return 0
}

func (m *McWarMcProto) GetAtkGuild() *GuildBasicProto {
	if m != nil {
		return m.AtkGuild
	}
	return nil
}

func (m *McWarMcProto) GetDefGuild() *GuildBasicProto {
	if m != nil {
		return m.DefGuild
	}
	return nil
}

func (m *McWarMcProto) GetCountry() int32 {
	if m != nil {
		return m.Country
	}
	return 0
}

func (m *McWarMcProto) GetAstAtkGuild() []*GuildBasicProto {
	if m != nil {
		return m.AstAtkGuild
	}
	return nil
}

func (m *McWarMcProto) GetAstDefGuild() []*GuildBasicProto {
	if m != nil {
		return m.AstDefGuild
	}
	return nil
}

func (m *McWarMcProto) GetEnded() bool {
	if m != nil {
		return m.Ended
	}
	return false
}

func (m *McWarMcProto) GetAtkWin() bool {
	if m != nil {
		return m.AtkWin
	}
	return false
}

// 申请攻打
type McApplyAtkProto struct {
	StartTime int32 `protobuf:"varint,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   int32 `protobuf:"varint,3,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (m *McApplyAtkProto) Reset()                    { *m = McApplyAtkProto{} }
func (m *McApplyAtkProto) String() string            { return proto.CompactTextString(m) }
func (*McApplyAtkProto) ProtoMessage()               {}
func (*McApplyAtkProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{4} }

func (m *McApplyAtkProto) GetStartTime() int32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *McApplyAtkProto) GetEndTime() int32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

// 申请协助
type McApplyAstProto struct {
	StartTime int32 `protobuf:"varint,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   int32 `protobuf:"varint,3,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (m *McApplyAstProto) Reset()                    { *m = McApplyAstProto{} }
func (m *McApplyAstProto) String() string            { return proto.CompactTextString(m) }
func (*McApplyAstProto) ProtoMessage()               {}
func (*McApplyAstProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{5} }

func (m *McApplyAstProto) GetStartTime() int32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *McApplyAstProto) GetEndTime() int32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

// 战斗
type McFightProto struct {
	StartTime int32 `protobuf:"varint,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   int32 `protobuf:"varint,3,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (m *McFightProto) Reset()                    { *m = McFightProto{} }
func (m *McFightProto) String() string            { return proto.CompactTextString(m) }
func (*McFightProto) ProtoMessage()               {}
func (*McFightProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{6} }

func (m *McFightProto) GetStartTime() int32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *McFightProto) GetEndTime() int32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

// 名城战战场
type McWarSceneProto struct {
	McId          int32                      `protobuf:"varint,1,opt,name=mc_id,json=mcId,proto3" json:"mc_id,omitempty"`
	McAllYinliang int32                      `protobuf:"varint,11,opt,name=mc_all_yinliang,json=mcAllYinliang,proto3" json:"mc_all_yinliang,omitempty"`
	Building      []*McWarSceneBuildingProto `protobuf:"bytes,2,rep,name=building" json:"building,omitempty"`
	Troop         []*McWarTroopProto         `protobuf:"bytes,3,rep,name=troop" json:"troop,omitempty"`
	StartTime     int32                      `protobuf:"varint,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	FightState    MingcWarFightState         `protobuf:"varint,5,opt,name=fight_state,json=fightState,proto3,enum=proto.MingcWarFightState" json:"fight_state,omitempty"`
	AtkDrumTimes  int32                      `protobuf:"varint,6,opt,name=atk_drum_times,json=atkDrumTimes,proto3" json:"atk_drum_times,omitempty"`
	DefDrumTimes  int32                      `protobuf:"varint,7,opt,name=def_drum_times,json=defDrumTimes,proto3" json:"def_drum_times,omitempty"`
	AtkDrumStat   *SpriteStatProto           `protobuf:"bytes,8,opt,name=atk_drum_stat,json=atkDrumStat" json:"atk_drum_stat,omitempty"`
	DefDrumStat   *SpriteStatProto           `protobuf:"bytes,9,opt,name=def_drum_stat,json=defDrumStat" json:"def_drum_stat,omitempty"`
	DrumStopTime  int32                      `protobuf:"varint,10,opt,name=drum_stop_time,json=drumStopTime,proto3" json:"drum_stop_time,omitempty"`
}

func (m *McWarSceneProto) Reset()                    { *m = McWarSceneProto{} }
func (m *McWarSceneProto) String() string            { return proto.CompactTextString(m) }
func (*McWarSceneProto) ProtoMessage()               {}
func (*McWarSceneProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{7} }

func (m *McWarSceneProto) GetMcId() int32 {
	if m != nil {
		return m.McId
	}
	return 0
}

func (m *McWarSceneProto) GetMcAllYinliang() int32 {
	if m != nil {
		return m.McAllYinliang
	}
	return 0
}

func (m *McWarSceneProto) GetBuilding() []*McWarSceneBuildingProto {
	if m != nil {
		return m.Building
	}
	return nil
}

func (m *McWarSceneProto) GetTroop() []*McWarTroopProto {
	if m != nil {
		return m.Troop
	}
	return nil
}

func (m *McWarSceneProto) GetStartTime() int32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *McWarSceneProto) GetFightState() MingcWarFightState {
	if m != nil {
		return m.FightState
	}
	return MingcWarFightState_MC_F_INVALID
}

func (m *McWarSceneProto) GetAtkDrumTimes() int32 {
	if m != nil {
		return m.AtkDrumTimes
	}
	return 0
}

func (m *McWarSceneProto) GetDefDrumTimes() int32 {
	if m != nil {
		return m.DefDrumTimes
	}
	return 0
}

func (m *McWarSceneProto) GetAtkDrumStat() *SpriteStatProto {
	if m != nil {
		return m.AtkDrumStat
	}
	return nil
}

func (m *McWarSceneProto) GetDefDrumStat() *SpriteStatProto {
	if m != nil {
		return m.DefDrumStat
	}
	return nil
}

func (m *McWarSceneProto) GetDrumStopTime() int32 {
	if m != nil {
		return m.DrumStopTime
	}
	return 0
}

// 据点
type McWarSceneBuildingProto struct {
	Atk                       bool                 `protobuf:"varint,1,opt,name=atk,proto3" json:"atk,omitempty"`
	PosX                      int32                `protobuf:"varint,2,opt,name=pos_x,json=posX,proto3" json:"pos_x,omitempty"`
	PosY                      int32                `protobuf:"varint,3,opt,name=pos_y,json=posY,proto3" json:"pos_y,omitempty"`
	Type                      MingcWarBuildingType `protobuf:"varint,4,opt,name=type,proto3,enum=proto.MingcWarBuildingType" json:"type,omitempty"`
	Prosperity                int32                `protobuf:"varint,5,opt,name=prosperity,proto3" json:"prosperity,omitempty"`
	LastDestroyProsperityTime int32                `protobuf:"varint,6,opt,name=last_destroy_prosperity_time,json=lastDestroyProsperityTime,proto3" json:"last_destroy_prosperity_time,omitempty"`
	TouShiTargetPosX          []int32              `protobuf:"varint,7,rep,name=tou_shi_target_pos_x,json=touShiTargetPosX" json:"tou_shi_target_pos_x,omitempty"`
	TouShiTargetPosY          []int32              `protobuf:"varint,8,rep,name=tou_shi_target_pos_y,json=touShiTargetPosY" json:"tou_shi_target_pos_y,omitempty"`
	TouShiTurnEndTime         int32                `protobuf:"varint,10,opt,name=tou_shi_turn_end_time,json=touShiTurnEndTime,proto3" json:"tou_shi_turn_end_time,omitempty"`
	TouShiPrepareEndTime      int32                `protobuf:"varint,11,opt,name=tou_shi_prepare_end_time,json=touShiPrepareEndTime,proto3" json:"tou_shi_prepare_end_time,omitempty"`
	TouShiTargetIndex         int32                `protobuf:"varint,12,opt,name=tou_shi_target_index,json=touShiTargetIndex,proto3" json:"tou_shi_target_index,omitempty"`
	LastFireHeroName          string               `protobuf:"bytes,13,opt,name=last_fire_hero_name,json=lastFireHeroName,proto3" json:"last_fire_hero_name,omitempty"`
	LastFireHeroCountry       int32                `protobuf:"varint,14,opt,name=last_fire_hero_country,json=lastFireHeroCountry,proto3" json:"last_fire_hero_country,omitempty"`
}

func (m *McWarSceneBuildingProto) Reset()                    { *m = McWarSceneBuildingProto{} }
func (m *McWarSceneBuildingProto) String() string            { return proto.CompactTextString(m) }
func (*McWarSceneBuildingProto) ProtoMessage()               {}
func (*McWarSceneBuildingProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{8} }

func (m *McWarSceneBuildingProto) GetAtk() bool {
	if m != nil {
		return m.Atk
	}
	return false
}

func (m *McWarSceneBuildingProto) GetPosX() int32 {
	if m != nil {
		return m.PosX
	}
	return 0
}

func (m *McWarSceneBuildingProto) GetPosY() int32 {
	if m != nil {
		return m.PosY
	}
	return 0
}

func (m *McWarSceneBuildingProto) GetType() MingcWarBuildingType {
	if m != nil {
		return m.Type
	}
	return MingcWarBuildingType_MC_B_INVALID
}

func (m *McWarSceneBuildingProto) GetProsperity() int32 {
	if m != nil {
		return m.Prosperity
	}
	return 0
}

func (m *McWarSceneBuildingProto) GetLastDestroyProsperityTime() int32 {
	if m != nil {
		return m.LastDestroyProsperityTime
	}
	return 0
}

func (m *McWarSceneBuildingProto) GetTouShiTargetPosX() []int32 {
	if m != nil {
		return m.TouShiTargetPosX
	}
	return nil
}

func (m *McWarSceneBuildingProto) GetTouShiTargetPosY() []int32 {
	if m != nil {
		return m.TouShiTargetPosY
	}
	return nil
}

func (m *McWarSceneBuildingProto) GetTouShiTurnEndTime() int32 {
	if m != nil {
		return m.TouShiTurnEndTime
	}
	return 0
}

func (m *McWarSceneBuildingProto) GetTouShiPrepareEndTime() int32 {
	if m != nil {
		return m.TouShiPrepareEndTime
	}
	return 0
}

func (m *McWarSceneBuildingProto) GetTouShiTargetIndex() int32 {
	if m != nil {
		return m.TouShiTargetIndex
	}
	return 0
}

func (m *McWarSceneBuildingProto) GetLastFireHeroName() string {
	if m != nil {
		return m.LastFireHeroName
	}
	return ""
}

func (m *McWarSceneBuildingProto) GetLastFireHeroCountry() int32 {
	if m != nil {
		return m.LastFireHeroCountry
	}
	return 0
}

// 名城战部队
type McWarTroopProto struct {
	Hero           *HeroBasicProto          `protobuf:"bytes,1,opt,name=hero" json:"hero,omitempty"`
	CaptainIndex   []int32                  `protobuf:"varint,2,rep,name=captain_index,json=captainIndex" json:"captain_index,omitempty"`
	Captains       []*CaptainInfoProto      `protobuf:"bytes,3,rep,name=captains" json:"captains,omitempty"`
	Atk            bool                     `protobuf:"varint,4,opt,name=atk,proto3" json:"atk,omitempty"`
	JoinTime       int32                    `protobuf:"varint,12,opt,name=join_time,json=joinTime,proto3" json:"join_time,omitempty"`
	Mode           MingcWarModeType         `protobuf:"varint,14,opt,name=mode,proto3,enum=proto.MingcWarModeType" json:"mode,omitempty"`
	NextDrumTime   int32                    `protobuf:"varint,15,opt,name=next_drum_time,json=nextDrumTime,proto3" json:"next_drum_time,omitempty"`
	State          MingcWarTroopState       `protobuf:"varint,5,opt,name=state,proto3,enum=proto.MingcWarTroopState" json:"state,omitempty"`
	StateStartTime int32                    `protobuf:"varint,6,opt,name=state_start_time,json=stateStartTime,proto3" json:"state_start_time,omitempty"`
	StateEndTime   int32                    `protobuf:"varint,7,opt,name=state_end_time,json=stateEndTime,proto3" json:"state_end_time,omitempty"`
	StartPosX      int32                    `protobuf:"varint,8,opt,name=start_pos_x,json=startPosX,proto3" json:"start_pos_x,omitempty"`
	StartPosY      int32                    `protobuf:"varint,9,opt,name=start_pos_y,json=startPosY,proto3" json:"start_pos_y,omitempty"`
	DestPosX       int32                    `protobuf:"varint,10,opt,name=dest_pos_x,json=destPosX,proto3" json:"dest_pos_x,omitempty"`
	DestPosY       int32                    `protobuf:"varint,11,opt,name=dest_pos_y,json=destPosY,proto3" json:"dest_pos_y,omitempty"`
	Record         []*McWarTroopRecordProto `protobuf:"bytes,13,rep,name=record" json:"record,omitempty"`
}

func (m *McWarTroopProto) Reset()                    { *m = McWarTroopProto{} }
func (m *McWarTroopProto) String() string            { return proto.CompactTextString(m) }
func (*McWarTroopProto) ProtoMessage()               {}
func (*McWarTroopProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{9} }

func (m *McWarTroopProto) GetHero() *HeroBasicProto {
	if m != nil {
		return m.Hero
	}
	return nil
}

func (m *McWarTroopProto) GetCaptainIndex() []int32 {
	if m != nil {
		return m.CaptainIndex
	}
	return nil
}

func (m *McWarTroopProto) GetCaptains() []*CaptainInfoProto {
	if m != nil {
		return m.Captains
	}
	return nil
}

func (m *McWarTroopProto) GetAtk() bool {
	if m != nil {
		return m.Atk
	}
	return false
}

func (m *McWarTroopProto) GetJoinTime() int32 {
	if m != nil {
		return m.JoinTime
	}
	return 0
}

func (m *McWarTroopProto) GetMode() MingcWarModeType {
	if m != nil {
		return m.Mode
	}
	return MingcWarModeType_MC_MT_INVALID
}

func (m *McWarTroopProto) GetNextDrumTime() int32 {
	if m != nil {
		return m.NextDrumTime
	}
	return 0
}

func (m *McWarTroopProto) GetState() MingcWarTroopState {
	if m != nil {
		return m.State
	}
	return MingcWarTroopState_MC_TP_INVALID
}

func (m *McWarTroopProto) GetStateStartTime() int32 {
	if m != nil {
		return m.StateStartTime
	}
	return 0
}

func (m *McWarTroopProto) GetStateEndTime() int32 {
	if m != nil {
		return m.StateEndTime
	}
	return 0
}

func (m *McWarTroopProto) GetStartPosX() int32 {
	if m != nil {
		return m.StartPosX
	}
	return 0
}

func (m *McWarTroopProto) GetStartPosY() int32 {
	if m != nil {
		return m.StartPosY
	}
	return 0
}

func (m *McWarTroopProto) GetDestPosX() int32 {
	if m != nil {
		return m.DestPosX
	}
	return 0
}

func (m *McWarTroopProto) GetDestPosY() int32 {
	if m != nil {
		return m.DestPosY
	}
	return 0
}

func (m *McWarTroopProto) GetRecord() []*McWarTroopRecordProto {
	if m != nil {
		return m.Record
	}
	return nil
}

// 一支队伍当前所有的战斗战报
type McWarTroopAllRecordProto struct {
	Record []*McWarTroopRecordProto `protobuf:"bytes,1,rep,name=record" json:"record,omitempty"`
}

func (m *McWarTroopAllRecordProto) Reset()         { *m = McWarTroopAllRecordProto{} }
func (m *McWarTroopAllRecordProto) String() string { return proto.CompactTextString(m) }
func (*McWarTroopAllRecordProto) ProtoMessage()    {}
func (*McWarTroopAllRecordProto) Descriptor() ([]byte, []int) {
	return fileDescriptorMingcWar, []int{10}
}

func (m *McWarTroopAllRecordProto) GetRecord() []*McWarTroopRecordProto {
	if m != nil {
		return m.Record
	}
	return nil
}

// 单条队伍战斗战报
type McWarTroopRecordProto struct {
	McId           int32             `protobuf:"varint,14,opt,name=mc_id,json=mcId,proto3" json:"mc_id,omitempty"`
	Time           int32             `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	Atk            bool              `protobuf:"varint,2,opt,name=atk,proto3" json:"atk,omitempty"`
	BuildingX      int32             `protobuf:"varint,3,opt,name=building_x,json=buildingX,proto3" json:"building_x,omitempty"`
	BuildingY      int32             `protobuf:"varint,7,opt,name=building_y,json=buildingY,proto3" json:"building_y,omitempty"`
	Target         *HeroBasicProto   `protobuf:"bytes,4,opt,name=target" json:"target,omitempty"`
	Win            bool              `protobuf:"varint,5,opt,name=win,proto3" json:"win,omitempty"`
	Link           string            `protobuf:"bytes,6,opt,name=link,proto3" json:"link,omitempty"`
	Combat         *CombatShareProto `protobuf:"bytes,9,opt,name=combat" json:"combat,omitempty"`
	BuildingName   string            `protobuf:"bytes,8,opt,name=building_name,json=buildingName,proto3" json:"building_name,omitempty"`
	Killed         int32             `protobuf:"varint,10,opt,name=killed,proto3" json:"killed,omitempty"`
	LastBeatKilled int32             `protobuf:"varint,11,opt,name=last_beat_killed,json=lastBeatKilled,proto3" json:"last_beat_killed,omitempty"`
	Wounded        int32             `protobuf:"varint,12,opt,name=wounded,proto3" json:"wounded,omitempty"`
	TouShi         bool              `protobuf:"varint,13,opt,name=tou_shi,json=touShi,proto3" json:"tou_shi,omitempty"`
}

func (m *McWarTroopRecordProto) Reset()                    { *m = McWarTroopRecordProto{} }
func (m *McWarTroopRecordProto) String() string            { return proto.CompactTextString(m) }
func (*McWarTroopRecordProto) ProtoMessage()               {}
func (*McWarTroopRecordProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{11} }

func (m *McWarTroopRecordProto) GetMcId() int32 {
	if m != nil {
		return m.McId
	}
	return 0
}

func (m *McWarTroopRecordProto) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *McWarTroopRecordProto) GetAtk() bool {
	if m != nil {
		return m.Atk
	}
	return false
}

func (m *McWarTroopRecordProto) GetBuildingX() int32 {
	if m != nil {
		return m.BuildingX
	}
	return 0
}

func (m *McWarTroopRecordProto) GetBuildingY() int32 {
	if m != nil {
		return m.BuildingY
	}
	return 0
}

func (m *McWarTroopRecordProto) GetTarget() *HeroBasicProto {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *McWarTroopRecordProto) GetWin() bool {
	if m != nil {
		return m.Win
	}
	return false
}

func (m *McWarTroopRecordProto) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *McWarTroopRecordProto) GetCombat() *CombatShareProto {
	if m != nil {
		return m.Combat
	}
	return nil
}

func (m *McWarTroopRecordProto) GetBuildingName() string {
	if m != nil {
		return m.BuildingName
	}
	return ""
}

func (m *McWarTroopRecordProto) GetKilled() int32 {
	if m != nil {
		return m.Killed
	}
	return 0
}

func (m *McWarTroopRecordProto) GetLastBeatKilled() int32 {
	if m != nil {
		return m.LastBeatKilled
	}
	return 0
}

func (m *McWarTroopRecordProto) GetWounded() int32 {
	if m != nil {
		return m.Wounded
	}
	return 0
}

func (m *McWarTroopRecordProto) GetTouShi() bool {
	if m != nil {
		return m.TouShi
	}
	return false
}

// 名城战结束后的结算
type McWarFightRecordProto struct {
	Atk           *McWarFightGuildRecordProto   `protobuf:"bytes,1,opt,name=atk" json:"atk,omitempty"`
	Def           *McWarFightGuildRecordProto   `protobuf:"bytes,2,opt,name=def" json:"def,omitempty"`
	AstAtk        []*McWarFightGuildRecordProto `protobuf:"bytes,3,rep,name=ast_atk,json=astAtk" json:"ast_atk,omitempty"`
	AstDef        []*McWarFightGuildRecordProto `protobuf:"bytes,4,rep,name=ast_def,json=astDef" json:"ast_def,omitempty"`
	AtkYinliang   int32                         `protobuf:"varint,7,opt,name=atk_yinliang,json=atkYinliang,proto3" json:"atk_yinliang,omitempty"`
	DefYinliang   int32                         `protobuf:"varint,8,opt,name=def_yinliang,json=defYinliang,proto3" json:"def_yinliang,omitempty"`
	AtkWin        bool                          `protobuf:"varint,9,opt,name=atk_win,json=atkWin,proto3" json:"atk_win,omitempty"`
	FightDuration int32                         `protobuf:"varint,10,opt,name=fight_duration,json=fightDuration,proto3" json:"fight_duration,omitempty"`
	McId          int32                         `protobuf:"varint,11,opt,name=mc_id,json=mcId,proto3" json:"mc_id,omitempty"`
	Timeout       bool                          `protobuf:"varint,12,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *McWarFightRecordProto) Reset()                    { *m = McWarFightRecordProto{} }
func (m *McWarFightRecordProto) String() string            { return proto.CompactTextString(m) }
func (*McWarFightRecordProto) ProtoMessage()               {}
func (*McWarFightRecordProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{12} }

func (m *McWarFightRecordProto) GetAtk() *McWarFightGuildRecordProto {
	if m != nil {
		return m.Atk
	}
	return nil
}

func (m *McWarFightRecordProto) GetDef() *McWarFightGuildRecordProto {
	if m != nil {
		return m.Def
	}
	return nil
}

func (m *McWarFightRecordProto) GetAstAtk() []*McWarFightGuildRecordProto {
	if m != nil {
		return m.AstAtk
	}
	return nil
}

func (m *McWarFightRecordProto) GetAstDef() []*McWarFightGuildRecordProto {
	if m != nil {
		return m.AstDef
	}
	return nil
}

func (m *McWarFightRecordProto) GetAtkYinliang() int32 {
	if m != nil {
		return m.AtkYinliang
	}
	return 0
}

func (m *McWarFightRecordProto) GetDefYinliang() int32 {
	if m != nil {
		return m.DefYinliang
	}
	return 0
}

func (m *McWarFightRecordProto) GetAtkWin() bool {
	if m != nil {
		return m.AtkWin
	}
	return false
}

func (m *McWarFightRecordProto) GetFightDuration() int32 {
	if m != nil {
		return m.FightDuration
	}
	return 0
}

func (m *McWarFightRecordProto) GetMcId() int32 {
	if m != nil {
		return m.McId
	}
	return 0
}

func (m *McWarFightRecordProto) GetTimeout() bool {
	if m != nil {
		return m.Timeout
	}
	return false
}

// 名城战结束后的结算中的每个联盟具体数据
type McWarFightGuildRecordProto struct {
	Guild         *GuildBasicProto `protobuf:"bytes,1,opt,name=guild" json:"guild,omitempty"`
	JoinedCount   int32            `protobuf:"varint,2,opt,name=joined_count,json=joinedCount,proto3" json:"joined_count,omitempty"`
	KilledAmount  int32            `protobuf:"varint,3,opt,name=killed_amount,json=killedAmount,proto3" json:"killed_amount,omitempty"`
	WoundedAmount int32            `protobuf:"varint,4,opt,name=wounded_amount,json=woundedAmount,proto3" json:"wounded_amount,omitempty"`
	Destroyed     int32            `protobuf:"varint,5,opt,name=destroyed,proto3" json:"destroyed,omitempty"`
}

func (m *McWarFightGuildRecordProto) Reset()         { *m = McWarFightGuildRecordProto{} }
func (m *McWarFightGuildRecordProto) String() string { return proto.CompactTextString(m) }
func (*McWarFightGuildRecordProto) ProtoMessage()    {}
func (*McWarFightGuildRecordProto) Descriptor() ([]byte, []int) {
	return fileDescriptorMingcWar, []int{13}
}

func (m *McWarFightGuildRecordProto) GetGuild() *GuildBasicProto {
	if m != nil {
		return m.Guild
	}
	return nil
}

func (m *McWarFightGuildRecordProto) GetJoinedCount() int32 {
	if m != nil {
		return m.JoinedCount
	}
	return 0
}

func (m *McWarFightGuildRecordProto) GetKilledAmount() int32 {
	if m != nil {
		return m.KilledAmount
	}
	return 0
}

func (m *McWarFightGuildRecordProto) GetWoundedAmount() int32 {
	if m != nil {
		return m.WoundedAmount
	}
	return 0
}

func (m *McWarFightGuildRecordProto) GetDestroyed() int32 {
	if m != nil {
		return m.Destroyed
	}
	return 0
}

// 所有部队排名（符合条件的部队）
type McWarTroopsRankProto struct {
	TroopsRank []*McWarTroopRankProto `protobuf:"bytes,1,rep,name=troops_rank,json=troopsRank" json:"troops_rank,omitempty"`
}

func (m *McWarTroopsRankProto) Reset()                    { *m = McWarTroopsRankProto{} }
func (m *McWarTroopsRankProto) String() string            { return proto.CompactTextString(m) }
func (*McWarTroopsRankProto) ProtoMessage()               {}
func (*McWarTroopsRankProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{14} }

func (m *McWarTroopsRankProto) GetTroopsRank() []*McWarTroopRankProto {
	if m != nil {
		return m.TroopsRank
	}
	return nil
}

// 部队排名
type McWarTroopRankProto struct {
	Info  *McWarTroopInfoProto `protobuf:"bytes,1,opt,name=info" json:"info,omitempty"`
	Rank  int32                `protobuf:"varint,2,opt,name=rank,proto3" json:"rank,omitempty"`
	IsAtk bool                 `protobuf:"varint,3,opt,name=isAtk,proto3" json:"isAtk,omitempty"`
}

func (m *McWarTroopRankProto) Reset()                    { *m = McWarTroopRankProto{} }
func (m *McWarTroopRankProto) String() string            { return proto.CompactTextString(m) }
func (*McWarTroopRankProto) ProtoMessage()               {}
func (*McWarTroopRankProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{15} }

func (m *McWarTroopRankProto) GetInfo() *McWarTroopInfoProto {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *McWarTroopRankProto) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *McWarTroopRankProto) GetIsAtk() bool {
	if m != nil {
		return m.IsAtk
	}
	return false
}

// 所有部队信息（符合条件的部队）
type McWarTroopsInfoProto struct {
	TroopsInfo []*McWarTroopInfoProto `protobuf:"bytes,1,rep,name=troops_info,json=troopsInfo" json:"troops_info,omitempty"`
}

func (m *McWarTroopsInfoProto) Reset()                    { *m = McWarTroopsInfoProto{} }
func (m *McWarTroopsInfoProto) String() string            { return proto.CompactTextString(m) }
func (*McWarTroopsInfoProto) ProtoMessage()               {}
func (*McWarTroopsInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{16} }

func (m *McWarTroopsInfoProto) GetTroopsInfo() []*McWarTroopInfoProto {
	if m != nil {
		return m.TroopsInfo
	}
	return nil
}

// 部队信息
type McWarTroopInfoProto struct {
	Hero  *HeroBasicProto       `protobuf:"bytes,1,opt,name=hero" json:"hero,omitempty"`
	Score *McWarTroopScoreProto `protobuf:"bytes,2,opt,name=score" json:"score,omitempty"`
}

func (m *McWarTroopInfoProto) Reset()                    { *m = McWarTroopInfoProto{} }
func (m *McWarTroopInfoProto) String() string            { return proto.CompactTextString(m) }
func (*McWarTroopInfoProto) ProtoMessage()               {}
func (*McWarTroopInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{17} }

func (m *McWarTroopInfoProto) GetHero() *HeroBasicProto {
	if m != nil {
		return m.Hero
	}
	return nil
}

func (m *McWarTroopInfoProto) GetScore() *McWarTroopScoreProto {
	if m != nil {
		return m.Score
	}
	return nil
}

// 战绩
type McWarTroopScoreProto struct {
	KillAmount    int32 `protobuf:"varint,1,opt,name=kill_amount,json=killAmount,proto3" json:"kill_amount,omitempty"`
	DestroyAmount int32 `protobuf:"varint,2,opt,name=destroy_amount,json=destroyAmount,proto3" json:"destroy_amount,omitempty"`
	WinTimes      int32 `protobuf:"varint,3,opt,name=win_times,json=winTimes,proto3" json:"win_times,omitempty"`
	MultiKill     int32 `protobuf:"varint,4,opt,name=multi_kill,json=multiKill,proto3" json:"multi_kill,omitempty"`
	DrumTimes     int32 `protobuf:"varint,5,opt,name=drum_times,json=drumTimes,proto3" json:"drum_times,omitempty"`
	LoseTimes     int32 `protobuf:"varint,6,opt,name=lose_times,json=loseTimes,proto3" json:"lose_times,omitempty"`
}

func (m *McWarTroopScoreProto) Reset()                    { *m = McWarTroopScoreProto{} }
func (m *McWarTroopScoreProto) String() string            { return proto.CompactTextString(m) }
func (*McWarTroopScoreProto) ProtoMessage()               {}
func (*McWarTroopScoreProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{18} }

func (m *McWarTroopScoreProto) GetKillAmount() int32 {
	if m != nil {
		return m.KillAmount
	}
	return 0
}

func (m *McWarTroopScoreProto) GetDestroyAmount() int32 {
	if m != nil {
		return m.DestroyAmount
	}
	return 0
}

func (m *McWarTroopScoreProto) GetWinTimes() int32 {
	if m != nil {
		return m.WinTimes
	}
	return 0
}

func (m *McWarTroopScoreProto) GetMultiKill() int32 {
	if m != nil {
		return m.MultiKill
	}
	return 0
}

func (m *McWarTroopScoreProto) GetDrumTimes() int32 {
	if m != nil {
		return m.DrumTimes
	}
	return 0
}

func (m *McWarTroopScoreProto) GetLoseTimes() int32 {
	if m != nil {
		return m.LoseTimes
	}
	return 0
}

func init() {
	proto.RegisterType((*McWarGuildProto)(nil), "proto.McWarGuildProto")
	proto.RegisterType((*McWarGuildApplyAstListProto)(nil), "proto.McWarGuildApplyAstListProto")
	proto.RegisterType((*McWarProto)(nil), "proto.McWarProto")
	proto.RegisterType((*McWarMcProto)(nil), "proto.McWarMcProto")
	proto.RegisterType((*McApplyAtkProto)(nil), "proto.McApplyAtkProto")
	proto.RegisterType((*McApplyAstProto)(nil), "proto.McApplyAstProto")
	proto.RegisterType((*McFightProto)(nil), "proto.McFightProto")
	proto.RegisterType((*McWarSceneProto)(nil), "proto.McWarSceneProto")
	proto.RegisterType((*McWarSceneBuildingProto)(nil), "proto.McWarSceneBuildingProto")
	proto.RegisterType((*McWarTroopProto)(nil), "proto.McWarTroopProto")
	proto.RegisterType((*McWarTroopAllRecordProto)(nil), "proto.McWarTroopAllRecordProto")
	proto.RegisterType((*McWarTroopRecordProto)(nil), "proto.McWarTroopRecordProto")
	proto.RegisterType((*McWarFightRecordProto)(nil), "proto.McWarFightRecordProto")
	proto.RegisterType((*McWarFightGuildRecordProto)(nil), "proto.McWarFightGuildRecordProto")
	proto.RegisterType((*McWarTroopsRankProto)(nil), "proto.McWarTroopsRankProto")
	proto.RegisterType((*McWarTroopRankProto)(nil), "proto.McWarTroopRankProto")
	proto.RegisterType((*McWarTroopsInfoProto)(nil), "proto.McWarTroopsInfoProto")
	proto.RegisterType((*McWarTroopInfoProto)(nil), "proto.McWarTroopInfoProto")
	proto.RegisterType((*McWarTroopScoreProto)(nil), "proto.McWarTroopScoreProto")
	proto.RegisterEnum("proto.MingcWarState", MingcWarState_name, MingcWarState_value)
	proto.RegisterEnum("proto.MingcWarFightState", MingcWarFightState_name, MingcWarFightState_value)
	proto.RegisterEnum("proto.MingcWarBuildingType", MingcWarBuildingType_name, MingcWarBuildingType_value)
	proto.RegisterEnum("proto.MingcWarTroopState", MingcWarTroopState_name, MingcWarTroopState_value)
	proto.RegisterEnum("proto.MingcWarGuildType", MingcWarGuildType_name, MingcWarGuildType_value)
	proto.RegisterEnum("proto.MingcWarModeType", MingcWarModeType_name, MingcWarModeType_value)
}
func (m *McWarGuildProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarGuildProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApplyMcId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.ApplyMcId))
	}
	if m.ApplyMcValue != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.ApplyMcValue))
	}
	if len(m.ReqAstGuild) > 0 {
		for _, msg := range m.ReqAstGuild {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ApplyAstAtkMcId) > 0 {
		for _, num := range m.ApplyAstAtkMcId {
			dAtA[i] = 0x28
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(num))
		}
	}
	if len(m.ApplyAstDefMcId) > 0 {
		for _, num := range m.ApplyAstDefMcId {
			dAtA[i] = 0x30
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *McWarGuildApplyAstListProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarGuildApplyAstListProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.McId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.McId))
	}
	if len(m.Guild) > 0 {
		for _, msg := range m.Guild {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *McWarProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.State))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.EndTime))
	}
	if len(m.Mc) > 0 {
		for _, msg := range m.Mc {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Atk != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Atk.Size()))
		n1, err := m.Atk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Ast != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Ast.Size()))
		n2, err := m.Ast.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Fight != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Fight.Size()))
		n3, err := m.Fight.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Id != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *McWarMcProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarMcProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Id))
	}
	if m.ApplyAtkCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.ApplyAtkCount))
	}
	if m.AtkGuild != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.AtkGuild.Size()))
		n4, err := m.AtkGuild.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.AstAtkGuild) > 0 {
		for _, msg := range m.AstAtkGuild {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AstDefGuild) > 0 {
		for _, msg := range m.AstDefGuild {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Ended {
		dAtA[i] = 0x30
		i++
		if m.Ended {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AtkWin {
		dAtA[i] = 0x38
		i++
		if m.AtkWin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Country != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Country))
	}
	if m.DefGuild != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.DefGuild.Size()))
		n5, err := m.DefGuild.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *McApplyAtkProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McApplyAtkProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *McApplyAstProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McApplyAstProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *McFightProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McFightProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *McWarSceneProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarSceneProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.McId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.McId))
	}
	if len(m.Building) > 0 {
		for _, msg := range m.Building {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Troop) > 0 {
		for _, msg := range m.Troop {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.StartTime))
	}
	if m.FightState != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.FightState))
	}
	if m.AtkDrumTimes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.AtkDrumTimes))
	}
	if m.DefDrumTimes != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.DefDrumTimes))
	}
	if m.AtkDrumStat != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.AtkDrumStat.Size()))
		n6, err := m.AtkDrumStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.DefDrumStat != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.DefDrumStat.Size()))
		n7, err := m.DefDrumStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.DrumStopTime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.DrumStopTime))
	}
	if m.McAllYinliang != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.McAllYinliang))
	}
	return i, nil
}

func (m *McWarSceneBuildingProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarSceneBuildingProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Atk {
		dAtA[i] = 0x8
		i++
		if m.Atk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PosX != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.PosX))
	}
	if m.PosY != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.PosY))
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Type))
	}
	if m.Prosperity != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Prosperity))
	}
	if m.LastDestroyProsperityTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.LastDestroyProsperityTime))
	}
	if len(m.TouShiTargetPosX) > 0 {
		for _, num := range m.TouShiTargetPosX {
			dAtA[i] = 0x38
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(num))
		}
	}
	if len(m.TouShiTargetPosY) > 0 {
		for _, num := range m.TouShiTargetPosY {
			dAtA[i] = 0x40
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(num))
		}
	}
	if m.TouShiTurnEndTime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.TouShiTurnEndTime))
	}
	if m.TouShiPrepareEndTime != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.TouShiPrepareEndTime))
	}
	if m.TouShiTargetIndex != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.TouShiTargetIndex))
	}
	if len(m.LastFireHeroName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(len(m.LastFireHeroName)))
		i += copy(dAtA[i:], m.LastFireHeroName)
	}
	if m.LastFireHeroCountry != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.LastFireHeroCountry))
	}
	return i, nil
}

func (m *McWarTroopProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarTroopProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hero != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Hero.Size()))
		n8, err := m.Hero.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.CaptainIndex) > 0 {
		for _, num := range m.CaptainIndex {
			dAtA[i] = 0x10
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(num))
		}
	}
	if len(m.Captains) > 0 {
		for _, msg := range m.Captains {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Atk {
		dAtA[i] = 0x20
		i++
		if m.Atk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.State != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.State))
	}
	if m.StateStartTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.StateStartTime))
	}
	if m.StateEndTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.StateEndTime))
	}
	if m.StartPosX != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.StartPosX))
	}
	if m.StartPosY != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.StartPosY))
	}
	if m.DestPosX != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.DestPosX))
	}
	if m.DestPosY != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.DestPosY))
	}
	if m.JoinTime != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.JoinTime))
	}
	if len(m.Record) > 0 {
		for _, msg := range m.Record {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Mode != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Mode))
	}
	if m.NextDrumTime != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.NextDrumTime))
	}
	return i, nil
}

func (m *McWarTroopAllRecordProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarTroopAllRecordProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Record) > 0 {
		for _, msg := range m.Record {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *McWarTroopRecordProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarTroopRecordProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Time))
	}
	if m.Atk {
		dAtA[i] = 0x10
		i++
		if m.Atk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BuildingX != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.BuildingX))
	}
	if m.Target != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Target.Size()))
		n9, err := m.Target.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Win {
		dAtA[i] = 0x28
		i++
		if m.Win {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Link) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(len(m.Link)))
		i += copy(dAtA[i:], m.Link)
	}
	if m.BuildingY != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.BuildingY))
	}
	if len(m.BuildingName) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(len(m.BuildingName)))
		i += copy(dAtA[i:], m.BuildingName)
	}
	if m.Combat != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Combat.Size()))
		n10, err := m.Combat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Killed != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Killed))
	}
	if m.LastBeatKilled != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.LastBeatKilled))
	}
	if m.Wounded != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Wounded))
	}
	if m.TouShi {
		dAtA[i] = 0x68
		i++
		if m.TouShi {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.McId != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.McId))
	}
	return i, nil
}

func (m *McWarFightRecordProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarFightRecordProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Atk != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Atk.Size()))
		n11, err := m.Atk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Def != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Def.Size()))
		n12, err := m.Def.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.AstAtk) > 0 {
		for _, msg := range m.AstAtk {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AstDef) > 0 {
		for _, msg := range m.AstDef {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AtkYinliang != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.AtkYinliang))
	}
	if m.DefYinliang != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.DefYinliang))
	}
	if m.AtkWin {
		dAtA[i] = 0x48
		i++
		if m.AtkWin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FightDuration != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.FightDuration))
	}
	if m.McId != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.McId))
	}
	if m.Timeout {
		dAtA[i] = 0x60
		i++
		if m.Timeout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *McWarFightGuildRecordProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarFightGuildRecordProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Guild != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Guild.Size()))
		n13, err := m.Guild.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.JoinedCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.JoinedCount))
	}
	if m.KilledAmount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.KilledAmount))
	}
	if m.WoundedAmount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.WoundedAmount))
	}
	if m.Destroyed != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Destroyed))
	}
	return i, nil
}

func (m *McWarTroopsRankProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarTroopsRankProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TroopsRank) > 0 {
		for _, msg := range m.TroopsRank {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *McWarTroopRankProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarTroopRankProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Info.Size()))
		n14, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Rank != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Rank))
	}
	if m.IsAtk {
		dAtA[i] = 0x18
		i++
		if m.IsAtk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *McWarTroopsInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarTroopsInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TroopsInfo) > 0 {
		for _, msg := range m.TroopsInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *McWarTroopInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarTroopInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hero != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Hero.Size()))
		n15, err := m.Hero.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Score != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Score.Size()))
		n16, err := m.Score.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *McWarTroopScoreProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarTroopScoreProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KillAmount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.KillAmount))
	}
	if m.DestroyAmount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.DestroyAmount))
	}
	if m.WinTimes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.WinTimes))
	}
	if m.MultiKill != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.MultiKill))
	}
	if m.DrumTimes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.DrumTimes))
	}
	if m.LoseTimes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.LoseTimes))
	}
	return i, nil
}

func encodeFixed64MingcWar(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32MingcWar(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMingcWar(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *McWarGuildProto) Size() (n int) {
	var l int
	_ = l
	if m.ApplyMcId != 0 {
		n += 1 + sovMingcWar(uint64(m.ApplyMcId))
	}
	if m.ApplyMcValue != 0 {
		n += 1 + sovMingcWar(uint64(m.ApplyMcValue))
	}
	if len(m.ReqAstGuild) > 0 {
		for _, e := range m.ReqAstGuild {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	if len(m.ApplyAstAtkMcId) > 0 {
		for _, e := range m.ApplyAstAtkMcId {
			n += 1 + sovMingcWar(uint64(e))
		}
	}
	if len(m.ApplyAstDefMcId) > 0 {
		for _, e := range m.ApplyAstDefMcId {
			n += 1 + sovMingcWar(uint64(e))
		}
	}
	return n
}

func (m *McWarGuildApplyAstListProto) Size() (n int) {
	var l int
	_ = l
	if m.McId != 0 {
		n += 1 + sovMingcWar(uint64(m.McId))
	}
	if len(m.Guild) > 0 {
		for _, e := range m.Guild {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	return n
}

func (m *McWarProto) Size() (n int) {
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovMingcWar(uint64(m.State))
	}
	if m.StartTime != 0 {
		n += 1 + sovMingcWar(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovMingcWar(uint64(m.EndTime))
	}
	if len(m.Mc) > 0 {
		for _, e := range m.Mc {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	if m.Atk != nil {
		l = m.Atk.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.Ast != nil {
		l = m.Ast.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.Fight != nil {
		l = m.Fight.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovMingcWar(uint64(m.Id))
	}
	return n
}

func (m *McWarMcProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMingcWar(uint64(m.Id))
	}
	if m.ApplyAtkCount != 0 {
		n += 1 + sovMingcWar(uint64(m.ApplyAtkCount))
	}
	if m.AtkGuild != nil {
		l = m.AtkGuild.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if len(m.AstAtkGuild) > 0 {
		for _, e := range m.AstAtkGuild {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	if len(m.AstDefGuild) > 0 {
		for _, e := range m.AstDefGuild {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	if m.Ended {
		n += 2
	}
	if m.AtkWin {
		n += 2
	}
	if m.Country != 0 {
		n += 1 + sovMingcWar(uint64(m.Country))
	}
	if m.DefGuild != nil {
		l = m.DefGuild.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	return n
}

func (m *McApplyAtkProto) Size() (n int) {
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovMingcWar(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovMingcWar(uint64(m.EndTime))
	}
	return n
}

func (m *McApplyAstProto) Size() (n int) {
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovMingcWar(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovMingcWar(uint64(m.EndTime))
	}
	return n
}

func (m *McFightProto) Size() (n int) {
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovMingcWar(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovMingcWar(uint64(m.EndTime))
	}
	return n
}

func (m *McWarSceneProto) Size() (n int) {
	var l int
	_ = l
	if m.McId != 0 {
		n += 1 + sovMingcWar(uint64(m.McId))
	}
	if len(m.Building) > 0 {
		for _, e := range m.Building {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	if len(m.Troop) > 0 {
		for _, e := range m.Troop {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	if m.StartTime != 0 {
		n += 1 + sovMingcWar(uint64(m.StartTime))
	}
	if m.FightState != 0 {
		n += 1 + sovMingcWar(uint64(m.FightState))
	}
	if m.AtkDrumTimes != 0 {
		n += 1 + sovMingcWar(uint64(m.AtkDrumTimes))
	}
	if m.DefDrumTimes != 0 {
		n += 1 + sovMingcWar(uint64(m.DefDrumTimes))
	}
	if m.AtkDrumStat != nil {
		l = m.AtkDrumStat.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.DefDrumStat != nil {
		l = m.DefDrumStat.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.DrumStopTime != 0 {
		n += 1 + sovMingcWar(uint64(m.DrumStopTime))
	}
	if m.McAllYinliang != 0 {
		n += 1 + sovMingcWar(uint64(m.McAllYinliang))
	}
	return n
}

func (m *McWarSceneBuildingProto) Size() (n int) {
	var l int
	_ = l
	if m.Atk {
		n += 2
	}
	if m.PosX != 0 {
		n += 1 + sovMingcWar(uint64(m.PosX))
	}
	if m.PosY != 0 {
		n += 1 + sovMingcWar(uint64(m.PosY))
	}
	if m.Type != 0 {
		n += 1 + sovMingcWar(uint64(m.Type))
	}
	if m.Prosperity != 0 {
		n += 1 + sovMingcWar(uint64(m.Prosperity))
	}
	if m.LastDestroyProsperityTime != 0 {
		n += 1 + sovMingcWar(uint64(m.LastDestroyProsperityTime))
	}
	if len(m.TouShiTargetPosX) > 0 {
		for _, e := range m.TouShiTargetPosX {
			n += 1 + sovMingcWar(uint64(e))
		}
	}
	if len(m.TouShiTargetPosY) > 0 {
		for _, e := range m.TouShiTargetPosY {
			n += 1 + sovMingcWar(uint64(e))
		}
	}
	if m.TouShiTurnEndTime != 0 {
		n += 1 + sovMingcWar(uint64(m.TouShiTurnEndTime))
	}
	if m.TouShiPrepareEndTime != 0 {
		n += 1 + sovMingcWar(uint64(m.TouShiPrepareEndTime))
	}
	if m.TouShiTargetIndex != 0 {
		n += 1 + sovMingcWar(uint64(m.TouShiTargetIndex))
	}
	l = len(m.LastFireHeroName)
	if l > 0 {
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.LastFireHeroCountry != 0 {
		n += 1 + sovMingcWar(uint64(m.LastFireHeroCountry))
	}
	return n
}

func (m *McWarTroopProto) Size() (n int) {
	var l int
	_ = l
	if m.Hero != nil {
		l = m.Hero.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if len(m.CaptainIndex) > 0 {
		for _, e := range m.CaptainIndex {
			n += 1 + sovMingcWar(uint64(e))
		}
	}
	if len(m.Captains) > 0 {
		for _, e := range m.Captains {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	if m.Atk {
		n += 2
	}
	if m.State != 0 {
		n += 1 + sovMingcWar(uint64(m.State))
	}
	if m.StateStartTime != 0 {
		n += 1 + sovMingcWar(uint64(m.StateStartTime))
	}
	if m.StateEndTime != 0 {
		n += 1 + sovMingcWar(uint64(m.StateEndTime))
	}
	if m.StartPosX != 0 {
		n += 1 + sovMingcWar(uint64(m.StartPosX))
	}
	if m.StartPosY != 0 {
		n += 1 + sovMingcWar(uint64(m.StartPosY))
	}
	if m.DestPosX != 0 {
		n += 1 + sovMingcWar(uint64(m.DestPosX))
	}
	if m.DestPosY != 0 {
		n += 1 + sovMingcWar(uint64(m.DestPosY))
	}
	if m.JoinTime != 0 {
		n += 1 + sovMingcWar(uint64(m.JoinTime))
	}
	if len(m.Record) > 0 {
		for _, e := range m.Record {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	if m.Mode != 0 {
		n += 1 + sovMingcWar(uint64(m.Mode))
	}
	if m.NextDrumTime != 0 {
		n += 1 + sovMingcWar(uint64(m.NextDrumTime))
	}
	return n
}

func (m *McWarTroopAllRecordProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Record) > 0 {
		for _, e := range m.Record {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	return n
}

func (m *McWarTroopRecordProto) Size() (n int) {
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovMingcWar(uint64(m.Time))
	}
	if m.Atk {
		n += 2
	}
	if m.BuildingX != 0 {
		n += 1 + sovMingcWar(uint64(m.BuildingX))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.Win {
		n += 2
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.BuildingY != 0 {
		n += 1 + sovMingcWar(uint64(m.BuildingY))
	}
	l = len(m.BuildingName)
	if l > 0 {
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.Combat != nil {
		l = m.Combat.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.Killed != 0 {
		n += 1 + sovMingcWar(uint64(m.Killed))
	}
	if m.LastBeatKilled != 0 {
		n += 1 + sovMingcWar(uint64(m.LastBeatKilled))
	}
	if m.Wounded != 0 {
		n += 1 + sovMingcWar(uint64(m.Wounded))
	}
	if m.TouShi {
		n += 2
	}
	if m.McId != 0 {
		n += 1 + sovMingcWar(uint64(m.McId))
	}
	return n
}

func (m *McWarFightRecordProto) Size() (n int) {
	var l int
	_ = l
	if m.Atk != nil {
		l = m.Atk.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.Def != nil {
		l = m.Def.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if len(m.AstAtk) > 0 {
		for _, e := range m.AstAtk {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	if len(m.AstDef) > 0 {
		for _, e := range m.AstDef {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	if m.AtkYinliang != 0 {
		n += 1 + sovMingcWar(uint64(m.AtkYinliang))
	}
	if m.DefYinliang != 0 {
		n += 1 + sovMingcWar(uint64(m.DefYinliang))
	}
	if m.AtkWin {
		n += 2
	}
	if m.FightDuration != 0 {
		n += 1 + sovMingcWar(uint64(m.FightDuration))
	}
	if m.McId != 0 {
		n += 1 + sovMingcWar(uint64(m.McId))
	}
	if m.Timeout {
		n += 2
	}
	return n
}

func (m *McWarFightGuildRecordProto) Size() (n int) {
	var l int
	_ = l
	if m.Guild != nil {
		l = m.Guild.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.JoinedCount != 0 {
		n += 1 + sovMingcWar(uint64(m.JoinedCount))
	}
	if m.KilledAmount != 0 {
		n += 1 + sovMingcWar(uint64(m.KilledAmount))
	}
	if m.WoundedAmount != 0 {
		n += 1 + sovMingcWar(uint64(m.WoundedAmount))
	}
	if m.Destroyed != 0 {
		n += 1 + sovMingcWar(uint64(m.Destroyed))
	}
	return n
}

func (m *McWarTroopsRankProto) Size() (n int) {
	var l int
	_ = l
	if len(m.TroopsRank) > 0 {
		for _, e := range m.TroopsRank {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	return n
}

func (m *McWarTroopRankProto) Size() (n int) {
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.Rank != 0 {
		n += 1 + sovMingcWar(uint64(m.Rank))
	}
	if m.IsAtk {
		n += 2
	}
	return n
}

func (m *McWarTroopsInfoProto) Size() (n int) {
	var l int
	_ = l
	if len(m.TroopsInfo) > 0 {
		for _, e := range m.TroopsInfo {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	return n
}

func (m *McWarTroopInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.Hero != nil {
		l = m.Hero.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.Score != nil {
		l = m.Score.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	return n
}

func (m *McWarTroopScoreProto) Size() (n int) {
	var l int
	_ = l
	if m.KillAmount != 0 {
		n += 1 + sovMingcWar(uint64(m.KillAmount))
	}
	if m.DestroyAmount != 0 {
		n += 1 + sovMingcWar(uint64(m.DestroyAmount))
	}
	if m.WinTimes != 0 {
		n += 1 + sovMingcWar(uint64(m.WinTimes))
	}
	if m.MultiKill != 0 {
		n += 1 + sovMingcWar(uint64(m.MultiKill))
	}
	if m.DrumTimes != 0 {
		n += 1 + sovMingcWar(uint64(m.DrumTimes))
	}
	if m.LoseTimes != 0 {
		n += 1 + sovMingcWar(uint64(m.LoseTimes))
	}
	return n
}

func sovMingcWar(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMingcWar(x uint64) (n int) {
	return sovMingcWar(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *McWarGuildProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarGuildProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarGuildProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyMcId", wireType)
			}
			m.ApplyMcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyMcId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyMcValue", wireType)
			}
			m.ApplyMcValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyMcValue |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqAstGuild", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqAstGuild = append(m.ReqAstGuild, &McWarGuildApplyAstListProto{})
			if err := m.ReqAstGuild[len(m.ReqAstGuild)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApplyAstAtkMcId = append(m.ApplyAstAtkMcId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMingcWar
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMingcWar
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApplyAstAtkMcId = append(m.ApplyAstAtkMcId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyAstAtkMcId", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApplyAstDefMcId = append(m.ApplyAstDefMcId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMingcWar
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMingcWar
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApplyAstDefMcId = append(m.ApplyAstDefMcId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyAstDefMcId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarGuildApplyAstListProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarGuildApplyAstListProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarGuildApplyAstListProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field McId", wireType)
			}
			m.McId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.McId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guild", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Guild = append(m.Guild, &GuildSnapshotProto{})
			if err := m.Guild[len(m.Guild)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (MingcWarState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mc = append(m.Mc, &McWarMcProto{})
			if err := m.Mc[len(m.Mc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Atk == nil {
				m.Atk = &McApplyAtkProto{}
			}
			if err := m.Atk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ast", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ast == nil {
				m.Ast = &McApplyAstProto{}
			}
			if err := m.Ast.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fight == nil {
				m.Fight = &McFightProto{}
			}
			if err := m.Fight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarMcProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarMcProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarMcProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyAtkCount", wireType)
			}
			m.ApplyAtkCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyAtkCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkGuild", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AtkGuild == nil {
				m.AtkGuild = &GuildBasicProto{}
			}
			if err := m.AtkGuild.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AstAtkGuild", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AstAtkGuild = append(m.AstAtkGuild, &GuildBasicProto{})
			if err := m.AstAtkGuild[len(m.AstAtkGuild)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AstDefGuild", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AstDefGuild = append(m.AstDefGuild, &GuildBasicProto{})
			if err := m.AstDefGuild[len(m.AstDefGuild)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ended", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ended = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkWin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AtkWin = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			m.Country = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Country |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefGuild", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefGuild == nil {
				m.DefGuild = &GuildBasicProto{}
			}
			if err := m.DefGuild.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McApplyAtkProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McApplyAtkProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McApplyAtkProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McApplyAstProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McApplyAstProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McApplyAstProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McFightProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McFightProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McFightProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarSceneProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarSceneProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarSceneProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field McId", wireType)
			}
			m.McId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.McId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Building", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Building = append(m.Building, &McWarSceneBuildingProto{})
			if err := m.Building[len(m.Building)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Troop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Troop = append(m.Troop, &McWarTroopProto{})
			if err := m.Troop[len(m.Troop)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightState", wireType)
			}
			m.FightState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightState |= (MingcWarFightState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkDrumTimes", wireType)
			}
			m.AtkDrumTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AtkDrumTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefDrumTimes", wireType)
			}
			m.DefDrumTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefDrumTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkDrumStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AtkDrumStat == nil {
				m.AtkDrumStat = &SpriteStatProto{}
			}
			if err := m.AtkDrumStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefDrumStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefDrumStat == nil {
				m.DefDrumStat = &SpriteStatProto{}
			}
			if err := m.DefDrumStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrumStopTime", wireType)
			}
			m.DrumStopTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrumStopTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field McAllYinliang", wireType)
			}
			m.McAllYinliang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.McAllYinliang |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarSceneBuildingProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarSceneBuildingProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarSceneBuildingProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Atk = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosX", wireType)
			}
			m.PosX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PosX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosY", wireType)
			}
			m.PosY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PosY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MingcWarBuildingType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prosperity", wireType)
			}
			m.Prosperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prosperity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastDestroyProsperityTime", wireType)
			}
			m.LastDestroyProsperityTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastDestroyProsperityTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TouShiTargetPosX = append(m.TouShiTargetPosX, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMingcWar
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMingcWar
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TouShiTargetPosX = append(m.TouShiTargetPosX, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TouShiTargetPosX", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TouShiTargetPosY = append(m.TouShiTargetPosY, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMingcWar
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMingcWar
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TouShiTargetPosY = append(m.TouShiTargetPosY, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TouShiTargetPosY", wireType)
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TouShiTurnEndTime", wireType)
			}
			m.TouShiTurnEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TouShiTurnEndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TouShiPrepareEndTime", wireType)
			}
			m.TouShiPrepareEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TouShiPrepareEndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TouShiTargetIndex", wireType)
			}
			m.TouShiTargetIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TouShiTargetIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastFireHeroName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastFireHeroName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastFireHeroCountry", wireType)
			}
			m.LastFireHeroCountry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastFireHeroCountry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarTroopProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarTroopProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarTroopProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hero", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hero == nil {
				m.Hero = &HeroBasicProto{}
			}
			if err := m.Hero.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainIndex = append(m.CaptainIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMingcWar
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMingcWar
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainIndex = append(m.CaptainIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainIndex", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Captains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Captains = append(m.Captains, &CaptainInfoProto{})
			if err := m.Captains[len(m.Captains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Atk = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (MingcWarTroopState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateStartTime", wireType)
			}
			m.StateStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StateStartTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateEndTime", wireType)
			}
			m.StateEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StateEndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPosX", wireType)
			}
			m.StartPosX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPosX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPosY", wireType)
			}
			m.StartPosY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPosY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestPosX", wireType)
			}
			m.DestPosX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestPosX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestPosY", wireType)
			}
			m.DestPosY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestPosY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinTime", wireType)
			}
			m.JoinTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Record", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Record = append(m.Record, &McWarTroopRecordProto{})
			if err := m.Record[len(m.Record)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (MingcWarModeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextDrumTime", wireType)
			}
			m.NextDrumTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextDrumTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarTroopAllRecordProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarTroopAllRecordProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarTroopAllRecordProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Record", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Record = append(m.Record, &McWarTroopRecordProto{})
			if err := m.Record[len(m.Record)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarTroopRecordProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarTroopRecordProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarTroopRecordProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Atk = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingX", wireType)
			}
			m.BuildingX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &HeroBasicProto{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Win = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingY", wireType)
			}
			m.BuildingY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildingName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Combat == nil {
				m.Combat = &CombatShareProto{}
			}
			if err := m.Combat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Killed", wireType)
			}
			m.Killed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Killed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBeatKilled", wireType)
			}
			m.LastBeatKilled = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastBeatKilled |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wounded", wireType)
			}
			m.Wounded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Wounded |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TouShi", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TouShi = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field McId", wireType)
			}
			m.McId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.McId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarFightRecordProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarFightRecordProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarFightRecordProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Atk == nil {
				m.Atk = &McWarFightGuildRecordProto{}
			}
			if err := m.Atk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Def == nil {
				m.Def = &McWarFightGuildRecordProto{}
			}
			if err := m.Def.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AstAtk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AstAtk = append(m.AstAtk, &McWarFightGuildRecordProto{})
			if err := m.AstAtk[len(m.AstAtk)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AstDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AstDef = append(m.AstDef, &McWarFightGuildRecordProto{})
			if err := m.AstDef[len(m.AstDef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkYinliang", wireType)
			}
			m.AtkYinliang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AtkYinliang |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefYinliang", wireType)
			}
			m.DefYinliang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefYinliang |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkWin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AtkWin = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightDuration", wireType)
			}
			m.FightDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field McId", wireType)
			}
			m.McId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.McId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timeout = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarFightGuildRecordProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarFightGuildRecordProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarFightGuildRecordProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guild", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Guild == nil {
				m.Guild = &GuildBasicProto{}
			}
			if err := m.Guild.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinedCount", wireType)
			}
			m.JoinedCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinedCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KilledAmount", wireType)
			}
			m.KilledAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KilledAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WoundedAmount", wireType)
			}
			m.WoundedAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WoundedAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destroyed", wireType)
			}
			m.Destroyed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Destroyed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarTroopsRankProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarTroopsRankProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarTroopsRankProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TroopsRank", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TroopsRank = append(m.TroopsRank, &McWarTroopRankProto{})
			if err := m.TroopsRank[len(m.TroopsRank)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarTroopRankProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarTroopRankProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarTroopRankProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &McWarTroopInfoProto{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAtk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAtk = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarTroopsInfoProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarTroopsInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarTroopsInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TroopsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TroopsInfo = append(m.TroopsInfo, &McWarTroopInfoProto{})
			if err := m.TroopsInfo[len(m.TroopsInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarTroopInfoProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarTroopInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarTroopInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hero", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hero == nil {
				m.Hero = &HeroBasicProto{}
			}
			if err := m.Hero.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Score == nil {
				m.Score = &McWarTroopScoreProto{}
			}
			if err := m.Score.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarTroopScoreProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarTroopScoreProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarTroopScoreProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillAmount", wireType)
			}
			m.KillAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestroyAmount", wireType)
			}
			m.DestroyAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestroyAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinTimes", wireType)
			}
			m.WinTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiKill", wireType)
			}
			m.MultiKill = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MultiKill |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrumTimes", wireType)
			}
			m.DrumTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrumTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoseTimes", wireType)
			}
			m.LoseTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoseTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMingcWar(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMingcWar
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMingcWar(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMingcWar = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMingcWar   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/shared_proto/mingc_war.proto", fileDescriptorMingcWar)
}

var fileDescriptorMingcWar = []byte{
	// 2190 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0xdd, 0x72, 0x1b, 0x49,
	0x15, 0xce, 0xe8, 0xcf, 0xd2, 0x91, 0x25, 0x4f, 0xda, 0x8e, 0xa3, 0xfc, 0x19, 0xaf, 0xb2, 0x2c,
	0x5e, 0xc3, 0x46, 0x8b, 0xbd, 0x2c, 0x4b, 0xb8, 0xa0, 0xc6, 0xb1, 0x1c, 0xab, 0x62, 0x39, 0xaa,
	0x91, 0xd6, 0x59, 0x73, 0x33, 0x35, 0xd6, 0xb4, 0xec, 0x41, 0xf3, 0xa3, 0x9d, 0x69, 0xe1, 0x88,
	0x3b, 0x8a, 0x97, 0xe0, 0x09, 0xb8, 0xe4, 0x8a, 0x87, 0xe0, 0x8a, 0xa2, 0x8a, 0x0b, 0xb8, 0xa4,
	0xc2, 0x13, 0xf0, 0x00, 0x54, 0x51, 0x7d, 0xba, 0x7b, 0x66, 0xe4, 0xbf, 0x38, 0xbb, 0x57, 0xd6,
	0x9c, 0xf3, 0x9d, 0xff, 0xd3, 0xa7, 0x4f, 0x1b, 0x7e, 0x71, 0xea, 0xb2, 0xb3, 0xe9, 0xc9, 0xb3,
	0x61, 0xe8, 0xb7, 0x3c, 0xf7, 0xf4, 0x8c, 0x4d, 0xec, 0xf3, 0x96, 0x6f, 0x7b, 0xf4, 0xe7, 0xad,
	0xc9, 0x49, 0x2b, 0x3e, 0xb3, 0x23, 0xea, 0x58, 0x93, 0x28, 0x64, 0x61, 0xcb, 0x77, 0x83, 0xd3,
	0xa1, 0x75, 0x6e, 0x47, 0xcf, 0xf0, 0x9b, 0x14, 0xf1, 0xcf, 0xc3, 0x2f, 0x6e, 0xaf, 0xe1, 0xc4,
	0x8e, 0xa9, 0x10, 0x7e, 0xf8, 0xd5, 0xed, 0xa5, 0xe2, 0xc0, 0x9e, 0xc4, 0x67, 0x21, 0x93, 0x92,
	0x3f, 0xbb, 0xbd, 0xe4, 0xe9, 0xd4, 0xf5, 0x9c, 0x0f, 0x37, 0xe8, 0xbb, 0x9e, 0xcb, 0xec, 0x68,
	0x26, 0x25, 0xbf, 0xbc, 0xbd, 0xe4, 0x30, 0xf4, 0x4f, 0x6c, 0xe9, 0x68, 0xf3, 0x0f, 0x39, 0x58,
	0xea, 0x0e, 0xdf, 0xd8, 0xd1, 0x4b, 0xee, 0x46, 0x0f, 0x73, 0xb6, 0x06, 0x55, 0x7b, 0x32, 0xf1,
	0x66, 0x96, 0x3f, 0xb4, 0x5c, 0xa7, 0xa1, 0xad, 0x6b, 0x1b, 0x45, 0xb3, 0x82, 0xa4, 0xee, 0xb0,
	0xe3, 0x90, 0x8f, 0xa1, 0x9e, 0xf0, 0x7f, 0x6b, 0x7b, 0x53, 0xda, 0xc8, 0x21, 0x64, 0x51, 0x42,
	0x8e, 0x38, 0x8d, 0xec, 0x41, 0x2d, 0xa2, 0xdf, 0x5a, 0x76, 0xcc, 0x2c, 0x0c, 0xb1, 0x51, 0x58,
	0xcf, 0x6f, 0x54, 0xb7, 0x9a, 0xc2, 0xf0, 0xb3, 0xd4, 0xa8, 0xc1, 0xa5, 0x8c, 0x98, 0x1d, 0xb8,
	0x31, 0x43, 0x07, 0xcc, 0x6a, 0x44, 0xbf, 0x35, 0x62, 0x86, 0x5c, 0xf2, 0x39, 0x2c, 0x0b, 0x6b,
	0x5c, 0x93, 0xcd, 0xc6, 0xd2, 0xab, 0xe2, 0x7a, 0x7e, 0xa3, 0xb8, 0x93, 0xd3, 0xef, 0x98, 0x4b,
	0xb6, 0x54, 0x60, 0xb0, 0x31, 0xfa, 0x37, 0x27, 0xe1, 0xd0, 0x91, 0x94, 0x28, 0x5d, 0x96, 0xd8,
	0xa5, 0x23, 0x2e, 0xd1, 0x1c, 0xc2, 0xa3, 0x1b, 0xfc, 0x21, 0xcb, 0x50, 0xcc, 0xa6, 0xa2, 0xe0,
	0x73, 0x2b, 0x2d, 0x28, 0x8a, 0xb8, 0xf2, 0x18, 0xd7, 0x03, 0x19, 0x17, 0xaa, 0xe8, 0xcb, 0x6e,
	0x10, 0xe1, 0x08, 0x5c, 0xf3, 0x4f, 0x39, 0x00, 0xb4, 0x22, 0x94, 0x6e, 0x42, 0x31, 0x66, 0x36,
	0xa3, 0xa8, 0xb4, 0xbe, 0xb5, 0xa2, 0xf2, 0xc2, 0x1b, 0xf8, 0x8d, 0x1d, 0xf5, 0x39, 0xcf, 0x14,
	0x10, 0xf2, 0x04, 0x20, 0x66, 0x76, 0xc4, 0x2c, 0xe6, 0xfa, 0x2a, 0xdb, 0x15, 0xa4, 0x0c, 0x5c,
	0x9f, 0x92, 0x07, 0x50, 0xa6, 0x81, 0x23, 0x98, 0x79, 0x64, 0x2e, 0xd0, 0xc0, 0x41, 0xd6, 0x53,
	0xc8, 0xf9, 0x43, 0x99, 0xfa, 0xe5, 0x6c, 0xea, 0xbb, 0x43, 0xe1, 0x5c, 0xce, 0x1f, 0x92, 0x0d,
	0xc8, 0xdb, 0x6c, 0xdc, 0x28, 0xae, 0x6b, 0x1b, 0xd5, 0xad, 0xd5, 0x04, 0x25, 0x12, 0xc1, 0xc6,
	0x02, 0xc8, 0x21, 0x88, 0x8c, 0x59, 0xa3, 0x74, 0x25, 0x52, 0x95, 0x8f, 0x43, 0xc8, 0xa7, 0x50,
	0x1c, 0xf1, 0x3e, 0x6c, 0x2c, 0x20, 0x36, 0xb5, 0xbd, 0xc7, 0xa9, 0x32, 0x31, 0x88, 0x20, 0x75,
	0xc8, 0xb9, 0x4e, 0xa3, 0x8c, 0x8e, 0xe7, 0x5c, 0xa7, 0xf9, 0xdf, 0x1c, 0x2c, 0x66, 0x7d, 0x94,
	0x00, 0x4d, 0x01, 0xc8, 0x27, 0xb0, 0x24, 0x0b, 0xcc, 0xc6, 0xd6, 0x30, 0x9c, 0x06, 0x4c, 0xe6,
	0xa4, 0x66, 0x4b, 0x97, 0x5f, 0x70, 0x22, 0xd9, 0x86, 0x0a, 0x47, 0xa8, 0x32, 0x65, 0x7d, 0xc6,
	0x32, 0xed, 0xd8, 0xb1, 0x2b, 0xd3, 0x50, 0xb6, 0xd9, 0x58, 0xf4, 0xdb, 0x73, 0xa8, 0xa9, 0x4e,
	0xcb, 0xf6, 0xed, 0x75, 0x82, 0x55, 0x1b, 0x1b, 0x6f, 0x4e, 0x96, 0xf7, 0x9c, 0x90, 0x2d, 0xbe,
	0x57, 0x76, 0x97, 0x8e, 0x84, 0xec, 0x0a, 0x14, 0x69, 0xe0, 0x50, 0x07, 0x93, 0x5b, 0x36, 0xc5,
	0x07, 0xb9, 0x0f, 0x0b, 0xdc, 0x93, 0x73, 0x37, 0xc0, 0x44, 0x96, 0xcd, 0x92, 0xcd, 0xc6, 0x6f,
	0xdc, 0x80, 0x34, 0x60, 0x01, 0x23, 0x8f, 0x66, 0x32, 0x73, 0xea, 0x93, 0x47, 0x9d, 0x3a, 0x50,
	0xb9, 0x39, 0x6a, 0x47, 0x5a, 0x6f, 0xbe, 0xe2, 0x63, 0x60, 0xae, 0xe0, 0xdf, 0xbd, 0xe9, 0xb2,
	0xca, 0xd4, 0x11, 0xfa, 0xee, 0xca, 0xf6, 0x79, 0x33, 0xa4, 0x4d, 0xf3, 0x3d, 0x34, 0xfd, 0x2f,
	0x2f, 0x67, 0x5d, 0x7f, 0x48, 0x03, 0x7a, 0xc3, 0xd1, 0x7e, 0x0e, 0xe5, 0x13, 0x9e, 0x15, 0x37,
	0x38, 0x6d, 0xe4, 0xb0, 0x82, 0x6b, 0xd9, 0xa3, 0x83, 0xe2, 0x3b, 0x12, 0x20, 0x13, 0xa9, 0xf0,
	0xe4, 0x27, 0x50, 0x64, 0x51, 0x18, 0x4e, 0xe4, 0x58, 0x58, 0xcd, 0x0a, 0x0e, 0x38, 0x43, 0xb6,
	0x3e, 0x82, 0x2e, 0x04, 0x53, 0xb8, 0x18, 0xcc, 0x73, 0xa8, 0xe2, 0x11, 0xb1, 0xc4, 0xa4, 0x28,
	0xe2, 0xa4, 0x78, 0x70, 0x61, 0x52, 0x60, 0x6e, 0xc4, 0xb8, 0x80, 0x51, 0xf2, 0x1b, 0xa7, 0x34,
	0x1b, 0x5b, 0x4e, 0x34, 0xf5, 0x51, 0x7b, 0x8c, 0x8d, 0xc5, 0xa7, 0x34, 0x1b, 0xef, 0x46, 0x53,
	0x9f, 0x1b, 0x88, 0x39, 0x8a, 0x37, 0x4b, 0x06, 0xb5, 0x20, 0x50, 0x0e, 0x1d, 0xa5, 0x28, 0xde,
	0xd7, 0x4a, 0x17, 0x77, 0x05, 0x5b, 0x2e, 0x0d, 0xae, 0x3f, 0x89, 0x5c, 0x46, 0xb9, 0x59, 0xd5,
	0xd7, 0xc2, 0x04, 0xa7, 0x70, 0xd9, 0xc4, 0x02, 0xca, 0x56, 0x6e, 0x96, 0x95, 0x86, 0x51, 0x96,
	0x7b, 0x27, 0xe4, 0xc2, 0x89, 0x48, 0x11, 0x48, 0xef, 0x10, 0x11, 0x4e, 0x30, 0x4b, 0x9f, 0xc0,
	0x92, 0x3f, 0xb4, 0x6c, 0xcf, 0xb3, 0x66, 0x6e, 0xe0, 0xb9, 0x76, 0x70, 0xda, 0xa8, 0x8a, 0x71,
	0xe0, 0x0f, 0x0d, 0xcf, 0x3b, 0x96, 0xc4, 0xe6, 0xdf, 0x0a, 0x70, 0xff, 0x9a, 0x02, 0x12, 0x5d,
	0x8c, 0x40, 0x0d, 0xcf, 0x18, 0x8e, 0xba, 0x65, 0x28, 0x4e, 0xc2, 0xd8, 0x7a, 0x2b, 0x5b, 0xac,
	0x30, 0x09, 0xe3, 0x6f, 0x14, 0x71, 0x26, 0x5b, 0x8b, 0x13, 0x8f, 0x49, 0x0b, 0x0a, 0x6c, 0x36,
	0x11, 0xe5, 0xab, 0x6f, 0x3d, 0xba, 0x50, 0x1e, 0x65, 0x67, 0x30, 0x9b, 0x50, 0x13, 0x81, 0x64,
	0x0d, 0x60, 0x12, 0x85, 0xf1, 0x84, 0x46, 0x2e, 0x9b, 0x61, 0x55, 0x8b, 0x66, 0x86, 0x42, 0x7e,
	0x05, 0x8f, 0x3d, 0x31, 0x47, 0x62, 0x16, 0x85, 0x33, 0x2b, 0x65, 0x89, 0x24, 0x88, 0x42, 0x3e,
	0xf0, 0x70, 0x7c, 0x20, 0xa4, 0x97, 0x20, 0x30, 0x23, 0x5b, 0xb0, 0xc2, 0xc2, 0xa9, 0x15, 0x9f,
	0xb9, 0x16, 0xb3, 0xa3, 0x53, 0xca, 0x2c, 0x11, 0xca, 0x42, 0x72, 0x05, 0xea, 0x2c, 0x9c, 0xf6,
	0xcf, 0xdc, 0x01, 0x72, 0x7b, 0x3c, 0xb4, 0xab, 0x65, 0xf8, 0x74, 0xb9, 0x4e, 0xe6, 0x98, 0x7c,
	0x0e, 0xf7, 0x12, 0x99, 0x69, 0x14, 0x58, 0xc9, 0xc9, 0x13, 0x65, 0xba, 0x2b, 0x05, 0xa6, 0x51,
	0xd0, 0x96, 0xf7, 0xd1, 0x97, 0xd0, 0x50, 0x12, 0x93, 0x88, 0x4e, 0xec, 0x88, 0xa6, 0x42, 0xa2,
	0x68, 0x2b, 0x42, 0xa8, 0x27, 0xb8, 0x4a, 0xae, 0x75, 0xc9, 0x3b, 0x37, 0x70, 0xe8, 0xdb, 0xc6,
	0xe2, 0x9c, 0x21, 0xe4, 0x74, 0x38, 0x83, 0x7c, 0x06, 0xcb, 0x98, 0xc3, 0x91, 0x1b, 0x51, 0xeb,
	0x8c, 0x46, 0xa1, 0x15, 0xd8, 0x3e, 0x6d, 0xd4, 0xd6, 0xb5, 0x8d, 0x8a, 0xa9, 0x73, 0xd6, 0x9e,
	0x1b, 0xd1, 0x7d, 0x1a, 0x85, 0x87, 0xb6, 0x4f, 0xc9, 0x36, 0xac, 0x5e, 0x80, 0xab, 0xe9, 0x5a,
	0x47, 0x0b, 0xcb, 0x59, 0x89, 0x17, 0x82, 0xd5, 0xfc, 0x47, 0x41, 0x0e, 0x94, 0xf4, 0x60, 0x93,
	0x4f, 0xa1, 0xc0, 0xc5, 0xb1, 0x93, 0xaa, 0x5b, 0xf7, 0x64, 0x33, 0x70, 0xa9, 0xcc, 0xdc, 0x45,
	0x08, 0xf9, 0x11, 0xd4, 0x86, 0xf6, 0x84, 0xd9, 0x6e, 0x20, 0x83, 0xc9, 0x25, 0xa9, 0x5e, 0x94,
	0x0c, 0x11, 0xcb, 0x36, 0x94, 0xe5, 0x77, 0x2c, 0xc7, 0xca, 0x7d, 0xa9, 0xf7, 0x85, 0x82, 0x8d,
	0x42, 0x39, 0x88, 0x14, 0x50, 0x75, 0x74, 0x21, 0xed, 0xe8, 0x96, 0xda, 0x38, 0xae, 0x9e, 0x23,
	0x18, 0xc4, 0xdc, 0xda, 0xb1, 0x01, 0x3a, 0xfe, 0xb0, 0x32, 0x33, 0x4a, 0xf4, 0x5e, 0x1d, 0xe9,
	0xfd, 0x64, 0x50, 0x7d, 0x0c, 0x82, 0x92, 0x16, 0x53, 0x8e, 0x11, 0xa4, 0xaa, 0x22, 0xae, 0x41,
	0x55, 0x68, 0x12, 0xdd, 0x58, 0xce, 0x8c, 0x3b, 0x6c, 0xc1, 0x39, 0xfe, 0x0c, 0x07, 0x45, 0x86,
	0x7f, 0x4c, 0x1e, 0x03, 0xf0, 0x23, 0x21, 0xc5, 0x45, 0x8f, 0x95, 0x39, 0x05, 0xa5, 0xb3, 0xdc,
	0x99, 0x6c, 0x26, 0xc5, 0x3d, 0x26, 0x8f, 0xa0, 0xf2, 0x9b, 0xd0, 0x0d, 0x84, 0x73, 0xa2, 0x6b,
	0xca, 0x9c, 0x80, 0x8e, 0x7d, 0x05, 0xa5, 0x88, 0x0e, 0xc3, 0xc8, 0x69, 0xd4, 0x30, 0xbd, 0x8f,
	0x2f, 0x4d, 0x6d, 0x13, 0xd9, 0x98, 0xe3, 0x9d, 0x5c, 0x43, 0x33, 0x25, 0x9e, 0xfc, 0x18, 0x0a,
	0x7e, 0xe8, 0x50, 0xec, 0x92, 0x7a, 0x52, 0x16, 0x95, 0xd2, 0x6e, 0xe8, 0x50, 0x71, 0xee, 0x39,
	0x88, 0x67, 0x29, 0xa0, 0x6f, 0x59, 0x3a, 0x6d, 0x1b, 0x4b, 0x22, 0x4b, 0x9c, 0xaa, 0xa6, 0x6d,
	0xb3, 0x07, 0x8d, 0xd4, 0xae, 0xe1, 0x79, 0x19, 0xd3, 0xe4, 0x8b, 0xc4, 0x51, 0xed, 0xfd, 0x8e,
	0x2a, 0x27, 0x9b, 0x7f, 0xc9, 0xc3, 0xbd, 0x2b, 0x11, 0x84, 0x40, 0x01, 0xfd, 0x90, 0xb7, 0x1f,
	0xff, 0xad, 0x1a, 0x27, 0x97, 0x36, 0xce, 0x13, 0x00, 0x75, 0xbf, 0x59, 0x6f, 0xe5, 0xe8, 0xab,
	0x28, 0xca, 0x37, 0xe4, 0x33, 0x28, 0x89, 0x33, 0x89, 0xcd, 0x76, 0x6d, 0xd3, 0x4b, 0x10, 0xd7,
	0xcf, 0xd7, 0x99, 0xa2, 0xd0, 0x7f, 0xee, 0x06, 0x64, 0x15, 0x0a, 0x9e, 0x1b, 0x8c, 0xb1, 0xb7,
	0x2a, 0x98, 0x5e, 0xfc, 0x9e, 0xb3, 0x3b, 0x93, 0x1d, 0x95, 0xd8, 0x3d, 0x26, 0x4f, 0xa1, 0x96,
	0xb0, 0xf1, 0x70, 0x97, 0xf1, 0x70, 0x2f, 0x2a, 0x22, 0x1e, 0xec, 0x16, 0x94, 0xc4, 0x83, 0x47,
	0xde, 0x3b, 0xc9, 0xc9, 0x41, 0x62, 0x9f, 0x3f, 0x8c, 0xa4, 0x7b, 0x02, 0x46, 0x56, 0xa1, 0x34,
	0x76, 0x3d, 0x8f, 0x3a, 0xb2, 0xc1, 0xe4, 0x17, 0x3f, 0x0c, 0x38, 0x21, 0x4e, 0xa8, 0xcd, 0x2c,
	0x89, 0x10, 0x4d, 0x56, 0xe7, 0xf4, 0x1d, 0x6a, 0xb3, 0x57, 0x02, 0xd9, 0x80, 0x85, 0xf3, 0x70,
	0x8a, 0xbb, 0x9c, 0x68, 0x34, 0xf5, 0xc9, 0xb7, 0x39, 0x39, 0xc5, 0x70, 0x10, 0x95, 0xcd, 0x92,
	0x18, 0x5c, 0xe9, 0x1a, 0x52, 0x4f, 0xd7, 0x90, 0xe6, 0x9f, 0x55, 0xd9, 0xf0, 0x86, 0xcf, 0x96,
	0x6d, 0x3b, 0xbd, 0xad, 0xaa, 0x5b, 0x1f, 0x65, 0x7b, 0x00, 0xa1, 0xb8, 0xd2, 0x65, 0x1b, 0x01,
	0xab, 0xb8, 0x0d, 0x79, 0x87, 0x8e, 0xb0, 0xae, 0xb7, 0x13, 0x72, 0xe8, 0x88, 0x3c, 0x87, 0x05,
	0xb9, 0x0d, 0xcb, 0xc9, 0x73, 0x0b, 0xc1, 0x92, 0x58, 0x89, 0x95, 0x2c, 0x37, 0x5a, 0xf8, 0x10,
	0xd9, 0x5d, 0x3a, 0x22, 0x1f, 0x01, 0xdf, 0x53, 0xd2, 0x0b, 0x5d, 0x14, 0x9f, 0x2f, 0x16, 0xea,
	0x3a, 0xe7, 0x10, 0xbe, 0x58, 0x24, 0x10, 0x31, 0x4e, 0xf8, 0xfe, 0x90, 0x40, 0x32, 0xdb, 0x73,
	0x65, 0x6e, 0x7b, 0xfe, 0x21, 0xd4, 0xc5, 0x62, 0xe5, 0x4c, 0x23, 0x9b, 0xb9, 0x61, 0x20, 0x8b,
	0x5d, 0x43, 0xea, 0xae, 0x24, 0xa6, 0x65, 0xa9, 0x66, 0xb6, 0xc3, 0x06, 0x2c, 0xf0, 0x73, 0x12,
	0x4e, 0x19, 0x96, 0xb7, 0x6c, 0xaa, 0xcf, 0xe6, 0x3f, 0x35, 0x78, 0x78, 0x7d, 0x6c, 0x7c, 0x35,
	0x14, 0x4b, 0xb9, 0x76, 0xe3, 0x52, 0x2e, 0x40, 0x3c, 0x3c, 0x3e, 0x9f, 0xa8, 0x33, 0xf7, 0xc2,
	0xa9, 0x0a, 0x9a, 0x78, 0xdf, 0x3c, 0x85, 0x9a, 0x68, 0x44, 0xcb, 0xf6, 0x11, 0x23, 0x8e, 0xe6,
	0xa2, 0x20, 0x1a, 0x48, 0xe3, 0xa1, 0xca, 0xf6, 0x53, 0x28, 0xb1, 0x66, 0xd6, 0x24, 0x55, 0xc2,
	0x1e, 0xf3, 0x57, 0x03, 0xee, 0x12, 0xd4, 0x91, 0x2b, 0x49, 0x4a, 0x68, 0xf6, 0x61, 0x25, 0x1d,
	0x20, 0xb1, 0x69, 0x07, 0xf2, 0x8d, 0xf0, 0x4b, 0xa8, 0xe2, 0x22, 0x1b, 0x5b, 0x91, 0x1d, 0x8c,
	0xe5, 0x50, 0x7a, 0x78, 0x79, 0x28, 0x29, 0x01, 0x13, 0x58, 0xa2, 0xa1, 0x19, 0xc2, 0xf2, 0x15,
	0x10, 0xf2, 0x0c, 0x0a, 0x6e, 0x30, 0x52, 0x37, 0xe8, 0x65, 0x65, 0xe9, 0x65, 0x87, 0x38, 0x3e,
	0xc3, 0xd0, 0xb8, 0xdc, 0xd3, 0xf8, 0x6f, 0xfe, 0x98, 0x72, 0x63, 0x03, 0x9b, 0x16, 0x1f, 0x53,
	0xf8, 0x71, 0x21, 0x8a, 0x44, 0x4f, 0x26, 0x0a, 0x69, 0x38, 0xff, 0x1e, 0xc3, 0x32, 0x0a, 0x4e,
	0x68, 0xc6, 0xd9, 0x28, 0x52, 0x9d, 0x1f, 0xb0, 0x07, 0xfc, 0x14, 0x8a, 0xf1, 0x30, 0x8c, 0xa8,
	0x3c, 0x9a, 0x8f, 0x2e, 0x19, 0xee, 0x73, 0xae, 0x6c, 0x0e, 0x44, 0x36, 0xff, 0xa5, 0x65, 0x43,
	0x49, 0xf9, 0xe4, 0x07, 0x50, 0xe5, 0xd5, 0x57, 0xa5, 0x16, 0x73, 0x1d, 0x38, 0x29, 0x6d, 0x07,
	0xb5, 0x56, 0x4a, 0x8c, 0x7c, 0x3a, 0x4b, 0xaa, 0x84, 0x3d, 0x82, 0xca, 0xb9, 0xbc, 0x2d, 0x63,
	0xd9, 0x56, 0xe5, 0x73, 0x71, 0x5b, 0xc6, 0x7c, 0x2e, 0xfb, 0x53, 0x8f, 0xb9, 0x38, 0x06, 0xd5,
	0xab, 0x05, 0x29, 0x7c, 0x02, 0x72, 0x76, 0xe6, 0x3d, 0xa1, 0x7a, 0x29, 0x79, 0x4c, 0x3c, 0x01,
	0xf0, 0xc2, 0x98, 0xce, 0x3d, 0x4a, 0x2a, 0x9c, 0x82, 0xec, 0xcd, 0xdf, 0x6b, 0x50, 0x9b, 0xfb,
	0x27, 0x08, 0xd1, 0x61, 0xb1, 0xfb, 0xc2, 0x1a, 0x58, 0x9d, 0xc3, 0x23, 0xe3, 0xa0, 0xb3, 0xab,
	0xdf, 0x21, 0x04, 0xea, 0x48, 0x31, 0x7a, 0xbd, 0x83, 0x63, 0xcb, 0x18, 0xbc, 0xd2, 0xb5, 0x8b,
	0xb4, 0xfe, 0x40, 0xcf, 0x91, 0x3a, 0x00, 0xd2, 0xf6, 0x3a, 0x2f, 0xf7, 0x07, 0x7a, 0x3e, 0xc1,
	0xe0, 0xb7, 0xd5, 0x3e, 0xdc, 0xd5, 0x0b, 0x09, 0xed, 0xf0, 0xf5, 0xc0, 0xea, 0x0f, 0x0c, 0x73,
	0xa0, 0x17, 0x37, 0x8f, 0x80, 0x5c, 0x7e, 0x5d, 0x49, 0x3f, 0xf6, 0x32, 0x7e, 0xac, 0x02, 0x41,
	0x8a, 0xd0, 0xd7, 0x33, 0xdb, 0x3d, 0xc3, 0x6c, 0xeb, 0xda, 0x05, 0xba, 0xf9, 0xf5, 0xe1, 0x61,
	0xe7, 0xf0, 0xa5, 0x9e, 0xdb, 0xfc, 0x1d, 0xac, 0x5c, 0xf5, 0x2c, 0x90, 0x9a, 0x77, 0x32, 0x9a,
	0x97, 0xa0, 0x8a, 0x14, 0xb3, 0x7d, 0xd0, 0x39, 0xe2, 0x2a, 0x6b, 0x50, 0x41, 0xc2, 0xfe, 0xeb,
	0x6e, 0x5b, 0xcf, 0x25, 0xfc, 0x17, 0x46, 0x7f, 0x70, 0xd0, 0xd6, 0xf3, 0x09, 0xff, 0xa5, 0x31,
	0x68, 0xeb, 0x85, 0x44, 0xe3, 0xe0, 0xf5, 0xd7, 0x56, 0x7f, 0xbf, 0xa3, 0x17, 0x37, 0x83, 0x34,
	0xa6, 0x74, 0xd3, 0x23, 0x77, 0xa1, 0xc6, 0xa3, 0xef, 0x65, 0x4c, 0x27, 0xa4, 0xfe, 0xc0, 0x18,
	0x74, 0x5e, 0x1f, 0xea, 0x9a, 0xaa, 0x40, 0xcf, 0xea, 0xbe, 0x3e, 0xc2, 0x48, 0x52, 0x8a, 0x74,
	0x30, 0xaf, 0x72, 0xdd, 0xb3, 0xde, 0x18, 0x9d, 0x81, 0x5e, 0xd8, 0xa4, 0x70, 0x57, 0xd9, 0xc3,
	0x09, 0x97, 0x09, 0xf4, 0x65, 0xc6, 0xda, 0x22, 0x94, 0x91, 0x22, 0x8a, 0xa8, 0xf8, 0x46, 0x7f,
	0x80, 0x94, 0x5c, 0xc2, 0xdf, 0x6d, 0xef, 0xe9, 0xf9, 0x39, 0x3e, 0xa7, 0x14, 0x36, 0x0f, 0x40,
	0xbf, 0xb8, 0x6d, 0xc9, 0x08, 0xba, 0xd9, 0x8e, 0x11, 0x82, 0x5d, 0x5e, 0x66, 0xb3, 0x6b, 0x1c,
	0xe8, 0x1a, 0x59, 0x86, 0x25, 0x41, 0xd9, 0x33, 0xdb, 0x6d, 0x6b, 0x60, 0x1c, 0xbe, 0xd2, 0x73,
	0x3b, 0xeb, 0x7f, 0x7d, 0xb7, 0xa6, 0xfd, 0xfd, 0xdd, 0x9a, 0xf6, 0xef, 0x77, 0x6b, 0xda, 0x1f,
	0xff, 0xb3, 0x76, 0x67, 0x5f, 0xfb, 0xf5, 0x62, 0xf6, 0xbf, 0xa7, 0x27, 0x25, 0xfc, 0xb3, 0xfd,
	0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x9a, 0xd8, 0x5c, 0x11, 0x94, 0x16, 0x00, 0x00,
}
