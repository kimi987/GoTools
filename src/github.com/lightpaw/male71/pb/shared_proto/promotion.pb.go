// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/shared_proto/promotion.proto
// DO NOT EDIT!

package shared_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type GiftType int32

const (
	GiftType_InvalidGift   GiftType = 0
	GiftType_DAILY_BARGAIN GiftType = 1
)

var GiftType_name = map[int32]string{
	0: "InvalidGift",
	1: "DAILY_BARGAIN",
}
var GiftType_value = map[string]int32{
	"InvalidGift":   0,
	"DAILY_BARGAIN": 1,
}

func (x GiftType) String() string {
	return proto.EnumName(GiftType_name, int32(x))
}
func (GiftType) EnumDescriptor() ([]byte, []int) { return fileDescriptorPromotion, []int{0} }

type HeroPromotionProto struct {
	// 已领取的登陆天数奖励
	CollectLoginPrizeDay []int32 `protobuf:"varint,1,rep,name=collect_login_prize_day,json=collectLoginPrizeDay" json:"collect_login_prize_day,omitempty"`
	// 已领取的君主等级基金
	CollectLevelFund []int32 `protobuf:"varint,3,rep,name=collect_level_fund,json=collectLevelFund" json:"collect_level_fund,omitempty"`
	// 当天已经领取的体力值奖励
	CollectDailySp []int32 `protobuf:"varint,2,rep,name=collect_daily_sp,json=collectDailySp" json:"collect_daily_sp,omitempty"`
	// 日常免费礼包
	CollectDailyFreeGift []int32 `protobuf:"varint,4,rep,name=collect_daily_free_gift,json=collectDailyFreeGift" json:"collect_daily_free_gift,omitempty"`
	// 一次性免费礼包
	CollectFreeGift []int32 `protobuf:"varint,5,rep,name=collect_free_gift,json=collectFreeGift" json:"collect_free_gift,omitempty"`
	// 时限礼包
	BuyTimeLimitGift []*TimeLimitGiftBoughtProto `protobuf:"bytes,6,rep,name=buy_time_limit_gift,json=buyTimeLimitGift" json:"buy_time_limit_gift,omitempty"`
	// 事件礼包
	EventLimitGifts []*EventLimitGiftProto `protobuf:"bytes,7,rep,name=event_limit_gifts,json=eventLimitGifts" json:"event_limit_gifts,omitempty"`
	// 时限礼包的购买次数
	TimeLimitGiftBuyTimes []*TimeLimitGiftBuyTimesProto `protobuf:"bytes,8,rep,name=time_limit_gift_buy_times,json=timeLimitGiftBuyTimes" json:"time_limit_gift_buy_times,omitempty"`
}

func (m *HeroPromotionProto) Reset()                    { *m = HeroPromotionProto{} }
func (m *HeroPromotionProto) String() string            { return proto.CompactTextString(m) }
func (*HeroPromotionProto) ProtoMessage()               {}
func (*HeroPromotionProto) Descriptor() ([]byte, []int) { return fileDescriptorPromotion, []int{0} }

func (m *HeroPromotionProto) GetCollectLoginPrizeDay() []int32 {
	if m != nil {
		return m.CollectLoginPrizeDay
	}
	return nil
}

func (m *HeroPromotionProto) GetCollectLevelFund() []int32 {
	if m != nil {
		return m.CollectLevelFund
	}
	return nil
}

func (m *HeroPromotionProto) GetCollectDailySp() []int32 {
	if m != nil {
		return m.CollectDailySp
	}
	return nil
}

func (m *HeroPromotionProto) GetCollectDailyFreeGift() []int32 {
	if m != nil {
		return m.CollectDailyFreeGift
	}
	return nil
}

func (m *HeroPromotionProto) GetCollectFreeGift() []int32 {
	if m != nil {
		return m.CollectFreeGift
	}
	return nil
}

func (m *HeroPromotionProto) GetBuyTimeLimitGift() []*TimeLimitGiftBoughtProto {
	if m != nil {
		return m.BuyTimeLimitGift
	}
	return nil
}

func (m *HeroPromotionProto) GetEventLimitGifts() []*EventLimitGiftProto {
	if m != nil {
		return m.EventLimitGifts
	}
	return nil
}

func (m *HeroPromotionProto) GetTimeLimitGiftBuyTimes() []*TimeLimitGiftBuyTimesProto {
	if m != nil {
		return m.TimeLimitGiftBuyTimes
	}
	return nil
}

// 时限礼包组
type TimeLimitGiftProto struct {
	Id      int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	EndTime int32 `protobuf:"varint,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (m *TimeLimitGiftProto) Reset()                    { *m = TimeLimitGiftProto{} }
func (m *TimeLimitGiftProto) String() string            { return proto.CompactTextString(m) }
func (*TimeLimitGiftProto) ProtoMessage()               {}
func (*TimeLimitGiftProto) Descriptor() ([]byte, []int) { return fileDescriptorPromotion, []int{1} }

func (m *TimeLimitGiftProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TimeLimitGiftProto) GetEndTime() int32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

// 购买过的Proto
type TimeLimitGiftBoughtProto struct {
	Id      int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Index   int32 `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
	EndTime int32 `protobuf:"varint,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (m *TimeLimitGiftBoughtProto) Reset()         { *m = TimeLimitGiftBoughtProto{} }
func (m *TimeLimitGiftBoughtProto) String() string { return proto.CompactTextString(m) }
func (*TimeLimitGiftBoughtProto) ProtoMessage()    {}
func (*TimeLimitGiftBoughtProto) Descriptor() ([]byte, []int) {
	return fileDescriptorPromotion, []int{2}
}

func (m *TimeLimitGiftBoughtProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TimeLimitGiftBoughtProto) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *TimeLimitGiftBoughtProto) GetEndTime() int32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

// 事件礼包
type EventLimitGiftProto struct {
	Id      int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	EndTime int32       `protobuf:"varint,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	Prize   *PrizeProto `protobuf:"bytes,3,opt,name=prize" json:"prize,omitempty"`
}

func (m *EventLimitGiftProto) Reset()                    { *m = EventLimitGiftProto{} }
func (m *EventLimitGiftProto) String() string            { return proto.CompactTextString(m) }
func (*EventLimitGiftProto) ProtoMessage()               {}
func (*EventLimitGiftProto) Descriptor() ([]byte, []int) { return fileDescriptorPromotion, []int{3} }

func (m *EventLimitGiftProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EventLimitGiftProto) GetEndTime() int32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *EventLimitGiftProto) GetPrize() *PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

// 时限礼包购买次数(限购次数而非限购数量)
type TimeLimitGiftBuyTimesProto struct {
	Id    int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Times int32 `protobuf:"varint,2,opt,name=times,proto3" json:"times,omitempty"`
}

func (m *TimeLimitGiftBuyTimesProto) Reset()         { *m = TimeLimitGiftBuyTimesProto{} }
func (m *TimeLimitGiftBuyTimesProto) String() string { return proto.CompactTextString(m) }
func (*TimeLimitGiftBuyTimesProto) ProtoMessage()    {}
func (*TimeLimitGiftBuyTimesProto) Descriptor() ([]byte, []int) {
	return fileDescriptorPromotion, []int{4}
}

func (m *TimeLimitGiftBuyTimesProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TimeLimitGiftBuyTimesProto) GetTimes() int32 {
	if m != nil {
		return m.Times
	}
	return 0
}

type TimeLimitGiftGroupDataProto struct {
	Id             int32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	GiftIds        []int32 `protobuf:"varint,2,rep,name=gift_ids,json=giftIds" json:"gift_ids,omitempty"`
	MinHeroLevel   int32   `protobuf:"varint,3,opt,name=min_hero_level,json=minHeroLevel,proto3" json:"min_hero_level,omitempty"`
	MaxHeroLevel   int32   `protobuf:"varint,4,opt,name=max_hero_level,json=maxHeroLevel,proto3" json:"max_hero_level,omitempty"`
	MinGuanfuLevel int32   `protobuf:"varint,5,opt,name=min_guanfu_level,json=minGuanfuLevel,proto3" json:"min_guanfu_level,omitempty"`
	MaxGuanfuLevel int32   `protobuf:"varint,6,opt,name=max_guanfu_level,json=maxGuanfuLevel,proto3" json:"max_guanfu_level,omitempty"`
}

func (m *TimeLimitGiftGroupDataProto) Reset()         { *m = TimeLimitGiftGroupDataProto{} }
func (m *TimeLimitGiftGroupDataProto) String() string { return proto.CompactTextString(m) }
func (*TimeLimitGiftGroupDataProto) ProtoMessage()    {}
func (*TimeLimitGiftGroupDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptorPromotion, []int{5}
}

func (m *TimeLimitGiftGroupDataProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TimeLimitGiftGroupDataProto) GetGiftIds() []int32 {
	if m != nil {
		return m.GiftIds
	}
	return nil
}

func (m *TimeLimitGiftGroupDataProto) GetMinHeroLevel() int32 {
	if m != nil {
		return m.MinHeroLevel
	}
	return 0
}

func (m *TimeLimitGiftGroupDataProto) GetMaxHeroLevel() int32 {
	if m != nil {
		return m.MaxHeroLevel
	}
	return 0
}

func (m *TimeLimitGiftGroupDataProto) GetMinGuanfuLevel() int32 {
	if m != nil {
		return m.MinGuanfuLevel
	}
	return 0
}

func (m *TimeLimitGiftGroupDataProto) GetMaxGuanfuLevel() int32 {
	if m != nil {
		return m.MaxGuanfuLevel
	}
	return 0
}

func init() {
	proto.RegisterType((*HeroPromotionProto)(nil), "proto.HeroPromotionProto")
	proto.RegisterType((*TimeLimitGiftProto)(nil), "proto.TimeLimitGiftProto")
	proto.RegisterType((*TimeLimitGiftBoughtProto)(nil), "proto.TimeLimitGiftBoughtProto")
	proto.RegisterType((*EventLimitGiftProto)(nil), "proto.EventLimitGiftProto")
	proto.RegisterType((*TimeLimitGiftBuyTimesProto)(nil), "proto.TimeLimitGiftBuyTimesProto")
	proto.RegisterType((*TimeLimitGiftGroupDataProto)(nil), "proto.TimeLimitGiftGroupDataProto")
	proto.RegisterEnum("proto.GiftType", GiftType_name, GiftType_value)
}
func (m *HeroPromotionProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroPromotionProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CollectLoginPrizeDay) > 0 {
		for _, num := range m.CollectLoginPrizeDay {
			dAtA[i] = 0x8
			i++
			i = encodeVarintPromotion(dAtA, i, uint64(num))
		}
	}
	if len(m.CollectDailySp) > 0 {
		for _, num := range m.CollectDailySp {
			dAtA[i] = 0x10
			i++
			i = encodeVarintPromotion(dAtA, i, uint64(num))
		}
	}
	if len(m.CollectLevelFund) > 0 {
		for _, num := range m.CollectLevelFund {
			dAtA[i] = 0x18
			i++
			i = encodeVarintPromotion(dAtA, i, uint64(num))
		}
	}
	if len(m.CollectDailyFreeGift) > 0 {
		for _, num := range m.CollectDailyFreeGift {
			dAtA[i] = 0x20
			i++
			i = encodeVarintPromotion(dAtA, i, uint64(num))
		}
	}
	if len(m.CollectFreeGift) > 0 {
		for _, num := range m.CollectFreeGift {
			dAtA[i] = 0x28
			i++
			i = encodeVarintPromotion(dAtA, i, uint64(num))
		}
	}
	if len(m.BuyTimeLimitGift) > 0 {
		for _, msg := range m.BuyTimeLimitGift {
			dAtA[i] = 0x32
			i++
			i = encodeVarintPromotion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EventLimitGifts) > 0 {
		for _, msg := range m.EventLimitGifts {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintPromotion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TimeLimitGiftBuyTimes) > 0 {
		for _, msg := range m.TimeLimitGiftBuyTimes {
			dAtA[i] = 0x42
			i++
			i = encodeVarintPromotion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TimeLimitGiftProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeLimitGiftProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPromotion(dAtA, i, uint64(m.Id))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPromotion(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *TimeLimitGiftBoughtProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeLimitGiftBoughtProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPromotion(dAtA, i, uint64(m.Id))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPromotion(dAtA, i, uint64(m.EndTime))
	}
	if m.Index != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPromotion(dAtA, i, uint64(m.Index))
	}
	return i, nil
}

func (m *EventLimitGiftProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventLimitGiftProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPromotion(dAtA, i, uint64(m.Id))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPromotion(dAtA, i, uint64(m.EndTime))
	}
	if m.Prize != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPromotion(dAtA, i, uint64(m.Prize.Size()))
		n1, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *TimeLimitGiftBuyTimesProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeLimitGiftBuyTimesProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPromotion(dAtA, i, uint64(m.Id))
	}
	if m.Times != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPromotion(dAtA, i, uint64(m.Times))
	}
	return i, nil
}

func (m *TimeLimitGiftGroupDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeLimitGiftGroupDataProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPromotion(dAtA, i, uint64(m.Id))
	}
	if len(m.GiftIds) > 0 {
		for _, num := range m.GiftIds {
			dAtA[i] = 0x10
			i++
			i = encodeVarintPromotion(dAtA, i, uint64(num))
		}
	}
	if m.MinHeroLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPromotion(dAtA, i, uint64(m.MinHeroLevel))
	}
	if m.MaxHeroLevel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPromotion(dAtA, i, uint64(m.MaxHeroLevel))
	}
	if m.MinGuanfuLevel != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPromotion(dAtA, i, uint64(m.MinGuanfuLevel))
	}
	if m.MaxGuanfuLevel != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPromotion(dAtA, i, uint64(m.MaxGuanfuLevel))
	}
	return i, nil
}

func encodeFixed64Promotion(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Promotion(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintPromotion(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HeroPromotionProto) Size() (n int) {
	var l int
	_ = l
	if len(m.CollectLoginPrizeDay) > 0 {
		for _, e := range m.CollectLoginPrizeDay {
			n += 1 + sovPromotion(uint64(e))
		}
	}
	if len(m.CollectDailySp) > 0 {
		for _, e := range m.CollectDailySp {
			n += 1 + sovPromotion(uint64(e))
		}
	}
	if len(m.CollectLevelFund) > 0 {
		for _, e := range m.CollectLevelFund {
			n += 1 + sovPromotion(uint64(e))
		}
	}
	if len(m.CollectDailyFreeGift) > 0 {
		for _, e := range m.CollectDailyFreeGift {
			n += 1 + sovPromotion(uint64(e))
		}
	}
	if len(m.CollectFreeGift) > 0 {
		for _, e := range m.CollectFreeGift {
			n += 1 + sovPromotion(uint64(e))
		}
	}
	if len(m.BuyTimeLimitGift) > 0 {
		for _, e := range m.BuyTimeLimitGift {
			l = e.Size()
			n += 1 + l + sovPromotion(uint64(l))
		}
	}
	if len(m.EventLimitGifts) > 0 {
		for _, e := range m.EventLimitGifts {
			l = e.Size()
			n += 1 + l + sovPromotion(uint64(l))
		}
	}
	if len(m.TimeLimitGiftBuyTimes) > 0 {
		for _, e := range m.TimeLimitGiftBuyTimes {
			l = e.Size()
			n += 1 + l + sovPromotion(uint64(l))
		}
	}
	return n
}

func (m *TimeLimitGiftProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPromotion(uint64(m.Id))
	}
	if m.EndTime != 0 {
		n += 1 + sovPromotion(uint64(m.EndTime))
	}
	return n
}

func (m *TimeLimitGiftBoughtProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPromotion(uint64(m.Id))
	}
	if m.EndTime != 0 {
		n += 1 + sovPromotion(uint64(m.EndTime))
	}
	if m.Index != 0 {
		n += 1 + sovPromotion(uint64(m.Index))
	}
	return n
}

func (m *EventLimitGiftProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPromotion(uint64(m.Id))
	}
	if m.EndTime != 0 {
		n += 1 + sovPromotion(uint64(m.EndTime))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovPromotion(uint64(l))
	}
	return n
}

func (m *TimeLimitGiftBuyTimesProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPromotion(uint64(m.Id))
	}
	if m.Times != 0 {
		n += 1 + sovPromotion(uint64(m.Times))
	}
	return n
}

func (m *TimeLimitGiftGroupDataProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPromotion(uint64(m.Id))
	}
	if len(m.GiftIds) > 0 {
		for _, e := range m.GiftIds {
			n += 1 + sovPromotion(uint64(e))
		}
	}
	if m.MinHeroLevel != 0 {
		n += 1 + sovPromotion(uint64(m.MinHeroLevel))
	}
	if m.MaxHeroLevel != 0 {
		n += 1 + sovPromotion(uint64(m.MaxHeroLevel))
	}
	if m.MinGuanfuLevel != 0 {
		n += 1 + sovPromotion(uint64(m.MinGuanfuLevel))
	}
	if m.MaxGuanfuLevel != 0 {
		n += 1 + sovPromotion(uint64(m.MaxGuanfuLevel))
	}
	return n
}

func sovPromotion(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPromotion(x uint64) (n int) {
	return sovPromotion(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HeroPromotionProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPromotion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroPromotionProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroPromotionProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPromotion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CollectLoginPrizeDay = append(m.CollectLoginPrizeDay, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPromotion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPromotion
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPromotion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CollectLoginPrizeDay = append(m.CollectLoginPrizeDay, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectLoginPrizeDay", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPromotion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CollectDailySp = append(m.CollectDailySp, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPromotion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPromotion
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPromotion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CollectDailySp = append(m.CollectDailySp, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectDailySp", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPromotion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CollectLevelFund = append(m.CollectLevelFund, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPromotion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPromotion
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPromotion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CollectLevelFund = append(m.CollectLevelFund, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectLevelFund", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPromotion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CollectDailyFreeGift = append(m.CollectDailyFreeGift, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPromotion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPromotion
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPromotion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CollectDailyFreeGift = append(m.CollectDailyFreeGift, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectDailyFreeGift", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPromotion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CollectFreeGift = append(m.CollectFreeGift, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPromotion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPromotion
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPromotion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CollectFreeGift = append(m.CollectFreeGift, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectFreeGift", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyTimeLimitGift", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPromotion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuyTimeLimitGift = append(m.BuyTimeLimitGift, &TimeLimitGiftBoughtProto{})
			if err := m.BuyTimeLimitGift[len(m.BuyTimeLimitGift)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventLimitGifts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPromotion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventLimitGifts = append(m.EventLimitGifts, &EventLimitGiftProto{})
			if err := m.EventLimitGifts[len(m.EventLimitGifts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeLimitGiftBuyTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPromotion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeLimitGiftBuyTimes = append(m.TimeLimitGiftBuyTimes, &TimeLimitGiftBuyTimesProto{})
			if err := m.TimeLimitGiftBuyTimes[len(m.TimeLimitGiftBuyTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPromotion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPromotion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeLimitGiftProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPromotion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeLimitGiftProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeLimitGiftProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPromotion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPromotion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeLimitGiftBoughtProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPromotion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeLimitGiftBoughtProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeLimitGiftBoughtProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPromotion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPromotion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventLimitGiftProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPromotion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventLimitGiftProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventLimitGiftProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPromotion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPromotion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPromotion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeLimitGiftBuyTimesProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPromotion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeLimitGiftBuyTimesProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeLimitGiftBuyTimesProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Times", wireType)
			}
			m.Times = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Times |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPromotion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPromotion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeLimitGiftGroupDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPromotion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeLimitGiftGroupDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeLimitGiftGroupDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPromotion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GiftIds = append(m.GiftIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPromotion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPromotion
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPromotion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GiftIds = append(m.GiftIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftIds", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinHeroLevel", wireType)
			}
			m.MinHeroLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinHeroLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxHeroLevel", wireType)
			}
			m.MaxHeroLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxHeroLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinGuanfuLevel", wireType)
			}
			m.MinGuanfuLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinGuanfuLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxGuanfuLevel", wireType)
			}
			m.MaxGuanfuLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxGuanfuLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPromotion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPromotion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPromotion(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPromotion
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPromotion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPromotion
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPromotion
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPromotion(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPromotion = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPromotion   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/shared_proto/promotion.proto", fileDescriptorPromotion)
}

var fileDescriptorPromotion = []byte{
	// 618 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x4f, 0x6b, 0x13, 0x41,
	0x14, 0xef, 0x26, 0xdd, 0x36, 0xbc, 0xd6, 0x36, 0x99, 0x56, 0xdc, 0x56, 0x8c, 0x31, 0x08, 0x06,
	0x91, 0x44, 0xaa, 0x20, 0x3d, 0x49, 0x43, 0x6c, 0x1a, 0x08, 0xa5, 0xc4, 0x5e, 0xb4, 0x87, 0x61,
	0xd2, 0x99, 0x24, 0x03, 0xbb, 0x33, 0xcb, 0xee, 0x6c, 0x4d, 0xfc, 0x12, 0x5e, 0xfd, 0x48, 0x1e,
	0xfd, 0x08, 0x52, 0xaf, 0x7e, 0x08, 0x99, 0x99, 0xcd, 0x76, 0x63, 0x53, 0xb0, 0xa7, 0x61, 0xde,
	0xef, 0xcf, 0x7b, 0xf9, 0x65, 0xde, 0xc2, 0xe1, 0x98, 0xab, 0x49, 0x32, 0x6c, 0x5e, 0xca, 0xa0,
	0xe5, 0xf3, 0xf1, 0x44, 0x85, 0xe4, 0x4b, 0x2b, 0x20, 0x3e, 0x7b, 0xd7, 0x0a, 0x87, 0xad, 0x78,
	0x42, 0x22, 0x46, 0x71, 0x18, 0x49, 0x25, 0x5b, 0x61, 0x24, 0x03, 0xa9, 0xb8, 0x14, 0x4d, 0x73,
	0x47, 0xae, 0x39, 0xf6, 0xdf, 0xfe, 0xbf, 0xc3, 0x90, 0xc4, 0xcc, 0x8a, 0xeb, 0xdf, 0x56, 0x01,
	0x9d, 0xb0, 0x48, 0x9e, 0xcd, 0x4d, 0xcf, 0x8c, 0xe7, 0x21, 0x3c, 0xba, 0x94, 0xbe, 0xcf, 0x2e,
	0x15, 0xf6, 0xe5, 0x98, 0x0b, 0x1c, 0x46, 0xfc, 0x2b, 0xc3, 0x94, 0xcc, 0x3c, 0xa7, 0x56, 0x6c,
	0xb8, 0xed, 0x42, 0x79, 0x65, 0xb0, 0x9b, 0x52, 0xfa, 0x9a, 0x71, 0xa6, 0x09, 0x1d, 0x32, 0x43,
	0xaf, 0xa0, 0x3c, 0x97, 0x52, 0xc2, 0xfd, 0x19, 0x8e, 0x43, 0xaf, 0x90, 0x69, 0xb6, 0x52, 0xac,
	0xa3, 0xa1, 0x8f, 0x21, 0x7a, 0x0d, 0x28, 0x6b, 0xc4, 0xae, 0x98, 0x8f, 0x47, 0x89, 0xa0, 0x5e,
	0x31, 0xe3, 0xcf, 0xbd, 0xfa, 0x1a, 0x3c, 0x4e, 0x04, 0xcd, 0x8f, 0x66, 0xfd, 0x47, 0x11, 0x63,
	0x78, 0xcc, 0x47, 0xca, 0x5b, 0xbd, 0x35, 0x9a, 0x69, 0x73, 0x1c, 0x31, 0xd6, 0xe5, 0x23, 0x85,
	0x9a, 0x50, 0x99, 0x4b, 0x6f, 0x44, 0x6e, 0x26, 0xda, 0x4e, 0xc1, 0x8c, 0x7f, 0x0a, 0x3b, 0xc3,
	0x64, 0x86, 0x15, 0x0f, 0x18, 0xf6, 0x79, 0xc0, 0x95, 0x55, 0xac, 0xd5, 0x8a, 0x8d, 0x8d, 0x83,
	0xa7, 0x36, 0xc1, 0xe6, 0x39, 0x0f, 0x58, 0x5f, 0x83, 0x5a, 0xd2, 0x96, 0xc9, 0x78, 0xa2, 0x4c,
	0x86, 0x83, 0xf2, 0x30, 0x99, 0x2d, 0x80, 0xe8, 0x18, 0x2a, 0xec, 0x8a, 0x09, 0x95, 0x33, 0x8b,
	0xbd, 0x75, 0xe3, 0xb6, 0x9f, 0xba, 0x7d, 0xd0, 0x78, 0xa6, 0xb0, 0x46, 0xdb, 0x6c, 0xa1, 0x18,
	0xa3, 0x0b, 0xd8, 0xfb, 0x67, 0x26, 0x3c, 0x9f, 0x33, 0xf6, 0x4a, 0xc6, 0xef, 0xd9, 0xd2, 0xe9,
	0xec, 0x40, 0xb1, 0xb5, 0x7d, 0xa8, 0x96, 0x61, 0xf5, 0xf7, 0x80, 0x16, 0x44, 0xf6, 0x41, 0x6c,
	0x41, 0x81, 0x53, 0xcf, 0xa9, 0x39, 0x0d, 0x77, 0x50, 0xe0, 0x14, 0xed, 0x41, 0x89, 0x09, 0x6a,
	0x5a, 0x7a, 0x05, 0x53, 0x5d, 0x67, 0x82, 0x6a, 0x61, 0xfd, 0x02, 0xbc, 0xbb, 0x32, 0xb9, 0x87,
	0x0d, 0xda, 0x05, 0x97, 0x0b, 0xca, 0xa6, 0x5e, 0xd1, 0xd4, 0xed, 0xa5, 0xce, 0x61, 0x67, 0x49,
	0x44, 0xf7, 0xf1, 0x7d, 0x01, 0xae, 0x79, 0xcc, 0xc6, 0x77, 0xe3, 0xa0, 0x92, 0x06, 0x65, 0xde,
	0xaf, 0x0d, 0xc6, 0xe2, 0xf5, 0x36, 0xec, 0xdf, 0x9d, 0xde, 0xad, 0x8e, 0xbb, 0xe0, 0xda, 0xfc,
	0x6d, 0x3b, 0x7b, 0xa9, 0xff, 0x71, 0xe0, 0xf1, 0x82, 0x49, 0x37, 0x92, 0x49, 0xd8, 0x21, 0x8a,
	0x2c, 0x77, 0x79, 0x02, 0x25, 0xf3, 0x77, 0x72, 0x1a, 0xe7, 0x96, 0x66, 0x5d, 0xd7, 0x7a, 0x34,
	0x46, 0xcf, 0x61, 0x2b, 0xe0, 0x02, 0x4f, 0x58, 0x24, 0xed, 0xba, 0xa4, 0xe1, 0x6c, 0x06, 0x5c,
	0xe8, 0x2d, 0x36, 0x5b, 0x62, 0x58, 0x64, 0x9a, 0x67, 0xad, 0xa6, 0x2c, 0x32, 0xbd, 0x61, 0x35,
	0xa0, 0xac, 0xbd, 0xc6, 0x09, 0x11, 0xa3, 0x24, 0xe5, 0xb9, 0x86, 0xa7, 0x7b, 0x74, 0x4d, 0xf9,
	0x86, 0x49, 0xa6, 0x8b, 0xcc, 0xb5, 0x94, 0x49, 0xa6, 0x39, 0xe6, 0xcb, 0x26, 0x94, 0xf4, 0x8f,
	0x3c, 0x9f, 0x85, 0x0c, 0x6d, 0xc3, 0x46, 0x4f, 0x5c, 0x11, 0x9f, 0x53, 0x5d, 0x2a, 0xaf, 0xa0,
	0x0a, 0x3c, 0xe8, 0x1c, 0xf5, 0xfa, 0x9f, 0x70, 0xfb, 0x68, 0xd0, 0x3d, 0xea, 0x9d, 0x96, 0x9d,
	0x76, 0xed, 0xc7, 0x75, 0xd5, 0xf9, 0x79, 0x5d, 0x75, 0x7e, 0x5d, 0x57, 0x9d, 0xef, 0xbf, 0xab,
	0x2b, 0x27, 0xce, 0xe7, 0xcd, 0xfc, 0xa7, 0x6a, 0xb8, 0x66, 0x8e, 0x37, 0x7f, 0x03, 0x00, 0x00,
	0xff, 0xff, 0x71, 0x16, 0xca, 0x4e, 0x20, 0x05, 0x00, 0x00,
}
