// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/server_proto/activity.proto
// DO NOT EDIT!

/*
	Package server_proto is a generated protocol buffer package.

	It is generated from these files:
		github.com/lightpaw/male7/pb/server_proto/activity.proto
		github.com/lightpaw/male7/pb/server_proto/bai_zhan.proto
		github.com/lightpaw/male7/pb/server_proto/bid.proto
		github.com/lightpaw/male7/pb/server_proto/buff.proto
		github.com/lightpaw/male7/pb/server_proto/captain_soul.proto
		github.com/lightpaw/male7/pb/server_proto/combat.proto
		github.com/lightpaw/male7/pb/server_proto/combatx.proto
		github.com/lightpaw/male7/pb/server_proto/country.proto
		github.com/lightpaw/male7/pb/server_proto/depot.proto
		github.com/lightpaw/male7/pb/server_proto/domestic.proto
		github.com/lightpaw/male7/pb/server_proto/function.proto
		github.com/lightpaw/male7/pb/server_proto/goods.proto
		github.com/lightpaw/male7/pb/server_proto/guild.proto
		github.com/lightpaw/male7/pb/server_proto/guizu.proto
		github.com/lightpaw/male7/pb/server_proto/hebi.proto
		github.com/lightpaw/male7/pb/server_proto/hero.proto
		github.com/lightpaw/male7/pb/server_proto/hero_gen.proto
		github.com/lightpaw/male7/pb/server_proto/kv.proto
		github.com/lightpaw/male7/pb/server_proto/military.proto
		github.com/lightpaw/male7/pb/server_proto/mingc.proto
		github.com/lightpaw/male7/pb/server_proto/mingc_war.proto
		github.com/lightpaw/male7/pb/server_proto/misc.proto
		github.com/lightpaw/male7/pb/server_proto/random_event.proto
		github.com/lightpaw/male7/pb/server_proto/rank.proto
		github.com/lightpaw/male7/pb/server_proto/red_packet.proto
		github.com/lightpaw/male7/pb/server_proto/snapshot.proto
		github.com/lightpaw/male7/pb/server_proto/teach.proto
		github.com/lightpaw/male7/pb/server_proto/tss.proto
		github.com/lightpaw/male7/pb/server_proto/vip.proto
		github.com/lightpaw/male7/pb/server_proto/xiongnu.proto
		github.com/lightpaw/male7/pb/server_proto/zhanjiang.proto
		github.com/lightpaw/male7/pb/server_proto/zhengwu.proto

	It has these top-level messages:
		HeroCollectionServerProto
		BaiZhanObjServerProto
		BaiZhanServerProto
		BidInfoProto
		BidObjProto
		HeroBuffServerProto
		BuffInfoServerProto
		HeroCaptainSoulServerProto
		CaptainSoulServerProto
		CombatRequestServerProto
		CombatResponseServerProto
		MultiCombatRequestServerProto
		MultiCombatResponseServerProto
		AliveSoldierProto
		CombatXRequestServerProto
		CombatXResponseServerProto
		CountriesServerProto
		CountryServerProto
		CountryChangeNameVoteServerProto
		CountryOfficialServerProto
		CountryOfficialHeroServerProto
		HeroCountryMiscServerProto
		HeroCountryChangeNameVoteServerProto
		HeroDepotServerProto
		HeroOpenCombineEquipServerProto
		HeroDomesticServerProto
		HeroCountdownPrizeServerProto
		HeroResourcePointServerProto
		HeroFunctionServerProto
		EquipmentServerProto
		GuildServerProto
		GuildWorkshopServerProto
		GuildMemberServerProto
		GuildImpeachServerProto
		HeroGuiZuServerProto
		HebiServerProto
		HeroServerProto
		BlackMarketGoodsItemServerProto
		HeroShopServerProto
		HeroMiscServerProto
		HeroPromotionServerProto
		HeroActivityServerProto
		HeroRelationServerProto
		HeroRandomEventServerProto
		HeroTreasuryTreeServerProto
		HeroGuildEventPrizeServerProto
		HeroMapServerProto
		HeroKeysServerProto
		HeroClientDatasServerProto
		HeroReservationProto
		RoBaseProto
		HeroBase
		HeroHome
		HeroRegionServerProto
		HeroInvestigationServerProto
		HeroMultiLevelNpcServerProto
		HeroHomeNpcBaseServerProto
		HeroTowerServerProto
		HeroSecretTowerServerProto
		HeroDungeonServerProto
		HeroTaskServerProto
		AchieveTaskListServerProto
		AchieveTaskServerProto
		ActiveDegreeTaskListServerProto
		ActiveDegreeTaskServerProto
		HeroBaYeStageServerProto
		BwzlTaskListServerProto
		BwzlTaskServerProto
		TitleTaskListServerProto
		TitleTaskServerProto
		ActivityTaskListModeServerProto
		ActivityTaskServerProto
		StratagemServerProto
		TrappedStratagemServerProto
		StratagemTargetTimesServerProto
		HeroStrategyServerProto
		HeroBufferServerProto
		HeroGenServerProto
		HeroGenXuanyuanServerProto
		HeroGenMiscDataServerProto
		HeroGenFarmExtraServerProto
		HeroGenCountryServerProto
		HeroGenShopServerProto
		HeroGenGuildWorkshopServerProto
		HeroGenProductServerProto
		TowerModuleProto
		InviteGuildRecommendHerosProto
		RegionModuleProto
		RealmRuinsBasePosInfosProto
		RuinsBasePosInfoProto
		Int64ArrayProto
		UInt64ArrayProto
		TimeProto
		UserMiscProto
		NpcBaseProto
		NpcDefendingTroopProto
		TroopServerProto
		XuanyuanModuleProto
		XuanyuanRankHeroProto
		AllAstDefendLogProto
		AstDefendLogListProto
		MilitaryConditionProto
		MilitaryAttributeProto
		HeroMilitaryServerProto
		HeroTroopsServerProto
		TroopsInvateProto
		HeroCaptainGemServerProto
		HeroCaptainServerProto
		MingcsServerProto
		MingcServerProto
		HeroMcBuildServerProto
		McBuildProto
		McBuildGuildInfoProto
		McBuildHeroInfoProto
		MingcWarServerProto
		MingcApplyAtkProto
		MingcApplyAstProto
		MingcObjProto
		MingcFightProto
		MingcStageProto
		McWarSceneServerProto
		McWarBuildingServerProto
		McWarTroopServerProto
		McWarFightRecordServerProto
		McWarFightGuildRecordServerProto
		McWarNpcTroop
		EventPositionServerProto
		RankServerProto
		TowerRankServerProto
		BaiZhanRankServerProto
		StarTaskRankServerProto
		XuanyRankServerProto
		HeroRedPacketServerProto
		AllRedPacketServerProto
		RedPacketServerProto
		RedPacketPartServerProto
		HeroBasicSnapshotServerProto
		HeroTeachServerProto
		TssChatCallbackProto
		HeroVipServerProto
		AllXiongNuServerProto
		XiongNuServerProto
		HeroZhanJiangServerProto
		ZhanJiangChallengeServerProto
		HeroZhengWuServerProto
		ZhengWuServerProto
*/
package server_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type HeroCollectionServerProto struct {
	ExchangeTimes map[uint64]uint64 `protobuf:"bytes,1,rep,name=exchange_times,json=exchangeTimes" json:"exchange_times,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	StartTime     int64             `protobuf:"varint,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime       int64             `protobuf:"varint,3,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (m *HeroCollectionServerProto) Reset()         { *m = HeroCollectionServerProto{} }
func (m *HeroCollectionServerProto) String() string { return proto.CompactTextString(m) }
func (*HeroCollectionServerProto) ProtoMessage()    {}
func (*HeroCollectionServerProto) Descriptor() ([]byte, []int) {
	return fileDescriptorActivity, []int{0}
}

func (m *HeroCollectionServerProto) GetExchangeTimes() map[uint64]uint64 {
	if m != nil {
		return m.ExchangeTimes
	}
	return nil
}

func (m *HeroCollectionServerProto) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *HeroCollectionServerProto) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func init() {
	proto.RegisterType((*HeroCollectionServerProto)(nil), "proto.HeroCollectionServerProto")
}
func (m *HeroCollectionServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroCollectionServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ExchangeTimes) > 0 {
		for k, _ := range m.ExchangeTimes {
			dAtA[i] = 0xa
			i++
			v := m.ExchangeTimes[k]
			mapSize := 1 + sovActivity(uint64(k)) + 1 + sovActivity(uint64(v))
			i = encodeVarintActivity(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintActivity(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintActivity(dAtA, i, uint64(v))
		}
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintActivity(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintActivity(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func encodeFixed64Activity(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Activity(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintActivity(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HeroCollectionServerProto) Size() (n int) {
	var l int
	_ = l
	if len(m.ExchangeTimes) > 0 {
		for k, v := range m.ExchangeTimes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovActivity(uint64(k)) + 1 + sovActivity(uint64(v))
			n += mapEntrySize + 1 + sovActivity(uint64(mapEntrySize))
		}
	}
	if m.StartTime != 0 {
		n += 1 + sovActivity(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovActivity(uint64(m.EndTime))
	}
	return n
}

func sovActivity(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozActivity(x uint64) (n int) {
	return sovActivity(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HeroCollectionServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroCollectionServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroCollectionServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.ExchangeTimes == nil {
				m.ExchangeTimes = make(map[uint64]uint64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExchangeTimes[mapkey] = mapvalue
			} else {
				var mapvalue uint64
				m.ExchangeTimes[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipActivity(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthActivity
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipActivity(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthActivity = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowActivity   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/server_proto/activity.proto", fileDescriptorActivity)
}

var fileDescriptorActivity = []byte{
	// 265 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xb2, 0x48, 0xcf, 0x2c, 0xc9,
	0x28, 0x4d, 0xd2, 0x4b, 0xce, 0xcf, 0xd5, 0xcf, 0xc9, 0x4c, 0xcf, 0x28, 0x29, 0x48, 0x2c, 0xd7,
	0xcf, 0x4d, 0xcc, 0x49, 0x35, 0xd7, 0x2f, 0x48, 0xd2, 0x2f, 0x4e, 0x2d, 0x2a, 0x4b, 0x2d, 0x8a,
	0x2f, 0x28, 0xca, 0x2f, 0xc9, 0xd7, 0x4f, 0x4c, 0x2e, 0xc9, 0x2c, 0xcb, 0x2c, 0xa9, 0xd4, 0x03,
	0x73, 0x85, 0x58, 0xc1, 0x94, 0xd2, 0x67, 0x46, 0x2e, 0x49, 0x8f, 0xd4, 0xa2, 0x7c, 0xe7, 0xfc,
	0x9c, 0x9c, 0xd4, 0xe4, 0x92, 0xcc, 0xfc, 0xbc, 0x60, 0xb0, 0xa6, 0x00, 0xb0, 0xa2, 0x28, 0x2e,
	0xbe, 0xd4, 0x8a, 0xe4, 0x8c, 0xc4, 0xbc, 0xf4, 0xd4, 0xf8, 0x92, 0xcc, 0xdc, 0xd4, 0x62, 0x09,
	0x46, 0x05, 0x66, 0x0d, 0x6e, 0x23, 0x63, 0x88, 0x21, 0x7a, 0x38, 0x75, 0xea, 0xb9, 0x42, 0xb5,
	0x85, 0x80, 0x74, 0xb9, 0xe6, 0x95, 0x14, 0x55, 0x06, 0xf1, 0xa6, 0x22, 0x8b, 0x09, 0xc9, 0x72,
	0x71, 0x15, 0x97, 0x24, 0x16, 0x95, 0x80, 0x0d, 0x96, 0x60, 0x52, 0x60, 0xd4, 0x60, 0x0e, 0xe2,
	0x04, 0x8b, 0x80, 0xe4, 0x85, 0x24, 0xb9, 0x38, 0x52, 0xf3, 0x52, 0x20, 0x92, 0xcc, 0x60, 0x49,
	0xf6, 0xd4, 0xbc, 0x14, 0x90, 0x94, 0x94, 0x03, 0x97, 0x10, 0xa6, 0xf1, 0x42, 0x02, 0x5c, 0xcc,
	0xd9, 0xa9, 0x95, 0x12, 0x8c, 0x0a, 0x8c, 0x1a, 0x2c, 0x41, 0x20, 0xa6, 0x90, 0x08, 0x17, 0x6b,
	0x59, 0x62, 0x4e, 0x29, 0xc4, 0x70, 0x96, 0x20, 0x08, 0xc7, 0x8a, 0xc9, 0x82, 0xd1, 0x49, 0xe1,
	0xc4, 0x23, 0x39, 0xc6, 0x0b, 0x8f, 0xe4, 0x18, 0x1f, 0x3c, 0x92, 0x63, 0x9c, 0xf1, 0x58, 0x8e,
	0xc1, 0x83, 0x31, 0x8a, 0x07, 0x39, 0xb4, 0x92, 0xd8, 0xc0, 0x94, 0x31, 0x20, 0x00, 0x00, 0xff,
	0xff, 0x4b, 0x87, 0x7c, 0x75, 0x61, 0x01, 0x00, 0x00,
}
