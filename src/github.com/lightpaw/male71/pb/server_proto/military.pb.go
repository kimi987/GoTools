// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/server_proto/military.proto
// DO NOT EDIT!

package server_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import proto1 "github.com/lightpaw/male7/pb/shared_proto"
import proto4 "github.com/lightpaw/male7/pb/shared_proto"
import _ "github.com/lightpaw/male7/pb/shared_proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type MilitaryConditionProto struct {
	IsOr       bool                      `protobuf:"varint,1,opt,name=isOr,proto3" json:"isOr,omitempty"`
	Conditions []*MilitaryConditionProto `protobuf:"bytes,2,rep,name=conditions" json:"conditions,omitempty"`
	Attributes []*MilitaryAttributeProto `protobuf:"bytes,3,rep,name=attributes" json:"attributes,omitempty"`
	BaseId     int64                     `protobuf:"varint,4,opt,name=base_id,json=baseId,proto3" json:"base_id,omitempty"`
}

func (m *MilitaryConditionProto) Reset()                    { *m = MilitaryConditionProto{} }
func (m *MilitaryConditionProto) String() string            { return proto.CompactTextString(m) }
func (*MilitaryConditionProto) ProtoMessage()               {}
func (*MilitaryConditionProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{0} }

func (m *MilitaryConditionProto) GetIsOr() bool {
	if m != nil {
		return m.IsOr
	}
	return false
}

func (m *MilitaryConditionProto) GetConditions() []*MilitaryConditionProto {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *MilitaryConditionProto) GetAttributes() []*MilitaryAttributeProto {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *MilitaryConditionProto) GetBaseId() int64 {
	if m != nil {
		return m.BaseId
	}
	return 0
}

type MilitaryAttributeProto struct {
	// 部队出发城池（部队拥有者），0表示不检查该项
	StartBaseId int64 `protobuf:"varint,2,opt,name=start_base_id,json=startBaseId,proto3" json:"start_base_id,omitempty"`
	// 部队目的地城池，0表示不检查该项
	TargetBaseId int64 `protobuf:"varint,3,opt,name=target_base_id,json=targetBaseId,proto3" json:"target_base_id,omitempty"`
	// 部队出发城池联盟（部队拥有者），0表示不检查该项
	StartBaseGuildId int64 `protobuf:"varint,4,opt,name=start_base_guild_id,json=startBaseGuildId,proto3" json:"start_base_guild_id,omitempty"`
	// 部队目的地城池联盟，0表示不检查该项
	TargetBaseGuildId int64 `protobuf:"varint,5,opt,name=target_base_guild_id,json=targetBaseGuildId,proto3" json:"target_base_guild_id,omitempty"`
	// 部队状态，1-出征路上，2-援助路上，3-回家，4-援助驻守，5-持续掠夺，0表示不检查该项
	TroopState int32 `protobuf:"varint,6,opt,name=troop_state,json=troopState,proto3" json:"troop_state,omitempty"`
	// 集结包含玩家id
	JoinAssemblyHeroId int64 `protobuf:"varint,7,opt,name=join_assembly_hero_id,json=joinAssemblyHeroId,proto3" json:"join_assembly_hero_id,omitempty"`
}

func (m *MilitaryAttributeProto) Reset()                    { *m = MilitaryAttributeProto{} }
func (m *MilitaryAttributeProto) String() string            { return proto.CompactTextString(m) }
func (*MilitaryAttributeProto) ProtoMessage()               {}
func (*MilitaryAttributeProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{1} }

func (m *MilitaryAttributeProto) GetStartBaseId() int64 {
	if m != nil {
		return m.StartBaseId
	}
	return 0
}

func (m *MilitaryAttributeProto) GetTargetBaseId() int64 {
	if m != nil {
		return m.TargetBaseId
	}
	return 0
}

func (m *MilitaryAttributeProto) GetStartBaseGuildId() int64 {
	if m != nil {
		return m.StartBaseGuildId
	}
	return 0
}

func (m *MilitaryAttributeProto) GetTargetBaseGuildId() int64 {
	if m != nil {
		return m.TargetBaseGuildId
	}
	return 0
}

func (m *MilitaryAttributeProto) GetTroopState() int32 {
	if m != nil {
		return m.TroopState
	}
	return 0
}

func (m *MilitaryAttributeProto) GetJoinAssemblyHeroId() int64 {
	if m != nil {
		return m.JoinAssemblyHeroId
	}
	return 0
}

type HeroMilitaryServerProto struct {
	OfficialView                 map[uint64]*proto1.Int32ArrayProto `protobuf:"bytes,9,rep,name=official_view,json=officialView" json:"official_view,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	CaptainFriendship            []uint64                           `protobuf:"varint,1,rep,packed,name=captain_friendship,json=captainFriendship" json:"captain_friendship,omitempty"`
	Captains                     []*HeroCaptainServerProto          `protobuf:"bytes,11,rep,name=captains" json:"captains,omitempty"`
	CaptainIndex                 []uint64                           `protobuf:"varint,4,rep,packed,name=captain_index,json=captainIndex" json:"captain_index,omitempty"`
	Defenser                     []uint64                           `protobuf:"varint,5,rep,packed,name=defenser" json:"defenser,omitempty"`
	SoldierLevel                 uint64                             `protobuf:"varint,31,opt,name=soldier_level,json=soldierLevel,proto3" json:"soldier_level,omitempty"`
	FreeSoldier                  uint64                             `protobuf:"varint,32,opt,name=free_soldier,json=freeSoldier,proto3" json:"free_soldier,omitempty"`
	LastRecruitTime              int32                              `protobuf:"varint,35,opt,name=last_recruit_time,json=lastRecruitTime,proto3" json:"last_recruit_time,omitempty"`
	WoundedSoldier               uint64                             `protobuf:"varint,36,opt,name=wounded_soldier,json=woundedSoldier,proto3" json:"wounded_soldier,omitempty"`
	FreeSoldierStartRecoveryTime int64                              `protobuf:"varint,56,opt,name=free_soldier_start_recovery_time,json=freeSoldierStartRecoveryTime,proto3" json:"free_soldier_start_recovery_time,omitempty"`
	OverflowFreeSoldier          uint64                             `protobuf:"varint,59,opt,name=overflow_free_soldier,json=overflowFreeSoldier,proto3" json:"overflow_free_soldier,omitempty"`
	ForceAddSoldierTimes         uint64                             `protobuf:"varint,60,opt,name=force_add_soldier_times,json=forceAddSoldierTimes,proto3" json:"force_add_soldier_times,omitempty"`
	//    int64 jiu_guan_start_recovey_time = 45; // 酒馆恢复时间
	JiuGuanRefreshTimes            uint64 `protobuf:"varint,46,opt,name=jiu_guan_refresh_times,json=jiuGuanRefreshTimes,proto3" json:"jiu_guan_refresh_times,omitempty"`
	JiuGuanTutorIndex              uint64 `protobuf:"varint,47,opt,name=jiu_guan_tutor_index,json=jiuGuanTutorIndex,proto3" json:"jiu_guan_tutor_index,omitempty"`
	JiuGuanCombineTimes            uint64 `protobuf:"varint,48,opt,name=jiu_guan_combine_times,json=jiuGuanCombineTimes,proto3" json:"jiu_guan_combine_times,omitempty"`
	JunYingRecruitStartRecoveyTime int64  `protobuf:"varint,50,opt,name=jun_ying_recruit_start_recovey_time,json=junYingRecruitStartRecoveyTime,proto3" json:"jun_ying_recruit_start_recovey_time,omitempty"`
	// 部队
	Troops                []*HeroTroopsServerProto    `protobuf:"bytes,51,rep,name=troops" json:"troops,omitempty"`
	InvestigateTroop      *HeroTroopsServerProto      `protobuf:"bytes,61,opt,name=investigate_troop,json=investigateTroop" json:"investigate_troop,omitempty"`
	PveTroops             []*proto4.HeroPveTroopProto `protobuf:"bytes,54,rep,name=pve_troops,json=pveTroops" json:"pve_troops,omitempty"`
	NextExpelTime         int64                       `protobuf:"varint,52,opt,name=next_expel_time,json=nextExpelTime,proto3" json:"next_expel_time,omitempty"`
	GlobalTrainStartTime  int64                       `protobuf:"varint,53,opt,name=global_train_start_time,json=globalTrainStartTime,proto3" json:"global_train_start_time,omitempty"`
	CaptainTrainStartTime int64                       `protobuf:"varint,55,opt,name=captain_train_start_time,json=captainTrainStartTime,proto3" json:"captain_train_start_time,omitempty"`
	CandidateCaptainHead  []string                    `protobuf:"bytes,57,rep,name=candidate_captain_head,json=candidateCaptainHead" json:"candidate_captain_head,omitempty"`
	ReservedExp           int64                       `protobuf:"varint,58,opt,name=reserved_exp,json=reservedExp,proto3" json:"reserved_exp,omitempty"`
}

func (m *HeroMilitaryServerProto) Reset()                    { *m = HeroMilitaryServerProto{} }
func (m *HeroMilitaryServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroMilitaryServerProto) ProtoMessage()               {}
func (*HeroMilitaryServerProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{2} }

func (m *HeroMilitaryServerProto) GetOfficialView() map[uint64]*proto1.Int32ArrayProto {
	if m != nil {
		return m.OfficialView
	}
	return nil
}

func (m *HeroMilitaryServerProto) GetCaptainFriendship() []uint64 {
	if m != nil {
		return m.CaptainFriendship
	}
	return nil
}

func (m *HeroMilitaryServerProto) GetCaptains() []*HeroCaptainServerProto {
	if m != nil {
		return m.Captains
	}
	return nil
}

func (m *HeroMilitaryServerProto) GetCaptainIndex() []uint64 {
	if m != nil {
		return m.CaptainIndex
	}
	return nil
}

func (m *HeroMilitaryServerProto) GetDefenser() []uint64 {
	if m != nil {
		return m.Defenser
	}
	return nil
}

func (m *HeroMilitaryServerProto) GetSoldierLevel() uint64 {
	if m != nil {
		return m.SoldierLevel
	}
	return 0
}

func (m *HeroMilitaryServerProto) GetFreeSoldier() uint64 {
	if m != nil {
		return m.FreeSoldier
	}
	return 0
}

func (m *HeroMilitaryServerProto) GetLastRecruitTime() int32 {
	if m != nil {
		return m.LastRecruitTime
	}
	return 0
}

func (m *HeroMilitaryServerProto) GetWoundedSoldier() uint64 {
	if m != nil {
		return m.WoundedSoldier
	}
	return 0
}

func (m *HeroMilitaryServerProto) GetFreeSoldierStartRecoveryTime() int64 {
	if m != nil {
		return m.FreeSoldierStartRecoveryTime
	}
	return 0
}

func (m *HeroMilitaryServerProto) GetOverflowFreeSoldier() uint64 {
	if m != nil {
		return m.OverflowFreeSoldier
	}
	return 0
}

func (m *HeroMilitaryServerProto) GetForceAddSoldierTimes() uint64 {
	if m != nil {
		return m.ForceAddSoldierTimes
	}
	return 0
}

func (m *HeroMilitaryServerProto) GetJiuGuanRefreshTimes() uint64 {
	if m != nil {
		return m.JiuGuanRefreshTimes
	}
	return 0
}

func (m *HeroMilitaryServerProto) GetJiuGuanTutorIndex() uint64 {
	if m != nil {
		return m.JiuGuanTutorIndex
	}
	return 0
}

func (m *HeroMilitaryServerProto) GetJiuGuanCombineTimes() uint64 {
	if m != nil {
		return m.JiuGuanCombineTimes
	}
	return 0
}

func (m *HeroMilitaryServerProto) GetJunYingRecruitStartRecoveyTime() int64 {
	if m != nil {
		return m.JunYingRecruitStartRecoveyTime
	}
	return 0
}

func (m *HeroMilitaryServerProto) GetTroops() []*HeroTroopsServerProto {
	if m != nil {
		return m.Troops
	}
	return nil
}

func (m *HeroMilitaryServerProto) GetInvestigateTroop() *HeroTroopsServerProto {
	if m != nil {
		return m.InvestigateTroop
	}
	return nil
}

func (m *HeroMilitaryServerProto) GetPveTroops() []*proto4.HeroPveTroopProto {
	if m != nil {
		return m.PveTroops
	}
	return nil
}

func (m *HeroMilitaryServerProto) GetNextExpelTime() int64 {
	if m != nil {
		return m.NextExpelTime
	}
	return 0
}

func (m *HeroMilitaryServerProto) GetGlobalTrainStartTime() int64 {
	if m != nil {
		return m.GlobalTrainStartTime
	}
	return 0
}

func (m *HeroMilitaryServerProto) GetCaptainTrainStartTime() int64 {
	if m != nil {
		return m.CaptainTrainStartTime
	}
	return 0
}

func (m *HeroMilitaryServerProto) GetCandidateCaptainHead() []string {
	if m != nil {
		return m.CandidateCaptainHead
	}
	return nil
}

func (m *HeroMilitaryServerProto) GetReservedExp() int64 {
	if m != nil {
		return m.ReservedExp
	}
	return 0
}

type HeroTroopsServerProto struct {
	Sequence int32 `protobuf:"varint,3,opt,name=sequence,proto3" json:"sequence,omitempty"`
	//    repeated HeroCaptainServerProto captain = 11;
	Captains       []int32 `protobuf:"varint,12,rep,packed,name=captains" json:"captains,omitempty"`
	CaptainsXIndex []int32 `protobuf:"varint,13,rep,packed,name=captains_x_index,json=captainsXIndex" json:"captains_x_index,omitempty"`
	// 出征数据
	InvateInfo *TroopsInvateProto `protobuf:"bytes,51,opt,name=invate_info,json=invateInfo" json:"invate_info,omitempty"`
}

func (m *HeroTroopsServerProto) Reset()                    { *m = HeroTroopsServerProto{} }
func (m *HeroTroopsServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroTroopsServerProto) ProtoMessage()               {}
func (*HeroTroopsServerProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{3} }

func (m *HeroTroopsServerProto) GetSequence() int32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *HeroTroopsServerProto) GetCaptains() []int32 {
	if m != nil {
		return m.Captains
	}
	return nil
}

func (m *HeroTroopsServerProto) GetCaptainsXIndex() []int32 {
	if m != nil {
		return m.CaptainsXIndex
	}
	return nil
}

func (m *HeroTroopsServerProto) GetInvateInfo() *TroopsInvateProto {
	if m != nil {
		return m.InvateInfo
	}
	return nil
}

type TroopsInvateProto struct {
	RealmId                  int64              `protobuf:"varint,1,opt,name=realm_id,json=realmId,proto3" json:"realm_id,omitempty"`
	TargetId                 int64              `protobuf:"varint,2,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
	OriginTargetId           int64              `protobuf:"varint,3,opt,name=origin_target_id,json=originTargetId,proto3" json:"origin_target_id,omitempty"`
	TargetBaseLevel          uint64             `protobuf:"varint,10,opt,name=target_base_level,json=targetBaseLevel,proto3" json:"target_base_level,omitempty"`
	State                    int32              `protobuf:"varint,22,opt,name=state,proto3" json:"state,omitempty"`
	CreateTime               int64              `protobuf:"varint,17,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	MoveSpeedRate            uint64             `protobuf:"varint,19,opt,name=move_speed_rate,json=moveSpeedRate,proto3" json:"move_speed_rate,omitempty"`
	MoveStartTime            int64              `protobuf:"varint,5,opt,name=move_start_time,json=moveStartTime,proto3" json:"move_start_time,omitempty"`
	MoveArriveTime           int64              `protobuf:"varint,6,opt,name=move_arrive_time,json=moveArriveTime,proto3" json:"move_arrive_time,omitempty"`
	RobbingEndTime           int64              `protobuf:"varint,15,opt,name=robbing_end_time,json=robbingEndTime,proto3" json:"robbing_end_time,omitempty"`
	NextReduceProsperityTime int64              `protobuf:"varint,16,opt,name=next_reduce_prosperity_time,json=nextReduceProsperityTime,proto3" json:"next_reduce_prosperity_time,omitempty"`
	NextAddHateTime          int64              `protobuf:"varint,18,opt,name=next_add_hate_time,json=nextAddHateTime,proto3" json:"next_add_hate_time,omitempty"`
	NextRobBaowuTime         int64              `protobuf:"varint,20,opt,name=next_rob_baowu_time,json=nextRobBaowuTime,proto3" json:"next_rob_baowu_time,omitempty"`
	BackHomeTargetX          int32              `protobuf:"varint,7,opt,name=back_home_target_x,json=backHomeTargetX,proto3" json:"back_home_target_x,omitempty"`
	BackHomeTargetY          int32              `protobuf:"varint,8,opt,name=back_home_target_y,json=backHomeTargetY,proto3" json:"back_home_target_y,omitempty"`
	OwnerCanSeeTarget        bool               `protobuf:"varint,9,opt,name=owner_can_see_target,json=ownerCanSeeTarget,proto3" json:"owner_can_see_target,omitempty"`
	AccumRobPrize            *proto1.PrizeProto `protobuf:"bytes,31,opt,name=accum_rob_prize,json=accumRobPrize" json:"accum_rob_prize,omitempty"`
	AccumReduceProsperity    uint64             `protobuf:"varint,32,opt,name=accum_reduce_prosperity,json=accumReduceProsperity,proto3" json:"accum_reduce_prosperity,omitempty"`
	AccumAddHate             uint64             `protobuf:"varint,33,opt,name=accum_add_hate,json=accumAddHate,proto3" json:"accum_add_hate,omitempty"`
	AssemblyId               int64              `protobuf:"varint,41,opt,name=assembly_id,json=assemblyId,proto3" json:"assembly_id,omitempty"`
	AssemblyTargetId         int64              `protobuf:"varint,42,opt,name=assembly_target_id,json=assemblyTargetId,proto3" json:"assembly_target_id,omitempty"`
	Dialogue                 uint64             `protobuf:"varint,43,opt,name=dialogue,proto3" json:"dialogue,omitempty"`
	NpcTimes                 uint64             `protobuf:"varint,44,opt,name=npc_times,json=npcTimes,proto3" json:"npc_times,omitempty"`
}

func (m *TroopsInvateProto) Reset()                    { *m = TroopsInvateProto{} }
func (m *TroopsInvateProto) String() string            { return proto.CompactTextString(m) }
func (*TroopsInvateProto) ProtoMessage()               {}
func (*TroopsInvateProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{4} }

func (m *TroopsInvateProto) GetRealmId() int64 {
	if m != nil {
		return m.RealmId
	}
	return 0
}

func (m *TroopsInvateProto) GetTargetId() int64 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

func (m *TroopsInvateProto) GetOriginTargetId() int64 {
	if m != nil {
		return m.OriginTargetId
	}
	return 0
}

func (m *TroopsInvateProto) GetTargetBaseLevel() uint64 {
	if m != nil {
		return m.TargetBaseLevel
	}
	return 0
}

func (m *TroopsInvateProto) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *TroopsInvateProto) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *TroopsInvateProto) GetMoveSpeedRate() uint64 {
	if m != nil {
		return m.MoveSpeedRate
	}
	return 0
}

func (m *TroopsInvateProto) GetMoveStartTime() int64 {
	if m != nil {
		return m.MoveStartTime
	}
	return 0
}

func (m *TroopsInvateProto) GetMoveArriveTime() int64 {
	if m != nil {
		return m.MoveArriveTime
	}
	return 0
}

func (m *TroopsInvateProto) GetRobbingEndTime() int64 {
	if m != nil {
		return m.RobbingEndTime
	}
	return 0
}

func (m *TroopsInvateProto) GetNextReduceProsperityTime() int64 {
	if m != nil {
		return m.NextReduceProsperityTime
	}
	return 0
}

func (m *TroopsInvateProto) GetNextAddHateTime() int64 {
	if m != nil {
		return m.NextAddHateTime
	}
	return 0
}

func (m *TroopsInvateProto) GetNextRobBaowuTime() int64 {
	if m != nil {
		return m.NextRobBaowuTime
	}
	return 0
}

func (m *TroopsInvateProto) GetBackHomeTargetX() int32 {
	if m != nil {
		return m.BackHomeTargetX
	}
	return 0
}

func (m *TroopsInvateProto) GetBackHomeTargetY() int32 {
	if m != nil {
		return m.BackHomeTargetY
	}
	return 0
}

func (m *TroopsInvateProto) GetOwnerCanSeeTarget() bool {
	if m != nil {
		return m.OwnerCanSeeTarget
	}
	return false
}

func (m *TroopsInvateProto) GetAccumRobPrize() *proto1.PrizeProto {
	if m != nil {
		return m.AccumRobPrize
	}
	return nil
}

func (m *TroopsInvateProto) GetAccumReduceProsperity() uint64 {
	if m != nil {
		return m.AccumReduceProsperity
	}
	return 0
}

func (m *TroopsInvateProto) GetAccumAddHate() uint64 {
	if m != nil {
		return m.AccumAddHate
	}
	return 0
}

func (m *TroopsInvateProto) GetAssemblyId() int64 {
	if m != nil {
		return m.AssemblyId
	}
	return 0
}

func (m *TroopsInvateProto) GetAssemblyTargetId() int64 {
	if m != nil {
		return m.AssemblyTargetId
	}
	return 0
}

func (m *TroopsInvateProto) GetDialogue() uint64 {
	if m != nil {
		return m.Dialogue
	}
	return 0
}

func (m *TroopsInvateProto) GetNpcTimes() uint64 {
	if m != nil {
		return m.NpcTimes
	}
	return 0
}

type HeroCaptainGemServerProto struct {
	Gem     uint64 `protobuf:"varint,1,opt,name=gem,proto3" json:"gem,omitempty"`
	SlotIdx int32  `protobuf:"varint,2,opt,name=slot_idx,json=slotIdx,proto3" json:"slot_idx,omitempty"`
}

func (m *HeroCaptainGemServerProto) Reset()         { *m = HeroCaptainGemServerProto{} }
func (m *HeroCaptainGemServerProto) String() string { return proto.CompactTextString(m) }
func (*HeroCaptainGemServerProto) ProtoMessage()    {}
func (*HeroCaptainGemServerProto) Descriptor() ([]byte, []int) {
	return fileDescriptorMilitary, []int{5}
}

func (m *HeroCaptainGemServerProto) GetGem() uint64 {
	if m != nil {
		return m.Gem
	}
	return 0
}

func (m *HeroCaptainGemServerProto) GetSlotIdx() int32 {
	if m != nil {
		return m.SlotIdx
	}
	return 0
}

type HeroCaptainServerProto struct {
	Id               uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	GainTime         int64  `protobuf:"varint,7,opt,name=gain_time,json=gainTime,proto3" json:"gain_time,omitempty"`
	LevelExp         uint64 `protobuf:"varint,9,opt,name=level_exp,json=levelExp,proto3" json:"level_exp,omitempty"`
	Level            uint64 `protobuf:"varint,10,opt,name=level,proto3" json:"level,omitempty"`
	Soldier          uint64 `protobuf:"varint,11,opt,name=soldier,proto3" json:"soldier,omitempty"`
	Star             uint64 `protobuf:"varint,12,opt,name=star,proto3" json:"star,omitempty"`
	AbilityExp       uint64 `protobuf:"varint,15,opt,name=ability_exp,json=abilityExp,proto3" json:"ability_exp,omitempty"`
	Ability          uint64 `protobuf:"varint,16,opt,name=ability,proto3" json:"ability,omitempty"`
	Rebirth          uint64 `protobuf:"varint,18,opt,name=rebirth,proto3" json:"rebirth,omitempty"`
	RebirthCdEndTime int64  `protobuf:"varint,22,opt,name=rebirth_cd_end_time,json=rebirthCdEndTime,proto3" json:"rebirth_cd_end_time,omitempty"`
	// 装备
	Equipment []*EquipmentServerProto `protobuf:"bytes,31,rep,name=equipment" json:"equipment,omitempty"`
	// 宝石
	Gems        []*HeroCaptainGemServerProto `protobuf:"bytes,34,rep,name=gems" json:"gems,omitempty"`
	TrainAccExp uint64                       `protobuf:"varint,38,opt,name=train_acc_exp,json=trainAccExp,proto3" json:"train_acc_exp,omitempty"`
	Gongxun     uint64                       `protobuf:"varint,37,opt,name=gongxun,proto3" json:"gongxun,omitempty"`
	Official    uint64                       `protobuf:"varint,39,opt,name=official,proto3" json:"official,omitempty"`
	OfficialIdx uint64                       `protobuf:"varint,40,opt,name=official_idx,json=officialIdx,proto3" json:"official_idx,omitempty"`
	Viewed      bool                         `protobuf:"varint,41,opt,name=viewed,proto3" json:"viewed,omitempty"`
}

func (m *HeroCaptainServerProto) Reset()                    { *m = HeroCaptainServerProto{} }
func (m *HeroCaptainServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroCaptainServerProto) ProtoMessage()               {}
func (*HeroCaptainServerProto) Descriptor() ([]byte, []int) { return fileDescriptorMilitary, []int{6} }

func (m *HeroCaptainServerProto) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *HeroCaptainServerProto) GetGainTime() int64 {
	if m != nil {
		return m.GainTime
	}
	return 0
}

func (m *HeroCaptainServerProto) GetLevelExp() uint64 {
	if m != nil {
		return m.LevelExp
	}
	return 0
}

func (m *HeroCaptainServerProto) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *HeroCaptainServerProto) GetSoldier() uint64 {
	if m != nil {
		return m.Soldier
	}
	return 0
}

func (m *HeroCaptainServerProto) GetStar() uint64 {
	if m != nil {
		return m.Star
	}
	return 0
}

func (m *HeroCaptainServerProto) GetAbilityExp() uint64 {
	if m != nil {
		return m.AbilityExp
	}
	return 0
}

func (m *HeroCaptainServerProto) GetAbility() uint64 {
	if m != nil {
		return m.Ability
	}
	return 0
}

func (m *HeroCaptainServerProto) GetRebirth() uint64 {
	if m != nil {
		return m.Rebirth
	}
	return 0
}

func (m *HeroCaptainServerProto) GetRebirthCdEndTime() int64 {
	if m != nil {
		return m.RebirthCdEndTime
	}
	return 0
}

func (m *HeroCaptainServerProto) GetEquipment() []*EquipmentServerProto {
	if m != nil {
		return m.Equipment
	}
	return nil
}

func (m *HeroCaptainServerProto) GetGems() []*HeroCaptainGemServerProto {
	if m != nil {
		return m.Gems
	}
	return nil
}

func (m *HeroCaptainServerProto) GetTrainAccExp() uint64 {
	if m != nil {
		return m.TrainAccExp
	}
	return 0
}

func (m *HeroCaptainServerProto) GetGongxun() uint64 {
	if m != nil {
		return m.Gongxun
	}
	return 0
}

func (m *HeroCaptainServerProto) GetOfficial() uint64 {
	if m != nil {
		return m.Official
	}
	return 0
}

func (m *HeroCaptainServerProto) GetOfficialIdx() uint64 {
	if m != nil {
		return m.OfficialIdx
	}
	return 0
}

func (m *HeroCaptainServerProto) GetViewed() bool {
	if m != nil {
		return m.Viewed
	}
	return false
}

func init() {
	proto.RegisterType((*MilitaryConditionProto)(nil), "proto.MilitaryConditionProto")
	proto.RegisterType((*MilitaryAttributeProto)(nil), "proto.MilitaryAttributeProto")
	proto.RegisterType((*HeroMilitaryServerProto)(nil), "proto.HeroMilitaryServerProto")
	proto.RegisterType((*HeroTroopsServerProto)(nil), "proto.HeroTroopsServerProto")
	proto.RegisterType((*TroopsInvateProto)(nil), "proto.TroopsInvateProto")
	proto.RegisterType((*HeroCaptainGemServerProto)(nil), "proto.HeroCaptainGemServerProto")
	proto.RegisterType((*HeroCaptainServerProto)(nil), "proto.HeroCaptainServerProto")
}
func (m *MilitaryConditionProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MilitaryConditionProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsOr {
		dAtA[i] = 0x8
		i++
		if m.IsOr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Attributes) > 0 {
		for _, msg := range m.Attributes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.BaseId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.BaseId))
	}
	return i, nil
}

func (m *MilitaryAttributeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MilitaryAttributeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartBaseId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.StartBaseId))
	}
	if m.TargetBaseId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TargetBaseId))
	}
	if m.StartBaseGuildId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.StartBaseGuildId))
	}
	if m.TargetBaseGuildId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TargetBaseGuildId))
	}
	if m.TroopState != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TroopState))
	}
	if m.JoinAssemblyHeroId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.JoinAssemblyHeroId))
	}
	return i, nil
}

func (m *HeroMilitaryServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroMilitaryServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CaptainFriendship) > 0 {
		dAtA2 := make([]byte, len(m.CaptainFriendship)*10)
		var j1 int
		for _, num := range m.CaptainFriendship {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if len(m.CaptainIndex) > 0 {
		dAtA4 := make([]byte, len(m.CaptainIndex)*10)
		var j3 int
		for _, num := range m.CaptainIndex {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if len(m.Defenser) > 0 {
		dAtA6 := make([]byte, len(m.Defenser)*10)
		var j5 int
		for _, num := range m.Defenser {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if len(m.OfficialView) > 0 {
		for k, _ := range m.OfficialView {
			dAtA[i] = 0x4a
			i++
			v := m.OfficialView[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMilitary(uint64(msgSize))
			}
			mapSize := 1 + sovMilitary(uint64(k)) + msgSize
			i = encodeVarintMilitary(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMilitary(dAtA, i, uint64(v.Size()))
				n7, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n7
			}
		}
	}
	if len(m.Captains) > 0 {
		for _, msg := range m.Captains {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SoldierLevel != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.SoldierLevel))
	}
	if m.FreeSoldier != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.FreeSoldier))
	}
	if m.LastRecruitTime != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.LastRecruitTime))
	}
	if m.WoundedSoldier != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.WoundedSoldier))
	}
	if m.JiuGuanRefreshTimes != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.JiuGuanRefreshTimes))
	}
	if m.JiuGuanTutorIndex != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.JiuGuanTutorIndex))
	}
	if m.JiuGuanCombineTimes != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.JiuGuanCombineTimes))
	}
	if m.JunYingRecruitStartRecoveyTime != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.JunYingRecruitStartRecoveyTime))
	}
	if len(m.Troops) > 0 {
		for _, msg := range m.Troops {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NextExpelTime != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.NextExpelTime))
	}
	if m.GlobalTrainStartTime != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.GlobalTrainStartTime))
	}
	if len(m.PveTroops) > 0 {
		for _, msg := range m.PveTroops {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CaptainTrainStartTime != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.CaptainTrainStartTime))
	}
	if m.FreeSoldierStartRecoveryTime != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.FreeSoldierStartRecoveryTime))
	}
	if len(m.CandidateCaptainHead) > 0 {
		for _, s := range m.CandidateCaptainHead {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x3
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.ReservedExp != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.ReservedExp))
	}
	if m.OverflowFreeSoldier != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.OverflowFreeSoldier))
	}
	if m.ForceAddSoldierTimes != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.ForceAddSoldierTimes))
	}
	if m.InvestigateTroop != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.InvestigateTroop.Size()))
		n8, err := m.InvestigateTroop.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *HeroTroopsServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroTroopsServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sequence != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Sequence))
	}
	if len(m.Captains) > 0 {
		dAtA10 := make([]byte, len(m.Captains)*10)
		var j9 int
		for _, num1 := range m.Captains {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	if len(m.CaptainsXIndex) > 0 {
		dAtA12 := make([]byte, len(m.CaptainsXIndex)*10)
		var j11 int
		for _, num1 := range m.CaptainsXIndex {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	if m.InvateInfo != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.InvateInfo.Size()))
		n13, err := m.InvateInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *TroopsInvateProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TroopsInvateProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RealmId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.RealmId))
	}
	if m.TargetId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TargetId))
	}
	if m.OriginTargetId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.OriginTargetId))
	}
	if m.MoveStartTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.MoveStartTime))
	}
	if m.MoveArriveTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.MoveArriveTime))
	}
	if m.BackHomeTargetX != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.BackHomeTargetX))
	}
	if m.BackHomeTargetY != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.BackHomeTargetY))
	}
	if m.OwnerCanSeeTarget {
		dAtA[i] = 0x48
		i++
		if m.OwnerCanSeeTarget {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TargetBaseLevel != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TargetBaseLevel))
	}
	if m.RobbingEndTime != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.RobbingEndTime))
	}
	if m.NextReduceProsperityTime != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.NextReduceProsperityTime))
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.CreateTime))
	}
	if m.NextAddHateTime != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.NextAddHateTime))
	}
	if m.MoveSpeedRate != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.MoveSpeedRate))
	}
	if m.NextRobBaowuTime != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.NextRobBaowuTime))
	}
	if m.State != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.State))
	}
	if m.AccumRobPrize != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.AccumRobPrize.Size()))
		n14, err := m.AccumRobPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.AccumReduceProsperity != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.AccumReduceProsperity))
	}
	if m.AccumAddHate != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.AccumAddHate))
	}
	if m.AssemblyId != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.AssemblyId))
	}
	if m.AssemblyTargetId != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.AssemblyTargetId))
	}
	if m.Dialogue != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Dialogue))
	}
	if m.NpcTimes != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.NpcTimes))
	}
	return i, nil
}

func (m *HeroCaptainGemServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroCaptainGemServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gem != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Gem))
	}
	if m.SlotIdx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.SlotIdx))
	}
	return i, nil
}

func (m *HeroCaptainServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroCaptainServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Id))
	}
	if m.GainTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.GainTime))
	}
	if m.LevelExp != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.LevelExp))
	}
	if m.Level != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Level))
	}
	if m.Soldier != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Soldier))
	}
	if m.Star != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Star))
	}
	if m.AbilityExp != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.AbilityExp))
	}
	if m.Ability != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Ability))
	}
	if m.Rebirth != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Rebirth))
	}
	if m.RebirthCdEndTime != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.RebirthCdEndTime))
	}
	if len(m.Equipment) > 0 {
		for _, msg := range m.Equipment {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Gems) > 0 {
		for _, msg := range m.Gems {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintMilitary(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Gongxun != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Gongxun))
	}
	if m.TrainAccExp != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.TrainAccExp))
	}
	if m.Official != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.Official))
	}
	if m.OfficialIdx != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMilitary(dAtA, i, uint64(m.OfficialIdx))
	}
	if m.Viewed {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		if m.Viewed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeFixed64Military(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Military(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMilitary(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MilitaryConditionProto) Size() (n int) {
	var l int
	_ = l
	if m.IsOr {
		n += 2
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovMilitary(uint64(l))
		}
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovMilitary(uint64(l))
		}
	}
	if m.BaseId != 0 {
		n += 1 + sovMilitary(uint64(m.BaseId))
	}
	return n
}

func (m *MilitaryAttributeProto) Size() (n int) {
	var l int
	_ = l
	if m.StartBaseId != 0 {
		n += 1 + sovMilitary(uint64(m.StartBaseId))
	}
	if m.TargetBaseId != 0 {
		n += 1 + sovMilitary(uint64(m.TargetBaseId))
	}
	if m.StartBaseGuildId != 0 {
		n += 1 + sovMilitary(uint64(m.StartBaseGuildId))
	}
	if m.TargetBaseGuildId != 0 {
		n += 1 + sovMilitary(uint64(m.TargetBaseGuildId))
	}
	if m.TroopState != 0 {
		n += 1 + sovMilitary(uint64(m.TroopState))
	}
	if m.JoinAssemblyHeroId != 0 {
		n += 1 + sovMilitary(uint64(m.JoinAssemblyHeroId))
	}
	return n
}

func (m *HeroMilitaryServerProto) Size() (n int) {
	var l int
	_ = l
	if len(m.CaptainFriendship) > 0 {
		l = 0
		for _, e := range m.CaptainFriendship {
			l += sovMilitary(uint64(e))
		}
		n += 1 + sovMilitary(uint64(l)) + l
	}
	if len(m.CaptainIndex) > 0 {
		l = 0
		for _, e := range m.CaptainIndex {
			l += sovMilitary(uint64(e))
		}
		n += 1 + sovMilitary(uint64(l)) + l
	}
	if len(m.Defenser) > 0 {
		l = 0
		for _, e := range m.Defenser {
			l += sovMilitary(uint64(e))
		}
		n += 1 + sovMilitary(uint64(l)) + l
	}
	if len(m.OfficialView) > 0 {
		for k, v := range m.OfficialView {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMilitary(uint64(l))
			}
			mapEntrySize := 1 + sovMilitary(uint64(k)) + l
			n += mapEntrySize + 1 + sovMilitary(uint64(mapEntrySize))
		}
	}
	if len(m.Captains) > 0 {
		for _, e := range m.Captains {
			l = e.Size()
			n += 1 + l + sovMilitary(uint64(l))
		}
	}
	if m.SoldierLevel != 0 {
		n += 2 + sovMilitary(uint64(m.SoldierLevel))
	}
	if m.FreeSoldier != 0 {
		n += 2 + sovMilitary(uint64(m.FreeSoldier))
	}
	if m.LastRecruitTime != 0 {
		n += 2 + sovMilitary(uint64(m.LastRecruitTime))
	}
	if m.WoundedSoldier != 0 {
		n += 2 + sovMilitary(uint64(m.WoundedSoldier))
	}
	if m.JiuGuanRefreshTimes != 0 {
		n += 2 + sovMilitary(uint64(m.JiuGuanRefreshTimes))
	}
	if m.JiuGuanTutorIndex != 0 {
		n += 2 + sovMilitary(uint64(m.JiuGuanTutorIndex))
	}
	if m.JiuGuanCombineTimes != 0 {
		n += 2 + sovMilitary(uint64(m.JiuGuanCombineTimes))
	}
	if m.JunYingRecruitStartRecoveyTime != 0 {
		n += 2 + sovMilitary(uint64(m.JunYingRecruitStartRecoveyTime))
	}
	if len(m.Troops) > 0 {
		for _, e := range m.Troops {
			l = e.Size()
			n += 2 + l + sovMilitary(uint64(l))
		}
	}
	if m.NextExpelTime != 0 {
		n += 2 + sovMilitary(uint64(m.NextExpelTime))
	}
	if m.GlobalTrainStartTime != 0 {
		n += 2 + sovMilitary(uint64(m.GlobalTrainStartTime))
	}
	if len(m.PveTroops) > 0 {
		for _, e := range m.PveTroops {
			l = e.Size()
			n += 2 + l + sovMilitary(uint64(l))
		}
	}
	if m.CaptainTrainStartTime != 0 {
		n += 2 + sovMilitary(uint64(m.CaptainTrainStartTime))
	}
	if m.FreeSoldierStartRecoveryTime != 0 {
		n += 2 + sovMilitary(uint64(m.FreeSoldierStartRecoveryTime))
	}
	if len(m.CandidateCaptainHead) > 0 {
		for _, s := range m.CandidateCaptainHead {
			l = len(s)
			n += 2 + l + sovMilitary(uint64(l))
		}
	}
	if m.ReservedExp != 0 {
		n += 2 + sovMilitary(uint64(m.ReservedExp))
	}
	if m.OverflowFreeSoldier != 0 {
		n += 2 + sovMilitary(uint64(m.OverflowFreeSoldier))
	}
	if m.ForceAddSoldierTimes != 0 {
		n += 2 + sovMilitary(uint64(m.ForceAddSoldierTimes))
	}
	if m.InvestigateTroop != nil {
		l = m.InvestigateTroop.Size()
		n += 2 + l + sovMilitary(uint64(l))
	}
	return n
}

func (m *HeroTroopsServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Sequence != 0 {
		n += 1 + sovMilitary(uint64(m.Sequence))
	}
	if len(m.Captains) > 0 {
		l = 0
		for _, e := range m.Captains {
			l += sovMilitary(uint64(e))
		}
		n += 1 + sovMilitary(uint64(l)) + l
	}
	if len(m.CaptainsXIndex) > 0 {
		l = 0
		for _, e := range m.CaptainsXIndex {
			l += sovMilitary(uint64(e))
		}
		n += 1 + sovMilitary(uint64(l)) + l
	}
	if m.InvateInfo != nil {
		l = m.InvateInfo.Size()
		n += 2 + l + sovMilitary(uint64(l))
	}
	return n
}

func (m *TroopsInvateProto) Size() (n int) {
	var l int
	_ = l
	if m.RealmId != 0 {
		n += 1 + sovMilitary(uint64(m.RealmId))
	}
	if m.TargetId != 0 {
		n += 1 + sovMilitary(uint64(m.TargetId))
	}
	if m.OriginTargetId != 0 {
		n += 1 + sovMilitary(uint64(m.OriginTargetId))
	}
	if m.MoveStartTime != 0 {
		n += 1 + sovMilitary(uint64(m.MoveStartTime))
	}
	if m.MoveArriveTime != 0 {
		n += 1 + sovMilitary(uint64(m.MoveArriveTime))
	}
	if m.BackHomeTargetX != 0 {
		n += 1 + sovMilitary(uint64(m.BackHomeTargetX))
	}
	if m.BackHomeTargetY != 0 {
		n += 1 + sovMilitary(uint64(m.BackHomeTargetY))
	}
	if m.OwnerCanSeeTarget {
		n += 2
	}
	if m.TargetBaseLevel != 0 {
		n += 1 + sovMilitary(uint64(m.TargetBaseLevel))
	}
	if m.RobbingEndTime != 0 {
		n += 1 + sovMilitary(uint64(m.RobbingEndTime))
	}
	if m.NextReduceProsperityTime != 0 {
		n += 2 + sovMilitary(uint64(m.NextReduceProsperityTime))
	}
	if m.CreateTime != 0 {
		n += 2 + sovMilitary(uint64(m.CreateTime))
	}
	if m.NextAddHateTime != 0 {
		n += 2 + sovMilitary(uint64(m.NextAddHateTime))
	}
	if m.MoveSpeedRate != 0 {
		n += 2 + sovMilitary(uint64(m.MoveSpeedRate))
	}
	if m.NextRobBaowuTime != 0 {
		n += 2 + sovMilitary(uint64(m.NextRobBaowuTime))
	}
	if m.State != 0 {
		n += 2 + sovMilitary(uint64(m.State))
	}
	if m.AccumRobPrize != nil {
		l = m.AccumRobPrize.Size()
		n += 2 + l + sovMilitary(uint64(l))
	}
	if m.AccumReduceProsperity != 0 {
		n += 2 + sovMilitary(uint64(m.AccumReduceProsperity))
	}
	if m.AccumAddHate != 0 {
		n += 2 + sovMilitary(uint64(m.AccumAddHate))
	}
	if m.AssemblyId != 0 {
		n += 2 + sovMilitary(uint64(m.AssemblyId))
	}
	if m.AssemblyTargetId != 0 {
		n += 2 + sovMilitary(uint64(m.AssemblyTargetId))
	}
	if m.Dialogue != 0 {
		n += 2 + sovMilitary(uint64(m.Dialogue))
	}
	if m.NpcTimes != 0 {
		n += 2 + sovMilitary(uint64(m.NpcTimes))
	}
	return n
}

func (m *HeroCaptainGemServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Gem != 0 {
		n += 1 + sovMilitary(uint64(m.Gem))
	}
	if m.SlotIdx != 0 {
		n += 1 + sovMilitary(uint64(m.SlotIdx))
	}
	return n
}

func (m *HeroCaptainServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMilitary(uint64(m.Id))
	}
	if m.GainTime != 0 {
		n += 1 + sovMilitary(uint64(m.GainTime))
	}
	if m.LevelExp != 0 {
		n += 1 + sovMilitary(uint64(m.LevelExp))
	}
	if m.Level != 0 {
		n += 1 + sovMilitary(uint64(m.Level))
	}
	if m.Soldier != 0 {
		n += 1 + sovMilitary(uint64(m.Soldier))
	}
	if m.Star != 0 {
		n += 1 + sovMilitary(uint64(m.Star))
	}
	if m.AbilityExp != 0 {
		n += 1 + sovMilitary(uint64(m.AbilityExp))
	}
	if m.Ability != 0 {
		n += 2 + sovMilitary(uint64(m.Ability))
	}
	if m.Rebirth != 0 {
		n += 2 + sovMilitary(uint64(m.Rebirth))
	}
	if m.RebirthCdEndTime != 0 {
		n += 2 + sovMilitary(uint64(m.RebirthCdEndTime))
	}
	if len(m.Equipment) > 0 {
		for _, e := range m.Equipment {
			l = e.Size()
			n += 2 + l + sovMilitary(uint64(l))
		}
	}
	if len(m.Gems) > 0 {
		for _, e := range m.Gems {
			l = e.Size()
			n += 2 + l + sovMilitary(uint64(l))
		}
	}
	if m.Gongxun != 0 {
		n += 2 + sovMilitary(uint64(m.Gongxun))
	}
	if m.TrainAccExp != 0 {
		n += 2 + sovMilitary(uint64(m.TrainAccExp))
	}
	if m.Official != 0 {
		n += 2 + sovMilitary(uint64(m.Official))
	}
	if m.OfficialIdx != 0 {
		n += 2 + sovMilitary(uint64(m.OfficialIdx))
	}
	if m.Viewed {
		n += 3
	}
	return n
}

func sovMilitary(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMilitary(x uint64) (n int) {
	return sovMilitary(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MilitaryConditionProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MilitaryConditionProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MilitaryConditionProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOr = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &MilitaryConditionProto{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &MilitaryAttributeProto{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseId", wireType)
			}
			m.BaseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MilitaryAttributeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MilitaryAttributeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MilitaryAttributeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBaseId", wireType)
			}
			m.StartBaseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBaseId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBaseId", wireType)
			}
			m.TargetBaseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetBaseId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBaseGuildId", wireType)
			}
			m.StartBaseGuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBaseGuildId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBaseGuildId", wireType)
			}
			m.TargetBaseGuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetBaseGuildId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TroopState", wireType)
			}
			m.TroopState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TroopState |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinAssemblyHeroId", wireType)
			}
			m.JoinAssemblyHeroId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinAssemblyHeroId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroMilitaryServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroMilitaryServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroMilitaryServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainFriendship = append(m.CaptainFriendship, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMilitary
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMilitary
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainFriendship = append(m.CaptainFriendship, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainFriendship", wireType)
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainIndex = append(m.CaptainIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMilitary
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMilitary
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainIndex = append(m.CaptainIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainIndex", wireType)
			}
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Defenser = append(m.Defenser, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMilitary
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMilitary
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Defenser = append(m.Defenser, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Defenser", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfficialView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.OfficialView == nil {
				m.OfficialView = make(map[uint64]*proto1.Int32ArrayProto)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthMilitary
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthMilitary
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &proto1.Int32ArrayProto{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.OfficialView[mapkey] = mapvalue
			} else {
				var mapvalue *proto1.Int32ArrayProto
				m.OfficialView[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Captains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Captains = append(m.Captains, &HeroCaptainServerProto{})
			if err := m.Captains[len(m.Captains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldierLevel", wireType)
			}
			m.SoldierLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoldierLevel |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeSoldier", wireType)
			}
			m.FreeSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeSoldier |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRecruitTime", wireType)
			}
			m.LastRecruitTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastRecruitTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WoundedSoldier", wireType)
			}
			m.WoundedSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WoundedSoldier |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JiuGuanRefreshTimes", wireType)
			}
			m.JiuGuanRefreshTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JiuGuanRefreshTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JiuGuanTutorIndex", wireType)
			}
			m.JiuGuanTutorIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JiuGuanTutorIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JiuGuanCombineTimes", wireType)
			}
			m.JiuGuanCombineTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JiuGuanCombineTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JunYingRecruitStartRecoveyTime", wireType)
			}
			m.JunYingRecruitStartRecoveyTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JunYingRecruitStartRecoveyTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Troops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Troops = append(m.Troops, &HeroTroopsServerProto{})
			if err := m.Troops[len(m.Troops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextExpelTime", wireType)
			}
			m.NextExpelTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextExpelTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalTrainStartTime", wireType)
			}
			m.GlobalTrainStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalTrainStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PveTroops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PveTroops = append(m.PveTroops, &proto4.HeroPveTroopProto{})
			if err := m.PveTroops[len(m.PveTroops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainTrainStartTime", wireType)
			}
			m.CaptainTrainStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainTrainStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeSoldierStartRecoveryTime", wireType)
			}
			m.FreeSoldierStartRecoveryTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeSoldierStartRecoveryTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CandidateCaptainHead", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CandidateCaptainHead = append(m.CandidateCaptainHead, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservedExp", wireType)
			}
			m.ReservedExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReservedExp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverflowFreeSoldier", wireType)
			}
			m.OverflowFreeSoldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverflowFreeSoldier |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceAddSoldierTimes", wireType)
			}
			m.ForceAddSoldierTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceAddSoldierTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvestigateTroop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InvestigateTroop == nil {
				m.InvestigateTroop = &HeroTroopsServerProto{}
			}
			if err := m.InvestigateTroop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroTroopsServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroTroopsServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroTroopsServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Captains = append(m.Captains, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMilitary
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMilitary
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Captains = append(m.Captains, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Captains", wireType)
			}
		case 13:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainsXIndex = append(m.CaptainsXIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMilitary
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMilitary
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainsXIndex = append(m.CaptainsXIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainsXIndex", wireType)
			}
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvateInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InvateInfo == nil {
				m.InvateInfo = &TroopsInvateProto{}
			}
			if err := m.InvateInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TroopsInvateProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TroopsInvateProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TroopsInvateProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealmId", wireType)
			}
			m.RealmId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RealmId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			m.TargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTargetId", wireType)
			}
			m.OriginTargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginTargetId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveStartTime", wireType)
			}
			m.MoveStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveArriveTime", wireType)
			}
			m.MoveArriveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveArriveTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackHomeTargetX", wireType)
			}
			m.BackHomeTargetX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackHomeTargetX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackHomeTargetY", wireType)
			}
			m.BackHomeTargetY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackHomeTargetY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerCanSeeTarget", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OwnerCanSeeTarget = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBaseLevel", wireType)
			}
			m.TargetBaseLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetBaseLevel |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobbingEndTime", wireType)
			}
			m.RobbingEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobbingEndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextReduceProsperityTime", wireType)
			}
			m.NextReduceProsperityTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextReduceProsperityTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextAddHateTime", wireType)
			}
			m.NextAddHateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextAddHateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveSpeedRate", wireType)
			}
			m.MoveSpeedRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveSpeedRate |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextRobBaowuTime", wireType)
			}
			m.NextRobBaowuTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextRobBaowuTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccumRobPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccumRobPrize == nil {
				m.AccumRobPrize = &proto1.PrizeProto{}
			}
			if err := m.AccumRobPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccumReduceProsperity", wireType)
			}
			m.AccumReduceProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccumReduceProsperity |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccumAddHate", wireType)
			}
			m.AccumAddHate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccumAddHate |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssemblyId", wireType)
			}
			m.AssemblyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssemblyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssemblyTargetId", wireType)
			}
			m.AssemblyTargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssemblyTargetId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dialogue", wireType)
			}
			m.Dialogue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dialogue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NpcTimes", wireType)
			}
			m.NpcTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NpcTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroCaptainGemServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroCaptainGemServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroCaptainGemServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gem", wireType)
			}
			m.Gem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gem |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotIdx", wireType)
			}
			m.SlotIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlotIdx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroCaptainServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroCaptainServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroCaptainServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GainTime", wireType)
			}
			m.GainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GainTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelExp", wireType)
			}
			m.LevelExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LevelExp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Soldier", wireType)
			}
			m.Soldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Soldier |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			m.Star = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Star |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbilityExp", wireType)
			}
			m.AbilityExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbilityExp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ability", wireType)
			}
			m.Ability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ability |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rebirth", wireType)
			}
			m.Rebirth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rebirth |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RebirthCdEndTime", wireType)
			}
			m.RebirthCdEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RebirthCdEndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equipment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Equipment = append(m.Equipment, &EquipmentServerProto{})
			if err := m.Equipment[len(m.Equipment)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMilitary
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gems = append(m.Gems, &HeroCaptainGemServerProto{})
			if err := m.Gems[len(m.Gems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gongxun", wireType)
			}
			m.Gongxun = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gongxun |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainAccExp", wireType)
			}
			m.TrainAccExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainAccExp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Official", wireType)
			}
			m.Official = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Official |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfficialIdx", wireType)
			}
			m.OfficialIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OfficialIdx |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Viewed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Viewed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMilitary(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMilitary
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMilitary(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMilitary
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMilitary
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMilitary
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMilitary
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMilitary(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMilitary = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMilitary   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/server_proto/military.proto", fileDescriptorMilitary)
}

var fileDescriptorMilitary = []byte{
	// 1774 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x57, 0x4b, 0x73, 0x1b, 0xc7,
	0x11, 0x0e, 0x08, 0x80, 0x8f, 0x06, 0x5f, 0x58, 0xf1, 0xb1, 0xa6, 0x1c, 0x0a, 0xa6, 0x1c, 0x19,
	0xb1, 0x25, 0xd2, 0x21, 0xf5, 0xa2, 0x13, 0x1d, 0x28, 0x16, 0x25, 0xa2, 0x92, 0x94, 0x55, 0x4b,
	0x26, 0xb1, 0x73, 0xd9, 0xda, 0x47, 0x63, 0x31, 0xf4, 0x62, 0x07, 0x9e, 0xdd, 0x05, 0x81, 0xfc,
	0x90, 0x54, 0x7e, 0x46, 0x0e, 0xf9, 0x07, 0xbe, 0xe4, 0x98, 0x5b, 0xae, 0x29, 0xe5, 0x8f, 0xa4,
	0xba, 0x67, 0x76, 0xb1, 0x94, 0x18, 0x5b, 0x27, 0xec, 0x7c, 0xfd, 0x75, 0x4f, 0x4f, 0x4f, 0xf7,
	0x74, 0x03, 0x9e, 0x47, 0x22, 0x1b, 0xe4, 0xfe, 0x7e, 0x20, 0x87, 0x07, 0xb1, 0x88, 0x06, 0xd9,
	0xc8, 0xbb, 0x3e, 0x18, 0x7a, 0x31, 0x3e, 0x3b, 0x18, 0xf9, 0x07, 0x29, 0xaa, 0x31, 0x2a, 0x77,
	0xa4, 0x64, 0x26, 0x0f, 0x86, 0x22, 0x16, 0x99, 0xa7, 0xa6, 0xfb, 0xbc, 0xb4, 0x9a, 0xfc, 0xb3,
	0xf3, 0xf8, 0xc7, 0x0d, 0x0c, 0x3c, 0x85, 0xa1, 0x31, 0xe0, 0x7b, 0x29, 0x6a, 0xe5, 0x9d, 0xe7,
	0x1f, 0xae, 0x75, 0x73, 0xdb, 0x9f, 0xda, 0xaf, 0xea, 0xb0, 0x9f, 0xf7, 0xfb, 0x46, 0xeb, 0xc9,
	0x87, 0x6b, 0x45, 0x52, 0x86, 0xa9, 0x51, 0x7b, 0xfa, 0xe1, 0x6e, 0x2a, 0x8c, 0x84, 0x4c, 0xb4,
	0xde, 0xde, 0x0f, 0x35, 0xd8, 0xfa, 0xbd, 0xf1, 0xfb, 0x54, 0x26, 0xa1, 0xc8, 0x84, 0x4c, 0xde,
	0x70, 0xd8, 0x2c, 0x68, 0x88, 0xf4, 0x6b, 0x65, 0xd7, 0x3a, 0xb5, 0xee, 0xa2, 0xc3, 0xdf, 0xd6,
	0x0b, 0x80, 0xa0, 0x60, 0xa5, 0xf6, 0x5c, 0xa7, 0xde, 0x6d, 0x1d, 0xfe, 0x5c, 0x9b, 0xda, 0xbf,
	0xdd, 0x8c, 0x53, 0x51, 0x20, 0x75, 0x2f, 0xcb, 0x94, 0xf0, 0xf3, 0x0c, 0x53, 0xbb, 0x7e, 0xab,
	0xfa, 0x49, 0x41, 0x30, 0xea, 0x33, 0x05, 0x6b, 0x1b, 0x16, 0xe8, 0x66, 0x5c, 0x11, 0xda, 0x8d,
	0x4e, 0xad, 0x5b, 0x77, 0xe6, 0x69, 0xd9, 0x0b, 0xf7, 0xfe, 0x3a, 0x37, 0x3b, 0xc5, 0x4d, 0x7d,
	0x6b, 0x0f, 0x56, 0xd2, 0xcc, 0x53, 0x99, 0x5b, 0x68, 0xce, 0xb1, 0x66, 0x8b, 0xc1, 0x97, 0xac,
	0x6e, 0x7d, 0x0a, 0xab, 0x99, 0xa7, 0x22, 0x9c, 0x91, 0xea, 0x4c, 0x5a, 0xd6, 0xa8, 0x61, 0x3d,
	0x82, 0x3b, 0x15, 0x4b, 0x51, 0x2e, 0xe2, 0x70, 0xe6, 0xc9, 0x7a, 0x69, 0xef, 0x35, 0x09, 0x7a,
	0xa1, 0x75, 0x00, 0x1b, 0x55, 0xa3, 0x25, 0xbf, 0xc9, 0xfc, 0xf6, 0xcc, 0x74, 0xa1, 0x70, 0x0f,
	0x5a, 0x99, 0x92, 0x72, 0xe4, 0xa6, 0x99, 0x97, 0xa1, 0x3d, 0xdf, 0xa9, 0x75, 0x9b, 0x0e, 0x30,
	0x74, 0x41, 0x88, 0xf5, 0x2b, 0xd8, 0xbc, 0x92, 0x22, 0x71, 0xbd, 0x34, 0xc5, 0xa1, 0x1f, 0x4f,
	0xdd, 0x01, 0x2a, 0x49, 0x26, 0x17, 0xd8, 0xa4, 0x45, 0xc2, 0x13, 0x23, 0x3b, 0x47, 0x25, 0x7b,
	0xe1, 0xde, 0xbf, 0x01, 0xb6, 0xe9, 0xb3, 0x08, 0xce, 0x05, 0xe7, 0x8f, 0x8e, 0xcc, 0x23, 0xb0,
	0x02, 0x6f, 0x94, 0x79, 0x22, 0x71, 0xfb, 0x4a, 0x60, 0x12, 0xa6, 0x03, 0x31, 0xb2, 0x6b, 0x9d,
	0x7a, 0xb7, 0xe1, 0xb4, 0x8d, 0xe4, 0x55, 0x29, 0xb0, 0xee, 0xc3, 0x4a, 0x41, 0x17, 0x49, 0x88,
	0x13, 0xbb, 0xc1, 0xcc, 0x65, 0x03, 0xf6, 0x08, 0xb3, 0x76, 0x60, 0x31, 0xc4, 0x3e, 0x26, 0x29,
	0x2a, 0xbb, 0xc9, 0xf2, 0x72, 0x6d, 0xfd, 0x01, 0x56, 0x64, 0xbf, 0x2f, 0x02, 0xe1, 0xc5, 0xee,
	0x58, 0xe0, 0xb5, 0xbd, 0xc4, 0xf7, 0xff, 0xa5, 0xb9, 0xff, 0xff, 0xe3, 0xe6, 0xfe, 0xd7, 0x46,
	0xe7, 0x8f, 0x02, 0xaf, 0xcf, 0x92, 0x4c, 0x4d, 0x9d, 0x65, 0x59, 0x81, 0xac, 0x63, 0x58, 0x34,
	0x2e, 0xa4, 0x76, 0xeb, 0x46, 0x46, 0x91, 0xc5, 0x53, 0x2d, 0xaa, 0x18, 0x74, 0x4a, 0x3a, 0x1d,
	0x29, 0x95, 0x71, 0x28, 0x50, 0xb9, 0x31, 0x8e, 0x31, 0xb6, 0xef, 0x75, 0x6a, 0x74, 0x24, 0x03,
	0xfe, 0x8e, 0x30, 0xeb, 0x13, 0x58, 0xee, 0x2b, 0x44, 0xd7, 0x80, 0x76, 0x87, 0x39, 0x2d, 0xc2,
	0x2e, 0x34, 0x64, 0x7d, 0x0e, 0xed, 0xd8, 0x4b, 0x33, 0x57, 0x61, 0xa0, 0x72, 0x91, 0xb9, 0x99,
	0x18, 0xa2, 0x7d, 0x9f, 0xef, 0x6f, 0x8d, 0x04, 0x8e, 0xc6, 0x2f, 0xc5, 0x10, 0xad, 0xcf, 0x60,
	0xed, 0x5a, 0xe6, 0x49, 0x88, 0x61, 0x69, 0xf1, 0x53, 0xb6, 0xb8, 0x6a, 0xe0, 0xc2, 0xe8, 0x11,
	0x6c, 0x5d, 0x89, 0xdc, 0x8d, 0x72, 0x2f, 0x71, 0x15, 0xf6, 0x15, 0xa6, 0x03, 0x36, 0x9c, 0xda,
	0xfb, 0xcc, 0xbf, 0x73, 0x25, 0xf2, 0xd7, 0xb9, 0x97, 0x38, 0x5a, 0x46, 0xc6, 0x53, 0x4a, 0xba,
	0x52, 0x29, 0xcb, 0x33, 0xa9, 0xcc, 0x5d, 0x1d, 0xb0, 0x4a, 0xdb, 0xa8, 0x5c, 0x92, 0x44, 0x5f,
	0x58, 0x75, 0x97, 0x40, 0x0e, 0x7d, 0x91, 0xa0, 0xd9, 0xe5, 0xcb, 0x1b, 0xbb, 0x9c, 0x6a, 0x99,
	0xde, 0xe5, 0xb7, 0x70, 0xff, 0x2a, 0x4f, 0xdc, 0xa9, 0x48, 0xa2, 0xf2, 0xcc, 0xba, 0x34, 0x14,
	0x06, 0x72, 0x8c, 0x53, 0x1d, 0x81, 0x43, 0x4e, 0xcb, 0xdd, 0xab, 0x3c, 0xf9, 0x56, 0x24, 0x91,
	0x09, 0xc2, 0x05, 0xf1, 0x1c, 0x4d, 0xe3, 0x80, 0x3c, 0x86, 0x79, 0xce, 0xf1, 0xd4, 0x3e, 0xe2,
	0xdb, 0xfb, 0xb8, 0x72, 0x7b, 0x97, 0x2c, 0xa8, 0x5e, 0x9e, 0xe1, 0x5a, 0x0f, 0x60, 0x2d, 0xc1,
	0x49, 0xe6, 0xe2, 0x64, 0x84, 0xb1, 0xde, 0xee, 0x31, 0x6f, 0xb7, 0x42, 0xf0, 0x19, 0xa1, 0x6c,
	0xfd, 0x09, 0x6c, 0x47, 0xb1, 0xf4, 0xbd, 0xd8, 0xcd, 0x14, 0xa5, 0xae, 0x76, 0x93, 0xf9, 0x4f,
	0x98, 0xbf, 0xa1, 0xc5, 0x97, 0x24, 0x65, 0xdf, 0x58, 0xed, 0x19, 0xc0, 0x68, 0x8c, 0xae, 0x71,
	0xec, 0x29, 0x3b, 0x66, 0x57, 0x1c, 0x7b, 0x33, 0x46, 0xf6, 0x4d, 0x3b, 0xb5, 0x34, 0x32, 0xcb,
	0xd4, 0x7a, 0x06, 0x76, 0x51, 0x25, 0xef, 0x6d, 0xf8, 0x8c, 0x37, 0xdc, 0x34, 0xf2, 0x77, 0x76,
	0x7c, 0x05, 0x9d, 0x6a, 0x9a, 0xdd, 0x88, 0xa7, 0x32, 0x01, 0x7d, 0xce, 0x06, 0x3e, 0xae, 0xa4,
	0x5e, 0x25, 0x9a, 0xaa, 0x08, 0xe7, 0x56, 0xe0, 0x25, 0xa1, 0x08, 0xbd, 0x0c, 0xdd, 0xc2, 0x95,
	0x01, 0x7a, 0xa1, 0x7d, 0xdc, 0xa9, 0x77, 0x97, 0x9c, 0x8d, 0x52, 0x6a, 0x4a, 0xe3, 0x1c, 0xbd,
	0x90, 0x92, 0x5c, 0x21, 0x37, 0x97, 0x90, 0x42, 0x6a, 0x7f, 0xa5, 0x1f, 0xc9, 0x02, 0x3b, 0x9b,
	0x8c, 0xac, 0x43, 0xd8, 0xa4, 0x5d, 0xfa, 0xb1, 0xbc, 0x76, 0x6f, 0x14, 0xc4, 0xaf, 0x75, 0xa2,
	0x14, 0xc2, 0x57, 0x95, 0xc2, 0x78, 0x02, 0xdb, 0x7d, 0xa9, 0x02, 0x74, 0xbd, 0xb0, 0x4c, 0x77,
	0x93, 0x5e, 0xbf, 0x61, 0xad, 0x0d, 0x16, 0x9f, 0x84, 0x45, 0xd6, 0xeb, 0xfc, 0xea, 0x41, 0x5b,
	0x24, 0x63, 0x4c, 0x33, 0x11, 0xd1, 0x29, 0xf8, 0x16, 0xec, 0x17, 0x9d, 0xda, 0x4f, 0x66, 0xc7,
	0x7a, 0x45, 0x8d, 0xa5, 0x3b, 0x7f, 0x82, 0xf6, 0x7b, 0x0f, 0x88, 0xb5, 0x0e, 0xf5, 0xef, 0x70,
	0xca, 0x8d, 0xad, 0xe1, 0xd0, 0xa7, 0xf5, 0x10, 0x9a, 0x63, 0x2f, 0xce, 0x91, 0xbb, 0x43, 0xeb,
	0x70, 0xcb, 0xec, 0xd2, 0x4b, 0xb2, 0xa3, 0xc3, 0x13, 0xa5, 0xbc, 0xa9, 0xb6, 0xaf, 0x49, 0x5f,
	0xcd, 0x3d, 0xaf, 0xed, 0xfd, 0xa3, 0x06, 0x9b, 0xb7, 0x3a, 0x41, 0x6f, 0x60, 0x8a, 0xdf, 0xe7,
	0x98, 0x04, 0xc8, 0x7d, 0xa4, 0xe9, 0x94, 0x6b, 0x92, 0x95, 0x8f, 0xd5, 0x72, 0xa7, 0x4e, 0xb2,
	0xf2, 0x35, 0xea, 0xc2, 0x7a, 0xf1, 0xed, 0x4e, 0x4c, 0xdd, 0xae, 0x30, 0x67, 0xb5, 0xc0, 0xbf,
	0xd1, 0x45, 0x7b, 0x0c, 0x2d, 0x91, 0x8c, 0x29, 0x34, 0x22, 0xe9, 0x4b, 0xfb, 0x88, 0x7d, 0x2e,
	0xd2, 0x53, 0x3b, 0xd4, 0x63, 0xb9, 0x69, 0xa1, 0x9a, 0xdc, 0x4b, 0xfa, 0x72, 0xef, 0x87, 0x05,
	0x68, 0xbf, 0xc7, 0xb0, 0x3e, 0x82, 0x45, 0x85, 0x5e, 0x3c, 0xa4, 0x66, 0x52, 0xe3, 0xab, 0x5f,
	0xe0, 0x75, 0x2f, 0xb4, 0xee, 0xc2, 0x92, 0x69, 0x63, 0x65, 0xef, 0x5c, 0xd4, 0x40, 0x2f, 0x24,
	0x97, 0xa5, 0x12, 0x11, 0x25, 0x7b, 0xc9, 0xd1, 0xad, 0x73, 0x55, 0xe3, 0x97, 0x05, 0xf3, 0x01,
	0xac, 0x0d, 0xe5, 0x18, 0xab, 0xe5, 0xa0, 0x1b, 0xe1, 0x0a, 0xc1, 0xb3, 0x32, 0xe8, 0xc2, 0x3a,
	0xf3, 0x3c, 0xa5, 0xc4, 0x58, 0x3f, 0x45, 0xdc, 0x09, 0xeb, 0xce, 0x2a, 0xe1, 0x27, 0x0c, 0x33,
	0xf3, 0x0b, 0xb0, 0x7c, 0x2f, 0xf8, 0xce, 0x1d, 0xc8, 0x21, 0x16, 0xdb, 0x4f, 0xb8, 0x15, 0x36,
	0x9d, 0x35, 0x92, 0x9c, 0xcb, 0x21, 0xea, 0xfd, 0xbf, 0xb9, 0x95, 0x3c, 0xb5, 0x17, 0x6f, 0x23,
	0x7f, 0x4b, 0x8f, 0xa8, 0xbc, 0x4e, 0x50, 0xb9, 0x81, 0x97, 0xb8, 0x29, 0x16, 0x0a, 0xf6, 0x12,
	0x0f, 0x42, 0x6d, 0x96, 0x9d, 0x7a, 0xc9, 0x05, 0x1a, 0x0d, 0x7a, 0xff, 0xab, 0xad, 0x5e, 0xf7,
	0x12, 0xe0, 0xec, 0x5a, 0x9b, 0xf5, 0x79, 0xdd, 0x4e, 0xba, 0xb0, 0xae, 0xa4, 0xef, 0xd3, 0xd3,
	0x89, 0x49, 0xa8, 0x0f, 0xb8, 0xa6, 0x0f, 0x68, 0xf0, 0xb3, 0x24, 0xe4, 0x03, 0xbe, 0x80, 0xbb,
	0xfc, 0xc4, 0x29, 0x0c, 0xf3, 0x00, 0x69, 0x78, 0x4b, 0x47, 0xa8, 0x44, 0x66, 0x1e, 0x83, 0x75,
	0x56, 0xb2, 0x89, 0xe2, 0x30, 0xe3, 0x4d, 0x49, 0x60, 0xf5, 0x7b, 0xd0, 0x0a, 0x14, 0x72, 0xfd,
	0x10, 0xbd, 0xcd, 0x74, 0xd0, 0x50, 0x11, 0x40, 0xb6, 0x4f, 0xb5, 0x39, 0x28, 0x79, 0x16, 0xf3,
	0xf8, 0x71, 0x3d, 0x09, 0xc3, 0xf3, 0x82, 0x5c, 0xde, 0xdf, 0x08, 0x31, 0x74, 0x15, 0x0d, 0x28,
	0x77, 0xf8, 0x80, 0xfa, 0xfe, 0x08, 0x75, 0x68, 0x46, 0x79, 0x04, 0x77, 0xb4, 0xd3, 0xd2, 0x77,
	0x7d, 0x4f, 0x5e, 0xe7, 0xda, 0xea, 0x86, 0x1e, 0x92, 0xd8, 0x59, 0xe9, 0xbf, 0x24, 0x01, 0x9b,
	0xdd, 0x80, 0xa6, 0x9e, 0x76, 0xb6, 0xf8, 0x2a, 0xf4, 0xc2, 0x3a, 0x86, 0x35, 0x2f, 0x08, 0xf2,
	0x21, 0x5b, 0x19, 0x29, 0xf1, 0x17, 0xe4, 0xce, 0xdc, 0x3a, 0x6c, 0x9b, 0x1c, 0x7f, 0x43, 0x98,
	0x4e, 0xee, 0x15, 0x66, 0x3a, 0xd2, 0x67, 0xcc, 0x7a, 0x0a, 0xdb, 0x46, 0xf5, 0xdd, 0xa8, 0x99,
	0xc6, 0xbd, 0xa9, 0xf9, 0xef, 0x44, 0x8c, 0x46, 0x40, 0xad, 0x57, 0x44, 0xc3, 0xfe, 0x44, 0xcf,
	0x02, 0x8c, 0x9a, 0x48, 0x50, 0x4c, 0xcb, 0xe1, 0x4b, 0x84, 0xf6, 0x2f, 0x75, 0x4c, 0x0b, 0xa8,
	0x17, 0x5a, 0x0f, 0xc1, 0x2a, 0x09, 0xb3, 0x92, 0xf8, 0x5c, 0x9f, 0xbe, 0x90, 0x94, 0x45, 0x41,
	0xd3, 0x92, 0xf0, 0x62, 0x19, 0xe5, 0x68, 0x7f, 0xc1, 0xdb, 0x95, 0x6b, 0xaa, 0xbb, 0x64, 0x14,
	0x98, 0xc7, 0xf2, 0xa1, 0x16, 0x26, 0xa3, 0x80, 0x1f, 0xc8, 0xbd, 0x73, 0xf8, 0xa8, 0x32, 0xdc,
	0xbc, 0xc6, 0x61, 0xf5, 0xfd, 0x59, 0x87, 0x7a, 0x84, 0xc3, 0xe2, 0x75, 0x8b, 0x70, 0x48, 0xe5,
	0x9d, 0xc6, 0x92, 0x5c, 0x99, 0x70, 0x09, 0x37, 0x9d, 0x05, 0x5a, 0xf7, 0xc2, 0xc9, 0xde, 0xdf,
	0x1b, 0xb0, 0x75, 0xfb, 0x9c, 0x64, 0xad, 0xc2, 0x9c, 0x79, 0x0e, 0x1a, 0xce, 0x9c, 0xe0, 0x97,
	0x20, 0xe2, 0xbe, 0x46, 0x17, 0xaa, 0x47, 0xce, 0x45, 0x02, 0xf8, 0x22, 0xef, 0xc2, 0x12, 0xa7,
	0x3d, 0x77, 0x8f, 0x25, 0xed, 0x2e, 0x03, 0xd4, 0x3a, 0x36, 0xa0, 0x59, 0xad, 0x09, 0xbd, 0xb0,
	0x6c, 0x58, 0x28, 0x5a, 0x48, 0x8b, 0xf1, 0x62, 0x49, 0xff, 0x3c, 0xe8, 0x9d, 0xb0, 0x97, 0x19,
	0xe6, 0x6f, 0x0e, 0xbd, 0x4f, 0xe3, 0xe1, 0x94, 0xb7, 0x58, 0x63, 0x11, 0x18, 0x88, 0x36, 0xb1,
	0x61, 0xc1, 0xac, 0xb8, 0x34, 0x1a, 0x4e, 0xb1, 0x24, 0x89, 0x42, 0x5f, 0xa8, 0x6c, 0xc0, 0xd9,
	0xdd, 0x70, 0x8a, 0x25, 0x65, 0xab, 0xf9, 0x74, 0x83, 0x70, 0x56, 0x8f, 0x5b, 0xfa, 0xbe, 0x8c,
	0xe8, 0x34, 0x2c, 0x2a, 0xf2, 0x18, 0x96, 0xf0, 0xfb, 0x5c, 0x8c, 0x86, 0x98, 0x64, 0xf6, 0x3d,
	0x1e, 0x0a, 0xee, 0x9a, 0x8c, 0x3c, 0x2b, 0xf0, 0x6a, 0x3b, 0x9a, 0xb1, 0xad, 0xc7, 0xd0, 0x88,
	0x70, 0x98, 0xda, 0x7b, 0xac, 0xd5, 0x79, 0x7f, 0x42, 0xbd, 0x79, 0x89, 0x0e, 0xb3, 0xc9, 0xf3,
	0x48, 0x26, 0xd1, 0x24, 0x4f, 0xec, 0x5f, 0x68, 0xcf, 0xcd, 0x92, 0xfe, 0xd6, 0xe8, 0xf9, 0xc2,
	0x0b, 0x02, 0x0e, 0xc8, 0x03, 0x3d, 0x96, 0x32, 0x78, 0x12, 0x04, 0x14, 0x91, 0x1d, 0x58, 0x2c,
	0x26, 0x65, 0xfb, 0x33, 0x7d, 0x25, 0xc5, 0x9a, 0x1a, 0x7e, 0x39, 0x8c, 0x53, 0x5a, 0x74, 0xb5,
	0x7a, 0x81, 0xf5, 0xc2, 0x89, 0xb5, 0x05, 0xf3, 0x34, 0xa6, 0xa3, 0xce, 0xf3, 0x45, 0xc7, 0xac,
	0x5e, 0x76, 0xfe, 0xf9, 0x76, 0xb7, 0xf6, 0xaf, 0xb7, 0xbb, 0xb5, 0xff, 0xbc, 0xdd, 0xad, 0xfd,
	0xed, 0xbf, 0xbb, 0x3f, 0x3b, 0xaf, 0xfd, 0x79, 0xb9, 0xfa, 0xc7, 0xd4, 0x9f, 0xe7, 0x9f, 0xa3,
	0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x10, 0x9a, 0x7a, 0xb1, 0xb3, 0x0f, 0x00, 0x00,
}
