// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/server_proto/mingc_war.proto
// DO NOT EDIT!

package server_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import proto1 "github.com/lightpaw/male7/pb/shared_proto"
import proto44 "github.com/lightpaw/male7/pb/shared_proto"
import proto3 "github.com/lightpaw/male7/pb/shared_proto"
import proto4 "github.com/lightpaw/male7/pb/shared_proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type McWarAiType int32

const (
	McWarAiType_MC_AI_STATION    McWarAiType = 0
	McWarAiType_MC_AI_ATK        McWarAiType = 1
	McWarAiType_MC_AI_DEF_HOME   McWarAiType = 2
	McWarAiType_MC_AI_DEF_CASTLE McWarAiType = 3
	McWarAiType_MC_AI_DEF_GATE   McWarAiType = 4
)

var McWarAiType_name = map[int32]string{
	0: "MC_AI_STATION",
	1: "MC_AI_ATK",
	2: "MC_AI_DEF_HOME",
	3: "MC_AI_DEF_CASTLE",
	4: "MC_AI_DEF_GATE",
}
var McWarAiType_value = map[string]int32{
	"MC_AI_STATION":    0,
	"MC_AI_ATK":        1,
	"MC_AI_DEF_HOME":   2,
	"MC_AI_DEF_CASTLE": 3,
	"MC_AI_DEF_GATE":   4,
}

func (x McWarAiType) String() string {
	return proto.EnumName(McWarAiType_name, int32(x))
}
func (McWarAiType) EnumDescriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{0} }

type MingcWarServerProto struct {
	Id        int32                     `protobuf:"varint,10,opt,name=id,proto3" json:"id,omitempty"`
	State     proto44.MingcWarState     `protobuf:"varint,1,opt,name=state,proto3,enum=proto.MingcWarState" json:"state,omitempty"`
	StartTime int64                     `protobuf:"varint,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   int64                     `protobuf:"varint,3,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	NotStart  *MingcStageProto          `protobuf:"bytes,9,opt,name=not_start,json=notStart" json:"not_start,omitempty"`
	ApplyAtk  *MingcApplyAtkProto       `protobuf:"bytes,4,opt,name=apply_atk,json=applyAtk" json:"apply_atk,omitempty"`
	ApplyAst  *MingcApplyAstProto       `protobuf:"bytes,5,opt,name=apply_ast,json=applyAst" json:"apply_ast,omitempty"`
	Fight     *MingcFightProto          `protobuf:"bytes,6,opt,name=fight" json:"fight,omitempty"`
	FightEnd  *MingcStageProto          `protobuf:"bytes,7,opt,name=fight_end,json=fightEnd" json:"fight_end,omitempty"`
	Mingc     map[uint64]*MingcObjProto `protobuf:"bytes,8,rep,name=mingc" json:"mingc,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *MingcWarServerProto) Reset()                    { *m = MingcWarServerProto{} }
func (m *MingcWarServerProto) String() string            { return proto.CompactTextString(m) }
func (*MingcWarServerProto) ProtoMessage()               {}
func (*MingcWarServerProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{0} }

func (m *MingcWarServerProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MingcWarServerProto) GetState() proto44.MingcWarState {
	if m != nil {
		return m.State
	}
	return proto44.MingcWarState_MC_T_INVALID
}

func (m *MingcWarServerProto) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *MingcWarServerProto) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *MingcWarServerProto) GetNotStart() *MingcStageProto {
	if m != nil {
		return m.NotStart
	}
	return nil
}

func (m *MingcWarServerProto) GetApplyAtk() *MingcApplyAtkProto {
	if m != nil {
		return m.ApplyAtk
	}
	return nil
}

func (m *MingcWarServerProto) GetApplyAst() *MingcApplyAstProto {
	if m != nil {
		return m.ApplyAst
	}
	return nil
}

func (m *MingcWarServerProto) GetFight() *MingcFightProto {
	if m != nil {
		return m.Fight
	}
	return nil
}

func (m *MingcWarServerProto) GetFightEnd() *MingcStageProto {
	if m != nil {
		return m.FightEnd
	}
	return nil
}

func (m *MingcWarServerProto) GetMingc() map[uint64]*MingcObjProto {
	if m != nil {
		return m.Mingc
	}
	return nil
}

type MingcApplyAtkProto struct {
	StartTime int64                    `protobuf:"varint,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   int64                    `protobuf:"varint,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	Bids      map[uint64]*BidInfoProto `protobuf:"bytes,3,rep,name=bids" json:"bids,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Applicant map[int64]uint64         `protobuf:"bytes,4,rep,name=applicant" json:"applicant,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Winners   map[uint64]int64         `protobuf:"bytes,5,rep,name=winners" json:"winners,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *MingcApplyAtkProto) Reset()                    { *m = MingcApplyAtkProto{} }
func (m *MingcApplyAtkProto) String() string            { return proto.CompactTextString(m) }
func (*MingcApplyAtkProto) ProtoMessage()               {}
func (*MingcApplyAtkProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{1} }

func (m *MingcApplyAtkProto) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *MingcApplyAtkProto) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *MingcApplyAtkProto) GetBids() map[uint64]*BidInfoProto {
	if m != nil {
		return m.Bids
	}
	return nil
}

func (m *MingcApplyAtkProto) GetApplicant() map[int64]uint64 {
	if m != nil {
		return m.Applicant
	}
	return nil
}

func (m *MingcApplyAtkProto) GetWinners() map[uint64]int64 {
	if m != nil {
		return m.Winners
	}
	return nil
}

type MingcApplyAstProto struct {
	StartTime int64                     `protobuf:"varint,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   int64                     `protobuf:"varint,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	Mingc     map[uint64]*MingcObjProto `protobuf:"bytes,3,rep,name=mingc" json:"mingc,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *MingcApplyAstProto) Reset()                    { *m = MingcApplyAstProto{} }
func (m *MingcApplyAstProto) String() string            { return proto.CompactTextString(m) }
func (*MingcApplyAstProto) ProtoMessage()               {}
func (*MingcApplyAstProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{2} }

func (m *MingcApplyAstProto) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *MingcApplyAstProto) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *MingcApplyAstProto) GetMingc() map[uint64]*MingcObjProto {
	if m != nil {
		return m.Mingc
	}
	return nil
}

type MingcObjProto struct {
	Id       uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	DefId    int64                  `protobuf:"varint,2,opt,name=def_id,json=defId,proto3" json:"def_id,omitempty"`
	AtkId    int64                  `protobuf:"varint,3,opt,name=atk_id,json=atkId,proto3" json:"atk_id,omitempty"`
	AstDef   []int64                `protobuf:"varint,4,rep,packed,name=ast_def,json=astDef" json:"ast_def,omitempty"`
	AstAtk   []int64                `protobuf:"varint,5,rep,packed,name=ast_atk,json=astAtk" json:"ast_atk,omitempty"`
	ApplyAst map[int64]bool         `protobuf:"bytes,6,rep,name=apply_ast,json=applyAst" json:"apply_ast,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Country  uint64                 `protobuf:"varint,10,opt,name=country,proto3" json:"country,omitempty"`
	Bid      *BidInfoProto          `protobuf:"bytes,8,opt,name=bid" json:"bid,omitempty"`
	Scene    *McWarSceneServerProto `protobuf:"bytes,9,opt,name=scene" json:"scene,omitempty"`
}

func (m *MingcObjProto) Reset()                    { *m = MingcObjProto{} }
func (m *MingcObjProto) String() string            { return proto.CompactTextString(m) }
func (*MingcObjProto) ProtoMessage()               {}
func (*MingcObjProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{3} }

func (m *MingcObjProto) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MingcObjProto) GetDefId() int64 {
	if m != nil {
		return m.DefId
	}
	return 0
}

func (m *MingcObjProto) GetAtkId() int64 {
	if m != nil {
		return m.AtkId
	}
	return 0
}

func (m *MingcObjProto) GetAstDef() []int64 {
	if m != nil {
		return m.AstDef
	}
	return nil
}

func (m *MingcObjProto) GetAstAtk() []int64 {
	if m != nil {
		return m.AstAtk
	}
	return nil
}

func (m *MingcObjProto) GetApplyAst() map[int64]bool {
	if m != nil {
		return m.ApplyAst
	}
	return nil
}

func (m *MingcObjProto) GetCountry() uint64 {
	if m != nil {
		return m.Country
	}
	return 0
}

func (m *MingcObjProto) GetBid() *BidInfoProto {
	if m != nil {
		return m.Bid
	}
	return nil
}

func (m *MingcObjProto) GetScene() *McWarSceneServerProto {
	if m != nil {
		return m.Scene
	}
	return nil
}

type MingcFightProto struct {
	StartTime int64 `protobuf:"varint,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   int64 `protobuf:"varint,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (m *MingcFightProto) Reset()                    { *m = MingcFightProto{} }
func (m *MingcFightProto) String() string            { return proto.CompactTextString(m) }
func (*MingcFightProto) ProtoMessage()               {}
func (*MingcFightProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{4} }

func (m *MingcFightProto) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *MingcFightProto) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type MingcStageProto struct {
	StartTime int64 `protobuf:"varint,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   int64 `protobuf:"varint,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (m *MingcStageProto) Reset()                    { *m = MingcStageProto{} }
func (m *MingcStageProto) String() string            { return proto.CompactTextString(m) }
func (*MingcStageProto) ProtoMessage()               {}
func (*MingcStageProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{5} }

func (m *MingcStageProto) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *MingcStageProto) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type McWarSceneServerProto struct {
	McId         uint64                       `protobuf:"varint,1,opt,name=mc_id,json=mcId,proto3" json:"mc_id,omitempty"`
	Building     []*McWarBuildingServerProto  `protobuf:"bytes,2,rep,name=building" json:"building,omitempty"`
	Npc          []*McWarNpcTroop             `protobuf:"bytes,7,rep,name=npc" json:"npc,omitempty"`
	StartTime    int64                        `protobuf:"varint,8,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	Ended        bool                         `protobuf:"varint,3,opt,name=ended,proto3" json:"ended,omitempty"`
	AtkWin       bool                         `protobuf:"varint,4,opt,name=atk_win,json=atkWin,proto3" json:"atk_win,omitempty"`
	EndedNoticed bool                         `protobuf:"varint,5,opt,name=ended_noticed,json=endedNoticed,proto3" json:"ended_noticed,omitempty"`
	Record       *McWarFightRecordServerProto `protobuf:"bytes,6,opt,name=record" json:"record,omitempty"`
	AtkDrumTimes uint64                       `protobuf:"varint,9,opt,name=atk_drum_times,json=atkDrumTimes,proto3" json:"atk_drum_times,omitempty"`
	DefDrumTimes uint64                       `protobuf:"varint,10,opt,name=def_drum_times,json=defDrumTimes,proto3" json:"def_drum_times,omitempty"`
	AtkDrumStat  *proto1.SpriteStatProto      `protobuf:"bytes,11,opt,name=atk_drum_stat,json=atkDrumStat" json:"atk_drum_stat,omitempty"`
	DefDrumStat  *proto1.SpriteStatProto      `protobuf:"bytes,12,opt,name=def_drum_stat,json=defDrumStat" json:"def_drum_stat,omitempty"`
}

func (m *McWarSceneServerProto) Reset()                    { *m = McWarSceneServerProto{} }
func (m *McWarSceneServerProto) String() string            { return proto.CompactTextString(m) }
func (*McWarSceneServerProto) ProtoMessage()               {}
func (*McWarSceneServerProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{6} }

func (m *McWarSceneServerProto) GetMcId() uint64 {
	if m != nil {
		return m.McId
	}
	return 0
}

func (m *McWarSceneServerProto) GetBuilding() []*McWarBuildingServerProto {
	if m != nil {
		return m.Building
	}
	return nil
}

func (m *McWarSceneServerProto) GetNpc() []*McWarNpcTroop {
	if m != nil {
		return m.Npc
	}
	return nil
}

func (m *McWarSceneServerProto) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *McWarSceneServerProto) GetEnded() bool {
	if m != nil {
		return m.Ended
	}
	return false
}

func (m *McWarSceneServerProto) GetAtkWin() bool {
	if m != nil {
		return m.AtkWin
	}
	return false
}

func (m *McWarSceneServerProto) GetEndedNoticed() bool {
	if m != nil {
		return m.EndedNoticed
	}
	return false
}

func (m *McWarSceneServerProto) GetRecord() *McWarFightRecordServerProto {
	if m != nil {
		return m.Record
	}
	return nil
}

func (m *McWarSceneServerProto) GetAtkDrumTimes() uint64 {
	if m != nil {
		return m.AtkDrumTimes
	}
	return 0
}

func (m *McWarSceneServerProto) GetDefDrumTimes() uint64 {
	if m != nil {
		return m.DefDrumTimes
	}
	return 0
}

func (m *McWarSceneServerProto) GetAtkDrumStat() *proto1.SpriteStatProto {
	if m != nil {
		return m.AtkDrumStat
	}
	return nil
}

func (m *McWarSceneServerProto) GetDefDrumStat() *proto1.SpriteStatProto {
	if m != nil {
		return m.DefDrumStat
	}
	return nil
}

type McWarBuildingServerProto struct {
	Atk                  bool                         `protobuf:"varint,1,opt,name=atk,proto3" json:"atk,omitempty"`
	Pos                  uint64                       `protobuf:"varint,2,opt,name=pos,proto3" json:"pos,omitempty"`
	Prosperity           uint64                       `protobuf:"varint,3,opt,name=prosperity,proto3" json:"prosperity,omitempty"`
	LastDestroyTime      int64                        `protobuf:"varint,4,opt,name=last_destroy_time,json=lastDestroyTime,proto3" json:"last_destroy_time,omitempty"`
	Troop                []*McWarTroopServerProto     `protobuf:"bytes,5,rep,name=troop" json:"troop,omitempty"`
	Type                 proto44.MingcWarBuildingType `protobuf:"varint,6,opt,name=type,proto3,enum=proto.MingcWarBuildingType" json:"type,omitempty"`
	Name                 string                       `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty"`
	TouShiTurnEndTime    int64                        `protobuf:"varint,10,opt,name=tou_shi_turn_end_time,json=touShiTurnEndTime,proto3" json:"tou_shi_turn_end_time,omitempty"`
	TouShiPrepareEndTime int64                        `protobuf:"varint,11,opt,name=tou_shi_prepare_end_time,json=touShiPrepareEndTime,proto3" json:"tou_shi_prepare_end_time,omitempty"`
	TouShiTargetIndex    int32                        `protobuf:"varint,12,opt,name=tou_shi_target_index,json=touShiTargetIndex,proto3" json:"tou_shi_target_index,omitempty"`
	LastFireHeroName     string                       `protobuf:"bytes,13,opt,name=last_fire_hero_name,json=lastFireHeroName,proto3" json:"last_fire_hero_name,omitempty"`
	LastFireHeroCountry  int32                        `protobuf:"varint,14,opt,name=last_fire_hero_country,json=lastFireHeroCountry,proto3" json:"last_fire_hero_country,omitempty"`
}

func (m *McWarBuildingServerProto) Reset()                    { *m = McWarBuildingServerProto{} }
func (m *McWarBuildingServerProto) String() string            { return proto.CompactTextString(m) }
func (*McWarBuildingServerProto) ProtoMessage()               {}
func (*McWarBuildingServerProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{7} }

func (m *McWarBuildingServerProto) GetAtk() bool {
	if m != nil {
		return m.Atk
	}
	return false
}

func (m *McWarBuildingServerProto) GetPos() uint64 {
	if m != nil {
		return m.Pos
	}
	return 0
}

func (m *McWarBuildingServerProto) GetProsperity() uint64 {
	if m != nil {
		return m.Prosperity
	}
	return 0
}

func (m *McWarBuildingServerProto) GetLastDestroyTime() int64 {
	if m != nil {
		return m.LastDestroyTime
	}
	return 0
}

func (m *McWarBuildingServerProto) GetTroop() []*McWarTroopServerProto {
	if m != nil {
		return m.Troop
	}
	return nil
}

func (m *McWarBuildingServerProto) GetType() proto44.MingcWarBuildingType {
	if m != nil {
		return m.Type
	}
	return proto44.MingcWarBuildingType_MC_B_INVALID
}

func (m *McWarBuildingServerProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *McWarBuildingServerProto) GetTouShiTurnEndTime() int64 {
	if m != nil {
		return m.TouShiTurnEndTime
	}
	return 0
}

func (m *McWarBuildingServerProto) GetTouShiPrepareEndTime() int64 {
	if m != nil {
		return m.TouShiPrepareEndTime
	}
	return 0
}

func (m *McWarBuildingServerProto) GetTouShiTargetIndex() int32 {
	if m != nil {
		return m.TouShiTargetIndex
	}
	return 0
}

func (m *McWarBuildingServerProto) GetLastFireHeroName() string {
	if m != nil {
		return m.LastFireHeroName
	}
	return ""
}

func (m *McWarBuildingServerProto) GetLastFireHeroCountry() int32 {
	if m != nil {
		return m.LastFireHeroCountry
	}
	return 0
}

type McWarTroopServerProto struct {
	HeroId          int64                              `protobuf:"varint,15,opt,name=hero_id,json=heroId,proto3" json:"hero_id,omitempty"`
	Hero            *proto3.HeroBasicProto             `protobuf:"bytes,1,opt,name=hero" json:"hero,omitempty"`
	Gid             int64                              `protobuf:"varint,2,opt,name=gid,proto3" json:"gid,omitempty"`
	Atk             bool                               `protobuf:"varint,3,opt,name=atk,proto3" json:"atk,omitempty"`
	JoinTime        int64                              `protobuf:"varint,4,opt,name=join_time,json=joinTime,proto3" json:"join_time,omitempty"`
	KillAmount      uint64                             `protobuf:"varint,11,opt,name=kill_amount,json=killAmount,proto3" json:"kill_amount,omitempty"`
	WoundedAmount   uint64                             `protobuf:"varint,12,opt,name=wounded_amount,json=woundedAmount,proto3" json:"wounded_amount,omitempty"`
	DestroyBuilding uint64                             `protobuf:"varint,16,opt,name=destroy_building,json=destroyBuilding,proto3" json:"destroy_building,omitempty"`
	NextDrumTime    int64                              `protobuf:"varint,18,opt,name=next_drum_time,json=nextDrumTime,proto3" json:"next_drum_time,omitempty"`
	NpcDataId       uint64                             `protobuf:"varint,19,opt,name=npc_data_id,json=npcDataId,proto3" json:"npc_data_id,omitempty"`
	Captain         map[int32]*proto4.CaptainInfoProto `protobuf:"bytes,13,rep,name=captain" json:"captain,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Record          []*proto44.McWarTroopRecordProto   `protobuf:"bytes,14,rep,name=record" json:"record,omitempty"`
	Mode            proto44.MingcWarModeType           `protobuf:"varint,17,opt,name=mode,proto3,enum=proto.MingcWarModeType" json:"mode,omitempty"`
	State           proto44.MingcWarTroopState         `protobuf:"varint,5,opt,name=state,proto3,enum=proto.MingcWarTroopState" json:"state,omitempty"`
	StartTime       int64                              `protobuf:"varint,6,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime         int64                              `protobuf:"varint,7,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	Pos             uint64                             `protobuf:"varint,8,opt,name=pos,proto3" json:"pos,omitempty"`
	StartPos        uint64                             `protobuf:"varint,9,opt,name=start_pos,json=startPos,proto3" json:"start_pos,omitempty"`
	DestPos         uint64                             `protobuf:"varint,10,opt,name=dest_pos,json=destPos,proto3" json:"dest_pos,omitempty"`
}

func (m *McWarTroopServerProto) Reset()                    { *m = McWarTroopServerProto{} }
func (m *McWarTroopServerProto) String() string            { return proto.CompactTextString(m) }
func (*McWarTroopServerProto) ProtoMessage()               {}
func (*McWarTroopServerProto) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{8} }

func (m *McWarTroopServerProto) GetHeroId() int64 {
	if m != nil {
		return m.HeroId
	}
	return 0
}

func (m *McWarTroopServerProto) GetHero() *proto3.HeroBasicProto {
	if m != nil {
		return m.Hero
	}
	return nil
}

func (m *McWarTroopServerProto) GetGid() int64 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func (m *McWarTroopServerProto) GetAtk() bool {
	if m != nil {
		return m.Atk
	}
	return false
}

func (m *McWarTroopServerProto) GetJoinTime() int64 {
	if m != nil {
		return m.JoinTime
	}
	return 0
}

func (m *McWarTroopServerProto) GetKillAmount() uint64 {
	if m != nil {
		return m.KillAmount
	}
	return 0
}

func (m *McWarTroopServerProto) GetWoundedAmount() uint64 {
	if m != nil {
		return m.WoundedAmount
	}
	return 0
}

func (m *McWarTroopServerProto) GetDestroyBuilding() uint64 {
	if m != nil {
		return m.DestroyBuilding
	}
	return 0
}

func (m *McWarTroopServerProto) GetNextDrumTime() int64 {
	if m != nil {
		return m.NextDrumTime
	}
	return 0
}

func (m *McWarTroopServerProto) GetNpcDataId() uint64 {
	if m != nil {
		return m.NpcDataId
	}
	return 0
}

func (m *McWarTroopServerProto) GetCaptain() map[int32]*proto4.CaptainInfoProto {
	if m != nil {
		return m.Captain
	}
	return nil
}

func (m *McWarTroopServerProto) GetRecord() []*proto44.McWarTroopRecordProto {
	if m != nil {
		return m.Record
	}
	return nil
}

func (m *McWarTroopServerProto) GetMode() proto44.MingcWarModeType {
	if m != nil {
		return m.Mode
	}
	return proto44.MingcWarModeType_MC_MT_INVALID
}

func (m *McWarTroopServerProto) GetState() proto44.MingcWarTroopState {
	if m != nil {
		return m.State
	}
	return proto44.MingcWarTroopState_MC_TP_INVALID
}

func (m *McWarTroopServerProto) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *McWarTroopServerProto) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *McWarTroopServerProto) GetPos() uint64 {
	if m != nil {
		return m.Pos
	}
	return 0
}

func (m *McWarTroopServerProto) GetStartPos() uint64 {
	if m != nil {
		return m.StartPos
	}
	return 0
}

func (m *McWarTroopServerProto) GetDestPos() uint64 {
	if m != nil {
		return m.DestPos
	}
	return 0
}

type McWarFightRecordServerProto struct {
	GuildRecord []*McWarFightGuildRecordServerProto `protobuf:"bytes,1,rep,name=guild_record,json=guildRecord" json:"guild_record,omitempty"`
}

func (m *McWarFightRecordServerProto) Reset()         { *m = McWarFightRecordServerProto{} }
func (m *McWarFightRecordServerProto) String() string { return proto.CompactTextString(m) }
func (*McWarFightRecordServerProto) ProtoMessage()    {}
func (*McWarFightRecordServerProto) Descriptor() ([]byte, []int) {
	return fileDescriptorMingcWar, []int{9}
}

func (m *McWarFightRecordServerProto) GetGuildRecord() []*McWarFightGuildRecordServerProto {
	if m != nil {
		return m.GuildRecord
	}
	return nil
}

type McWarFightGuildRecordServerProto struct {
	Gid           int64          `protobuf:"varint,1,opt,name=gid,proto3" json:"gid,omitempty"`
	JoinedCount   uint64         `protobuf:"varint,2,opt,name=joined_count,json=joinedCount,proto3" json:"joined_count,omitempty"`
	KilledAmount  uint64         `protobuf:"varint,3,opt,name=killed_amount,json=killedAmount,proto3" json:"killed_amount,omitempty"`
	WoundedAmount uint64         `protobuf:"varint,4,opt,name=wounded_amount,json=woundedAmount,proto3" json:"wounded_amount,omitempty"`
	Destroyed     uint64         `protobuf:"varint,5,opt,name=destroyed,proto3" json:"destroyed,omitempty"`
	JoinedTroops  map[int64]bool `protobuf:"bytes,6,rep,name=joined_troops,json=joinedTroops" json:"joined_troops,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *McWarFightGuildRecordServerProto) Reset()         { *m = McWarFightGuildRecordServerProto{} }
func (m *McWarFightGuildRecordServerProto) String() string { return proto.CompactTextString(m) }
func (*McWarFightGuildRecordServerProto) ProtoMessage()    {}
func (*McWarFightGuildRecordServerProto) Descriptor() ([]byte, []int) {
	return fileDescriptorMingcWar, []int{10}
}

func (m *McWarFightGuildRecordServerProto) GetGid() int64 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func (m *McWarFightGuildRecordServerProto) GetJoinedCount() uint64 {
	if m != nil {
		return m.JoinedCount
	}
	return 0
}

func (m *McWarFightGuildRecordServerProto) GetKilledAmount() uint64 {
	if m != nil {
		return m.KilledAmount
	}
	return 0
}

func (m *McWarFightGuildRecordServerProto) GetWoundedAmount() uint64 {
	if m != nil {
		return m.WoundedAmount
	}
	return 0
}

func (m *McWarFightGuildRecordServerProto) GetDestroyed() uint64 {
	if m != nil {
		return m.Destroyed
	}
	return 0
}

func (m *McWarFightGuildRecordServerProto) GetJoinedTroops() map[int64]bool {
	if m != nil {
		return m.JoinedTroops
	}
	return nil
}

type McWarNpcTroop struct {
	AiType  McWarAiType `protobuf:"varint,1,opt,name=ai_type,json=aiType,proto3,enum=proto.McWarAiType" json:"ai_type,omitempty"`
	TroopId int64       `protobuf:"varint,2,opt,name=troop_id,json=troopId,proto3" json:"troop_id,omitempty"`
}

func (m *McWarNpcTroop) Reset()                    { *m = McWarNpcTroop{} }
func (m *McWarNpcTroop) String() string            { return proto.CompactTextString(m) }
func (*McWarNpcTroop) ProtoMessage()               {}
func (*McWarNpcTroop) Descriptor() ([]byte, []int) { return fileDescriptorMingcWar, []int{11} }

func (m *McWarNpcTroop) GetAiType() McWarAiType {
	if m != nil {
		return m.AiType
	}
	return McWarAiType_MC_AI_STATION
}

func (m *McWarNpcTroop) GetTroopId() int64 {
	if m != nil {
		return m.TroopId
	}
	return 0
}

func init() {
	proto.RegisterType((*MingcWarServerProto)(nil), "proto.MingcWarServerProto")
	proto.RegisterType((*MingcApplyAtkProto)(nil), "proto.MingcApplyAtkProto")
	proto.RegisterType((*MingcApplyAstProto)(nil), "proto.MingcApplyAstProto")
	proto.RegisterType((*MingcObjProto)(nil), "proto.MingcObjProto")
	proto.RegisterType((*MingcFightProto)(nil), "proto.MingcFightProto")
	proto.RegisterType((*MingcStageProto)(nil), "proto.MingcStageProto")
	proto.RegisterType((*McWarSceneServerProto)(nil), "proto.McWarSceneServerProto")
	proto.RegisterType((*McWarBuildingServerProto)(nil), "proto.McWarBuildingServerProto")
	proto.RegisterType((*McWarTroopServerProto)(nil), "proto.McWarTroopServerProto")
	proto.RegisterType((*McWarFightRecordServerProto)(nil), "proto.McWarFightRecordServerProto")
	proto.RegisterType((*McWarFightGuildRecordServerProto)(nil), "proto.McWarFightGuildRecordServerProto")
	proto.RegisterType((*McWarNpcTroop)(nil), "proto.McWarNpcTroop")
	proto.RegisterEnum("proto.McWarAiType", McWarAiType_name, McWarAiType_value)
}
func (m *MingcWarServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MingcWarServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.State))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.EndTime))
	}
	if m.ApplyAtk != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.ApplyAtk.Size()))
		n1, err := m.ApplyAtk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.ApplyAst != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.ApplyAst.Size()))
		n2, err := m.ApplyAst.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Fight != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Fight.Size()))
		n3, err := m.Fight.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.FightEnd != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.FightEnd.Size()))
		n4, err := m.FightEnd.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Mingc) > 0 {
		for k, _ := range m.Mingc {
			dAtA[i] = 0x42
			i++
			v := m.Mingc[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMingcWar(uint64(msgSize))
			}
			mapSize := 1 + sovMingcWar(uint64(k)) + msgSize
			i = encodeVarintMingcWar(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMingcWar(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	if m.NotStart != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.NotStart.Size()))
		n6, err := m.NotStart.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Id != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *MingcApplyAtkProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MingcApplyAtkProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.EndTime))
	}
	if len(m.Bids) > 0 {
		for k, _ := range m.Bids {
			dAtA[i] = 0x1a
			i++
			v := m.Bids[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMingcWar(uint64(msgSize))
			}
			mapSize := 1 + sovMingcWar(uint64(k)) + msgSize
			i = encodeVarintMingcWar(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMingcWar(dAtA, i, uint64(v.Size()))
				n7, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n7
			}
		}
	}
	if len(m.Applicant) > 0 {
		for k, _ := range m.Applicant {
			dAtA[i] = 0x22
			i++
			v := m.Applicant[k]
			mapSize := 1 + sovMingcWar(uint64(k)) + 1 + sovMingcWar(uint64(v))
			i = encodeVarintMingcWar(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(v))
		}
	}
	if len(m.Winners) > 0 {
		for k, _ := range m.Winners {
			dAtA[i] = 0x2a
			i++
			v := m.Winners[k]
			mapSize := 1 + sovMingcWar(uint64(k)) + 1 + sovMingcWar(uint64(v))
			i = encodeVarintMingcWar(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *MingcApplyAstProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MingcApplyAstProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.EndTime))
	}
	if len(m.Mingc) > 0 {
		for k, _ := range m.Mingc {
			dAtA[i] = 0x1a
			i++
			v := m.Mingc[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMingcWar(uint64(msgSize))
			}
			mapSize := 1 + sovMingcWar(uint64(k)) + msgSize
			i = encodeVarintMingcWar(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMingcWar(dAtA, i, uint64(v.Size()))
				n8, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n8
			}
		}
	}
	return i, nil
}

func (m *MingcObjProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MingcObjProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Id))
	}
	if m.DefId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.DefId))
	}
	if m.AtkId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.AtkId))
	}
	if len(m.AstDef) > 0 {
		dAtA10 := make([]byte, len(m.AstDef)*10)
		var j9 int
		for _, num1 := range m.AstDef {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	if len(m.AstAtk) > 0 {
		dAtA12 := make([]byte, len(m.AstAtk)*10)
		var j11 int
		for _, num1 := range m.AstAtk {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	if len(m.ApplyAst) > 0 {
		for k, _ := range m.ApplyAst {
			dAtA[i] = 0x32
			i++
			v := m.ApplyAst[k]
			mapSize := 1 + sovMingcWar(uint64(k)) + 1 + 1
			i = encodeVarintMingcWar(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if m.Bid != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Bid.Size()))
		n13, err := m.Bid.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Scene != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Scene.Size()))
		n14, err := m.Scene.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Country != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Country))
	}
	return i, nil
}

func (m *MingcFightProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MingcFightProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *MingcStageProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MingcStageProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *McWarSceneServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarSceneServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.McId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.McId))
	}
	if len(m.Building) > 0 {
		for _, msg := range m.Building {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Ended {
		dAtA[i] = 0x18
		i++
		if m.Ended {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AtkWin {
		dAtA[i] = 0x20
		i++
		if m.AtkWin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EndedNoticed {
		dAtA[i] = 0x28
		i++
		if m.EndedNoticed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Record != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Record.Size()))
		n15, err := m.Record.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Npc) > 0 {
		for _, msg := range m.Npc {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.StartTime))
	}
	if m.AtkDrumTimes != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.AtkDrumTimes))
	}
	if m.DefDrumTimes != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.DefDrumTimes))
	}
	if m.AtkDrumStat != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.AtkDrumStat.Size()))
		n16, err := m.AtkDrumStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.DefDrumStat != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.DefDrumStat.Size()))
		n17, err := m.DefDrumStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *McWarBuildingServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarBuildingServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Atk {
		dAtA[i] = 0x8
		i++
		if m.Atk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Pos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Pos))
	}
	if m.Prosperity != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Prosperity))
	}
	if m.LastDestroyTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.LastDestroyTime))
	}
	if len(m.Troop) > 0 {
		for _, msg := range m.Troop {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Type != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Type))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.TouShiTurnEndTime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.TouShiTurnEndTime))
	}
	if m.TouShiPrepareEndTime != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.TouShiPrepareEndTime))
	}
	if m.TouShiTargetIndex != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.TouShiTargetIndex))
	}
	if len(m.LastFireHeroName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(len(m.LastFireHeroName)))
		i += copy(dAtA[i:], m.LastFireHeroName)
	}
	if m.LastFireHeroCountry != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.LastFireHeroCountry))
	}
	return i, nil
}

func (m *McWarTroopServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarTroopServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hero != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Hero.Size()))
		n18, err := m.Hero.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Gid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Gid))
	}
	if m.Atk {
		dAtA[i] = 0x18
		i++
		if m.Atk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.JoinTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.JoinTime))
	}
	if m.State != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.State))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.EndTime))
	}
	if m.Pos != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Pos))
	}
	if m.StartPos != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.StartPos))
	}
	if m.DestPos != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.DestPos))
	}
	if m.KillAmount != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.KillAmount))
	}
	if m.WoundedAmount != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.WoundedAmount))
	}
	if len(m.Captain) > 0 {
		for k, _ := range m.Captain {
			dAtA[i] = 0x6a
			i++
			v := m.Captain[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMingcWar(uint64(msgSize))
			}
			mapSize := 1 + sovMingcWar(uint64(k)) + msgSize
			i = encodeVarintMingcWar(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMingcWar(dAtA, i, uint64(v.Size()))
				n19, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n19
			}
		}
	}
	if len(m.Record) > 0 {
		for _, msg := range m.Record {
			dAtA[i] = 0x72
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HeroId != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.HeroId))
	}
	if m.DestroyBuilding != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.DestroyBuilding))
	}
	if m.Mode != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Mode))
	}
	if m.NextDrumTime != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.NextDrumTime))
	}
	if m.NpcDataId != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.NpcDataId))
	}
	return i, nil
}

func (m *McWarFightRecordServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarFightRecordServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GuildRecord) > 0 {
		for _, msg := range m.GuildRecord {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *McWarFightGuildRecordServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarFightGuildRecordServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Gid))
	}
	if m.JoinedCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.JoinedCount))
	}
	if m.KilledAmount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.KilledAmount))
	}
	if m.WoundedAmount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.WoundedAmount))
	}
	if m.Destroyed != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.Destroyed))
	}
	if len(m.JoinedTroops) > 0 {
		for k, _ := range m.JoinedTroops {
			dAtA[i] = 0x32
			i++
			v := m.JoinedTroops[k]
			mapSize := 1 + sovMingcWar(uint64(k)) + 1 + 1
			i = encodeVarintMingcWar(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMingcWar(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	return i, nil
}

func (m *McWarNpcTroop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McWarNpcTroop) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AiType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.AiType))
	}
	if m.TroopId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMingcWar(dAtA, i, uint64(m.TroopId))
	}
	return i, nil
}

func encodeFixed64MingcWar(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32MingcWar(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMingcWar(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MingcWarServerProto) Size() (n int) {
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovMingcWar(uint64(m.State))
	}
	if m.StartTime != 0 {
		n += 1 + sovMingcWar(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovMingcWar(uint64(m.EndTime))
	}
	if m.ApplyAtk != nil {
		l = m.ApplyAtk.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.ApplyAst != nil {
		l = m.ApplyAst.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.Fight != nil {
		l = m.Fight.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.FightEnd != nil {
		l = m.FightEnd.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if len(m.Mingc) > 0 {
		for k, v := range m.Mingc {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMingcWar(uint64(l))
			}
			mapEntrySize := 1 + sovMingcWar(uint64(k)) + l
			n += mapEntrySize + 1 + sovMingcWar(uint64(mapEntrySize))
		}
	}
	if m.NotStart != nil {
		l = m.NotStart.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovMingcWar(uint64(m.Id))
	}
	return n
}

func (m *MingcApplyAtkProto) Size() (n int) {
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovMingcWar(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovMingcWar(uint64(m.EndTime))
	}
	if len(m.Bids) > 0 {
		for k, v := range m.Bids {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMingcWar(uint64(l))
			}
			mapEntrySize := 1 + sovMingcWar(uint64(k)) + l
			n += mapEntrySize + 1 + sovMingcWar(uint64(mapEntrySize))
		}
	}
	if len(m.Applicant) > 0 {
		for k, v := range m.Applicant {
			_ = k
			_ = v
			mapEntrySize := 1 + sovMingcWar(uint64(k)) + 1 + sovMingcWar(uint64(v))
			n += mapEntrySize + 1 + sovMingcWar(uint64(mapEntrySize))
		}
	}
	if len(m.Winners) > 0 {
		for k, v := range m.Winners {
			_ = k
			_ = v
			mapEntrySize := 1 + sovMingcWar(uint64(k)) + 1 + sovMingcWar(uint64(v))
			n += mapEntrySize + 1 + sovMingcWar(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MingcApplyAstProto) Size() (n int) {
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovMingcWar(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovMingcWar(uint64(m.EndTime))
	}
	if len(m.Mingc) > 0 {
		for k, v := range m.Mingc {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMingcWar(uint64(l))
			}
			mapEntrySize := 1 + sovMingcWar(uint64(k)) + l
			n += mapEntrySize + 1 + sovMingcWar(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MingcObjProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMingcWar(uint64(m.Id))
	}
	if m.DefId != 0 {
		n += 1 + sovMingcWar(uint64(m.DefId))
	}
	if m.AtkId != 0 {
		n += 1 + sovMingcWar(uint64(m.AtkId))
	}
	if len(m.AstDef) > 0 {
		l = 0
		for _, e := range m.AstDef {
			l += sovMingcWar(uint64(e))
		}
		n += 1 + sovMingcWar(uint64(l)) + l
	}
	if len(m.AstAtk) > 0 {
		l = 0
		for _, e := range m.AstAtk {
			l += sovMingcWar(uint64(e))
		}
		n += 1 + sovMingcWar(uint64(l)) + l
	}
	if len(m.ApplyAst) > 0 {
		for k, v := range m.ApplyAst {
			_ = k
			_ = v
			mapEntrySize := 1 + sovMingcWar(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovMingcWar(uint64(mapEntrySize))
		}
	}
	if m.Bid != nil {
		l = m.Bid.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.Scene != nil {
		l = m.Scene.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.Country != 0 {
		n += 1 + sovMingcWar(uint64(m.Country))
	}
	return n
}

func (m *MingcFightProto) Size() (n int) {
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovMingcWar(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovMingcWar(uint64(m.EndTime))
	}
	return n
}

func (m *MingcStageProto) Size() (n int) {
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovMingcWar(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovMingcWar(uint64(m.EndTime))
	}
	return n
}

func (m *McWarSceneServerProto) Size() (n int) {
	var l int
	_ = l
	if m.McId != 0 {
		n += 1 + sovMingcWar(uint64(m.McId))
	}
	if len(m.Building) > 0 {
		for _, e := range m.Building {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	if m.Ended {
		n += 2
	}
	if m.AtkWin {
		n += 2
	}
	if m.EndedNoticed {
		n += 2
	}
	if m.Record != nil {
		l = m.Record.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if len(m.Npc) > 0 {
		for _, e := range m.Npc {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	if m.StartTime != 0 {
		n += 1 + sovMingcWar(uint64(m.StartTime))
	}
	if m.AtkDrumTimes != 0 {
		n += 1 + sovMingcWar(uint64(m.AtkDrumTimes))
	}
	if m.DefDrumTimes != 0 {
		n += 1 + sovMingcWar(uint64(m.DefDrumTimes))
	}
	if m.AtkDrumStat != nil {
		l = m.AtkDrumStat.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.DefDrumStat != nil {
		l = m.DefDrumStat.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	return n
}

func (m *McWarBuildingServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Atk {
		n += 2
	}
	if m.Pos != 0 {
		n += 1 + sovMingcWar(uint64(m.Pos))
	}
	if m.Prosperity != 0 {
		n += 1 + sovMingcWar(uint64(m.Prosperity))
	}
	if m.LastDestroyTime != 0 {
		n += 1 + sovMingcWar(uint64(m.LastDestroyTime))
	}
	if len(m.Troop) > 0 {
		for _, e := range m.Troop {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	if m.Type != 0 {
		n += 1 + sovMingcWar(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.TouShiTurnEndTime != 0 {
		n += 1 + sovMingcWar(uint64(m.TouShiTurnEndTime))
	}
	if m.TouShiPrepareEndTime != 0 {
		n += 1 + sovMingcWar(uint64(m.TouShiPrepareEndTime))
	}
	if m.TouShiTargetIndex != 0 {
		n += 1 + sovMingcWar(uint64(m.TouShiTargetIndex))
	}
	l = len(m.LastFireHeroName)
	if l > 0 {
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.LastFireHeroCountry != 0 {
		n += 1 + sovMingcWar(uint64(m.LastFireHeroCountry))
	}
	return n
}

func (m *McWarTroopServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Hero != nil {
		l = m.Hero.Size()
		n += 1 + l + sovMingcWar(uint64(l))
	}
	if m.Gid != 0 {
		n += 1 + sovMingcWar(uint64(m.Gid))
	}
	if m.Atk {
		n += 2
	}
	if m.JoinTime != 0 {
		n += 1 + sovMingcWar(uint64(m.JoinTime))
	}
	if m.State != 0 {
		n += 1 + sovMingcWar(uint64(m.State))
	}
	if m.StartTime != 0 {
		n += 1 + sovMingcWar(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovMingcWar(uint64(m.EndTime))
	}
	if m.Pos != 0 {
		n += 1 + sovMingcWar(uint64(m.Pos))
	}
	if m.StartPos != 0 {
		n += 1 + sovMingcWar(uint64(m.StartPos))
	}
	if m.DestPos != 0 {
		n += 1 + sovMingcWar(uint64(m.DestPos))
	}
	if m.KillAmount != 0 {
		n += 1 + sovMingcWar(uint64(m.KillAmount))
	}
	if m.WoundedAmount != 0 {
		n += 1 + sovMingcWar(uint64(m.WoundedAmount))
	}
	if len(m.Captain) > 0 {
		for k, v := range m.Captain {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMingcWar(uint64(l))
			}
			mapEntrySize := 1 + sovMingcWar(uint64(k)) + l
			n += mapEntrySize + 1 + sovMingcWar(uint64(mapEntrySize))
		}
	}
	if len(m.Record) > 0 {
		for _, e := range m.Record {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	if m.HeroId != 0 {
		n += 1 + sovMingcWar(uint64(m.HeroId))
	}
	if m.DestroyBuilding != 0 {
		n += 2 + sovMingcWar(uint64(m.DestroyBuilding))
	}
	if m.Mode != 0 {
		n += 2 + sovMingcWar(uint64(m.Mode))
	}
	if m.NextDrumTime != 0 {
		n += 2 + sovMingcWar(uint64(m.NextDrumTime))
	}
	if m.NpcDataId != 0 {
		n += 2 + sovMingcWar(uint64(m.NpcDataId))
	}
	return n
}

func (m *McWarFightRecordServerProto) Size() (n int) {
	var l int
	_ = l
	if len(m.GuildRecord) > 0 {
		for _, e := range m.GuildRecord {
			l = e.Size()
			n += 1 + l + sovMingcWar(uint64(l))
		}
	}
	return n
}

func (m *McWarFightGuildRecordServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Gid != 0 {
		n += 1 + sovMingcWar(uint64(m.Gid))
	}
	if m.JoinedCount != 0 {
		n += 1 + sovMingcWar(uint64(m.JoinedCount))
	}
	if m.KilledAmount != 0 {
		n += 1 + sovMingcWar(uint64(m.KilledAmount))
	}
	if m.WoundedAmount != 0 {
		n += 1 + sovMingcWar(uint64(m.WoundedAmount))
	}
	if m.Destroyed != 0 {
		n += 1 + sovMingcWar(uint64(m.Destroyed))
	}
	if len(m.JoinedTroops) > 0 {
		for k, v := range m.JoinedTroops {
			_ = k
			_ = v
			mapEntrySize := 1 + sovMingcWar(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovMingcWar(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *McWarNpcTroop) Size() (n int) {
	var l int
	_ = l
	if m.AiType != 0 {
		n += 1 + sovMingcWar(uint64(m.AiType))
	}
	if m.TroopId != 0 {
		n += 1 + sovMingcWar(uint64(m.TroopId))
	}
	return n
}

func sovMingcWar(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMingcWar(x uint64) (n int) {
	return sovMingcWar(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MingcWarServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MingcWarServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MingcWarServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (proto44.MingcWarState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyAtk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyAtk == nil {
				m.ApplyAtk = &MingcApplyAtkProto{}
			}
			if err := m.ApplyAtk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyAst", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplyAst == nil {
				m.ApplyAst = &MingcApplyAstProto{}
			}
			if err := m.ApplyAst.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fight == nil {
				m.Fight = &MingcFightProto{}
			}
			if err := m.Fight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FightEnd == nil {
				m.FightEnd = &MingcStageProto{}
			}
			if err := m.FightEnd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mingc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Mingc == nil {
				m.Mingc = make(map[uint64]*MingcObjProto)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthMingcWar
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthMingcWar
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &MingcObjProto{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Mingc[mapkey] = mapvalue
			} else {
				var mapvalue *MingcObjProto
				m.Mingc[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotStart == nil {
				m.NotStart = &MingcStageProto{}
			}
			if err := m.NotStart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MingcApplyAtkProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MingcApplyAtkProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MingcApplyAtkProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Bids == nil {
				m.Bids = make(map[uint64]*BidInfoProto)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthMingcWar
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthMingcWar
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &BidInfoProto{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Bids[mapkey] = mapvalue
			} else {
				var mapvalue *BidInfoProto
				m.Bids[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applicant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Applicant == nil {
				m.Applicant = make(map[int64]uint64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Applicant[mapkey] = mapvalue
			} else {
				var mapvalue uint64
				m.Applicant[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Winners", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Winners == nil {
				m.Winners = make(map[uint64]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Winners[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.Winners[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MingcApplyAstProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MingcApplyAstProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MingcApplyAstProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mingc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Mingc == nil {
				m.Mingc = make(map[uint64]*MingcObjProto)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthMingcWar
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthMingcWar
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &MingcObjProto{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Mingc[mapkey] = mapvalue
			} else {
				var mapvalue *MingcObjProto
				m.Mingc[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MingcObjProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MingcObjProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MingcObjProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefId", wireType)
			}
			m.DefId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkId", wireType)
			}
			m.AtkId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AtkId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AstDef = append(m.AstDef, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMingcWar
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMingcWar
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AstDef = append(m.AstDef, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AstDef", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AstAtk = append(m.AstAtk, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMingcWar
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMingcWar
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AstAtk = append(m.AstAtk, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AstAtk", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyAst", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.ApplyAst == nil {
				m.ApplyAst = make(map[int64]bool)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvaluetemp int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvaluetemp |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				mapvalue := bool(mapvaluetemp != 0)
				m.ApplyAst[mapkey] = mapvalue
			} else {
				var mapvalue bool
				m.ApplyAst[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bid == nil {
				m.Bid = &BidInfoProto{}
			}
			if err := m.Bid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scene", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scene == nil {
				m.Scene = &McWarSceneServerProto{}
			}
			if err := m.Scene.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			m.Country = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Country |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MingcFightProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MingcFightProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MingcFightProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MingcStageProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MingcStageProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MingcStageProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarSceneServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarSceneServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarSceneServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field McId", wireType)
			}
			m.McId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.McId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Building", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Building = append(m.Building, &McWarBuildingServerProto{})
			if err := m.Building[len(m.Building)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ended", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ended = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkWin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AtkWin = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndedNoticed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EndedNoticed = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Record", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Record == nil {
				m.Record = &McWarFightRecordServerProto{}
			}
			if err := m.Record.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Npc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Npc = append(m.Npc, &McWarNpcTroop{})
			if err := m.Npc[len(m.Npc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkDrumTimes", wireType)
			}
			m.AtkDrumTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AtkDrumTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefDrumTimes", wireType)
			}
			m.DefDrumTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefDrumTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkDrumStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AtkDrumStat == nil {
				m.AtkDrumStat = &proto1.SpriteStatProto{}
			}
			if err := m.AtkDrumStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefDrumStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefDrumStat == nil {
				m.DefDrumStat = &proto1.SpriteStatProto{}
			}
			if err := m.DefDrumStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarBuildingServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarBuildingServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarBuildingServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Atk = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prosperity", wireType)
			}
			m.Prosperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prosperity |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastDestroyTime", wireType)
			}
			m.LastDestroyTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastDestroyTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Troop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Troop = append(m.Troop, &McWarTroopServerProto{})
			if err := m.Troop[len(m.Troop)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (proto44.MingcWarBuildingType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TouShiTurnEndTime", wireType)
			}
			m.TouShiTurnEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TouShiTurnEndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TouShiPrepareEndTime", wireType)
			}
			m.TouShiPrepareEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TouShiPrepareEndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TouShiTargetIndex", wireType)
			}
			m.TouShiTargetIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TouShiTargetIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastFireHeroName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastFireHeroName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastFireHeroCountry", wireType)
			}
			m.LastFireHeroCountry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastFireHeroCountry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarTroopServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarTroopServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarTroopServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hero", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hero == nil {
				m.Hero = &proto3.HeroBasicProto{}
			}
			if err := m.Hero.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Atk = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinTime", wireType)
			}
			m.JoinTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (proto44.MingcWarTroopState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPos", wireType)
			}
			m.StartPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestPos", wireType)
			}
			m.DestPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestPos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillAmount", wireType)
			}
			m.KillAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillAmount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WoundedAmount", wireType)
			}
			m.WoundedAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WoundedAmount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Captain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Captain == nil {
				m.Captain = make(map[int32]*proto4.CaptainInfoProto)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthMingcWar
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthMingcWar
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &proto4.CaptainInfoProto{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Captain[mapkey] = mapvalue
			} else {
				var mapvalue *proto4.CaptainInfoProto
				m.Captain[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Record", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Record = append(m.Record, &proto44.McWarTroopRecordProto{})
			if err := m.Record[len(m.Record)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroId", wireType)
			}
			m.HeroId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestroyBuilding", wireType)
			}
			m.DestroyBuilding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestroyBuilding |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (proto44.MingcWarModeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextDrumTime", wireType)
			}
			m.NextDrumTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextDrumTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NpcDataId", wireType)
			}
			m.NpcDataId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NpcDataId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarFightRecordServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarFightRecordServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarFightRecordServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildRecord = append(m.GuildRecord, &McWarFightGuildRecordServerProto{})
			if err := m.GuildRecord[len(m.GuildRecord)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarFightGuildRecordServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarFightGuildRecordServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarFightGuildRecordServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinedCount", wireType)
			}
			m.JoinedCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinedCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KilledAmount", wireType)
			}
			m.KilledAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KilledAmount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WoundedAmount", wireType)
			}
			m.WoundedAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WoundedAmount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destroyed", wireType)
			}
			m.Destroyed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Destroyed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinedTroops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMingcWar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.JoinedTroops == nil {
				m.JoinedTroops = make(map[int64]bool)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvaluetemp int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvaluetemp |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				mapvalue := bool(mapvaluetemp != 0)
				m.JoinedTroops[mapkey] = mapvalue
			} else {
				var mapvalue bool
				m.JoinedTroops[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McWarNpcTroop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McWarNpcTroop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McWarNpcTroop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AiType", wireType)
			}
			m.AiType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AiType |= (McWarAiType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TroopId", wireType)
			}
			m.TroopId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TroopId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMingcWar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMingcWar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMingcWar(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMingcWar
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMingcWar
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMingcWar
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMingcWar
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMingcWar(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMingcWar = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMingcWar   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/server_proto/mingc_war.proto", fileDescriptorMingcWar)
}

var fileDescriptorMingcWar = []byte{
	// 1711 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xdd, 0x6e, 0x1b, 0xc7,
	0x15, 0xce, 0x92, 0xcb, 0xbf, 0xc3, 0x1f, 0x53, 0x23, 0x39, 0x5e, 0xd3, 0xa9, 0x22, 0x28, 0x71,
	0x2a, 0x3b, 0x8d, 0x54, 0xc8, 0x41, 0x13, 0x2b, 0x05, 0x52, 0x4a, 0x96, 0x63, 0x26, 0xb1, 0x6c,
	0xac, 0x08, 0x18, 0xe8, 0x45, 0x17, 0x43, 0xce, 0x90, 0x9a, 0x90, 0xdc, 0x5d, 0xec, 0x0e, 0xa3,
	0xf0, 0xb6, 0x28, 0xd0, 0x57, 0xe8, 0x65, 0x1f, 0xa7, 0x97, 0xbd, 0x6d, 0xaf, 0x0a, 0x17, 0xe8,
	0x03, 0xf4, 0x09, 0x8a, 0x39, 0x33, 0xcb, 0xdd, 0xa5, 0x44, 0xc5, 0xa9, 0x73, 0xc5, 0xdd, 0x73,
	0xce, 0x77, 0xe6, 0xec, 0x77, 0xfe, 0x46, 0x82, 0xc7, 0x63, 0x21, 0x2f, 0xe6, 0x83, 0xfd, 0x61,
	0x30, 0x3b, 0x98, 0x8a, 0xf1, 0x85, 0x0c, 0xe9, 0xe5, 0xc1, 0x8c, 0x4e, 0xf9, 0x67, 0x07, 0xe1,
	0xe0, 0x20, 0xe6, 0xd1, 0xf7, 0x3c, 0xf2, 0xc2, 0x28, 0x90, 0xc1, 0xc1, 0x4c, 0xf8, 0xe3, 0xa1,
	0x77, 0x49, 0xa3, 0x7d, 0x7c, 0x27, 0x25, 0xfc, 0xe9, 0x7c, 0x7a, 0xb3, 0x87, 0x0b, 0x1a, 0x71,
	0x66, 0x3c, 0x0c, 0x68, 0xcc, 0x35, 0xb8, 0xf3, 0xf8, 0xcd, 0x51, 0x2b, 0xe7, 0x76, 0x1e, 0xbd,
	0x79, 0xc8, 0x03, 0xc1, 0x0c, 0xe8, 0xf3, 0x37, 0x3f, 0x2f, 0xf6, 0x69, 0x18, 0x5f, 0x04, 0xf2,
	0xa7, 0x23, 0x67, 0x62, 0x2a, 0x24, 0x8d, 0x16, 0x1a, 0xb9, 0xfb, 0x57, 0x1b, 0x36, 0x9f, 0xab,
	0xe0, 0x5f, 0xd1, 0xe8, 0x1c, 0xc3, 0x7a, 0x89, 0xc4, 0x3d, 0x84, 0x52, 0x2c, 0xa9, 0xe4, 0x8e,
	0xb5, 0x63, 0xed, 0xb5, 0x0e, 0xb7, 0xb4, 0xf9, 0xfe, 0xd2, 0x54, 0xe9, 0x5c, 0x6d, 0x42, 0x7e,
	0x01, 0x10, 0x4b, 0x1a, 0x49, 0x4f, 0x8a, 0x19, 0x77, 0x0a, 0x3b, 0xd6, 0x5e, 0xd1, 0xad, 0xa1,
	0xa4, 0x2f, 0x66, 0x9c, 0xdc, 0x85, 0x2a, 0xf7, 0x99, 0x56, 0x16, 0x51, 0x59, 0xe1, 0x3e, 0x43,
	0xd5, 0x6f, 0xa0, 0x46, 0xc3, 0x70, 0xba, 0xf0, 0xa8, 0x9c, 0x38, 0xf6, 0x8e, 0xb5, 0x57, 0x3f,
	0xbc, 0x9b, 0x3d, 0xa9, 0xab, 0x94, 0x5d, 0x39, 0xc1, 0x98, 0xdc, 0x2a, 0x35, 0xaf, 0x19, 0x5c,
	0x2c, 0x9d, 0xd2, 0x3a, 0x5c, 0x2c, 0x73, 0xb8, 0x58, 0x92, 0x5f, 0x41, 0x69, 0xa4, 0xe8, 0x71,
	0xca, 0x88, 0x79, 0x37, 0x8b, 0x79, 0xaa, 0x14, 0x1a, 0xa0, 0x8d, 0xc8, 0x23, 0xa8, 0xe1, 0x83,
	0xc7, 0x7d, 0xe6, 0x54, 0xae, 0x22, 0xce, 0x25, 0x1d, 0x73, 0x73, 0x04, 0x1a, 0x9e, 0xfa, 0x8c,
	0x7c, 0x01, 0x25, 0x2c, 0x06, 0xa7, 0xba, 0x53, 0xdc, 0xab, 0x1f, 0xde, 0x5f, 0x25, 0x2e, 0xe5,
	0x58, 0xcb, 0x4e, 0x7d, 0x19, 0x2d, 0x5c, 0x8d, 0x51, 0x27, 0xfa, 0x81, 0xf4, 0x90, 0x3b, 0xa7,
	0x76, 0xf3, 0x89, 0x7e, 0x20, 0xcf, 0x95, 0x1d, 0x69, 0x41, 0x41, 0x30, 0x07, 0x76, 0xac, 0xbd,
	0x92, 0x5b, 0x10, 0xac, 0x73, 0x06, 0x90, 0x7a, 0x26, 0x6d, 0x28, 0x4e, 0xf8, 0x02, 0xd3, 0x68,
	0xbb, 0xea, 0x51, 0xa5, 0xf6, 0x7b, 0x3a, 0x9d, 0xeb, 0x4c, 0xd5, 0xf3, 0xa9, 0x7d, 0x31, 0xf8,
	0xce, 0x50, 0x80, 0x26, 0x47, 0x85, 0xcf, 0xad, 0xdd, 0x7f, 0x14, 0x81, 0x5c, 0xcd, 0xc6, 0x4a,
	0xd6, 0xad, 0x9b, 0xb2, 0x5e, 0xc8, 0x67, 0xfd, 0x33, 0xb0, 0x07, 0x82, 0xc5, 0x4e, 0x11, 0x19,
	0xfa, 0x60, 0x6d, 0xc2, 0xf7, 0x8f, 0x05, 0x8b, 0x35, 0x3f, 0x08, 0x20, 0x4f, 0x75, 0xda, 0xc5,
	0x90, 0xfa, 0xd2, 0xb1, 0x11, 0xbd, 0xb7, 0x1e, 0xdd, 0x4d, 0x4c, 0xb5, 0x8b, 0x14, 0x4a, 0x7e,
	0x07, 0x95, 0x4b, 0xe1, 0xfb, 0x3c, 0x8a, 0x9d, 0x12, 0x7a, 0xf9, 0x68, 0xbd, 0x97, 0x57, 0xda,
	0x50, 0xfb, 0x48, 0x60, 0x9d, 0x6f, 0xa1, 0xb6, 0x0c, 0xee, 0x1a, 0x8a, 0x1f, 0xe4, 0x29, 0xde,
	0x34, 0xee, 0x8f, 0x05, 0xeb, 0xf9, 0xa3, 0x60, 0x95, 0xe1, 0xce, 0x6f, 0xa1, 0x95, 0x0f, 0x36,
	0xeb, 0xb2, 0xa8, 0x5d, 0x6e, 0x65, 0x5d, 0xda, 0x59, 0xf4, 0x11, 0x34, 0xb2, 0x41, 0x5e, 0x13,
	0x4e, 0x0e, 0x5b, 0xcc, 0xe6, 0xf6, 0x9f, 0x56, 0x2e, 0xb7, 0xa6, 0x63, 0xde, 0x22, 0xb7, 0x47,
	0x49, 0xf9, 0xeb, 0xe4, 0x7e, 0xb8, 0xb6, 0x2b, 0xaf, 0x56, 0xff, 0xcf, 0x5e, 0xb8, 0xff, 0x2d,
	0x40, 0x33, 0xa7, 0x34, 0xad, 0xa2, 0x5d, 0x16, 0x04, 0x23, 0xb7, 0xa1, 0xcc, 0xf8, 0xc8, 0x13,
	0x2c, 0x61, 0x86, 0xf1, 0x51, 0x0f, 0xc5, 0x54, 0x4e, 0x94, 0x58, 0xcf, 0xab, 0x12, 0x95, 0x93,
	0x1e, 0x23, 0x77, 0xa0, 0x42, 0x63, 0xe9, 0x31, 0x3e, 0xc2, 0xe2, 0x2b, 0xba, 0x65, 0x1a, 0xcb,
	0x27, 0x7c, 0x94, 0x28, 0xd4, 0x10, 0x2b, 0x2d, 0x15, 0x6a, 0x4e, 0x7d, 0x99, 0x9d, 0x53, 0x65,
	0x64, 0x64, 0xf7, 0xba, 0xa8, 0xf7, 0x13, 0x6a, 0x34, 0x1f, 0xe9, 0xc0, 0xba, 0x0f, 0xc5, 0x81,
	0x60, 0x4e, 0x75, 0x7d, 0x19, 0x29, 0x3d, 0x39, 0x84, 0x52, 0x3c, 0xe4, 0x3e, 0x37, 0x33, 0xe3,
	0xbd, 0xe4, 0x0c, 0x9c, 0x38, 0x4a, 0x91, 0x19, 0x3b, 0xae, 0x36, 0x25, 0x0e, 0x54, 0x86, 0xc1,
	0x5c, 0x9d, 0x87, 0xb3, 0xc3, 0x76, 0x93, 0xd7, 0xce, 0x17, 0xd0, 0xcc, 0xc5, 0xf3, 0x63, 0xd5,
	0x58, 0xcd, 0x92, 0xfe, 0x0d, 0xdc, 0x5a, 0x19, 0xa7, 0xff, 0x7f, 0x35, 0x2d, 0x9d, 0xa5, 0x73,
	0xef, 0x2d, 0x9c, 0xfd, 0xc9, 0x86, 0xdb, 0xd7, 0x32, 0x42, 0x36, 0xa1, 0x34, 0x1b, 0x7a, 0xcb,
	0xca, 0xb0, 0x67, 0xc3, 0x9e, 0x1a, 0xe4, 0xd5, 0xc1, 0x5c, 0x4c, 0x99, 0xf0, 0xc7, 0x4e, 0x01,
	0x53, 0xf7, 0x7e, 0x96, 0xd6, 0x63, 0xa3, 0xcb, 0x32, 0xbb, 0x04, 0x28, 0x7e, 0xb8, 0xcf, 0xb8,
	0x2e, 0xa0, 0xaa, 0xab, 0x5f, 0xb0, 0x4e, 0xe4, 0xc4, 0xbb, 0x14, 0x3e, 0x2e, 0xbb, 0xaa, 0xab,
	0xca, 0xec, 0x95, 0xf0, 0xc9, 0x07, 0xd0, 0x44, 0x0b, 0xcf, 0x0f, 0xa4, 0x18, 0x72, 0x86, 0x3b,
	0xad, 0xea, 0x36, 0x50, 0x78, 0xa6, 0x65, 0xe4, 0x08, 0xca, 0x11, 0x1f, 0x06, 0x11, 0x33, 0xdb,
	0x6b, 0x37, 0x1b, 0x0e, 0xd2, 0xed, 0xa2, 0x3a, 0x1b, 0x91, 0x41, 0x90, 0x8f, 0xa0, 0xe8, 0x87,
	0x43, 0xa7, 0x82, 0xdf, 0xb1, 0x95, 0x05, 0x9e, 0x85, 0xc3, 0x7e, 0x14, 0x04, 0xa1, 0xab, 0x0c,
	0x56, 0xd8, 0xad, 0xae, 0xb2, 0xfb, 0x21, 0xb4, 0xd4, 0x07, 0xb0, 0x68, 0x3e, 0x43, 0x8b, 0x18,
	0x0b, 0xce, 0x76, 0x1b, 0x54, 0x4e, 0x9e, 0x44, 0xf3, 0x99, 0x32, 0x8a, 0x95, 0x95, 0xea, 0xaa,
	0x8c, 0x95, 0x2e, 0xb0, 0x06, 0xe3, 0xa3, 0xd4, 0xea, 0x08, 0x9a, 0x4b, 0x5f, 0xea, 0x1e, 0xe1,
	0xd4, 0x73, 0xfb, 0xee, 0x3c, 0x8c, 0x84, 0xe4, 0xea, 0x9e, 0xa1, 0xbf, 0xa4, 0x6e, 0x8e, 0x50,
	0x12, 0x85, 0x5d, 0x9e, 0x80, 0xd8, 0xc6, 0xcd, 0x58, 0x73, 0xb0, 0x92, 0xec, 0xfe, 0xd1, 0x06,
	0x67, 0x5d, 0x06, 0x55, 0xa5, 0xab, 0x2e, 0xb6, 0x90, 0x7e, 0xf5, 0xa8, 0x24, 0x61, 0x10, 0x9b,
	0xa9, 0xab, 0x1e, 0xc9, 0x36, 0x40, 0x18, 0x05, 0x71, 0xc8, 0x23, 0x21, 0x17, 0x98, 0x60, 0xdb,
	0xcd, 0x48, 0xc8, 0x43, 0xd8, 0x98, 0xea, 0x39, 0x11, 0xcb, 0x28, 0x58, 0x68, 0x2a, 0x6d, 0xa4,
	0xf2, 0xd6, 0x14, 0x27, 0x06, 0xca, 0x91, 0xd0, 0x43, 0x28, 0x49, 0xc5, 0xbe, 0xd9, 0x43, 0xb9,
	0xc6, 0xc5, 0xb4, 0xe4, 0x1a, 0x17, 0x4d, 0xc9, 0x01, 0xd8, 0x72, 0x11, 0x72, 0xac, 0x82, 0xd6,
	0xe1, 0xbd, 0x95, 0x0b, 0x46, 0xf2, 0x55, 0xfd, 0x45, 0xc8, 0x5d, 0x34, 0x24, 0x04, 0x6c, 0x9f,
	0xce, 0x38, 0x5e, 0x61, 0x6a, 0x2e, 0x3e, 0x93, 0x5f, 0xc3, 0x6d, 0x19, 0xcc, 0xbd, 0xf8, 0x42,
	0x78, 0x72, 0x1e, 0xf9, 0xde, 0xb2, 0x69, 0x00, 0x03, 0xdd, 0x90, 0xc1, 0xfc, 0xfc, 0x42, 0xf4,
	0xe7, 0x91, 0x7f, 0xba, 0xbc, 0xab, 0x39, 0x09, 0x22, 0x8c, 0x78, 0x48, 0x23, 0x9e, 0x82, 0xea,
	0x08, 0xda, 0xd2, 0xa0, 0x97, 0x5a, 0x9b, 0xe0, 0x0e, 0x60, 0x6b, 0x79, 0x12, 0x8d, 0xc6, 0x5c,
	0x7a, 0xc2, 0x67, 0xfc, 0x07, 0x4c, 0x59, 0x69, 0x79, 0x10, 0x6a, 0x7a, 0x4a, 0x41, 0x3e, 0x81,
	0x4d, 0xe4, 0x6f, 0x24, 0x22, 0xee, 0x5d, 0xf0, 0x28, 0xf0, 0x30, 0xfa, 0x26, 0x46, 0xdf, 0x56,
	0xaa, 0xa7, 0x22, 0xe2, 0xcf, 0x78, 0x14, 0x9c, 0xa9, 0x2f, 0x79, 0x04, 0xef, 0xae, 0x98, 0x27,
	0x63, 0xad, 0x85, 0x27, 0x6c, 0x66, 0x11, 0x27, 0x5a, 0xb5, 0xfb, 0xe7, 0xb2, 0x99, 0x05, 0xab,
	0x24, 0x93, 0x07, 0x60, 0x2b, 0x27, 0x58, 0x02, 0xf5, 0xc3, 0xdb, 0x86, 0x5d, 0x85, 0x3d, 0xa6,
	0xb1, 0x18, 0xea, 0x4c, 0xa0, 0x89, 0x2a, 0x8d, 0xf1, 0x72, 0x75, 0xa8, 0xc7, 0xa4, 0x7c, 0x8a,
	0x69, 0xf9, 0xdc, 0x83, 0xda, 0x77, 0x81, 0xf0, 0xb3, 0x45, 0x50, 0x55, 0x02, 0x43, 0x8d, 0xb9,
	0x64, 0x97, 0x30, 0x95, 0x77, 0x57, 0x52, 0xa9, 0x63, 0x5b, 0x7f, 0xd3, 0x2e, 0xdf, 0x34, 0xfc,
	0x2a, 0xf9, 0xbd, 0x6c, 0xca, 0xb8, 0x9a, 0x96, 0xf1, 0x3d, 0xd0, 0x48, 0x4f, 0xc9, 0x75, 0x1b,
	0x57, 0x51, 0xf0, 0x32, 0x88, 0x95, 0x27, 0x55, 0xbe, 0xa8, 0x33, 0xdb, 0x41, 0xbd, 0x2b, 0xd5,
	0xfb, 0x50, 0x9f, 0x88, 0xe9, 0xd4, 0xa3, 0x33, 0xc5, 0x25, 0xa6, 0xde, 0x76, 0x41, 0x89, 0xba,
	0x28, 0x21, 0xf7, 0xa1, 0x75, 0x19, 0xcc, 0x71, 0x9c, 0x19, 0x9b, 0x06, 0xda, 0x34, 0x8d, 0xd4,
	0x98, 0x9d, 0x40, 0x65, 0x48, 0x43, 0x49, 0x85, 0xef, 0x34, 0xb1, 0xf8, 0x1f, 0xdc, 0x54, 0xfc,
	0xfb, 0x27, 0xda, 0xd6, 0xdc, 0xc3, 0x0c, 0x92, 0x7c, 0xba, 0x9c, 0x89, 0xad, 0x35, 0x0d, 0xa4,
	0x67, 0x62, 0x7e, 0x1a, 0xde, 0x81, 0x0a, 0x16, 0x8a, 0x60, 0xce, 0x2d, 0xa4, 0xa9, 0xac, 0x5e,
	0x7b, 0x8c, 0x3c, 0x80, 0x76, 0xd2, 0xb5, 0xcb, 0xd9, 0xdf, 0xc6, 0xe0, 0x6f, 0x19, 0x79, 0xd2,
	0x5e, 0xe4, 0x63, 0xb0, 0x67, 0x01, 0xe3, 0xce, 0x06, 0xa6, 0xee, 0xce, 0x4a, 0xea, 0x9e, 0x07,
	0x8c, 0xeb, 0x0e, 0x54, 0x46, 0x6a, 0x22, 0xfa, 0xfc, 0x07, 0x99, 0x8e, 0x44, 0x87, 0xe0, 0xb9,
	0x0d, 0x25, 0x4d, 0x46, 0x22, 0xd9, 0x86, 0xba, 0x1f, 0x0e, 0x3d, 0x46, 0x25, 0x55, 0xa1, 0x6d,
	0xe2, 0xc1, 0x35, 0x3f, 0x1c, 0x3e, 0xa1, 0x92, 0xf6, 0x58, 0xe7, 0x1c, 0x1a, 0x59, 0x16, 0xb2,
	0x6b, 0xb9, 0xa4, 0xd7, 0xf2, 0x27, 0xf9, 0x1b, 0x52, 0x12, 0x95, 0x41, 0x5d, 0x77, 0xf7, 0xdc,
	0x15, 0x70, 0xef, 0x86, 0x05, 0x42, 0xbe, 0x86, 0xc6, 0x58, 0x7d, 0xb2, 0x67, 0x68, 0xb6, 0x90,
	0xe6, 0x5f, 0x5e, 0x59, 0x3d, 0x5f, 0x29, 0xa3, 0xab, 0xfb, 0xa7, 0x3e, 0x4e, 0xe5, 0xbb, 0xff,
	0x29, 0xc0, 0xce, 0x8f, 0x21, 0x92, 0xa6, 0xb2, 0xd2, 0xa6, 0xba, 0x0f, 0x0d, 0xd5, 0x31, 0x9c,
	0xe9, 0xc6, 0xd6, 0xa3, 0xf8, 0xb8, 0xe0, 0x58, 0x6e, 0x5d, 0xcb, 0xb1, 0xa9, 0xd5, 0x0e, 0x55,
	0x45, 0x98, 0x56, 0x9d, 0x9e, 0xcc, 0x0d, 0x2d, 0x5c, 0x5b, 0x9b, 0xf6, 0x75, 0xb5, 0xf9, 0x1e,
	0xd4, 0x4c, 0xbe, 0xcd, 0x2e, 0xb6, 0xdd, 0x54, 0x40, 0xfe, 0x00, 0x4d, 0x13, 0x10, 0x0e, 0xe4,
	0xd8, 0xdc, 0xec, 0x1e, 0xbf, 0x21, 0x29, 0xfb, 0x5f, 0x23, 0x18, 0xab, 0xd3, 0xfc, 0x5d, 0x61,
	0x3e, 0x50, 0x8b, 0x3a, 0x5f, 0xc2, 0xc6, 0x15, 0x93, 0x9f, 0x74, 0x07, 0x7b, 0x05, 0xcd, 0xdc,
	0x6e, 0x27, 0x1f, 0x43, 0x85, 0x0a, 0x0f, 0xb7, 0x86, 0xfe, 0x7b, 0x9e, 0x64, 0x63, 0xed, 0x0a,
	0x2c, 0xd5, 0x32, 0xc5, 0x5f, 0xd5, 0xfb, 0xf8, 0x5d, 0xe9, 0xb5, 0xb8, 0x82, 0xef, 0x3d, 0xf6,
	0x70, 0x06, 0xf5, 0x0c, 0x82, 0x6c, 0x40, 0xf3, 0xf9, 0x89, 0xd7, 0xed, 0x79, 0xe7, 0xfd, 0x6e,
	0xbf, 0xf7, 0xe2, 0xac, 0xfd, 0x0e, 0x69, 0x42, 0x4d, 0x8b, 0xba, 0xfd, 0x6f, 0xda, 0x16, 0x21,
	0xd0, 0xd2, 0xaf, 0x4f, 0x4e, 0x9f, 0x7a, 0xcf, 0x5e, 0x3c, 0x3f, 0x6d, 0x17, 0xc8, 0x16, 0xb4,
	0x53, 0xd9, 0x49, 0xf7, 0xbc, 0xff, 0xed, 0x69, 0xbb, 0x98, 0xb7, 0xfc, 0xaa, 0xdb, 0x3f, 0x6d,
	0xdb, 0xc7, 0x3b, 0x7f, 0x7b, 0xbd, 0x6d, 0xfd, 0xfd, 0xf5, 0xb6, 0xf5, 0xaf, 0xd7, 0xdb, 0xd6,
	0x5f, 0xfe, 0xbd, 0xfd, 0xce, 0x33, 0xeb, 0xf7, 0x8d, 0xec, 0x3f, 0x4f, 0x06, 0x65, 0xfc, 0x79,
	0xf4, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7d, 0xf2, 0xdf, 0x3f, 0x23, 0x12, 0x00, 0x00,
}
