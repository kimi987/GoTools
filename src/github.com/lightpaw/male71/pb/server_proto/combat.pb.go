// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/server_proto/combat.proto
// DO NOT EDIT!

package server_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import proto5 "github.com/lightpaw/male7/pb/shared_proto"
import proto1 "github.com/lightpaw/male7/pb/shared_proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 请求打架
type CombatRequestServerProto struct {
	Seed           int64  `protobuf:"varint,1,opt,name=seed,proto3" json:"seed,omitempty"`
	UploadFilePath string `protobuf:"bytes,2,opt,name=upload_file_path,json=uploadFilePath,proto3" json:"upload_file_path,omitempty"`
	ReturnResult   bool   `protobuf:"varint,3,opt,name=return_result,json=returnResult,proto3" json:"return_result,omitempty"`
	// 初始数据 进攻方 防守方
	AttackerId int64                     `protobuf:"varint,9,opt,name=attacker_id,json=attackerId,proto3" json:"attacker_id,omitempty"`
	DefenserId int64                     `protobuf:"varint,10,opt,name=defenser_id,json=defenserId,proto3" json:"defenser_id,omitempty"`
	Attacker   *proto5.CombatPlayerProto `protobuf:"bytes,11,opt,name=attacker" json:"attacker,omitempty"`
	Defenser   *proto5.CombatPlayerProto `protobuf:"bytes,12,opt,name=defenser" json:"defenser,omitempty"`
	// 地图资源
	MapRes                      string                  `protobuf:"bytes,13,opt,name=map_res,json=mapRes,proto3" json:"map_res,omitempty"`
	MapXLen                     int32                   `protobuf:"varint,14,opt,name=map_x_len,json=mapXLen,proto3" json:"map_x_len,omitempty"`
	MapYLen                     int32                   `protobuf:"varint,15,opt,name=map_y_len,json=mapYLen,proto3" json:"map_y_len,omitempty"`
	MaxRound                    int32                   `protobuf:"varint,21,opt,name=max_round,json=maxRound,proto3" json:"max_round,omitempty"`
	Coef                        int32                   `protobuf:"varint,23,opt,name=coef,proto3" json:"coef,omitempty"`
	CritRate                    int32                   `protobuf:"varint,24,opt,name=crit_rate,json=critRate,proto3" json:"crit_rate,omitempty"`
	RestraintRate               int32                   `protobuf:"varint,32,opt,name=restraint_rate,json=restraintRate,proto3" json:"restraint_rate,omitempty"`
	Races                       []*proto1.RaceDataProto `protobuf:"bytes,25,rep,name=races" json:"races,omitempty"`
	MinWallAttackRound          int32                   `protobuf:"varint,30,opt,name=min_wall_attack_round,json=minWallAttackRound,proto3" json:"min_wall_attack_round,omitempty"`
	MaxWallAttachFixDamageRound int32                   `protobuf:"varint,29,opt,name=max_wall_attach_fix_damage_round,json=maxWallAttachFixDamageRound,proto3" json:"max_wall_attach_fix_damage_round,omitempty"`
	MaxWallBeenHurtPercent      int32                   `protobuf:"varint,33,opt,name=max_wall_been_hurt_percent,json=maxWallBeenHurtPercent,proto3" json:"max_wall_been_hurt_percent,omitempty"`
	// 评价
	ScorePercent []uint64 `protobuf:"varint,31,rep,packed,name=score_percent,json=scorePercent" json:"score_percent,omitempty"`
}

func (m *CombatRequestServerProto) Reset()                    { *m = CombatRequestServerProto{} }
func (m *CombatRequestServerProto) String() string            { return proto.CompactTextString(m) }
func (*CombatRequestServerProto) ProtoMessage()               {}
func (*CombatRequestServerProto) Descriptor() ([]byte, []int) { return fileDescriptorCombat, []int{0} }

func (m *CombatRequestServerProto) GetSeed() int64 {
	if m != nil {
		return m.Seed
	}
	return 0
}

func (m *CombatRequestServerProto) GetUploadFilePath() string {
	if m != nil {
		return m.UploadFilePath
	}
	return ""
}

func (m *CombatRequestServerProto) GetReturnResult() bool {
	if m != nil {
		return m.ReturnResult
	}
	return false
}

func (m *CombatRequestServerProto) GetAttackerId() int64 {
	if m != nil {
		return m.AttackerId
	}
	return 0
}

func (m *CombatRequestServerProto) GetDefenserId() int64 {
	if m != nil {
		return m.DefenserId
	}
	return 0
}

func (m *CombatRequestServerProto) GetAttacker() *proto5.CombatPlayerProto {
	if m != nil {
		return m.Attacker
	}
	return nil
}

func (m *CombatRequestServerProto) GetDefenser() *proto5.CombatPlayerProto {
	if m != nil {
		return m.Defenser
	}
	return nil
}

func (m *CombatRequestServerProto) GetMapRes() string {
	if m != nil {
		return m.MapRes
	}
	return ""
}

func (m *CombatRequestServerProto) GetMapXLen() int32 {
	if m != nil {
		return m.MapXLen
	}
	return 0
}

func (m *CombatRequestServerProto) GetMapYLen() int32 {
	if m != nil {
		return m.MapYLen
	}
	return 0
}

func (m *CombatRequestServerProto) GetMaxRound() int32 {
	if m != nil {
		return m.MaxRound
	}
	return 0
}

func (m *CombatRequestServerProto) GetCoef() int32 {
	if m != nil {
		return m.Coef
	}
	return 0
}

func (m *CombatRequestServerProto) GetCritRate() int32 {
	if m != nil {
		return m.CritRate
	}
	return 0
}

func (m *CombatRequestServerProto) GetRestraintRate() int32 {
	if m != nil {
		return m.RestraintRate
	}
	return 0
}

func (m *CombatRequestServerProto) GetRaces() []*proto1.RaceDataProto {
	if m != nil {
		return m.Races
	}
	return nil
}

func (m *CombatRequestServerProto) GetMinWallAttackRound() int32 {
	if m != nil {
		return m.MinWallAttackRound
	}
	return 0
}

func (m *CombatRequestServerProto) GetMaxWallAttachFixDamageRound() int32 {
	if m != nil {
		return m.MaxWallAttachFixDamageRound
	}
	return 0
}

func (m *CombatRequestServerProto) GetMaxWallBeenHurtPercent() int32 {
	if m != nil {
		return m.MaxWallBeenHurtPercent
	}
	return 0
}

func (m *CombatRequestServerProto) GetScorePercent() []uint64 {
	if m != nil {
		return m.ScorePercent
	}
	return nil
}

type CombatResponseServerProto struct {
	ReturnCode    int32                    `protobuf:"varint,1,opt,name=return_code,json=returnCode,proto3" json:"return_code,omitempty"`
	ReturnMsg     string                   `protobuf:"bytes,2,opt,name=return_msg,json=returnMsg,proto3" json:"return_msg,omitempty"`
	Link          string                   `protobuf:"bytes,5,opt,name=link,proto3" json:"link,omitempty"`
	AttackerShare *proto5.CombatShareProto `protobuf:"bytes,6,opt,name=attacker_share,json=attackerShare" json:"attacker_share,omitempty"`
	DefenserShare *proto5.CombatShareProto `protobuf:"bytes,7,opt,name=defenser_share,json=defenserShare" json:"defenser_share,omitempty"`
	// 胜利方 true表示进攻方胜利了
	AttackerId  int64 `protobuf:"varint,9,opt,name=attacker_id,json=attackerId,proto3" json:"attacker_id,omitempty"`
	DefenserId  int64 `protobuf:"varint,10,opt,name=defenser_id,json=defenserId,proto3" json:"defenser_id,omitempty"`
	AttackerWin bool  `protobuf:"varint,11,opt,name=attacker_win,json=attackerWin,proto3" json:"attacker_win,omitempty"`
	// 双方剩余兵力 key是武将id，value是剩余兵力
	AttackerAliveSoldier map[int32]int32 `protobuf:"bytes,12,rep,name=attacker_alive_soldier,json=attackerAliveSoldier" json:"attacker_alive_soldier,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	DefenserAliveSoldier map[int32]int32 `protobuf:"bytes,13,rep,name=defenser_alive_soldier,json=defenserAliveSoldier" json:"defenser_alive_soldier,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	AttackerKillSoldier  map[int32]int32 `protobuf:"bytes,15,rep,name=attacker_kill_soldier,json=attackerKillSoldier" json:"attacker_kill_soldier,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	DefenserKillSoldier  map[int32]int32 `protobuf:"bytes,16,rep,name=defenser_kill_soldier,json=defenserKillSoldier" json:"defenser_kill_soldier,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// 评分，0-险胜 1-小胜 2-大胜 3-完胜
	Score  int32               `protobuf:"varint,14,opt,name=score,proto3" json:"score,omitempty"`
	Result *proto5.CombatProto `protobuf:"bytes,99,opt,name=result" json:"result,omitempty"`
}

func (m *CombatResponseServerProto) Reset()                    { *m = CombatResponseServerProto{} }
func (m *CombatResponseServerProto) String() string            { return proto.CompactTextString(m) }
func (*CombatResponseServerProto) ProtoMessage()               {}
func (*CombatResponseServerProto) Descriptor() ([]byte, []int) { return fileDescriptorCombat, []int{1} }

func (m *CombatResponseServerProto) GetReturnCode() int32 {
	if m != nil {
		return m.ReturnCode
	}
	return 0
}

func (m *CombatResponseServerProto) GetReturnMsg() string {
	if m != nil {
		return m.ReturnMsg
	}
	return ""
}

func (m *CombatResponseServerProto) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *CombatResponseServerProto) GetAttackerShare() *proto5.CombatShareProto {
	if m != nil {
		return m.AttackerShare
	}
	return nil
}

func (m *CombatResponseServerProto) GetDefenserShare() *proto5.CombatShareProto {
	if m != nil {
		return m.DefenserShare
	}
	return nil
}

func (m *CombatResponseServerProto) GetAttackerId() int64 {
	if m != nil {
		return m.AttackerId
	}
	return 0
}

func (m *CombatResponseServerProto) GetDefenserId() int64 {
	if m != nil {
		return m.DefenserId
	}
	return 0
}

func (m *CombatResponseServerProto) GetAttackerWin() bool {
	if m != nil {
		return m.AttackerWin
	}
	return false
}

func (m *CombatResponseServerProto) GetAttackerAliveSoldier() map[int32]int32 {
	if m != nil {
		return m.AttackerAliveSoldier
	}
	return nil
}

func (m *CombatResponseServerProto) GetDefenserAliveSoldier() map[int32]int32 {
	if m != nil {
		return m.DefenserAliveSoldier
	}
	return nil
}

func (m *CombatResponseServerProto) GetAttackerKillSoldier() map[int32]int32 {
	if m != nil {
		return m.AttackerKillSoldier
	}
	return nil
}

func (m *CombatResponseServerProto) GetDefenserKillSoldier() map[int32]int32 {
	if m != nil {
		return m.DefenserKillSoldier
	}
	return nil
}

func (m *CombatResponseServerProto) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *CombatResponseServerProto) GetResult() *proto5.CombatProto {
	if m != nil {
		return m.Result
	}
	return nil
}

// 请求打架
type MultiCombatRequestServerProto struct {
	Seed           int64  `protobuf:"varint,1,opt,name=seed,proto3" json:"seed,omitempty"`
	UploadFilePath string `protobuf:"bytes,2,opt,name=upload_file_path,json=uploadFilePath,proto3" json:"upload_file_path,omitempty"`
	ReturnResult   bool   `protobuf:"varint,3,opt,name=return_result,json=returnResult,proto3" json:"return_result,omitempty"`
	// 初始数据 进攻方 防守方
	AttackerId []int64                     `protobuf:"varint,9,rep,packed,name=attacker_id,json=attackerId" json:"attacker_id,omitempty"`
	DefenserId []int64                     `protobuf:"varint,10,rep,packed,name=defenser_id,json=defenserId" json:"defenser_id,omitempty"`
	Attacker   []*proto5.CombatPlayerProto `protobuf:"bytes,11,rep,name=attacker" json:"attacker,omitempty"`
	Defenser   []*proto5.CombatPlayerProto `protobuf:"bytes,12,rep,name=defenser" json:"defenser,omitempty"`
	// 地图资源
	MapRes                      string                  `protobuf:"bytes,13,opt,name=map_res,json=mapRes,proto3" json:"map_res,omitempty"`
	MapXLen                     int32                   `protobuf:"varint,14,opt,name=map_x_len,json=mapXLen,proto3" json:"map_x_len,omitempty"`
	MapYLen                     int32                   `protobuf:"varint,15,opt,name=map_y_len,json=mapYLen,proto3" json:"map_y_len,omitempty"`
	MaxRound                    int32                   `protobuf:"varint,21,opt,name=max_round,json=maxRound,proto3" json:"max_round,omitempty"`
	Coef                        int32                   `protobuf:"varint,23,opt,name=coef,proto3" json:"coef,omitempty"`
	CritRate                    int32                   `protobuf:"varint,24,opt,name=crit_rate,json=critRate,proto3" json:"crit_rate,omitempty"`
	RestraintRate               int32                   `protobuf:"varint,32,opt,name=restraint_rate,json=restraintRate,proto3" json:"restraint_rate,omitempty"`
	Races                       []*proto1.RaceDataProto `protobuf:"bytes,25,rep,name=races" json:"races,omitempty"`
	ConcurrentFightCount        int32                   `protobuf:"varint,26,opt,name=concurrent_fight_count,json=concurrentFightCount,proto3" json:"concurrent_fight_count,omitempty"`
	AttackerContinueWinCount    int32                   `protobuf:"varint,27,opt,name=attacker_continue_win_count,json=attackerContinueWinCount,proto3" json:"attacker_continue_win_count,omitempty"`
	DefenserContinueWinCount    int32                   `protobuf:"varint,28,opt,name=defenser_continue_win_count,json=defenserContinueWinCount,proto3" json:"defenser_continue_win_count,omitempty"`
	MinWallAttackRound          int32                   `protobuf:"varint,30,opt,name=min_wall_attack_round,json=minWallAttackRound,proto3" json:"min_wall_attack_round,omitempty"`
	MaxWallAttachFixDamageRound int32                   `protobuf:"varint,29,opt,name=max_wall_attach_fix_damage_round,json=maxWallAttachFixDamageRound,proto3" json:"max_wall_attach_fix_damage_round,omitempty"`
	MaxWallBeenHurtPercent      int32                   `protobuf:"varint,33,opt,name=max_wall_been_hurt_percent,json=maxWallBeenHurtPercent,proto3" json:"max_wall_been_hurt_percent,omitempty"`
	// 评价
	ScorePercent []uint64 `protobuf:"varint,31,rep,packed,name=score_percent,json=scorePercent" json:"score_percent,omitempty"`
}

func (m *MultiCombatRequestServerProto) Reset()         { *m = MultiCombatRequestServerProto{} }
func (m *MultiCombatRequestServerProto) String() string { return proto.CompactTextString(m) }
func (*MultiCombatRequestServerProto) ProtoMessage()    {}
func (*MultiCombatRequestServerProto) Descriptor() ([]byte, []int) {
	return fileDescriptorCombat, []int{2}
}

func (m *MultiCombatRequestServerProto) GetSeed() int64 {
	if m != nil {
		return m.Seed
	}
	return 0
}

func (m *MultiCombatRequestServerProto) GetUploadFilePath() string {
	if m != nil {
		return m.UploadFilePath
	}
	return ""
}

func (m *MultiCombatRequestServerProto) GetReturnResult() bool {
	if m != nil {
		return m.ReturnResult
	}
	return false
}

func (m *MultiCombatRequestServerProto) GetAttackerId() []int64 {
	if m != nil {
		return m.AttackerId
	}
	return nil
}

func (m *MultiCombatRequestServerProto) GetDefenserId() []int64 {
	if m != nil {
		return m.DefenserId
	}
	return nil
}

func (m *MultiCombatRequestServerProto) GetAttacker() []*proto5.CombatPlayerProto {
	if m != nil {
		return m.Attacker
	}
	return nil
}

func (m *MultiCombatRequestServerProto) GetDefenser() []*proto5.CombatPlayerProto {
	if m != nil {
		return m.Defenser
	}
	return nil
}

func (m *MultiCombatRequestServerProto) GetMapRes() string {
	if m != nil {
		return m.MapRes
	}
	return ""
}

func (m *MultiCombatRequestServerProto) GetMapXLen() int32 {
	if m != nil {
		return m.MapXLen
	}
	return 0
}

func (m *MultiCombatRequestServerProto) GetMapYLen() int32 {
	if m != nil {
		return m.MapYLen
	}
	return 0
}

func (m *MultiCombatRequestServerProto) GetMaxRound() int32 {
	if m != nil {
		return m.MaxRound
	}
	return 0
}

func (m *MultiCombatRequestServerProto) GetCoef() int32 {
	if m != nil {
		return m.Coef
	}
	return 0
}

func (m *MultiCombatRequestServerProto) GetCritRate() int32 {
	if m != nil {
		return m.CritRate
	}
	return 0
}

func (m *MultiCombatRequestServerProto) GetRestraintRate() int32 {
	if m != nil {
		return m.RestraintRate
	}
	return 0
}

func (m *MultiCombatRequestServerProto) GetRaces() []*proto1.RaceDataProto {
	if m != nil {
		return m.Races
	}
	return nil
}

func (m *MultiCombatRequestServerProto) GetConcurrentFightCount() int32 {
	if m != nil {
		return m.ConcurrentFightCount
	}
	return 0
}

func (m *MultiCombatRequestServerProto) GetAttackerContinueWinCount() int32 {
	if m != nil {
		return m.AttackerContinueWinCount
	}
	return 0
}

func (m *MultiCombatRequestServerProto) GetDefenserContinueWinCount() int32 {
	if m != nil {
		return m.DefenserContinueWinCount
	}
	return 0
}

func (m *MultiCombatRequestServerProto) GetMinWallAttackRound() int32 {
	if m != nil {
		return m.MinWallAttackRound
	}
	return 0
}

func (m *MultiCombatRequestServerProto) GetMaxWallAttachFixDamageRound() int32 {
	if m != nil {
		return m.MaxWallAttachFixDamageRound
	}
	return 0
}

func (m *MultiCombatRequestServerProto) GetMaxWallBeenHurtPercent() int32 {
	if m != nil {
		return m.MaxWallBeenHurtPercent
	}
	return 0
}

func (m *MultiCombatRequestServerProto) GetScorePercent() []uint64 {
	if m != nil {
		return m.ScorePercent
	}
	return nil
}

type MultiCombatResponseServerProto struct {
	ReturnCode    int32                    `protobuf:"varint,1,opt,name=return_code,json=returnCode,proto3" json:"return_code,omitempty"`
	ReturnMsg     string                   `protobuf:"bytes,2,opt,name=return_msg,json=returnMsg,proto3" json:"return_msg,omitempty"`
	Link          string                   `protobuf:"bytes,5,opt,name=link,proto3" json:"link,omitempty"`
	AttackerShare *proto5.CombatShareProto `protobuf:"bytes,6,opt,name=attacker_share,json=attackerShare" json:"attacker_share,omitempty"`
	DefenserShare *proto5.CombatShareProto `protobuf:"bytes,7,opt,name=defenser_share,json=defenserShare" json:"defenser_share,omitempty"`
	// 胜利方 true表示进攻方胜利了
	AttackerId  []int64 `protobuf:"varint,9,rep,packed,name=attacker_id,json=attackerId" json:"attacker_id,omitempty"`
	DefenserId  []int64 `protobuf:"varint,10,rep,packed,name=defenser_id,json=defenserId" json:"defenser_id,omitempty"`
	AttackerWin bool    `protobuf:"varint,11,opt,name=attacker_win,json=attackerWin,proto3" json:"attacker_win,omitempty"`
	// 双方剩余兵力 key是index，value是剩余兵力
	AliveSoldiers []*AliveSoldierProto `protobuf:"bytes,12,rep,name=alive_soldiers,json=aliveSoldiers" json:"alive_soldiers,omitempty"`
	// 胜利次数map
	WinTimesMap map[int64]int64 `protobuf:"bytes,13,rep,name=winTimesMap" json:"winTimesMap,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// 评分，0-险胜 1-小胜 2-大胜 3-完胜
	Score  int32                    `protobuf:"varint,14,opt,name=score,proto3" json:"score,omitempty"`
	Result *proto5.MultiCombatProto `protobuf:"bytes,99,opt,name=result" json:"result,omitempty"`
}

func (m *MultiCombatResponseServerProto) Reset()         { *m = MultiCombatResponseServerProto{} }
func (m *MultiCombatResponseServerProto) String() string { return proto.CompactTextString(m) }
func (*MultiCombatResponseServerProto) ProtoMessage()    {}
func (*MultiCombatResponseServerProto) Descriptor() ([]byte, []int) {
	return fileDescriptorCombat, []int{3}
}

func (m *MultiCombatResponseServerProto) GetReturnCode() int32 {
	if m != nil {
		return m.ReturnCode
	}
	return 0
}

func (m *MultiCombatResponseServerProto) GetReturnMsg() string {
	if m != nil {
		return m.ReturnMsg
	}
	return ""
}

func (m *MultiCombatResponseServerProto) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *MultiCombatResponseServerProto) GetAttackerShare() *proto5.CombatShareProto {
	if m != nil {
		return m.AttackerShare
	}
	return nil
}

func (m *MultiCombatResponseServerProto) GetDefenserShare() *proto5.CombatShareProto {
	if m != nil {
		return m.DefenserShare
	}
	return nil
}

func (m *MultiCombatResponseServerProto) GetAttackerId() []int64 {
	if m != nil {
		return m.AttackerId
	}
	return nil
}

func (m *MultiCombatResponseServerProto) GetDefenserId() []int64 {
	if m != nil {
		return m.DefenserId
	}
	return nil
}

func (m *MultiCombatResponseServerProto) GetAttackerWin() bool {
	if m != nil {
		return m.AttackerWin
	}
	return false
}

func (m *MultiCombatResponseServerProto) GetAliveSoldiers() []*AliveSoldierProto {
	if m != nil {
		return m.AliveSoldiers
	}
	return nil
}

func (m *MultiCombatResponseServerProto) GetWinTimesMap() map[int64]int64 {
	if m != nil {
		return m.WinTimesMap
	}
	return nil
}

func (m *MultiCombatResponseServerProto) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *MultiCombatResponseServerProto) GetResult() *proto5.MultiCombatProto {
	if m != nil {
		return m.Result
	}
	return nil
}

type AliveSoldierProto struct {
	Id           int64           `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	AliveSoldier map[int32]int32 `protobuf:"bytes,2,rep,name=alive_soldier,json=aliveSoldier" json:"alive_soldier,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *AliveSoldierProto) Reset()                    { *m = AliveSoldierProto{} }
func (m *AliveSoldierProto) String() string            { return proto.CompactTextString(m) }
func (*AliveSoldierProto) ProtoMessage()               {}
func (*AliveSoldierProto) Descriptor() ([]byte, []int) { return fileDescriptorCombat, []int{4} }

func (m *AliveSoldierProto) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AliveSoldierProto) GetAliveSoldier() map[int32]int32 {
	if m != nil {
		return m.AliveSoldier
	}
	return nil
}

func init() {
	proto.RegisterType((*CombatRequestServerProto)(nil), "proto.CombatRequestServerProto")
	proto.RegisterType((*CombatResponseServerProto)(nil), "proto.CombatResponseServerProto")
	proto.RegisterType((*MultiCombatRequestServerProto)(nil), "proto.MultiCombatRequestServerProto")
	proto.RegisterType((*MultiCombatResponseServerProto)(nil), "proto.MultiCombatResponseServerProto")
	proto.RegisterType((*AliveSoldierProto)(nil), "proto.AliveSoldierProto")
}
func (m *CombatRequestServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombatRequestServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seed != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Seed))
	}
	if len(m.UploadFilePath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCombat(dAtA, i, uint64(len(m.UploadFilePath)))
		i += copy(dAtA[i:], m.UploadFilePath)
	}
	if m.ReturnResult {
		dAtA[i] = 0x18
		i++
		if m.ReturnResult {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AttackerId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.AttackerId))
	}
	if m.DefenserId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.DefenserId))
	}
	if m.Attacker != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Attacker.Size()))
		n1, err := m.Attacker.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Defenser != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Defenser.Size()))
		n2, err := m.Defenser.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.MapRes) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCombat(dAtA, i, uint64(len(m.MapRes)))
		i += copy(dAtA[i:], m.MapRes)
	}
	if m.MapXLen != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.MapXLen))
	}
	if m.MapYLen != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.MapYLen))
	}
	if m.MaxRound != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.MaxRound))
	}
	if m.Coef != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Coef))
	}
	if m.CritRate != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.CritRate))
	}
	if len(m.Races) > 0 {
		for _, msg := range m.Races {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCombat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MaxWallAttachFixDamageRound != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.MaxWallAttachFixDamageRound))
	}
	if m.MinWallAttackRound != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.MinWallAttackRound))
	}
	if len(m.ScorePercent) > 0 {
		dAtA4 := make([]byte, len(m.ScorePercent)*10)
		var j3 int
		for _, num := range m.ScorePercent {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.RestraintRate != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.RestraintRate))
	}
	if m.MaxWallBeenHurtPercent != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.MaxWallBeenHurtPercent))
	}
	return i, nil
}

func (m *CombatResponseServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombatResponseServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReturnCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.ReturnCode))
	}
	if len(m.ReturnMsg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCombat(dAtA, i, uint64(len(m.ReturnMsg)))
		i += copy(dAtA[i:], m.ReturnMsg)
	}
	if len(m.Link) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCombat(dAtA, i, uint64(len(m.Link)))
		i += copy(dAtA[i:], m.Link)
	}
	if m.AttackerShare != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.AttackerShare.Size()))
		n5, err := m.AttackerShare.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.DefenserShare != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.DefenserShare.Size()))
		n6, err := m.DefenserShare.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.AttackerId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.AttackerId))
	}
	if m.DefenserId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.DefenserId))
	}
	if m.AttackerWin {
		dAtA[i] = 0x58
		i++
		if m.AttackerWin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AttackerAliveSoldier) > 0 {
		for k, _ := range m.AttackerAliveSoldier {
			dAtA[i] = 0x62
			i++
			v := m.AttackerAliveSoldier[k]
			mapSize := 1 + sovCombat(uint64(k)) + 1 + sovCombat(uint64(v))
			i = encodeVarintCombat(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCombat(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCombat(dAtA, i, uint64(v))
		}
	}
	if len(m.DefenserAliveSoldier) > 0 {
		for k, _ := range m.DefenserAliveSoldier {
			dAtA[i] = 0x6a
			i++
			v := m.DefenserAliveSoldier[k]
			mapSize := 1 + sovCombat(uint64(k)) + 1 + sovCombat(uint64(v))
			i = encodeVarintCombat(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCombat(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCombat(dAtA, i, uint64(v))
		}
	}
	if m.Score != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Score))
	}
	if len(m.AttackerKillSoldier) > 0 {
		for k, _ := range m.AttackerKillSoldier {
			dAtA[i] = 0x7a
			i++
			v := m.AttackerKillSoldier[k]
			mapSize := 1 + sovCombat(uint64(k)) + 1 + sovCombat(uint64(v))
			i = encodeVarintCombat(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCombat(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCombat(dAtA, i, uint64(v))
		}
	}
	if len(m.DefenserKillSoldier) > 0 {
		for k, _ := range m.DefenserKillSoldier {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			v := m.DefenserKillSoldier[k]
			mapSize := 1 + sovCombat(uint64(k)) + 1 + sovCombat(uint64(v))
			i = encodeVarintCombat(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCombat(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCombat(dAtA, i, uint64(v))
		}
	}
	if m.Result != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Result.Size()))
		n7, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *MultiCombatRequestServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiCombatRequestServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seed != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Seed))
	}
	if len(m.UploadFilePath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCombat(dAtA, i, uint64(len(m.UploadFilePath)))
		i += copy(dAtA[i:], m.UploadFilePath)
	}
	if m.ReturnResult {
		dAtA[i] = 0x18
		i++
		if m.ReturnResult {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AttackerId) > 0 {
		dAtA9 := make([]byte, len(m.AttackerId)*10)
		var j8 int
		for _, num1 := range m.AttackerId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCombat(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	if len(m.DefenserId) > 0 {
		dAtA11 := make([]byte, len(m.DefenserId)*10)
		var j10 int
		for _, num1 := range m.DefenserId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0x52
		i++
		i = encodeVarintCombat(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	if len(m.Attacker) > 0 {
		for _, msg := range m.Attacker {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintCombat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Defenser) > 0 {
		for _, msg := range m.Defenser {
			dAtA[i] = 0x62
			i++
			i = encodeVarintCombat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MapRes) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCombat(dAtA, i, uint64(len(m.MapRes)))
		i += copy(dAtA[i:], m.MapRes)
	}
	if m.MapXLen != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.MapXLen))
	}
	if m.MapYLen != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.MapYLen))
	}
	if m.MaxRound != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.MaxRound))
	}
	if m.Coef != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Coef))
	}
	if m.CritRate != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.CritRate))
	}
	if len(m.Races) > 0 {
		for _, msg := range m.Races {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCombat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ConcurrentFightCount != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.ConcurrentFightCount))
	}
	if m.AttackerContinueWinCount != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.AttackerContinueWinCount))
	}
	if m.DefenserContinueWinCount != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.DefenserContinueWinCount))
	}
	if m.MaxWallAttachFixDamageRound != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.MaxWallAttachFixDamageRound))
	}
	if m.MinWallAttackRound != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.MinWallAttackRound))
	}
	if len(m.ScorePercent) > 0 {
		dAtA13 := make([]byte, len(m.ScorePercent)*10)
		var j12 int
		for _, num := range m.ScorePercent {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCombat(dAtA, i, uint64(j12))
		i += copy(dAtA[i:], dAtA13[:j12])
	}
	if m.RestraintRate != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.RestraintRate))
	}
	if m.MaxWallBeenHurtPercent != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.MaxWallBeenHurtPercent))
	}
	return i, nil
}

func (m *MultiCombatResponseServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiCombatResponseServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReturnCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.ReturnCode))
	}
	if len(m.ReturnMsg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCombat(dAtA, i, uint64(len(m.ReturnMsg)))
		i += copy(dAtA[i:], m.ReturnMsg)
	}
	if len(m.Link) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCombat(dAtA, i, uint64(len(m.Link)))
		i += copy(dAtA[i:], m.Link)
	}
	if m.AttackerShare != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.AttackerShare.Size()))
		n14, err := m.AttackerShare.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.DefenserShare != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.DefenserShare.Size()))
		n15, err := m.DefenserShare.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.AttackerId) > 0 {
		dAtA17 := make([]byte, len(m.AttackerId)*10)
		var j16 int
		for _, num1 := range m.AttackerId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCombat(dAtA, i, uint64(j16))
		i += copy(dAtA[i:], dAtA17[:j16])
	}
	if len(m.DefenserId) > 0 {
		dAtA19 := make([]byte, len(m.DefenserId)*10)
		var j18 int
		for _, num1 := range m.DefenserId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		dAtA[i] = 0x52
		i++
		i = encodeVarintCombat(dAtA, i, uint64(j18))
		i += copy(dAtA[i:], dAtA19[:j18])
	}
	if m.AttackerWin {
		dAtA[i] = 0x58
		i++
		if m.AttackerWin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AliveSoldiers) > 0 {
		for _, msg := range m.AliveSoldiers {
			dAtA[i] = 0x62
			i++
			i = encodeVarintCombat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.WinTimesMap) > 0 {
		for k, _ := range m.WinTimesMap {
			dAtA[i] = 0x6a
			i++
			v := m.WinTimesMap[k]
			mapSize := 1 + sovCombat(uint64(k)) + 1 + sovCombat(uint64(v))
			i = encodeVarintCombat(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCombat(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCombat(dAtA, i, uint64(v))
		}
	}
	if m.Score != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Score))
	}
	if m.Result != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Result.Size()))
		n20, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *AliveSoldierProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AliveSoldierProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCombat(dAtA, i, uint64(m.Id))
	}
	if len(m.AliveSoldier) > 0 {
		for k, _ := range m.AliveSoldier {
			dAtA[i] = 0x12
			i++
			v := m.AliveSoldier[k]
			mapSize := 1 + sovCombat(uint64(k)) + 1 + sovCombat(uint64(v))
			i = encodeVarintCombat(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCombat(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCombat(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func encodeFixed64Combat(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Combat(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintCombat(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CombatRequestServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Seed != 0 {
		n += 1 + sovCombat(uint64(m.Seed))
	}
	l = len(m.UploadFilePath)
	if l > 0 {
		n += 1 + l + sovCombat(uint64(l))
	}
	if m.ReturnResult {
		n += 2
	}
	if m.AttackerId != 0 {
		n += 1 + sovCombat(uint64(m.AttackerId))
	}
	if m.DefenserId != 0 {
		n += 1 + sovCombat(uint64(m.DefenserId))
	}
	if m.Attacker != nil {
		l = m.Attacker.Size()
		n += 1 + l + sovCombat(uint64(l))
	}
	if m.Defenser != nil {
		l = m.Defenser.Size()
		n += 1 + l + sovCombat(uint64(l))
	}
	l = len(m.MapRes)
	if l > 0 {
		n += 1 + l + sovCombat(uint64(l))
	}
	if m.MapXLen != 0 {
		n += 1 + sovCombat(uint64(m.MapXLen))
	}
	if m.MapYLen != 0 {
		n += 1 + sovCombat(uint64(m.MapYLen))
	}
	if m.MaxRound != 0 {
		n += 2 + sovCombat(uint64(m.MaxRound))
	}
	if m.Coef != 0 {
		n += 2 + sovCombat(uint64(m.Coef))
	}
	if m.CritRate != 0 {
		n += 2 + sovCombat(uint64(m.CritRate))
	}
	if len(m.Races) > 0 {
		for _, e := range m.Races {
			l = e.Size()
			n += 2 + l + sovCombat(uint64(l))
		}
	}
	if m.MaxWallAttachFixDamageRound != 0 {
		n += 2 + sovCombat(uint64(m.MaxWallAttachFixDamageRound))
	}
	if m.MinWallAttackRound != 0 {
		n += 2 + sovCombat(uint64(m.MinWallAttackRound))
	}
	if len(m.ScorePercent) > 0 {
		l = 0
		for _, e := range m.ScorePercent {
			l += sovCombat(uint64(e))
		}
		n += 2 + sovCombat(uint64(l)) + l
	}
	if m.RestraintRate != 0 {
		n += 2 + sovCombat(uint64(m.RestraintRate))
	}
	if m.MaxWallBeenHurtPercent != 0 {
		n += 2 + sovCombat(uint64(m.MaxWallBeenHurtPercent))
	}
	return n
}

func (m *CombatResponseServerProto) Size() (n int) {
	var l int
	_ = l
	if m.ReturnCode != 0 {
		n += 1 + sovCombat(uint64(m.ReturnCode))
	}
	l = len(m.ReturnMsg)
	if l > 0 {
		n += 1 + l + sovCombat(uint64(l))
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovCombat(uint64(l))
	}
	if m.AttackerShare != nil {
		l = m.AttackerShare.Size()
		n += 1 + l + sovCombat(uint64(l))
	}
	if m.DefenserShare != nil {
		l = m.DefenserShare.Size()
		n += 1 + l + sovCombat(uint64(l))
	}
	if m.AttackerId != 0 {
		n += 1 + sovCombat(uint64(m.AttackerId))
	}
	if m.DefenserId != 0 {
		n += 1 + sovCombat(uint64(m.DefenserId))
	}
	if m.AttackerWin {
		n += 2
	}
	if len(m.AttackerAliveSoldier) > 0 {
		for k, v := range m.AttackerAliveSoldier {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCombat(uint64(k)) + 1 + sovCombat(uint64(v))
			n += mapEntrySize + 1 + sovCombat(uint64(mapEntrySize))
		}
	}
	if len(m.DefenserAliveSoldier) > 0 {
		for k, v := range m.DefenserAliveSoldier {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCombat(uint64(k)) + 1 + sovCombat(uint64(v))
			n += mapEntrySize + 1 + sovCombat(uint64(mapEntrySize))
		}
	}
	if m.Score != 0 {
		n += 1 + sovCombat(uint64(m.Score))
	}
	if len(m.AttackerKillSoldier) > 0 {
		for k, v := range m.AttackerKillSoldier {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCombat(uint64(k)) + 1 + sovCombat(uint64(v))
			n += mapEntrySize + 1 + sovCombat(uint64(mapEntrySize))
		}
	}
	if len(m.DefenserKillSoldier) > 0 {
		for k, v := range m.DefenserKillSoldier {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCombat(uint64(k)) + 1 + sovCombat(uint64(v))
			n += mapEntrySize + 2 + sovCombat(uint64(mapEntrySize))
		}
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 2 + l + sovCombat(uint64(l))
	}
	return n
}

func (m *MultiCombatRequestServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Seed != 0 {
		n += 1 + sovCombat(uint64(m.Seed))
	}
	l = len(m.UploadFilePath)
	if l > 0 {
		n += 1 + l + sovCombat(uint64(l))
	}
	if m.ReturnResult {
		n += 2
	}
	if len(m.AttackerId) > 0 {
		l = 0
		for _, e := range m.AttackerId {
			l += sovCombat(uint64(e))
		}
		n += 1 + sovCombat(uint64(l)) + l
	}
	if len(m.DefenserId) > 0 {
		l = 0
		for _, e := range m.DefenserId {
			l += sovCombat(uint64(e))
		}
		n += 1 + sovCombat(uint64(l)) + l
	}
	if len(m.Attacker) > 0 {
		for _, e := range m.Attacker {
			l = e.Size()
			n += 1 + l + sovCombat(uint64(l))
		}
	}
	if len(m.Defenser) > 0 {
		for _, e := range m.Defenser {
			l = e.Size()
			n += 1 + l + sovCombat(uint64(l))
		}
	}
	l = len(m.MapRes)
	if l > 0 {
		n += 1 + l + sovCombat(uint64(l))
	}
	if m.MapXLen != 0 {
		n += 1 + sovCombat(uint64(m.MapXLen))
	}
	if m.MapYLen != 0 {
		n += 1 + sovCombat(uint64(m.MapYLen))
	}
	if m.MaxRound != 0 {
		n += 2 + sovCombat(uint64(m.MaxRound))
	}
	if m.Coef != 0 {
		n += 2 + sovCombat(uint64(m.Coef))
	}
	if m.CritRate != 0 {
		n += 2 + sovCombat(uint64(m.CritRate))
	}
	if len(m.Races) > 0 {
		for _, e := range m.Races {
			l = e.Size()
			n += 2 + l + sovCombat(uint64(l))
		}
	}
	if m.ConcurrentFightCount != 0 {
		n += 2 + sovCombat(uint64(m.ConcurrentFightCount))
	}
	if m.AttackerContinueWinCount != 0 {
		n += 2 + sovCombat(uint64(m.AttackerContinueWinCount))
	}
	if m.DefenserContinueWinCount != 0 {
		n += 2 + sovCombat(uint64(m.DefenserContinueWinCount))
	}
	if m.MaxWallAttachFixDamageRound != 0 {
		n += 2 + sovCombat(uint64(m.MaxWallAttachFixDamageRound))
	}
	if m.MinWallAttackRound != 0 {
		n += 2 + sovCombat(uint64(m.MinWallAttackRound))
	}
	if len(m.ScorePercent) > 0 {
		l = 0
		for _, e := range m.ScorePercent {
			l += sovCombat(uint64(e))
		}
		n += 2 + sovCombat(uint64(l)) + l
	}
	if m.RestraintRate != 0 {
		n += 2 + sovCombat(uint64(m.RestraintRate))
	}
	if m.MaxWallBeenHurtPercent != 0 {
		n += 2 + sovCombat(uint64(m.MaxWallBeenHurtPercent))
	}
	return n
}

func (m *MultiCombatResponseServerProto) Size() (n int) {
	var l int
	_ = l
	if m.ReturnCode != 0 {
		n += 1 + sovCombat(uint64(m.ReturnCode))
	}
	l = len(m.ReturnMsg)
	if l > 0 {
		n += 1 + l + sovCombat(uint64(l))
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovCombat(uint64(l))
	}
	if m.AttackerShare != nil {
		l = m.AttackerShare.Size()
		n += 1 + l + sovCombat(uint64(l))
	}
	if m.DefenserShare != nil {
		l = m.DefenserShare.Size()
		n += 1 + l + sovCombat(uint64(l))
	}
	if len(m.AttackerId) > 0 {
		l = 0
		for _, e := range m.AttackerId {
			l += sovCombat(uint64(e))
		}
		n += 1 + sovCombat(uint64(l)) + l
	}
	if len(m.DefenserId) > 0 {
		l = 0
		for _, e := range m.DefenserId {
			l += sovCombat(uint64(e))
		}
		n += 1 + sovCombat(uint64(l)) + l
	}
	if m.AttackerWin {
		n += 2
	}
	if len(m.AliveSoldiers) > 0 {
		for _, e := range m.AliveSoldiers {
			l = e.Size()
			n += 1 + l + sovCombat(uint64(l))
		}
	}
	if len(m.WinTimesMap) > 0 {
		for k, v := range m.WinTimesMap {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCombat(uint64(k)) + 1 + sovCombat(uint64(v))
			n += mapEntrySize + 1 + sovCombat(uint64(mapEntrySize))
		}
	}
	if m.Score != 0 {
		n += 1 + sovCombat(uint64(m.Score))
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 2 + l + sovCombat(uint64(l))
	}
	return n
}

func (m *AliveSoldierProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCombat(uint64(m.Id))
	}
	if len(m.AliveSoldier) > 0 {
		for k, v := range m.AliveSoldier {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCombat(uint64(k)) + 1 + sovCombat(uint64(v))
			n += mapEntrySize + 1 + sovCombat(uint64(mapEntrySize))
		}
	}
	return n
}

func sovCombat(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCombat(x uint64) (n int) {
	return sovCombat(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CombatRequestServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombatRequestServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombatRequestServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			m.Seed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadFilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadFilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnResult", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReturnResult = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerId", wireType)
			}
			m.AttackerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackerId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserId", wireType)
			}
			m.DefenserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefenserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attacker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attacker == nil {
				m.Attacker = &proto5.CombatPlayerProto{}
			}
			if err := m.Attacker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defenser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Defenser == nil {
				m.Defenser = &proto5.CombatPlayerProto{}
			}
			if err := m.Defenser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapRes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapRes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapXLen", wireType)
			}
			m.MapXLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapXLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapYLen", wireType)
			}
			m.MapYLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapYLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRound", wireType)
			}
			m.MaxRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRound |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coef", wireType)
			}
			m.Coef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CritRate", wireType)
			}
			m.CritRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CritRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Races", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Races = append(m.Races, &proto1.RaceDataProto{})
			if err := m.Races[len(m.Races)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxWallAttachFixDamageRound", wireType)
			}
			m.MaxWallAttachFixDamageRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxWallAttachFixDamageRound |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinWallAttackRound", wireType)
			}
			m.MinWallAttackRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinWallAttackRound |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ScorePercent = append(m.ScorePercent, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCombat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCombat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ScorePercent = append(m.ScorePercent, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ScorePercent", wireType)
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestraintRate", wireType)
			}
			m.RestraintRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestraintRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxWallBeenHurtPercent", wireType)
			}
			m.MaxWallBeenHurtPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxWallBeenHurtPercent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCombat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombatResponseServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombatResponseServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombatResponseServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnCode", wireType)
			}
			m.ReturnCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReturnCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReturnMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerShare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttackerShare == nil {
				m.AttackerShare = &proto5.CombatShareProto{}
			}
			if err := m.AttackerShare.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserShare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefenserShare == nil {
				m.DefenserShare = &proto5.CombatShareProto{}
			}
			if err := m.DefenserShare.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerId", wireType)
			}
			m.AttackerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackerId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserId", wireType)
			}
			m.DefenserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefenserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerWin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttackerWin = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerAliveSoldier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.AttackerAliveSoldier == nil {
				m.AttackerAliveSoldier = make(map[int32]int32)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AttackerAliveSoldier[mapkey] = mapvalue
			} else {
				var mapvalue int32
				m.AttackerAliveSoldier[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserAliveSoldier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.DefenserAliveSoldier == nil {
				m.DefenserAliveSoldier = make(map[int32]int32)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DefenserAliveSoldier[mapkey] = mapvalue
			} else {
				var mapvalue int32
				m.DefenserAliveSoldier[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerKillSoldier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.AttackerKillSoldier == nil {
				m.AttackerKillSoldier = make(map[int32]int32)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AttackerKillSoldier[mapkey] = mapvalue
			} else {
				var mapvalue int32
				m.AttackerKillSoldier[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserKillSoldier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.DefenserKillSoldier == nil {
				m.DefenserKillSoldier = make(map[int32]int32)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DefenserKillSoldier[mapkey] = mapvalue
			} else {
				var mapvalue int32
				m.DefenserKillSoldier[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &proto5.CombatProto{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCombat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiCombatRequestServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiCombatRequestServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiCombatRequestServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			m.Seed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadFilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadFilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnResult", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReturnResult = bool(v != 0)
		case 9:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AttackerId = append(m.AttackerId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCombat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCombat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AttackerId = append(m.AttackerId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerId", wireType)
			}
		case 10:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DefenserId = append(m.DefenserId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCombat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCombat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DefenserId = append(m.DefenserId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserId", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attacker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attacker = append(m.Attacker, &proto5.CombatPlayerProto{})
			if err := m.Attacker[len(m.Attacker)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defenser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Defenser = append(m.Defenser, &proto5.CombatPlayerProto{})
			if err := m.Defenser[len(m.Defenser)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapRes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapRes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapXLen", wireType)
			}
			m.MapXLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapXLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapYLen", wireType)
			}
			m.MapYLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapYLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRound", wireType)
			}
			m.MaxRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRound |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coef", wireType)
			}
			m.Coef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coef |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CritRate", wireType)
			}
			m.CritRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CritRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Races", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Races = append(m.Races, &proto1.RaceDataProto{})
			if err := m.Races[len(m.Races)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcurrentFightCount", wireType)
			}
			m.ConcurrentFightCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConcurrentFightCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerContinueWinCount", wireType)
			}
			m.AttackerContinueWinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackerContinueWinCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserContinueWinCount", wireType)
			}
			m.DefenserContinueWinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefenserContinueWinCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxWallAttachFixDamageRound", wireType)
			}
			m.MaxWallAttachFixDamageRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxWallAttachFixDamageRound |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinWallAttackRound", wireType)
			}
			m.MinWallAttackRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinWallAttackRound |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ScorePercent = append(m.ScorePercent, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCombat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCombat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ScorePercent = append(m.ScorePercent, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ScorePercent", wireType)
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestraintRate", wireType)
			}
			m.RestraintRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestraintRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxWallBeenHurtPercent", wireType)
			}
			m.MaxWallBeenHurtPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxWallBeenHurtPercent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCombat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiCombatResponseServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiCombatResponseServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiCombatResponseServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnCode", wireType)
			}
			m.ReturnCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReturnCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReturnMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerShare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttackerShare == nil {
				m.AttackerShare = &proto5.CombatShareProto{}
			}
			if err := m.AttackerShare.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserShare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefenserShare == nil {
				m.DefenserShare = &proto5.CombatShareProto{}
			}
			if err := m.DefenserShare.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AttackerId = append(m.AttackerId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCombat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCombat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AttackerId = append(m.AttackerId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerId", wireType)
			}
		case 10:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DefenserId = append(m.DefenserId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCombat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCombat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DefenserId = append(m.DefenserId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenserId", wireType)
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackerWin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttackerWin = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliveSoldiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliveSoldiers = append(m.AliveSoldiers, &AliveSoldierProto{})
			if err := m.AliveSoldiers[len(m.AliveSoldiers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinTimesMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.WinTimesMap == nil {
				m.WinTimesMap = make(map[int64]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WinTimesMap[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.WinTimesMap[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &proto5.MultiCombatProto{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCombat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AliveSoldierProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCombat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AliveSoldierProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AliveSoldierProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliveSoldier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCombat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.AliveSoldier == nil {
				m.AliveSoldier = make(map[int32]int32)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AliveSoldier[mapkey] = mapvalue
			} else {
				var mapvalue int32
				m.AliveSoldier[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCombat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCombat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCombat(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCombat
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCombat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCombat
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCombat
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCombat(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCombat = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCombat   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/server_proto/combat.proto", fileDescriptorCombat)
}

var fileDescriptorCombat = []byte{
	// 1088 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0x5f, 0x6f, 0xe3, 0x44,
	0x10, 0xc7, 0x75, 0xd3, 0x3f, 0x9b, 0x3f, 0x57, 0x96, 0xfe, 0x71, 0x53, 0x9a, 0xe6, 0x7a, 0x42,
	0x8a, 0xfa, 0x90, 0x88, 0xa3, 0x3a, 0xa0, 0x12, 0x77, 0xea, 0xb5, 0x57, 0xee, 0x04, 0x15, 0x95,
	0x8b, 0xd4, 0x83, 0x17, 0x6b, 0x63, 0x4f, 0x9b, 0x55, 0xec, 0xb5, 0x59, 0xaf, 0xdb, 0xf4, 0x9b,
	0xf0, 0x35, 0x78, 0xe0, 0x3b, 0xf0, 0xc8, 0x47, 0x40, 0xe5, 0x4b, 0x20, 0x78, 0x41, 0xbb, 0x6b,
	0xfb, 0xe2, 0x26, 0xb9, 0x36, 0xf0, 0x82, 0x74, 0x3c, 0xc5, 0x3b, 0xf3, 0xfb, 0xcd, 0xec, 0xcc,
	0xce, 0xec, 0x6c, 0xd0, 0x93, 0x0b, 0x2a, 0x7a, 0x49, 0xb7, 0xed, 0x86, 0x41, 0xc7, 0xa7, 0x17,
	0x3d, 0x11, 0x91, 0xab, 0x4e, 0x40, 0x7c, 0xf8, 0xb4, 0x13, 0x75, 0x3b, 0x31, 0xf0, 0x4b, 0xe0,
	0x4e, 0xc4, 0x43, 0x11, 0x76, 0xdc, 0x30, 0xe8, 0x12, 0xd1, 0x56, 0x0b, 0x5c, 0x52, 0x3f, 0xf5,
	0x3b, 0xe8, 0x3d, 0xc2, 0xc1, 0x1b, 0x43, 0xaf, 0xef, 0xde, 0x9f, 0xd7, 0x25, 0x31, 0x68, 0xd6,
	0xf6, 0x1f, 0x25, 0x64, 0x1d, 0x28, 0x33, 0x36, 0xfc, 0x90, 0x40, 0x2c, 0x4e, 0xd5, 0xfe, 0x4e,
	0xd4, 0x8e, 0x30, 0x9a, 0x8d, 0x01, 0x3c, 0xcb, 0x68, 0x1a, 0x2d, 0xd3, 0x56, 0xdf, 0xb8, 0x85,
	0x96, 0x92, 0xc8, 0x0f, 0x89, 0xe7, 0x9c, 0x53, 0x1f, 0x9c, 0x88, 0x88, 0x9e, 0x35, 0xd3, 0x34,
	0x5a, 0x8b, 0x76, 0x4d, 0xcb, 0x8f, 0xa8, 0x0f, 0x27, 0x44, 0xf4, 0xf0, 0x23, 0x54, 0xe5, 0x20,
	0x12, 0xce, 0x1c, 0x0e, 0x71, 0xe2, 0x0b, 0xcb, 0x6c, 0x1a, 0xad, 0x05, 0xbb, 0xa2, 0x85, 0xb6,
	0x92, 0xe1, 0x2d, 0x54, 0x26, 0x42, 0x10, 0xb7, 0x0f, 0xdc, 0xa1, 0x9e, 0xb5, 0xa8, 0x3c, 0xa1,
	0x4c, 0xf4, 0xca, 0x93, 0x00, 0x0f, 0xce, 0x81, 0xc5, 0x1a, 0x80, 0x34, 0x20, 0x13, 0xbd, 0xf2,
	0xf0, 0x2e, 0x5a, 0xc8, 0xe0, 0x56, 0xb9, 0x69, 0xb4, 0xca, 0x8f, 0x2d, 0x1d, 0x5b, 0x5b, 0xc7,
	0x75, 0xe2, 0x93, 0xeb, 0x34, 0x20, 0x3b, 0x47, 0x4a, 0x56, 0x66, 0xc3, 0xaa, 0xdc, 0xc5, 0xca,
	0x90, 0x78, 0x0d, 0xcd, 0x07, 0x24, 0x92, 0xf1, 0x58, 0x55, 0x15, 0xf3, 0x5c, 0x40, 0x22, 0x1b,
	0x62, 0x5c, 0x47, 0x8b, 0x52, 0x31, 0x70, 0x7c, 0x60, 0x56, 0xad, 0x69, 0xb4, 0x4a, 0xb6, 0x44,
	0xbe, 0xfe, 0x1a, 0x58, 0xa6, 0xbb, 0x56, 0xba, 0x07, 0xb9, 0xee, 0x3b, 0xa9, 0xdb, 0x90, 0xba,
	0x81, 0xc3, 0xc3, 0x84, 0x79, 0xd6, 0x8a, 0xd2, 0x2d, 0x04, 0x64, 0x60, 0xcb, 0xb5, 0x4c, 0xbf,
	0x1b, 0xc2, 0xb9, 0xb5, 0xa6, 0xe4, 0xea, 0x5b, 0x12, 0x5c, 0x4e, 0x85, 0xc3, 0x89, 0x00, 0xcb,
	0xd2, 0x04, 0x29, 0xb0, 0x89, 0x00, 0xbc, 0x83, 0x4a, 0x9c, 0xb8, 0x10, 0x5b, 0xeb, 0x4d, 0xb3,
	0x55, 0x7e, 0xbc, 0x9c, 0x46, 0x64, 0x13, 0x17, 0x0e, 0x89, 0x20, 0x3a, 0x1a, 0x0d, 0xc1, 0x2f,
	0x50, 0x53, 0x7a, 0xbe, 0x22, 0xbe, 0xef, 0xa8, 0xac, 0xf4, 0x9c, 0x73, 0x3a, 0x70, 0x3c, 0x12,
	0x90, 0x0b, 0x48, 0x37, 0xb4, 0xa9, 0xec, 0x6f, 0x04, 0x64, 0x70, 0x46, 0x7c, 0x7f, 0x5f, 0xa1,
	0x8e, 0xe8, 0xe0, 0x50, 0x61, 0xf4, 0x1e, 0x3f, 0x46, 0x2b, 0x01, 0x65, 0x43, 0x66, 0xfa, 0x29,
	0xb7, 0xa1, 0xb8, 0x38, 0xa0, 0x2c, 0xe7, 0xf6, 0x35, 0xe5, 0x11, 0xaa, 0xc6, 0x6e, 0xc8, 0xc1,
	0x89, 0x80, 0xbb, 0xc0, 0x84, 0xb5, 0xd5, 0x34, 0x5b, 0xb3, 0x76, 0x45, 0x09, 0x4f, 0xb4, 0x0c,
	0x7f, 0x84, 0x6a, 0x1c, 0x62, 0xc1, 0x09, 0x65, 0x69, 0xb0, 0x4d, 0x65, 0xb0, 0x9a, 0x4b, 0x55,
	0xc4, 0x7b, 0xa8, 0x9e, 0x47, 0xd1, 0x05, 0x60, 0x4e, 0x2f, 0xe1, 0x22, 0x37, 0xfc, 0x50, 0x51,
	0x56, 0xd3, 0xfd, 0x3f, 0x07, 0x60, 0x2f, 0x13, 0x2e, 0x52, 0x17, 0xdb, 0x7f, 0x2e, 0xa0, 0xf5,
	0xac, 0xf4, 0xe3, 0x28, 0x64, 0x31, 0x0c, 0xd7, 0xfe, 0x16, 0x2a, 0xa7, 0xd5, 0xeb, 0x86, 0x1e,
	0xa8, 0x16, 0x28, 0xd9, 0x48, 0x8b, 0x0e, 0x42, 0x0f, 0xf0, 0x26, 0x4a, 0x57, 0x4e, 0x10, 0x5f,
	0xa4, 0x2d, 0xb0, 0xa8, 0x25, 0xc7, 0xf1, 0x85, 0x3c, 0x3c, 0x9f, 0xb2, 0xbe, 0x55, 0x52, 0x0a,
	0xf5, 0x8d, 0x9f, 0xa2, 0x5a, 0x5e, 0xec, 0xaa, 0x21, 0xad, 0x39, 0x55, 0x7a, 0x6b, 0x85, 0xd2,
	0x3b, 0x95, 0x1a, 0x7d, 0x56, 0xd5, 0x0c, 0xae, 0x64, 0x92, 0x9f, 0xf7, 0x82, 0xe6, 0xcf, 0xdf,
	0xc1, 0xcf, 0xe0, 0x9a, 0xff, 0xef, 0x9b, 0xed, 0x21, 0xaa, 0xe4, 0x16, 0xae, 0x28, 0x53, 0x0d,
	0xb7, 0x60, 0xe7, 0x56, 0xcf, 0x28, 0xc3, 0x11, 0x5a, 0xcd, 0x21, 0xc4, 0xa7, 0x97, 0xe0, 0xc4,
	0xa1, 0xef, 0x51, 0xd5, 0x67, 0xb2, 0x2a, 0xf7, 0x0a, 0x9b, 0x1d, 0x93, 0xfa, 0xf6, 0x7e, 0x4a,
	0xdf, 0x97, 0xec, 0x53, 0x4d, 0x7e, 0xc1, 0x04, 0xbf, 0xb6, 0x97, 0xc9, 0x18, 0x95, 0xf4, 0x98,
	0xef, 0xba, 0xe8, 0xb1, 0x7a, 0x4f, 0x8f, 0x87, 0x29, 0x7d, 0x8c, 0x47, 0x6f, 0x8c, 0x0a, 0x2f,
	0xa3, 0x92, 0xaa, 0xd6, 0xb4, 0xd5, 0xf5, 0x02, 0x07, 0x68, 0x25, 0x8f, 0xbc, 0x4f, 0x7d, 0x3f,
	0xdf, 0xc6, 0x03, 0xb5, 0x8d, 0xcf, 0xef, 0x1d, 0xf8, 0x57, 0xd4, 0xf7, 0x0b, 0xbb, 0xf8, 0x80,
	0x8c, 0x6a, 0xa4, 0xbb, 0x3c, 0xec, 0x82, 0xbb, 0xa5, 0x7b, 0xba, 0xcb, 0xa2, 0x1e, 0x75, 0xe7,
	0x8d, 0x6a, 0xf0, 0x0e, 0x9a, 0x4b, 0xef, 0x71, 0x57, 0x15, 0x1d, 0x2e, 0xde, 0x97, 0xaa, 0xde,
	0x52, 0x44, 0xfd, 0x4b, 0xb4, 0x3e, 0xf1, 0x10, 0xf1, 0x12, 0x32, 0xfb, 0x70, 0x9d, 0x76, 0x94,
	0xfc, 0x94, 0xe9, 0xbc, 0x24, 0x7e, 0x02, 0xaa, 0x8b, 0x4a, 0xb6, 0x5e, 0xec, 0xcd, 0x7c, 0x66,
	0x48, 0x43, 0x13, 0xcf, 0x66, 0x2a, 0x43, 0x47, 0xc8, 0x9a, 0x94, 0xdd, 0x69, 0xed, 0x4c, 0x4a,
	0xdb, 0x34, 0x76, 0xb6, 0x7f, 0x9a, 0x47, 0x9b, 0xc7, 0x89, 0x2f, 0xe8, 0x7f, 0x6a, 0xf8, 0x9a,
	0x77, 0xdd, 0x07, 0xe6, 0x5b, 0x87, 0xaf, 0xf9, 0x8f, 0x86, 0xaf, 0xf9, 0xee, 0x0d, 0xdf, 0x5d,
	0xb4, 0xea, 0x86, 0xcc, 0x4d, 0x38, 0x07, 0x26, 0x9c, 0x73, 0xf9, 0x5a, 0x73, 0xdc, 0x30, 0x61,
	0xc2, 0xaa, 0x2b, 0xab, 0xcb, 0x6f, 0xb4, 0x47, 0x52, 0x79, 0x20, 0x75, 0xf8, 0x0b, 0xb4, 0x91,
	0x1f, 0x97, 0x1b, 0x32, 0x41, 0x59, 0x02, 0xf2, 0x16, 0x4e, 0xa9, 0x1b, 0x8a, 0x6a, 0x65, 0x90,
	0x83, 0x14, 0x71, 0x46, 0x59, 0x4e, 0xcf, 0x0f, 0x73, 0x0c, 0xfd, 0x43, 0x4d, 0xcf, 0x20, 0x23,
	0xf4, 0xff, 0x1f, 0x0c, 0x7f, 0xcd, 0xa2, 0x46, 0xa1, 0x67, 0xdf, 0xd1, 0x57, 0xc3, 0xd4, 0xb7,
	0xc4, 0x3d, 0x5e, 0x0d, 0xcf, 0x50, 0xad, 0x30, 0xba, 0xe3, 0x5b, 0x17, 0xc3, 0xf0, 0xed, 0x9f,
	0x45, 0x39, 0x24, 0x8a, 0xf1, 0x6b, 0x54, 0xbe, 0xa2, 0xec, 0x5b, 0x1a, 0x40, 0x7c, 0x4c, 0xa2,
	0x74, 0xf2, 0x3f, 0x49, 0xd9, 0x6f, 0x3f, 0xb5, 0xf6, 0xd9, 0x1b, 0xa2, 0x1e, 0x80, 0xc3, 0xa6,
	0x26, 0x0c, 0xfb, 0xce, 0xad, 0x71, 0xb8, 0x36, 0xea, 0xaa, 0x38, 0x13, 0x9f, 0xa2, 0xa5, 0xdb,
	0x7e, 0x86, 0x27, 0x86, 0x39, 0x66, 0x62, 0x98, 0xc3, 0x13, 0xe3, 0x67, 0x03, 0xbd, 0x3f, 0x92,
	0x05, 0x5c, 0x43, 0x33, 0x34, 0x9b, 0x11, 0x33, 0xd4, 0xc3, 0xdf, 0xa0, 0x6a, 0xf1, 0x09, 0x34,
	0xa3, 0x12, 0xb1, 0x33, 0x29, 0x8d, 0xed, 0xd1, 0x27, 0x4f, 0x65, 0x38, 0xb1, 0xf5, 0x67, 0x45,
	0xaf, 0x53, 0x4f, 0xba, 0xe7, 0xcd, 0x5f, 0x6e, 0x1a, 0xc6, 0xaf, 0x37, 0x0d, 0xe3, 0xb7, 0x9b,
	0x86, 0xf1, 0xe3, 0xef, 0x8d, 0xf7, 0x5e, 0x1a, 0xdf, 0x57, 0x86, 0xff, 0x05, 0x77, 0xe7, 0xd4,
	0xcf, 0x27, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0x09, 0x99, 0xca, 0x20, 0x39, 0x0f, 0x00, 0x00,
}
