// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/server_proto/domestic.proto
// DO NOT EDIT!

package server_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import proto1 "github.com/lightpaw/male7/pb/shared_proto"
import proto7 "github.com/lightpaw/male7/pb/shared_proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type HeroDomesticServerProto struct {
	WorkerRestEndTime             []int32                         `protobuf:"varint,16,rep,packed,name=worker_rest_end_time,json=workerRestEndTime" json:"worker_rest_end_time,omitempty"`
	WorkerSeekHelp                []bool                          `protobuf:"varint,51,rep,packed,name=worker_seek_help,json=workerSeekHelp" json:"worker_seek_help,omitempty"`
	CheckRemoveWorkerSeekHelp     []bool                          `protobuf:"varint,54,rep,packed,name=check_remove_worker_seek_help,json=checkRemoveWorkerSeekHelp" json:"check_remove_worker_seek_help,omitempty"`
	WorkerAlwaysUnlocked          []bool                          `protobuf:"varint,66,rep,packed,name=worker_always_unlocked,json=workerAlwaysUnlocked" json:"worker_always_unlocked,omitempty"`
	WorkerLockStartTime           []int32                         `protobuf:"varint,67,rep,packed,name=worker_lock_start_time,json=workerLockStartTime" json:"worker_lock_start_time,omitempty"`
	Building                      []uint64                        `protobuf:"varint,18,rep,packed,name=building" json:"building,omitempty"`
	ResourcePoint                 []*HeroResourcePointServerProto `protobuf:"bytes,19,rep,name=resource_point,json=resourcePoint" json:"resource_point,omitempty"`
	ConflictResourcePoints        []uint64                        `protobuf:"varint,20,rep,packed,name=conflict_resource_points,json=conflictResourcePoints" json:"conflict_resource_points,omitempty"`
	Cities                        *proto7.OuterCitiesProto        `protobuf:"bytes,23,opt,name=cities" json:"cities,omitempty"`
	Technology                    []uint64                        `protobuf:"varint,21,rep,packed,name=technology" json:"technology,omitempty"`
	TechnologyRestEndTime         []int32                         `protobuf:"varint,22,rep,packed,name=technology_rest_end_time,json=technologyRestEndTime" json:"technology_rest_end_time,omitempty"`
	TechnologySeekHelp            []bool                          `protobuf:"varint,52,rep,packed,name=technology_seek_help,json=technologySeekHelp" json:"technology_seek_help,omitempty"`
	CheckRemoveTechnologySeekHelp []bool                          `protobuf:"varint,55,rep,packed,name=check_remove_technology_seek_help,json=checkRemoveTechnologySeekHelp" json:"check_remove_technology_seek_help,omitempty"`
	GuildTechnology               []uint64                        `protobuf:"varint,56,rep,packed,name=guild_technology,json=guildTechnology" json:"guild_technology,omitempty"`
	DailyHelpMemberTimes          uint64                          `protobuf:"varint,53,opt,name=daily_help_member_times,json=dailyHelpMemberTimes,proto3" json:"daily_help_member_times,omitempty"`
	//    int32 start_recovery_forging_times_time = 25; // 开始恢复锻造次数的时间
	ForgingCombineTimes uint64   `protobuf:"varint,26,opt,name=forging_combine_times,json=forgingCombineTimes,proto3" json:"forging_combine_times,omitempty"`
	NewForgingPos       []uint64 `protobuf:"varint,46,rep,packed,name=new_forging_pos,json=newForgingPos" json:"new_forging_pos,omitempty"`
	// 装备作坊（新的锻造）
	WorkshopEquipmentIds    []uint64 `protobuf:"varint,61,rep,packed,name=workshop_equipment_ids,json=workshopEquipmentIds" json:"workshop_equipment_ids,omitempty"`
	WorkshopIndex           uint64   `protobuf:"varint,62,opt,name=workshop_index,json=workshopIndex,proto3" json:"workshop_index,omitempty"`
	WorkshopCollectTime     int64    `protobuf:"varint,63,opt,name=workshop_collect_time,json=workshopCollectTime,proto3" json:"workshop_collect_time,omitempty"`
	NextRefreshWorkshopTime int64    `protobuf:"varint,64,opt,name=next_refresh_workshop_time,json=nextRefreshWorkshopTime,proto3" json:"next_refresh_workshop_time,omitempty"`
	WorkshopRefreshTimes    uint64   `protobuf:"varint,65,opt,name=workshop_refresh_times,json=workshopRefreshTimes,proto3" json:"workshop_refresh_times,omitempty"`
	// 城内事件
	CityEvent                 *proto7.CityEventProto `protobuf:"bytes,30,opt,name=city_event,json=cityEvent" json:"city_event,omitempty"`
	NextCollectTimeType       []proto1.ResType       `protobuf:"varint,36,rep,packed,name=next_collect_time_type,json=nextCollectTimeType,enum=proto.ResType" json:"next_collect_time_type,omitempty"`
	NextCollectTime           []int64                `protobuf:"varint,37,rep,packed,name=next_collect_time,json=nextCollectTime" json:"next_collect_time,omitempty"`
	DailyResourceCollectTimes uint64                 `protobuf:"varint,38,opt,name=daily_resource_collect_times,json=dailyResourceCollectTimes,proto3" json:"daily_resource_collect_times,omitempty"`
	// 签名
	Sign string `protobuf:"bytes,40,opt,name=sign,proto3" json:"sign,omitempty"`
	// 语音
	Voice []byte `protobuf:"bytes,41,opt,name=voice,proto3" json:"voice,omitempty"`
	// 倒计时礼包
	CountdownPrize                                 *HeroCountdownPrizeServerProto `protobuf:"bytes,42,opt,name=countdown_prize,json=countdownPrize" json:"countdown_prize,omitempty"`
	CollectProsperityDownCountDownPrizeTimes       uint64                         `protobuf:"varint,43,opt,name=collectProsperityDownCountDownPrizeTimes,proto3" json:"collectProsperityDownCountDownPrizeTimes,omitempty"`
	NextCanCollectProsperityDownCountDownPrizeTime int64                          `protobuf:"varint,44,opt,name=nextCanCollectProsperityDownCountDownPrizeTime,proto3" json:"nextCanCollectProsperityDownCountDownPrizeTime,omitempty"`
	IsCollectSeasonPrize                           bool                           `protobuf:"varint,57,opt,name=is_collect_season_prize,json=isCollectSeasonPrize,proto3" json:"is_collect_season_prize,omitempty"`
}

func (m *HeroDomesticServerProto) Reset()                    { *m = HeroDomesticServerProto{} }
func (m *HeroDomesticServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroDomesticServerProto) ProtoMessage()               {}
func (*HeroDomesticServerProto) Descriptor() ([]byte, []int) { return fileDescriptorDomestic, []int{0} }

func (m *HeroDomesticServerProto) GetWorkerRestEndTime() []int32 {
	if m != nil {
		return m.WorkerRestEndTime
	}
	return nil
}

func (m *HeroDomesticServerProto) GetWorkerSeekHelp() []bool {
	if m != nil {
		return m.WorkerSeekHelp
	}
	return nil
}

func (m *HeroDomesticServerProto) GetCheckRemoveWorkerSeekHelp() []bool {
	if m != nil {
		return m.CheckRemoveWorkerSeekHelp
	}
	return nil
}

func (m *HeroDomesticServerProto) GetWorkerAlwaysUnlocked() []bool {
	if m != nil {
		return m.WorkerAlwaysUnlocked
	}
	return nil
}

func (m *HeroDomesticServerProto) GetWorkerLockStartTime() []int32 {
	if m != nil {
		return m.WorkerLockStartTime
	}
	return nil
}

func (m *HeroDomesticServerProto) GetBuilding() []uint64 {
	if m != nil {
		return m.Building
	}
	return nil
}

func (m *HeroDomesticServerProto) GetResourcePoint() []*HeroResourcePointServerProto {
	if m != nil {
		return m.ResourcePoint
	}
	return nil
}

func (m *HeroDomesticServerProto) GetConflictResourcePoints() []uint64 {
	if m != nil {
		return m.ConflictResourcePoints
	}
	return nil
}

func (m *HeroDomesticServerProto) GetCities() *proto7.OuterCitiesProto {
	if m != nil {
		return m.Cities
	}
	return nil
}

func (m *HeroDomesticServerProto) GetTechnology() []uint64 {
	if m != nil {
		return m.Technology
	}
	return nil
}

func (m *HeroDomesticServerProto) GetTechnologyRestEndTime() []int32 {
	if m != nil {
		return m.TechnologyRestEndTime
	}
	return nil
}

func (m *HeroDomesticServerProto) GetTechnologySeekHelp() []bool {
	if m != nil {
		return m.TechnologySeekHelp
	}
	return nil
}

func (m *HeroDomesticServerProto) GetCheckRemoveTechnologySeekHelp() []bool {
	if m != nil {
		return m.CheckRemoveTechnologySeekHelp
	}
	return nil
}

func (m *HeroDomesticServerProto) GetGuildTechnology() []uint64 {
	if m != nil {
		return m.GuildTechnology
	}
	return nil
}

func (m *HeroDomesticServerProto) GetDailyHelpMemberTimes() uint64 {
	if m != nil {
		return m.DailyHelpMemberTimes
	}
	return 0
}

func (m *HeroDomesticServerProto) GetForgingCombineTimes() uint64 {
	if m != nil {
		return m.ForgingCombineTimes
	}
	return 0
}

func (m *HeroDomesticServerProto) GetNewForgingPos() []uint64 {
	if m != nil {
		return m.NewForgingPos
	}
	return nil
}

func (m *HeroDomesticServerProto) GetWorkshopEquipmentIds() []uint64 {
	if m != nil {
		return m.WorkshopEquipmentIds
	}
	return nil
}

func (m *HeroDomesticServerProto) GetWorkshopIndex() uint64 {
	if m != nil {
		return m.WorkshopIndex
	}
	return 0
}

func (m *HeroDomesticServerProto) GetWorkshopCollectTime() int64 {
	if m != nil {
		return m.WorkshopCollectTime
	}
	return 0
}

func (m *HeroDomesticServerProto) GetNextRefreshWorkshopTime() int64 {
	if m != nil {
		return m.NextRefreshWorkshopTime
	}
	return 0
}

func (m *HeroDomesticServerProto) GetWorkshopRefreshTimes() uint64 {
	if m != nil {
		return m.WorkshopRefreshTimes
	}
	return 0
}

func (m *HeroDomesticServerProto) GetCityEvent() *proto7.CityEventProto {
	if m != nil {
		return m.CityEvent
	}
	return nil
}

func (m *HeroDomesticServerProto) GetNextCollectTimeType() []proto1.ResType {
	if m != nil {
		return m.NextCollectTimeType
	}
	return nil
}

func (m *HeroDomesticServerProto) GetNextCollectTime() []int64 {
	if m != nil {
		return m.NextCollectTime
	}
	return nil
}

func (m *HeroDomesticServerProto) GetDailyResourceCollectTimes() uint64 {
	if m != nil {
		return m.DailyResourceCollectTimes
	}
	return 0
}

func (m *HeroDomesticServerProto) GetSign() string {
	if m != nil {
		return m.Sign
	}
	return ""
}

func (m *HeroDomesticServerProto) GetVoice() []byte {
	if m != nil {
		return m.Voice
	}
	return nil
}

func (m *HeroDomesticServerProto) GetCountdownPrize() *HeroCountdownPrizeServerProto {
	if m != nil {
		return m.CountdownPrize
	}
	return nil
}

func (m *HeroDomesticServerProto) GetCollectProsperityDownCountDownPrizeTimes() uint64 {
	if m != nil {
		return m.CollectProsperityDownCountDownPrizeTimes
	}
	return 0
}

func (m *HeroDomesticServerProto) GetNextCanCollectProsperityDownCountDownPrizeTime() int64 {
	if m != nil {
		return m.NextCanCollectProsperityDownCountDownPrizeTime
	}
	return 0
}

func (m *HeroDomesticServerProto) GetIsCollectSeasonPrize() bool {
	if m != nil {
		return m.IsCollectSeasonPrize
	}
	return false
}

type HeroCountdownPrizeServerProto struct {
	Id          uint64             `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Prize       *proto1.PrizeProto `protobuf:"bytes,2,opt,name=prize" json:"prize,omitempty"`
	CollectTime int64              `protobuf:"varint,3,opt,name=collect_time,json=collectTime,proto3" json:"collect_time,omitempty"`
	DescId      uint64             `protobuf:"varint,4,opt,name=desc_id,json=descId,proto3" json:"desc_id,omitempty"`
}

func (m *HeroCountdownPrizeServerProto) Reset()         { *m = HeroCountdownPrizeServerProto{} }
func (m *HeroCountdownPrizeServerProto) String() string { return proto.CompactTextString(m) }
func (*HeroCountdownPrizeServerProto) ProtoMessage()    {}
func (*HeroCountdownPrizeServerProto) Descriptor() ([]byte, []int) {
	return fileDescriptorDomestic, []int{1}
}

func (m *HeroCountdownPrizeServerProto) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *HeroCountdownPrizeServerProto) GetPrize() *proto1.PrizeProto {
	if m != nil {
		return m.Prize
	}
	return nil
}

func (m *HeroCountdownPrizeServerProto) GetCollectTime() int64 {
	if m != nil {
		return m.CollectTime
	}
	return 0
}

func (m *HeroCountdownPrizeServerProto) GetDescId() uint64 {
	if m != nil {
		return m.DescId
	}
	return 0
}

type HeroResourcePointServerProto struct {
	// 资源点信息
	LayoutId        uint64 `protobuf:"varint,1,opt,name=layout_id,json=layoutId,proto3" json:"layout_id,omitempty"`
	BuildingId      uint64 `protobuf:"varint,2,opt,name=building_id,json=buildingId,proto3" json:"building_id,omitempty"`
	OutputStartTime int64  `protobuf:"varint,11,opt,name=output_start_time,json=outputStartTime,proto3" json:"output_start_time,omitempty"`
}

func (m *HeroResourcePointServerProto) Reset()         { *m = HeroResourcePointServerProto{} }
func (m *HeroResourcePointServerProto) String() string { return proto.CompactTextString(m) }
func (*HeroResourcePointServerProto) ProtoMessage()    {}
func (*HeroResourcePointServerProto) Descriptor() ([]byte, []int) {
	return fileDescriptorDomestic, []int{2}
}

func (m *HeroResourcePointServerProto) GetLayoutId() uint64 {
	if m != nil {
		return m.LayoutId
	}
	return 0
}

func (m *HeroResourcePointServerProto) GetBuildingId() uint64 {
	if m != nil {
		return m.BuildingId
	}
	return 0
}

func (m *HeroResourcePointServerProto) GetOutputStartTime() int64 {
	if m != nil {
		return m.OutputStartTime
	}
	return 0
}

func init() {
	proto.RegisterType((*HeroDomesticServerProto)(nil), "proto.HeroDomesticServerProto")
	proto.RegisterType((*HeroCountdownPrizeServerProto)(nil), "proto.HeroCountdownPrizeServerProto")
	proto.RegisterType((*HeroResourcePointServerProto)(nil), "proto.HeroResourcePointServerProto")
}
func (m *HeroDomesticServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroDomesticServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.WorkerRestEndTime) > 0 {
		dAtA2 := make([]byte, len(m.WorkerRestEndTime)*10)
		var j1 int
		for _, num1 := range m.WorkerRestEndTime {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if len(m.Building) > 0 {
		dAtA4 := make([]byte, len(m.Building)*10)
		var j3 int
		for _, num := range m.Building {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if len(m.ResourcePoint) > 0 {
		for _, msg := range m.ResourcePoint {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDomestic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ConflictResourcePoints) > 0 {
		dAtA6 := make([]byte, len(m.ConflictResourcePoints)*10)
		var j5 int
		for _, num := range m.ConflictResourcePoints {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if len(m.Technology) > 0 {
		dAtA8 := make([]byte, len(m.Technology)*10)
		var j7 int
		for _, num := range m.Technology {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if len(m.TechnologyRestEndTime) > 0 {
		dAtA10 := make([]byte, len(m.TechnologyRestEndTime)*10)
		var j9 int
		for _, num1 := range m.TechnologyRestEndTime {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	if m.Cities != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Cities.Size()))
		n11, err := m.Cities.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.ForgingCombineTimes != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.ForgingCombineTimes))
	}
	if m.CityEvent != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.CityEvent.Size()))
		n12, err := m.CityEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.NextCollectTimeType) > 0 {
		dAtA14 := make([]byte, len(m.NextCollectTimeType)*10)
		var j13 int
		for _, num := range m.NextCollectTimeType {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if len(m.NextCollectTime) > 0 {
		dAtA16 := make([]byte, len(m.NextCollectTime)*10)
		var j15 int
		for _, num1 := range m.NextCollectTime {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(j15))
		i += copy(dAtA[i:], dAtA16[:j15])
	}
	if m.DailyResourceCollectTimes != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.DailyResourceCollectTimes))
	}
	if len(m.Sign) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Sign)))
		i += copy(dAtA[i:], m.Sign)
	}
	if len(m.Voice) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.Voice)))
		i += copy(dAtA[i:], m.Voice)
	}
	if m.CountdownPrize != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.CountdownPrize.Size()))
		n17, err := m.CountdownPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.CollectProsperityDownCountDownPrizeTimes != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.CollectProsperityDownCountDownPrizeTimes))
	}
	if m.NextCanCollectProsperityDownCountDownPrizeTime != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.NextCanCollectProsperityDownCountDownPrizeTime))
	}
	if len(m.NewForgingPos) > 0 {
		dAtA19 := make([]byte, len(m.NewForgingPos)*10)
		var j18 int
		for _, num := range m.NewForgingPos {
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(j18))
		i += copy(dAtA[i:], dAtA19[:j18])
	}
	if len(m.WorkerSeekHelp) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.WorkerSeekHelp)))
		for _, b := range m.WorkerSeekHelp {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.TechnologySeekHelp) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.TechnologySeekHelp)))
		for _, b := range m.TechnologySeekHelp {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if m.DailyHelpMemberTimes != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.DailyHelpMemberTimes))
	}
	if len(m.CheckRemoveWorkerSeekHelp) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.CheckRemoveWorkerSeekHelp)))
		for _, b := range m.CheckRemoveWorkerSeekHelp {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.CheckRemoveTechnologySeekHelp) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.CheckRemoveTechnologySeekHelp)))
		for _, b := range m.CheckRemoveTechnologySeekHelp {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.GuildTechnology) > 0 {
		dAtA21 := make([]byte, len(m.GuildTechnology)*10)
		var j20 int
		for _, num := range m.GuildTechnology {
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(j20))
		i += copy(dAtA[i:], dAtA21[:j20])
	}
	if m.IsCollectSeasonPrize {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x3
		i++
		if m.IsCollectSeasonPrize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.WorkshopEquipmentIds) > 0 {
		dAtA23 := make([]byte, len(m.WorkshopEquipmentIds)*10)
		var j22 int
		for _, num := range m.WorkshopEquipmentIds {
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(j22))
		i += copy(dAtA[i:], dAtA23[:j22])
	}
	if m.WorkshopIndex != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.WorkshopIndex))
	}
	if m.WorkshopCollectTime != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.WorkshopCollectTime))
	}
	if m.NextRefreshWorkshopTime != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.NextRefreshWorkshopTime))
	}
	if m.WorkshopRefreshTimes != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.WorkshopRefreshTimes))
	}
	if len(m.WorkerAlwaysUnlocked) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(len(m.WorkerAlwaysUnlocked)))
		for _, b := range m.WorkerAlwaysUnlocked {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.WorkerLockStartTime) > 0 {
		dAtA25 := make([]byte, len(m.WorkerLockStartTime)*10)
		var j24 int
		for _, num1 := range m.WorkerLockStartTime {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(j24))
		i += copy(dAtA[i:], dAtA25[:j24])
	}
	return i, nil
}

func (m *HeroCountdownPrizeServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroCountdownPrizeServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Id))
	}
	if m.Prize != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.Prize.Size()))
		n26, err := m.Prize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.CollectTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.CollectTime))
	}
	if m.DescId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.DescId))
	}
	return i, nil
}

func (m *HeroResourcePointServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroResourcePointServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LayoutId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.LayoutId))
	}
	if m.BuildingId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.BuildingId))
	}
	if m.OutputStartTime != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintDomestic(dAtA, i, uint64(m.OutputStartTime))
	}
	return i, nil
}

func encodeFixed64Domestic(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Domestic(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintDomestic(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HeroDomesticServerProto) Size() (n int) {
	var l int
	_ = l
	if len(m.WorkerRestEndTime) > 0 {
		l = 0
		for _, e := range m.WorkerRestEndTime {
			l += sovDomestic(uint64(e))
		}
		n += 2 + sovDomestic(uint64(l)) + l
	}
	if len(m.Building) > 0 {
		l = 0
		for _, e := range m.Building {
			l += sovDomestic(uint64(e))
		}
		n += 2 + sovDomestic(uint64(l)) + l
	}
	if len(m.ResourcePoint) > 0 {
		for _, e := range m.ResourcePoint {
			l = e.Size()
			n += 2 + l + sovDomestic(uint64(l))
		}
	}
	if len(m.ConflictResourcePoints) > 0 {
		l = 0
		for _, e := range m.ConflictResourcePoints {
			l += sovDomestic(uint64(e))
		}
		n += 2 + sovDomestic(uint64(l)) + l
	}
	if len(m.Technology) > 0 {
		l = 0
		for _, e := range m.Technology {
			l += sovDomestic(uint64(e))
		}
		n += 2 + sovDomestic(uint64(l)) + l
	}
	if len(m.TechnologyRestEndTime) > 0 {
		l = 0
		for _, e := range m.TechnologyRestEndTime {
			l += sovDomestic(uint64(e))
		}
		n += 2 + sovDomestic(uint64(l)) + l
	}
	if m.Cities != nil {
		l = m.Cities.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if m.ForgingCombineTimes != 0 {
		n += 2 + sovDomestic(uint64(m.ForgingCombineTimes))
	}
	if m.CityEvent != nil {
		l = m.CityEvent.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if len(m.NextCollectTimeType) > 0 {
		l = 0
		for _, e := range m.NextCollectTimeType {
			l += sovDomestic(uint64(e))
		}
		n += 2 + sovDomestic(uint64(l)) + l
	}
	if len(m.NextCollectTime) > 0 {
		l = 0
		for _, e := range m.NextCollectTime {
			l += sovDomestic(uint64(e))
		}
		n += 2 + sovDomestic(uint64(l)) + l
	}
	if m.DailyResourceCollectTimes != 0 {
		n += 2 + sovDomestic(uint64(m.DailyResourceCollectTimes))
	}
	l = len(m.Sign)
	if l > 0 {
		n += 2 + l + sovDomestic(uint64(l))
	}
	l = len(m.Voice)
	if l > 0 {
		n += 2 + l + sovDomestic(uint64(l))
	}
	if m.CountdownPrize != nil {
		l = m.CountdownPrize.Size()
		n += 2 + l + sovDomestic(uint64(l))
	}
	if m.CollectProsperityDownCountDownPrizeTimes != 0 {
		n += 2 + sovDomestic(uint64(m.CollectProsperityDownCountDownPrizeTimes))
	}
	if m.NextCanCollectProsperityDownCountDownPrizeTime != 0 {
		n += 2 + sovDomestic(uint64(m.NextCanCollectProsperityDownCountDownPrizeTime))
	}
	if len(m.NewForgingPos) > 0 {
		l = 0
		for _, e := range m.NewForgingPos {
			l += sovDomestic(uint64(e))
		}
		n += 2 + sovDomestic(uint64(l)) + l
	}
	if len(m.WorkerSeekHelp) > 0 {
		n += 2 + sovDomestic(uint64(len(m.WorkerSeekHelp))) + len(m.WorkerSeekHelp)*1
	}
	if len(m.TechnologySeekHelp) > 0 {
		n += 2 + sovDomestic(uint64(len(m.TechnologySeekHelp))) + len(m.TechnologySeekHelp)*1
	}
	if m.DailyHelpMemberTimes != 0 {
		n += 2 + sovDomestic(uint64(m.DailyHelpMemberTimes))
	}
	if len(m.CheckRemoveWorkerSeekHelp) > 0 {
		n += 2 + sovDomestic(uint64(len(m.CheckRemoveWorkerSeekHelp))) + len(m.CheckRemoveWorkerSeekHelp)*1
	}
	if len(m.CheckRemoveTechnologySeekHelp) > 0 {
		n += 2 + sovDomestic(uint64(len(m.CheckRemoveTechnologySeekHelp))) + len(m.CheckRemoveTechnologySeekHelp)*1
	}
	if len(m.GuildTechnology) > 0 {
		l = 0
		for _, e := range m.GuildTechnology {
			l += sovDomestic(uint64(e))
		}
		n += 2 + sovDomestic(uint64(l)) + l
	}
	if m.IsCollectSeasonPrize {
		n += 3
	}
	if len(m.WorkshopEquipmentIds) > 0 {
		l = 0
		for _, e := range m.WorkshopEquipmentIds {
			l += sovDomestic(uint64(e))
		}
		n += 2 + sovDomestic(uint64(l)) + l
	}
	if m.WorkshopIndex != 0 {
		n += 2 + sovDomestic(uint64(m.WorkshopIndex))
	}
	if m.WorkshopCollectTime != 0 {
		n += 2 + sovDomestic(uint64(m.WorkshopCollectTime))
	}
	if m.NextRefreshWorkshopTime != 0 {
		n += 2 + sovDomestic(uint64(m.NextRefreshWorkshopTime))
	}
	if m.WorkshopRefreshTimes != 0 {
		n += 2 + sovDomestic(uint64(m.WorkshopRefreshTimes))
	}
	if len(m.WorkerAlwaysUnlocked) > 0 {
		n += 2 + sovDomestic(uint64(len(m.WorkerAlwaysUnlocked))) + len(m.WorkerAlwaysUnlocked)*1
	}
	if len(m.WorkerLockStartTime) > 0 {
		l = 0
		for _, e := range m.WorkerLockStartTime {
			l += sovDomestic(uint64(e))
		}
		n += 2 + sovDomestic(uint64(l)) + l
	}
	return n
}

func (m *HeroCountdownPrizeServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDomestic(uint64(m.Id))
	}
	if m.Prize != nil {
		l = m.Prize.Size()
		n += 1 + l + sovDomestic(uint64(l))
	}
	if m.CollectTime != 0 {
		n += 1 + sovDomestic(uint64(m.CollectTime))
	}
	if m.DescId != 0 {
		n += 1 + sovDomestic(uint64(m.DescId))
	}
	return n
}

func (m *HeroResourcePointServerProto) Size() (n int) {
	var l int
	_ = l
	if m.LayoutId != 0 {
		n += 1 + sovDomestic(uint64(m.LayoutId))
	}
	if m.BuildingId != 0 {
		n += 1 + sovDomestic(uint64(m.BuildingId))
	}
	if m.OutputStartTime != 0 {
		n += 1 + sovDomestic(uint64(m.OutputStartTime))
	}
	return n
}

func sovDomestic(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDomestic(x uint64) (n int) {
	return sovDomestic(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HeroDomesticServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroDomesticServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroDomesticServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WorkerRestEndTime = append(m.WorkerRestEndTime, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WorkerRestEndTime = append(m.WorkerRestEndTime, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerRestEndTime", wireType)
			}
		case 18:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Building = append(m.Building, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Building = append(m.Building, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Building", wireType)
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourcePoint = append(m.ResourcePoint, &HeroResourcePointServerProto{})
			if err := m.ResourcePoint[len(m.ResourcePoint)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ConflictResourcePoints = append(m.ConflictResourcePoints, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ConflictResourcePoints = append(m.ConflictResourcePoints, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ConflictResourcePoints", wireType)
			}
		case 21:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Technology = append(m.Technology, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Technology = append(m.Technology, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Technology", wireType)
			}
		case 22:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TechnologyRestEndTime = append(m.TechnologyRestEndTime, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TechnologyRestEndTime = append(m.TechnologyRestEndTime, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TechnologyRestEndTime", wireType)
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cities == nil {
				m.Cities = &proto7.OuterCitiesProto{}
			}
			if err := m.Cities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForgingCombineTimes", wireType)
			}
			m.ForgingCombineTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForgingCombineTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CityEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CityEvent == nil {
				m.CityEvent = &proto7.CityEventProto{}
			}
			if err := m.CityEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType == 0 {
				var v proto1.ResType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (proto1.ResType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NextCollectTimeType = append(m.NextCollectTimeType, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v proto1.ResType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (proto1.ResType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NextCollectTimeType = append(m.NextCollectTimeType, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NextCollectTimeType", wireType)
			}
		case 37:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NextCollectTime = append(m.NextCollectTime, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NextCollectTime = append(m.NextCollectTime, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NextCollectTime", wireType)
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyResourceCollectTimes", wireType)
			}
			m.DailyResourceCollectTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailyResourceCollectTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voice", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voice = append(m.Voice[:0], dAtA[iNdEx:postIndex]...)
			if m.Voice == nil {
				m.Voice = []byte{}
			}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountdownPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CountdownPrize == nil {
				m.CountdownPrize = &HeroCountdownPrizeServerProto{}
			}
			if err := m.CountdownPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectProsperityDownCountDownPrizeTimes", wireType)
			}
			m.CollectProsperityDownCountDownPrizeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectProsperityDownCountDownPrizeTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextCanCollectProsperityDownCountDownPrizeTime", wireType)
			}
			m.NextCanCollectProsperityDownCountDownPrizeTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextCanCollectProsperityDownCountDownPrizeTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NewForgingPos = append(m.NewForgingPos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NewForgingPos = append(m.NewForgingPos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NewForgingPos", wireType)
			}
		case 51:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WorkerSeekHelp = append(m.WorkerSeekHelp, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WorkerSeekHelp = append(m.WorkerSeekHelp, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerSeekHelp", wireType)
			}
		case 52:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TechnologySeekHelp = append(m.TechnologySeekHelp, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TechnologySeekHelp = append(m.TechnologySeekHelp, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TechnologySeekHelp", wireType)
			}
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyHelpMemberTimes", wireType)
			}
			m.DailyHelpMemberTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailyHelpMemberTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 54:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CheckRemoveWorkerSeekHelp = append(m.CheckRemoveWorkerSeekHelp, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CheckRemoveWorkerSeekHelp = append(m.CheckRemoveWorkerSeekHelp, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckRemoveWorkerSeekHelp", wireType)
			}
		case 55:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CheckRemoveTechnologySeekHelp = append(m.CheckRemoveTechnologySeekHelp, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CheckRemoveTechnologySeekHelp = append(m.CheckRemoveTechnologySeekHelp, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckRemoveTechnologySeekHelp", wireType)
			}
		case 56:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GuildTechnology = append(m.GuildTechnology, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GuildTechnology = append(m.GuildTechnology, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildTechnology", wireType)
			}
		case 57:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCollectSeasonPrize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCollectSeasonPrize = bool(v != 0)
		case 61:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WorkshopEquipmentIds = append(m.WorkshopEquipmentIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WorkshopEquipmentIds = append(m.WorkshopEquipmentIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopEquipmentIds", wireType)
			}
		case 62:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopIndex", wireType)
			}
			m.WorkshopIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 63:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopCollectTime", wireType)
			}
			m.WorkshopCollectTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopCollectTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 64:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextRefreshWorkshopTime", wireType)
			}
			m.NextRefreshWorkshopTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextRefreshWorkshopTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 65:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopRefreshTimes", wireType)
			}
			m.WorkshopRefreshTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopRefreshTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 66:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WorkerAlwaysUnlocked = append(m.WorkerAlwaysUnlocked, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WorkerAlwaysUnlocked = append(m.WorkerAlwaysUnlocked, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerAlwaysUnlocked", wireType)
			}
		case 67:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WorkerLockStartTime = append(m.WorkerLockStartTime, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomestic
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomestic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WorkerLockStartTime = append(m.WorkerLockStartTime, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerLockStartTime", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroCountdownPrizeServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroCountdownPrizeServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroCountdownPrizeServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomestic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prize == nil {
				m.Prize = &proto1.PrizeProto{}
			}
			if err := m.Prize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectTime", wireType)
			}
			m.CollectTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescId", wireType)
			}
			m.DescId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroResourcePointServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroResourcePointServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroResourcePointServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LayoutId", wireType)
			}
			m.LayoutId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LayoutId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingId", wireType)
			}
			m.BuildingId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputStartTime", wireType)
			}
			m.OutputStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomestic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomestic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDomestic(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDomestic
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDomestic
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDomestic
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDomestic
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDomestic(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDomestic = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDomestic   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/server_proto/domestic.proto", fileDescriptorDomestic)
}

var fileDescriptorDomestic = []byte{
	// 1046 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xdd, 0x52, 0x23, 0x45,
	0x14, 0x76, 0x08, 0x20, 0x34, 0x10, 0xa0, 0x09, 0xa4, 0x17, 0x97, 0x38, 0x8b, 0xbb, 0xeb, 0xec,
	0x6a, 0x11, 0x0b, 0x58, 0xc1, 0xb2, 0x74, 0x7f, 0x02, 0x16, 0x58, 0x6e, 0x49, 0x0d, 0x58, 0x5b,
	0xb5, 0x37, 0x5d, 0xc9, 0xcc, 0x21, 0xe9, 0xca, 0x64, 0x7a, 0x9c, 0xee, 0x90, 0x8d, 0x4f, 0xe0,
	0x03, 0x78, 0xe1, 0x23, 0x79, 0xe9, 0x23, 0x58, 0x78, 0xe1, 0x6b, 0x58, 0x7d, 0x7a, 0x26, 0x99,
	0x2c, 0x16, 0x85, 0x57, 0x93, 0x3e, 0xdf, 0x77, 0xfe, 0x4f, 0x9f, 0x0e, 0x39, 0x6c, 0x0b, 0xdd,
	0xe9, 0xb7, 0x76, 0x02, 0xd9, 0xab, 0x47, 0xa2, 0xdd, 0xd1, 0x49, 0x73, 0x50, 0xef, 0x35, 0x23,
	0x38, 0xa8, 0x27, 0xad, 0xba, 0x82, 0xf4, 0x0a, 0x52, 0x9e, 0xa4, 0x52, 0xcb, 0x7a, 0x28, 0x7b,
	0xa0, 0xb4, 0x08, 0x76, 0xf0, 0x48, 0x67, 0xf0, 0xb3, 0xb9, 0x7f, 0xbb, 0x81, 0x4e, 0x33, 0x85,
	0x30, 0x33, 0xd0, 0x6a, 0x2a, 0xb0, 0xca, 0x9b, 0x87, 0x77, 0xd7, 0x9a, 0x74, 0xbb, 0xfd, 0xcf,
	0x12, 0xa9, 0x9e, 0x40, 0x2a, 0x8f, 0x32, 0xf1, 0x39, 0x86, 0x78, 0x86, 0x21, 0xd5, 0x49, 0x65,
	0x20, 0xd3, 0x2e, 0xa4, 0x3c, 0x05, 0xa5, 0x39, 0xc4, 0x21, 0xd7, 0xa2, 0x07, 0x6c, 0xc5, 0x2d,
	0x79, 0x33, 0xfe, 0xaa, 0xc5, 0x7c, 0x50, 0xfa, 0x38, 0x0e, 0x2f, 0x44, 0x0f, 0xe8, 0x26, 0x99,
	0x6b, 0xf5, 0x45, 0x14, 0x8a, 0xb8, 0xcd, 0xa8, 0x5b, 0xf2, 0xa6, 0xfd, 0xd1, 0x99, 0x7e, 0x4f,
	0xca, 0x29, 0x28, 0xd9, 0x4f, 0x03, 0xe0, 0x89, 0x14, 0xb1, 0x66, 0x6b, 0x6e, 0xc9, 0x5b, 0xd8,
	0xfd, 0xc4, 0x06, 0xb2, 0x63, 0x82, 0xf0, 0x33, 0xc2, 0x99, 0xc1, 0x0b, 0x91, 0xf8, 0x4b, 0x69,
	0x11, 0xa1, 0x87, 0x84, 0x05, 0x32, 0xbe, 0x8c, 0x44, 0xa0, 0xf9, 0xa4, 0x51, 0xc5, 0x2a, 0xe8,
	0x77, 0x23, 0xc7, 0x27, 0x4c, 0x2a, 0x5a, 0x23, 0x44, 0x43, 0xd0, 0x89, 0x65, 0x24, 0xdb, 0x43,
	0xb6, 0x8e, 0xdc, 0x82, 0x84, 0x1e, 0x10, 0x36, 0x3e, 0xbd, 0x97, 0xf6, 0x06, 0xa6, 0xbd, 0x3e,
	0xc6, 0x8b, 0xa9, 0xd7, 0xc9, 0x6c, 0x20, 0xb4, 0x00, 0xc5, 0xaa, 0xae, 0xe3, 0x2d, 0xec, 0x56,
	0xb3, 0xb4, 0x7e, 0xec, 0x6b, 0x48, 0x1b, 0x88, 0xd8, 0x54, 0x32, 0x1a, 0xdd, 0x25, 0xeb, 0x97,
	0x32, 0x6d, 0x8b, 0xb8, 0xcd, 0x03, 0xd9, 0x6b, 0x89, 0x18, 0xd0, 0x8b, 0x62, 0x9b, 0xae, 0xe3,
	0x4d, 0xfb, 0x6b, 0x19, 0xd8, 0xb0, 0x98, 0xf1, 0xa1, 0xe8, 0x3e, 0x21, 0x81, 0xd0, 0x43, 0x0e,
	0x57, 0x10, 0x6b, 0x56, 0x43, 0x47, 0xeb, 0x99, 0xa3, 0x86, 0xd0, 0xc3, 0x63, 0x23, 0xb7, 0x6e,
	0xe6, 0x83, 0xfc, 0x4c, 0x1b, 0x64, 0x23, 0x86, 0x77, 0x9a, 0x07, 0x32, 0x8a, 0x20, 0xd0, 0xe8,
	0x86, 0xeb, 0x61, 0x02, 0xec, 0xa1, 0x5b, 0xf2, 0xca, 0xbb, 0xe5, 0xcc, 0x82, 0x0f, 0xea, 0x62,
	0x98, 0x80, 0xbf, 0x66, 0xd8, 0x0d, 0x4b, 0x36, 0x7e, 0x8d, 0x90, 0x3e, 0x25, 0xab, 0x37, 0x8c,
	0xb0, 0x47, 0x6e, 0xc9, 0x2b, 0xf9, 0xcb, 0xef, 0xf1, 0xe9, 0x73, 0x72, 0x3f, 0x6c, 0x8a, 0x68,
	0x38, 0xee, 0x4d, 0x51, 0x4b, 0xb1, 0xc7, 0x98, 0xe1, 0x3d, 0xe4, 0xe4, 0xfd, 0x29, 0xe8, 0x2b,
	0x4a, 0xc9, 0xb4, 0x12, 0xed, 0x98, 0x79, 0xae, 0xe3, 0xcd, 0xfb, 0xf8, 0x9b, 0x56, 0xc8, 0xcc,
	0x95, 0x14, 0x01, 0xb0, 0x27, 0xae, 0xe3, 0x2d, 0xfa, 0xf6, 0x40, 0x5f, 0x93, 0xe5, 0x40, 0xf6,
	0x63, 0x1d, 0xca, 0x41, 0xcc, 0x93, 0x54, 0xfc, 0x02, 0xec, 0x29, 0x96, 0xe5, 0x61, 0x61, 0xac,
	0x1a, 0x39, 0xe3, 0xcc, 0x10, 0x8a, 0x73, 0x55, 0x0e, 0x26, 0x20, 0xfa, 0x96, 0x78, 0x59, 0xa8,
	0x67, 0xa9, 0x54, 0x09, 0xa4, 0x42, 0x0f, 0x8f, 0xe4, 0x20, 0x46, 0x0b, 0x47, 0x39, 0x0d, 0x83,
	0x64, 0x9f, 0x61, 0x16, 0x77, 0xe6, 0xd3, 0x4b, 0xb2, 0x83, 0x85, 0x6a, 0xc6, 0x8d, 0xbb, 0xa9,
	0xb0, 0xcf, 0x5d, 0xc7, 0x2b, 0xf9, 0xff, 0x53, 0x8b, 0x3e, 0x26, 0xcb, 0x31, 0x0c, 0x78, 0x3e,
	0x5c, 0x89, 0x54, 0x6c, 0x07, 0xe7, 0x7c, 0x29, 0x86, 0xc1, 0x77, 0x56, 0x7a, 0x26, 0x15, 0xf5,
	0xc8, 0x4a, 0x76, 0xbb, 0x15, 0x40, 0x97, 0x77, 0x20, 0x4a, 0xd8, 0x9e, 0x5b, 0xf2, 0xe6, 0xfc,
	0xb2, 0x95, 0x9f, 0x03, 0x74, 0x4f, 0x20, 0x4a, 0xe8, 0x17, 0xa4, 0x52, 0xb8, 0x14, 0x63, 0xf6,
	0x3e, 0xb2, 0xe9, 0x18, 0x1b, 0x69, 0x3c, 0x23, 0x55, 0x3b, 0x01, 0x86, 0xc7, 0x7b, 0xd0, 0x6b,
	0x41, 0x9a, 0x35, 0xff, 0x19, 0x96, 0xad, 0x82, 0xb0, 0xe1, 0xbe, 0x46, 0xd0, 0x96, 0xe8, 0x05,
	0xd9, 0x0a, 0x3a, 0x10, 0x74, 0x79, 0x0a, 0x3d, 0x79, 0x05, 0xfc, 0x46, 0x7c, 0x5f, 0xa2, 0xc7,
	0x7b, 0x48, 0xf2, 0x91, 0xf3, 0x66, 0x32, 0xd4, 0x13, 0xf2, 0x60, 0xc2, 0xc2, 0x7f, 0xc6, 0x7d,
	0x80, 0x56, 0xb6, 0x0a, 0x56, 0x2e, 0x6e, 0xa6, 0xf0, 0x84, 0xac, 0xb4, 0xcd, 0xee, 0x2a, 0x98,
	0x60, 0x87, 0x58, 0xc7, 0x65, 0x94, 0x8f, 0x55, 0x4c, 0xb6, 0x42, 0x8d, 0x66, 0x5c, 0x41, 0x53,
	0xc9, 0x7c, 0x18, 0xbf, 0x72, 0x1d, 0x6f, 0xce, 0xaf, 0x08, 0x95, 0x75, 0xef, 0x1c, 0x41, 0x3b,
	0x6c, 0xfb, 0x64, 0xc3, 0x24, 0xa8, 0x3a, 0x32, 0xe1, 0xf0, 0x73, 0x5f, 0x24, 0x3d, 0x88, 0x35,
	0x17, 0xa1, 0x62, 0xdf, 0xa0, 0x9f, 0x4a, 0x8e, 0x1e, 0xe7, 0xe0, 0x69, 0xa8, 0xe8, 0x23, 0x52,
	0x1e, 0x69, 0x89, 0x38, 0x84, 0x77, 0xec, 0x5b, 0xac, 0xe8, 0x52, 0x2e, 0x3d, 0x35, 0x42, 0xb3,
	0x5e, 0x46, 0xb4, 0x89, 0x3b, 0xfb, 0x1c, 0x87, 0x6a, 0x2d, 0x07, 0x8b, 0xf7, 0xf6, 0x6b, 0xb2,
	0x89, 0x77, 0x3c, 0x85, 0xcb, 0x14, 0x54, 0x87, 0x8f, 0x0c, 0xa0, 0xe2, 0x0b, 0x54, 0xac, 0x1a,
	0x86, 0x6f, 0x09, 0x6f, 0x32, 0x1c, 0x95, 0x8b, 0xd9, 0xe4, 0x06, 0x6c, 0xc7, 0x5f, 0xda, 0x8e,
	0xe7, 0x68, 0xa6, 0x9c, 0x6f, 0xb4, 0x8d, 0xac, 0xc9, 0xcd, 0x68, 0xd0, 0x1c, 0x2a, 0xde, 0x8f,
	0x23, 0x19, 0x74, 0x21, 0x64, 0xaf, 0xb0, 0x49, 0xd9, 0x03, 0xf4, 0x12, 0xc1, 0x9f, 0x32, 0x8c,
	0xee, 0x8d, 0xb4, 0x8c, 0x80, 0x2b, 0xdd, 0x4c, 0xb3, 0xec, 0x1a, 0xb8, 0xa3, 0xd7, 0x2c, 0xfa,
	0x83, 0x0c, 0xba, 0xe7, 0x06, 0x33, 0xbe, 0xb6, 0x7f, 0x73, 0xc8, 0xd6, 0xad, 0xdb, 0x80, 0x96,
	0xc9, 0x94, 0x08, 0x99, 0x83, 0xe1, 0x4e, 0x89, 0x90, 0x7e, 0x4a, 0x66, 0x6c, 0x17, 0xa7, 0x70,
	0xa5, 0xac, 0x66, 0x2b, 0x05, 0xf5, 0xec, 0xfe, 0xb0, 0x38, 0x7d, 0x40, 0x16, 0x27, 0x6a, 0x5c,
	0xc2, 0x52, 0x2d, 0x04, 0x85, 0xda, 0x56, 0xc9, 0x87, 0x21, 0xa8, 0x80, 0x8b, 0x90, 0x4d, 0xa3,
	0x83, 0x59, 0x73, 0x3c, 0x0d, 0xb7, 0x7f, 0x75, 0xc8, 0xfd, 0xdb, 0xde, 0x3e, 0xfa, 0x11, 0x99,
	0x8f, 0x9a, 0x43, 0xd9, 0x37, 0xa3, 0x91, 0x05, 0x37, 0x67, 0x05, 0xa7, 0x21, 0xfd, 0x98, 0x2c,
	0xe4, 0x2f, 0xac, 0x81, 0xa7, 0x10, 0x26, 0xb9, 0xe8, 0x34, 0x34, 0x7b, 0x5b, 0xf6, 0x75, 0xd2,
	0xd7, 0xc5, 0x2a, 0x2d, 0x60, 0x7c, 0xcb, 0x16, 0x18, 0x55, 0xe8, 0x95, 0xfb, 0xc7, 0x75, 0xcd,
	0xf9, 0xf3, 0xba, 0xe6, 0xfc, 0x75, 0x5d, 0x73, 0x7e, 0xff, 0xbb, 0xf6, 0xc1, 0x89, 0xf3, 0x76,
	0xb1, 0xf8, 0x9f, 0xa5, 0x35, 0x8b, 0x9f, 0xbd, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x3a, 0xbf,
	0x4e, 0x3d, 0xe7, 0x08, 0x00, 0x00,
}
