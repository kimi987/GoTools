// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/server_proto/hero.proto
// DO NOT EDIT!

package server_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import proto15 "github.com/lightpaw/male7/pb/shared_proto"
import proto42 "github.com/lightpaw/male7/pb/shared_proto"
import proto23 "github.com/lightpaw/male7/pb/shared_proto"
import proto26 "github.com/lightpaw/male7/pb/shared_proto"
import proto12 "github.com/lightpaw/male7/pb/shared_proto"
import proto30 "github.com/lightpaw/male7/pb/shared_proto"
import proto27 "github.com/lightpaw/male7/pb/shared_proto"
import proto32 "github.com/lightpaw/male7/pb/shared_proto"
import proto1 "github.com/lightpaw/male7/pb/shared_proto"
import proto33 "github.com/lightpaw/male7/pb/shared_proto"
import proto18 "github.com/lightpaw/male7/pb/shared_proto"
import proto11 "github.com/lightpaw/male7/pb/shared_proto"
import proto22 "github.com/lightpaw/male7/pb/shared_proto"
import proto43 "github.com/lightpaw/male7/pb/shared_proto"
import proto34 "github.com/lightpaw/male7/pb/shared_proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// heroMap
type HeroMapCategory int32

const (
	HeroMapCategory_invalid_hero_map_category                HeroMapCategory = 0
	HeroMapCategory_daily_shop_goods                         HeroMapCategory = 1
	HeroMapCategory_history_amount                           HeroMapCategory = 2
	HeroMapCategory_daily_amount                             HeroMapCategory = 6
	HeroMapCategory_daily_guild_event_prize_trigger_times    HeroMapCategory = 3
	HeroMapCategory_history_guild_event_prize_trigger_times  HeroMapCategory = 4
	HeroMapCategory_daily_guild_event_prize_collect_times    HeroMapCategory = 5
	HeroMapCategory_daily_guild_prestige_event_trigger_times HeroMapCategory = 9
	HeroMapCategory_sys_broadcast_send_type                  HeroMapCategory = 7
	HeroMapCategory_daily_event_limit_gift                   HeroMapCategory = 8
	HeroMapCategory_client_keys                              HeroMapCategory = 10
	HeroMapCategory_login_day_prize                          HeroMapCategory = 11
	HeroMapCategory_hero_level_fund                          HeroMapCategory = 12
	HeroMapCategory_daily_sp_collection                      HeroMapCategory = 13
	HeroMapCategory_daily_free_gift_collection               HeroMapCategory = 14
	HeroMapCategory_free_gift_collection                     HeroMapCategory = 15
	HeroMapCategory_time_limit_gift_buy_times                HeroMapCategory = 16
	HeroMapCategory_event_limit_gift_buy_times               HeroMapCategory = 17
	HeroMapCategory_collected_charge_prizes                  HeroMapCategory = 18
	HeroMapCategory_daily_bought_bargain_times               HeroMapCategory = 19
	HeroMapCategory_daily_collected_duration_card_prizes     HeroMapCategory = 20
	HeroMapCategory_first_charged_objs                       HeroMapCategory = 21
)

var HeroMapCategory_name = map[int32]string{
	0:  "invalid_hero_map_category",
	1:  "daily_shop_goods",
	2:  "history_amount",
	6:  "daily_amount",
	3:  "daily_guild_event_prize_trigger_times",
	4:  "history_guild_event_prize_trigger_times",
	5:  "daily_guild_event_prize_collect_times",
	9:  "daily_guild_prestige_event_trigger_times",
	7:  "sys_broadcast_send_type",
	8:  "daily_event_limit_gift",
	10: "client_keys",
	11: "login_day_prize",
	12: "hero_level_fund",
	13: "daily_sp_collection",
	14: "daily_free_gift_collection",
	15: "free_gift_collection",
	16: "time_limit_gift_buy_times",
	17: "event_limit_gift_buy_times",
	18: "collected_charge_prizes",
	19: "daily_bought_bargain_times",
	20: "daily_collected_duration_card_prizes",
	21: "first_charged_objs",
}
var HeroMapCategory_value = map[string]int32{
	"invalid_hero_map_category":                0,
	"daily_shop_goods":                         1,
	"history_amount":                           2,
	"daily_amount":                             6,
	"daily_guild_event_prize_trigger_times":    3,
	"history_guild_event_prize_trigger_times":  4,
	"daily_guild_event_prize_collect_times":    5,
	"daily_guild_prestige_event_trigger_times": 9,
	"sys_broadcast_send_type":                  7,
	"daily_event_limit_gift":                   8,
	"client_keys":                              10,
	"login_day_prize":                          11,
	"hero_level_fund":                          12,
	"daily_sp_collection":                      13,
	"daily_free_gift_collection":               14,
	"free_gift_collection":                     15,
	"time_limit_gift_buy_times":                16,
	"event_limit_gift_buy_times":               17,
	"collected_charge_prizes":                  18,
	"daily_bought_bargain_times":               19,
	"daily_collected_duration_card_prizes":     20,
	"first_charged_objs":                       21,
}

func (x HeroMapCategory) String() string {
	return proto.EnumName(HeroMapCategory_name, int32(x))
}
func (HeroMapCategory) EnumDescriptor() ([]byte, []int) { return fileDescriptorHero, []int{0} }

type HistoryAmountType int32

const (
	HistoryAmountType_CaptainRefinedTimes      HistoryAmountType = 0
	HistoryAmountType_CollectResource          HistoryAmountType = 1
	HistoryAmountType_CollectResourceGold      HistoryAmountType = 2
	HistoryAmountType_CollectResourceFood      HistoryAmountType = 3
	HistoryAmountType_CollectResourceWood      HistoryAmountType = 4
	HistoryAmountType_CollectResourceStone     HistoryAmountType = 5
	HistoryAmountType_RecruitSoldierCount      HistoryAmountType = 6
	HistoryAmountType_HealSoldierCount         HistoryAmountType = 7
	HistoryAmountType_TaskCount                HistoryAmountType = 8
	HistoryAmountType_RobJadeOre               HistoryAmountType = 9
	HistoryAmountType_Jade                     HistoryAmountType = 10
	HistoryAmountType_GuildContributionCoin    HistoryAmountType = 11
	HistoryAmountType_GuildDonate              HistoryAmountType = 12
	HistoryAmountType_RestoreProsperity        HistoryAmountType = 13
	HistoryAmountType_Expel                    HistoryAmountType = 14
	HistoryAmountType_Consult                  HistoryAmountType = 15
	HistoryAmountType_MaxJunXianLevel          HistoryAmountType = 16
	HistoryAmountType_CombineEquip             HistoryAmountType = 17
	HistoryAmountType_KillHomeNpc              HistoryAmountType = 18
	HistoryAmountType_Fishing                  HistoryAmountType = 19
	HistoryAmountType_SellBaowu                HistoryAmountType = 20
	HistoryAmountType_AccumBaiZhan             HistoryAmountType = 21
	HistoryAmountType_SmeltEquip               HistoryAmountType = 22
	HistoryAmountType_CollectActiveBox         HistoryAmountType = 23
	HistoryAmountType_ChallengeSecretTower     HistoryAmountType = 24
	HistoryAmountType_HelpSecretTower          HistoryAmountType = 66
	HistoryAmountType_ShopBuy                  HistoryAmountType = 25
	HistoryAmountType_ShopGoodsBuy             HistoryAmountType = 26
	HistoryAmountType_MaxActiveDegree          HistoryAmountType = 27
	HistoryAmountType_InvadeMultiLevelMonster  HistoryAmountType = 28
	HistoryAmountType_WinMultiLevelMonster     HistoryAmountType = 29
	HistoryAmountType_RobMultiLevelMonsterRes  HistoryAmountType = 63
	HistoryAmountType_ExpelFightMonster        HistoryAmountType = 65
	HistoryAmountType_RealmPvpSuccess          HistoryAmountType = 30
	HistoryAmountType_RealmPvpFail             HistoryAmountType = 31
	HistoryAmountType_Inverstigation           HistoryAmountType = 32
	HistoryAmountType_BeenInverstigation       HistoryAmountType = 33
	HistoryAmountType_RealmPvpAssist           HistoryAmountType = 34
	HistoryAmountType_RealmPvpBeenAssist       HistoryAmountType = 35
	HistoryAmountType_CompleteZhengWu          HistoryAmountType = 36
	HistoryAmountType_TreasuryTree             HistoryAmountType = 37
	HistoryAmountType_InvaseKillSoldier        HistoryAmountType = 38
	HistoryAmountType_AssistKillSoldier        HistoryAmountType = 39
	HistoryAmountType_DefenseKillSoldier       HistoryAmountType = 55
	HistoryAmountType_QuestionRightAmount      HistoryAmountType = 40
	HistoryAmountType_AccumStartQuestion       HistoryAmountType = 41
	HistoryAmountType_AccumLoginDays           HistoryAmountType = 42
	HistoryAmountType_AccumHelpWater           HistoryAmountType = 43
	HistoryAmountType_AccumBaseDead            HistoryAmountType = 44
	HistoryAmountType_AccumMoveBase            HistoryAmountType = 45
	HistoryAmountType_AccumDestroyBase         HistoryAmountType = 46
	HistoryAmountType_AccumDestroyProsperity   HistoryAmountType = 47
	HistoryAmountType_AccumRobbingRes          HistoryAmountType = 48
	HistoryAmountType_AccumFarmHarvestRes      HistoryAmountType = 49
	HistoryAmountType_AccumZhanJiangGuanqia    HistoryAmountType = 50
	HistoryAmountType_AccumXiongNuStart        HistoryAmountType = 51
	HistoryAmountType_AccumFarmStealRes        HistoryAmountType = 52
	HistoryAmountType_AccumDungeonAutoComplete HistoryAmountType = 53
	HistoryAmountType_AccumCountDownPrizeTimes HistoryAmountType = 54
	HistoryAmountType_UseTuFeiGoodsCount       HistoryAmountType = 56
	HistoryAmountType_HelpGuildMember          HistoryAmountType = 57
	HistoryAmountType_UnlockBaowu              HistoryAmountType = 58
	HistoryAmountType_RobBaowu                 HistoryAmountType = 59
	HistoryAmountType_RobNpcBaowu              HistoryAmountType = 64
	HistoryAmountType_XuanyuanHisMaxScore      HistoryAmountType = 60
	HistoryAmountType_StartHebi                HistoryAmountType = 61
	HistoryAmountType_RobHebi                  HistoryAmountType = 62
	HistoryAmountType_MaxTroopFightAmount      HistoryAmountType = 67
	HistoryAmountType_McWarKillSolider         HistoryAmountType = 68
	HistoryAmountType_McWarWin                 HistoryAmountType = 69
	HistoryAmountType_McWarDestroyBuilding     HistoryAmountType = 70
	HistoryAmountType_McWarJoin                HistoryAmountType = 75
	HistoryAmountType_McOccupy                 HistoryAmountType = 76
	HistoryAmountType_CaptainExpGoodsUsed      HistoryAmountType = 71
	HistoryAmountType_StrategyUsed             HistoryAmountType = 72
	HistoryAmountType_FarmHarvestTimes         HistoryAmountType = 73
	HistoryAmountType_KillJunTuanTimes         HistoryAmountType = 74
)

var HistoryAmountType_name = map[int32]string{
	0:  "CaptainRefinedTimes",
	1:  "CollectResource",
	2:  "CollectResourceGold",
	3:  "CollectResourceFood",
	4:  "CollectResourceWood",
	5:  "CollectResourceStone",
	6:  "RecruitSoldierCount",
	7:  "HealSoldierCount",
	8:  "TaskCount",
	9:  "RobJadeOre",
	10: "Jade",
	11: "GuildContributionCoin",
	12: "GuildDonate",
	13: "RestoreProsperity",
	14: "Expel",
	15: "Consult",
	16: "MaxJunXianLevel",
	17: "CombineEquip",
	18: "KillHomeNpc",
	19: "Fishing",
	20: "SellBaowu",
	21: "AccumBaiZhan",
	22: "SmeltEquip",
	23: "CollectActiveBox",
	24: "ChallengeSecretTower",
	66: "HelpSecretTower",
	25: "ShopBuy",
	26: "ShopGoodsBuy",
	27: "MaxActiveDegree",
	28: "InvadeMultiLevelMonster",
	29: "WinMultiLevelMonster",
	63: "RobMultiLevelMonsterRes",
	65: "ExpelFightMonster",
	30: "RealmPvpSuccess",
	31: "RealmPvpFail",
	32: "Inverstigation",
	33: "BeenInverstigation",
	34: "RealmPvpAssist",
	35: "RealmPvpBeenAssist",
	36: "CompleteZhengWu",
	37: "TreasuryTree",
	38: "InvaseKillSoldier",
	39: "AssistKillSoldier",
	55: "DefenseKillSoldier",
	40: "QuestionRightAmount",
	41: "AccumStartQuestion",
	42: "AccumLoginDays",
	43: "AccumHelpWater",
	44: "AccumBaseDead",
	45: "AccumMoveBase",
	46: "AccumDestroyBase",
	47: "AccumDestroyProsperity",
	48: "AccumRobbingRes",
	49: "AccumFarmHarvestRes",
	50: "AccumZhanJiangGuanqia",
	51: "AccumXiongNuStart",
	52: "AccumFarmStealRes",
	53: "AccumDungeonAutoComplete",
	54: "AccumCountDownPrizeTimes",
	56: "UseTuFeiGoodsCount",
	57: "HelpGuildMember",
	58: "UnlockBaowu",
	59: "RobBaowu",
	64: "RobNpcBaowu",
	60: "XuanyuanHisMaxScore",
	61: "StartHebi",
	62: "RobHebi",
	67: "MaxTroopFightAmount",
	68: "McWarKillSolider",
	69: "McWarWin",
	70: "McWarDestroyBuilding",
	75: "McWarJoin",
	76: "McOccupy",
	71: "CaptainExpGoodsUsed",
	72: "StrategyUsed",
	73: "FarmHarvestTimes",
	74: "KillJunTuanTimes",
}
var HistoryAmountType_value = map[string]int32{
	"CaptainRefinedTimes":      0,
	"CollectResource":          1,
	"CollectResourceGold":      2,
	"CollectResourceFood":      3,
	"CollectResourceWood":      4,
	"CollectResourceStone":     5,
	"RecruitSoldierCount":      6,
	"HealSoldierCount":         7,
	"TaskCount":                8,
	"RobJadeOre":               9,
	"Jade":                     10,
	"GuildContributionCoin":    11,
	"GuildDonate":              12,
	"RestoreProsperity":        13,
	"Expel":                    14,
	"Consult":                  15,
	"MaxJunXianLevel":          16,
	"CombineEquip":             17,
	"KillHomeNpc":              18,
	"Fishing":                  19,
	"SellBaowu":                20,
	"AccumBaiZhan":             21,
	"SmeltEquip":               22,
	"CollectActiveBox":         23,
	"ChallengeSecretTower":     24,
	"HelpSecretTower":          66,
	"ShopBuy":                  25,
	"ShopGoodsBuy":             26,
	"MaxActiveDegree":          27,
	"InvadeMultiLevelMonster":  28,
	"WinMultiLevelMonster":     29,
	"RobMultiLevelMonsterRes":  63,
	"ExpelFightMonster":        65,
	"RealmPvpSuccess":          30,
	"RealmPvpFail":             31,
	"Inverstigation":           32,
	"BeenInverstigation":       33,
	"RealmPvpAssist":           34,
	"RealmPvpBeenAssist":       35,
	"CompleteZhengWu":          36,
	"TreasuryTree":             37,
	"InvaseKillSoldier":        38,
	"AssistKillSoldier":        39,
	"DefenseKillSoldier":       55,
	"QuestionRightAmount":      40,
	"AccumStartQuestion":       41,
	"AccumLoginDays":           42,
	"AccumHelpWater":           43,
	"AccumBaseDead":            44,
	"AccumMoveBase":            45,
	"AccumDestroyBase":         46,
	"AccumDestroyProsperity":   47,
	"AccumRobbingRes":          48,
	"AccumFarmHarvestRes":      49,
	"AccumZhanJiangGuanqia":    50,
	"AccumXiongNuStart":        51,
	"AccumFarmStealRes":        52,
	"AccumDungeonAutoComplete": 53,
	"AccumCountDownPrizeTimes": 54,
	"UseTuFeiGoodsCount":       56,
	"HelpGuildMember":          57,
	"UnlockBaowu":              58,
	"RobBaowu":                 59,
	"RobNpcBaowu":              64,
	"XuanyuanHisMaxScore":      60,
	"StartHebi":                61,
	"RobHebi":                  62,
	"MaxTroopFightAmount":      67,
	"McWarKillSolider":         68,
	"McWarWin":                 69,
	"McWarDestroyBuilding":     70,
	"McWarJoin":                75,
	"McOccupy":                 76,
	"CaptainExpGoodsUsed":      71,
	"StrategyUsed":             72,
	"FarmHarvestTimes":         73,
	"KillJunTuanTimes":         74,
}

func (x HistoryAmountType) String() string {
	return proto.EnumName(HistoryAmountType_name, int32(x))
}
func (HistoryAmountType) EnumDescriptor() ([]byte, []int) { return fileDescriptorHero, []int{1} }

type HeroServerProto struct {
	Id       int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name     string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Head     string `protobuf:"bytes,26,opt,name=head,proto3" json:"head,omitempty"`
	Body     uint64 `protobuf:"varint,21,opt,name=body,proto3" json:"body,omitempty"`
	Level    uint64 `protobuf:"varint,12,opt,name=level,proto3" json:"level,omitempty"`
	Exp      uint64 `protobuf:"varint,13,opt,name=exp,proto3" json:"exp,omitempty"`
	Male     bool   `protobuf:"varint,14,opt,name=male,proto3" json:"male,omitempty"`
	Location uint64 `protobuf:"varint,76,opt,name=location,proto3" json:"location,omitempty"`
	// 改名
	OldName                      []string `protobuf:"bytes,5,rep,name=old_name,json=oldName" json:"old_name,omitempty"`
	NextChangeNameTime           int64    `protobuf:"varint,15,opt,name=next_change_name_time,json=nextChangeNameTime,proto3" json:"next_change_name_time,omitempty"`
	ChangeHeroNameTimes          uint64   `protobuf:"varint,18,opt,name=change_hero_name_times,json=changeHeroNameTimes,proto3" json:"change_hero_name_times,omitempty"`
	GiveFirstChangeHeroNamePrize bool     `protobuf:"varint,19,opt,name=give_first_change_hero_name_prize,json=giveFirstChangeHeroNamePrize,proto3" json:"give_first_change_hero_name_prize,omitempty"`
	// 上次离线时间
	LastOfflineTime int64 `protobuf:"varint,17,opt,name=last_offline_time,json=lastOfflineTime,proto3" json:"last_offline_time,omitempty"`
	TotalOnlineTime int64 `protobuf:"varint,98,opt,name=total_online_time,json=totalOnlineTime,proto3" json:"total_online_time,omitempty"`
	LoginTime       int64 `protobuf:"varint,100,opt,name=login_time,json=loginTime,proto3" json:"login_time,omitempty"`
	// 帮派
	GuildId       int64 `protobuf:"varint,31,opt,name=guild_id,json=guildId,proto3" json:"guild_id,omitempty"`
	JoinGuildTime int64 `protobuf:"varint,32,opt,name=join_guild_time,json=joinGuildTime,proto3" json:"join_guild_time,omitempty"`
	// 新野外
	Region              *HeroRegionServerProto `protobuf:"bytes,30,opt,name=region" json:"region,omitempty"`
	ContributionCoin    uint64                 `protobuf:"varint,35,opt,name=contribution_coin,json=contributionCoin,proto3" json:"contribution_coin,omitempty"`
	GuildDonateTimes    []uint64               `protobuf:"varint,36,rep,packed,name=guild_donate_times,json=guildDonateTimes" json:"guild_donate_times,omitempty"`
	JoinGuildIds        []int64                `protobuf:"varint,37,rep,packed,name=join_guild_ids,json=joinGuildIds" json:"join_guild_ids,omitempty"`
	BeenInvateGuildIds  []int64                `protobuf:"varint,38,rep,packed,name=been_invate_guild_ids,json=beenInvateGuildIds" json:"been_invate_guild_ids,omitempty"`
	NextNotifyGuildTime int64                  `protobuf:"varint,39,opt,name=next_notify_guild_time,json=nextNotifyGuildTime,proto3" json:"next_notify_guild_time,omitempty"`
	// bool has_first_join_guild_prize = 39; // 有首次加入联盟奖励可以领取
	CollectedFirstJoinGuildPrize bool                               `protobuf:"varint,40,opt,name=collected_first_join_guild_prize,json=collectedFirstJoinGuildPrize,proto3" json:"collected_first_join_guild_prize,omitempty"`
	CollectedDailyGuildRankPrize bool                               `protobuf:"varint,33,opt,name=collected_daily_guild_rank_prize,json=collectedDailyGuildRankPrize,proto3" json:"collected_daily_guild_rank_prize,omitempty"`
	WorkshopOutputStartTime      int64                              `protobuf:"varint,80,opt,name=workshop_output_start_time,json=workshopOutputStartTime,proto3" json:"workshop_output_start_time,omitempty"`
	CollectedGuildTaskStages     map[uint64]*proto1.Int32ArrayProto `protobuf:"bytes,81,rep,name=collected_guild_task_stages,json=collectedGuildTaskStages" json:"collected_guild_task_stages,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Domestic                     *HeroDomesticServerProto           `protobuf:"bytes,3,opt,name=domestic" json:"domestic,omitempty"`
	Military                     *HeroMilitaryServerProto           `protobuf:"bytes,4,opt,name=military" json:"military,omitempty"`
	// 元宝
	Yuanbao uint64 `protobuf:"varint,41,opt,name=yuanbao,proto3" json:"yuanbao,omitempty"`
	// 点券
	Dianquan uint64 `protobuf:"varint,104,opt,name=dianquan,proto3" json:"dianquan,omitempty"`
	// 银两
	Yinliang uint64 `protobuf:"varint,108,opt,name=yinliang,proto3" json:"yinliang,omitempty"`
	// 体力值相关
	Sp                uint64 `protobuf:"varint,109,opt,name=sp,proto3" json:"sp,omitempty"`
	LastRecoverSpTime int64  `protobuf:"varint,110,opt,name=last_recover_sp_time,json=lastRecoverSpTime,proto3" json:"last_recover_sp_time,omitempty"`
	BuySpTimes        uint64 `protobuf:"varint,111,opt,name=buy_sp_times,json=buySpTimes,proto3" json:"buy_sp_times,omitempty"`
	// 资源
	Gold             uint64                      `protobuf:"varint,42,opt,name=gold,proto3" json:"gold,omitempty"`
	Food             uint64                      `protobuf:"varint,43,opt,name=food,proto3" json:"food,omitempty"`
	Wood             uint64                      `protobuf:"varint,44,opt,name=wood,proto3" json:"wood,omitempty"`
	Stone            uint64                      `protobuf:"varint,45,opt,name=stone,proto3" json:"stone,omitempty"`
	SafeGold         uint64                      `protobuf:"varint,22,opt,name=safe_gold,json=safeGold,proto3" json:"safe_gold,omitempty"`
	SafeFood         uint64                      `protobuf:"varint,23,opt,name=safe_food,json=safeFood,proto3" json:"safe_food,omitempty"`
	SafeWood         uint64                      `protobuf:"varint,24,opt,name=safe_wood,json=safeWood,proto3" json:"safe_wood,omitempty"`
	SafeStone        uint64                      `protobuf:"varint,25,opt,name=safe_stone,json=safeStone,proto3" json:"safe_stone,omitempty"`
	Jade             uint64                      `protobuf:"varint,46,opt,name=jade,proto3" json:"jade,omitempty"`
	JadeOre          uint64                      `protobuf:"varint,47,opt,name=jade_ore,json=jadeOre,proto3" json:"jade_ore,omitempty"`
	HistoryJade      uint64                      `protobuf:"varint,48,opt,name=history_jade,json=historyJade,proto3" json:"history_jade,omitempty"`
	TodayObtainJade  uint64                      `protobuf:"varint,49,opt,name=today_obtain_jade,json=todayObtainJade,proto3" json:"today_obtain_jade,omitempty"`
	NextResDecayTime int64                       `protobuf:"varint,105,opt,name=next_res_decay_time,json=nextResDecayTime,proto3" json:"next_res_decay_time,omitempty"`
	Depot            *HeroDepotServerProto       `protobuf:"bytes,51,opt,name=depot" json:"depot,omitempty"`
	Tower            *HeroTowerServerProto       `protobuf:"bytes,52,opt,name=tower" json:"tower,omitempty"`
	Task             *HeroTaskServerProto        `protobuf:"bytes,53,opt,name=task" json:"task,omitempty"`
	CaptainSoul      *HeroCaptainSoulServerProto `protobuf:"bytes,54,opt,name=captain_soul,json=captainSoul" json:"captain_soul,omitempty"`
	// 开启了的装备合成
	OpenCombineEquip *HeroOpenCombineEquipServerProto `protobuf:"bytes,55,opt,name=open_combine_equip,json=openCombineEquip" json:"open_combine_equip,omitempty"`
	// 重楼密室
	SecretTower *HeroSecretTowerServerProto `protobuf:"bytes,56,opt,name=secret_tower,json=secretTower" json:"secret_tower,omitempty"`
	// 副本
	Dungeon *HeroDungeonServerProto `protobuf:"bytes,58,opt,name=dungeon" json:"dungeon,omitempty"`
	// 标签
	Tag *proto15.HeroTagProto `protobuf:"bytes,60,opt,name=tag" json:"tag,omitempty"`
	// 君主策略
	Strategy *HeroStrategyServerProto `protobuf:"bytes,61,opt,name=strategy" json:"strategy,omitempty"`
	// 主城增益
	BufEffect *HeroBufferServerProto `protobuf:"bytes,59,opt,name=buf_effect,json=bufEffect" json:"buf_effect,omitempty"`
	// buff
	Buff *HeroBuffServerProto `protobuf:"bytes,79,opt,name=buff" json:"buff,omitempty"`
	// 客户端数据
	ClientDatas *HeroClientDatasServerProto `protobuf:"bytes,62,opt,name=client_datas,json=clientDatas" json:"client_datas,omitempty"`
	// 钓鱼
	Fishing *proto23.HeroFishingProto `protobuf:"bytes,63,opt,name=fishing" json:"fishing,omitempty"`
	// 功能开启
	Function *HeroFunctionServerProto `protobuf:"bytes,64,opt,name=function" json:"function,omitempty"`
	// 贵族
	GuiZu *HeroGuiZuServerProto `protobuf:"bytes,65,opt,name=gui_zu,json=guiZu" json:"gui_zu,omitempty"`
	// 盟友礼包
	GuildEventPrizes []*HeroGuildEventPrizeServerProto `protobuf:"bytes,66,rep,name=guild_event_prizes,json=guildEventPrizes" json:"guild_event_prizes,omitempty"`
	// 摇钱树
	TreasuryTree *HeroTreasuryTreeServerProto `protobuf:"bytes,67,opt,name=treasury_tree,json=treasuryTree" json:"treasury_tree,omitempty"`
	// 政务
	ZhengWu *HeroZhengWuServerProto `protobuf:"bytes,68,opt,name=zheng_wu,json=zhengWu" json:"zheng_wu,omitempty"`
	// 过关斩将
	ZhanJiang *HeroZhanJiangServerProto `protobuf:"bytes,69,opt,name=zhan_jiang,json=zhanJiang" json:"zhan_jiang,omitempty"`
	// 答题
	Question *proto30.HeroQuestionProto `protobuf:"bytes,70,opt,name=question" json:"question,omitempty"`
	// 关系
	Relation *HeroRelationServerProto `protobuf:"bytes,71,opt,name=relation" json:"relation,omitempty"`
	// 随机事件
	RandomEvent *HeroRandomEventServerProto `protobuf:"bytes,78,opt,name=random_event,json=randomEvent" json:"random_event,omitempty"`
	// 问卷调查
	Survey     *proto32.HeroSurveyProto `protobuf:"bytes,72,opt,name=survey" json:"survey,omitempty"`
	CreateTime int64                    `protobuf:"varint,73,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// 设置
	Settings *proto33.HeroSettingsProto `protobuf:"bytes,74,opt,name=settings" json:"settings,omitempty"`
	// 合璧
	Hebi *proto11.HeroHebiProto `protobuf:"bytes,75,opt,name=hebi" json:"hebi,omitempty"`
	// 商店数据
	Shop *HeroShopServerProto `protobuf:"bytes,77,opt,name=shop" json:"shop,omitempty"`
	// 消耗预约
	Reservation *HeroReservationProto `protobuf:"bytes,97,opt,name=reservation" json:"reservation,omitempty"`
	Vip         *HeroVipServerProto   `protobuf:"bytes,112,opt,name=vip" json:"vip,omitempty"`
	// 名城营建
	McBuild   *HeroMcBuildServerProto   `protobuf:"bytes,114,opt,name=mc_build,json=mcBuild" json:"mc_build,omitempty"`
	RedPacket *HeroRedPacketServerProto `protobuf:"bytes,115,opt,name=red_packet,json=redPacket" json:"red_packet,omitempty"`
	// 教学
	Teach *HeroTeachServerProto `protobuf:"bytes,116,opt,name=teach" json:"teach,omitempty"`
	// 国家杂项
	CountryMisc *HeroCountryMiscServerProto `protobuf:"bytes,117,opt,name=country_misc,json=countryMisc" json:"country_misc,omitempty"`
	// map数据
	HeroMaps []*HeroMapServerProto `protobuf:"bytes,101,rep,name=hero_maps,json=heroMaps" json:"hero_maps,omitempty"`
	// keys数据
	HeroKeys []*HeroKeysServerProto `protobuf:"bytes,107,rep,name=hero_keys,json=heroKeys" json:"hero_keys,omitempty"`
	// bool数据
	HeroBools []uint64 `protobuf:"varint,102,rep,packed,name=hero_bools,json=heroBools" json:"hero_bools,omitempty"`
	// 零碎的额外数据
	Misc      *HeroMiscServerProto      `protobuf:"bytes,103,opt,name=misc" json:"misc,omitempty"`
	Promotion *HeroPromotionServerProto `protobuf:"bytes,113,opt,name=promotion" json:"promotion,omitempty"`
	Activity  *HeroActivityServerProto  `protobuf:"bytes,141,opt,name=activity" json:"activity,omitempty"`
	// 代码生成的proto
	HeroGen *HeroGenServerProto `protobuf:"bytes,106,opt,name=hero_gen,json=heroGen" json:"hero_gen,omitempty"`
}

func (m *HeroServerProto) Reset()                    { *m = HeroServerProto{} }
func (m *HeroServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroServerProto) ProtoMessage()               {}
func (*HeroServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{0} }

func (m *HeroServerProto) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *HeroServerProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeroServerProto) GetHead() string {
	if m != nil {
		return m.Head
	}
	return ""
}

func (m *HeroServerProto) GetBody() uint64 {
	if m != nil {
		return m.Body
	}
	return 0
}

func (m *HeroServerProto) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *HeroServerProto) GetExp() uint64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *HeroServerProto) GetMale() bool {
	if m != nil {
		return m.Male
	}
	return false
}

func (m *HeroServerProto) GetLocation() uint64 {
	if m != nil {
		return m.Location
	}
	return 0
}

func (m *HeroServerProto) GetOldName() []string {
	if m != nil {
		return m.OldName
	}
	return nil
}

func (m *HeroServerProto) GetNextChangeNameTime() int64 {
	if m != nil {
		return m.NextChangeNameTime
	}
	return 0
}

func (m *HeroServerProto) GetChangeHeroNameTimes() uint64 {
	if m != nil {
		return m.ChangeHeroNameTimes
	}
	return 0
}

func (m *HeroServerProto) GetGiveFirstChangeHeroNamePrize() bool {
	if m != nil {
		return m.GiveFirstChangeHeroNamePrize
	}
	return false
}

func (m *HeroServerProto) GetLastOfflineTime() int64 {
	if m != nil {
		return m.LastOfflineTime
	}
	return 0
}

func (m *HeroServerProto) GetTotalOnlineTime() int64 {
	if m != nil {
		return m.TotalOnlineTime
	}
	return 0
}

func (m *HeroServerProto) GetLoginTime() int64 {
	if m != nil {
		return m.LoginTime
	}
	return 0
}

func (m *HeroServerProto) GetGuildId() int64 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *HeroServerProto) GetJoinGuildTime() int64 {
	if m != nil {
		return m.JoinGuildTime
	}
	return 0
}

func (m *HeroServerProto) GetRegion() *HeroRegionServerProto {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *HeroServerProto) GetContributionCoin() uint64 {
	if m != nil {
		return m.ContributionCoin
	}
	return 0
}

func (m *HeroServerProto) GetGuildDonateTimes() []uint64 {
	if m != nil {
		return m.GuildDonateTimes
	}
	return nil
}

func (m *HeroServerProto) GetJoinGuildIds() []int64 {
	if m != nil {
		return m.JoinGuildIds
	}
	return nil
}

func (m *HeroServerProto) GetBeenInvateGuildIds() []int64 {
	if m != nil {
		return m.BeenInvateGuildIds
	}
	return nil
}

func (m *HeroServerProto) GetNextNotifyGuildTime() int64 {
	if m != nil {
		return m.NextNotifyGuildTime
	}
	return 0
}

func (m *HeroServerProto) GetCollectedFirstJoinGuildPrize() bool {
	if m != nil {
		return m.CollectedFirstJoinGuildPrize
	}
	return false
}

func (m *HeroServerProto) GetCollectedDailyGuildRankPrize() bool {
	if m != nil {
		return m.CollectedDailyGuildRankPrize
	}
	return false
}

func (m *HeroServerProto) GetWorkshopOutputStartTime() int64 {
	if m != nil {
		return m.WorkshopOutputStartTime
	}
	return 0
}

func (m *HeroServerProto) GetCollectedGuildTaskStages() map[uint64]*proto1.Int32ArrayProto {
	if m != nil {
		return m.CollectedGuildTaskStages
	}
	return nil
}

func (m *HeroServerProto) GetDomestic() *HeroDomesticServerProto {
	if m != nil {
		return m.Domestic
	}
	return nil
}

func (m *HeroServerProto) GetMilitary() *HeroMilitaryServerProto {
	if m != nil {
		return m.Military
	}
	return nil
}

func (m *HeroServerProto) GetYuanbao() uint64 {
	if m != nil {
		return m.Yuanbao
	}
	return 0
}

func (m *HeroServerProto) GetDianquan() uint64 {
	if m != nil {
		return m.Dianquan
	}
	return 0
}

func (m *HeroServerProto) GetYinliang() uint64 {
	if m != nil {
		return m.Yinliang
	}
	return 0
}

func (m *HeroServerProto) GetSp() uint64 {
	if m != nil {
		return m.Sp
	}
	return 0
}

func (m *HeroServerProto) GetLastRecoverSpTime() int64 {
	if m != nil {
		return m.LastRecoverSpTime
	}
	return 0
}

func (m *HeroServerProto) GetBuySpTimes() uint64 {
	if m != nil {
		return m.BuySpTimes
	}
	return 0
}

func (m *HeroServerProto) GetGold() uint64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *HeroServerProto) GetFood() uint64 {
	if m != nil {
		return m.Food
	}
	return 0
}

func (m *HeroServerProto) GetWood() uint64 {
	if m != nil {
		return m.Wood
	}
	return 0
}

func (m *HeroServerProto) GetStone() uint64 {
	if m != nil {
		return m.Stone
	}
	return 0
}

func (m *HeroServerProto) GetSafeGold() uint64 {
	if m != nil {
		return m.SafeGold
	}
	return 0
}

func (m *HeroServerProto) GetSafeFood() uint64 {
	if m != nil {
		return m.SafeFood
	}
	return 0
}

func (m *HeroServerProto) GetSafeWood() uint64 {
	if m != nil {
		return m.SafeWood
	}
	return 0
}

func (m *HeroServerProto) GetSafeStone() uint64 {
	if m != nil {
		return m.SafeStone
	}
	return 0
}

func (m *HeroServerProto) GetJade() uint64 {
	if m != nil {
		return m.Jade
	}
	return 0
}

func (m *HeroServerProto) GetJadeOre() uint64 {
	if m != nil {
		return m.JadeOre
	}
	return 0
}

func (m *HeroServerProto) GetHistoryJade() uint64 {
	if m != nil {
		return m.HistoryJade
	}
	return 0
}

func (m *HeroServerProto) GetTodayObtainJade() uint64 {
	if m != nil {
		return m.TodayObtainJade
	}
	return 0
}

func (m *HeroServerProto) GetNextResDecayTime() int64 {
	if m != nil {
		return m.NextResDecayTime
	}
	return 0
}

func (m *HeroServerProto) GetDepot() *HeroDepotServerProto {
	if m != nil {
		return m.Depot
	}
	return nil
}

func (m *HeroServerProto) GetTower() *HeroTowerServerProto {
	if m != nil {
		return m.Tower
	}
	return nil
}

func (m *HeroServerProto) GetTask() *HeroTaskServerProto {
	if m != nil {
		return m.Task
	}
	return nil
}

func (m *HeroServerProto) GetCaptainSoul() *HeroCaptainSoulServerProto {
	if m != nil {
		return m.CaptainSoul
	}
	return nil
}

func (m *HeroServerProto) GetOpenCombineEquip() *HeroOpenCombineEquipServerProto {
	if m != nil {
		return m.OpenCombineEquip
	}
	return nil
}

func (m *HeroServerProto) GetSecretTower() *HeroSecretTowerServerProto {
	if m != nil {
		return m.SecretTower
	}
	return nil
}

func (m *HeroServerProto) GetDungeon() *HeroDungeonServerProto {
	if m != nil {
		return m.Dungeon
	}
	return nil
}

func (m *HeroServerProto) GetTag() *proto15.HeroTagProto {
	if m != nil {
		return m.Tag
	}
	return nil
}

func (m *HeroServerProto) GetStrategy() *HeroStrategyServerProto {
	if m != nil {
		return m.Strategy
	}
	return nil
}

func (m *HeroServerProto) GetBufEffect() *HeroBufferServerProto {
	if m != nil {
		return m.BufEffect
	}
	return nil
}

func (m *HeroServerProto) GetBuff() *HeroBuffServerProto {
	if m != nil {
		return m.Buff
	}
	return nil
}

func (m *HeroServerProto) GetClientDatas() *HeroClientDatasServerProto {
	if m != nil {
		return m.ClientDatas
	}
	return nil
}

func (m *HeroServerProto) GetFishing() *proto23.HeroFishingProto {
	if m != nil {
		return m.Fishing
	}
	return nil
}

func (m *HeroServerProto) GetFunction() *HeroFunctionServerProto {
	if m != nil {
		return m.Function
	}
	return nil
}

func (m *HeroServerProto) GetGuiZu() *HeroGuiZuServerProto {
	if m != nil {
		return m.GuiZu
	}
	return nil
}

func (m *HeroServerProto) GetGuildEventPrizes() []*HeroGuildEventPrizeServerProto {
	if m != nil {
		return m.GuildEventPrizes
	}
	return nil
}

func (m *HeroServerProto) GetTreasuryTree() *HeroTreasuryTreeServerProto {
	if m != nil {
		return m.TreasuryTree
	}
	return nil
}

func (m *HeroServerProto) GetZhengWu() *HeroZhengWuServerProto {
	if m != nil {
		return m.ZhengWu
	}
	return nil
}

func (m *HeroServerProto) GetZhanJiang() *HeroZhanJiangServerProto {
	if m != nil {
		return m.ZhanJiang
	}
	return nil
}

func (m *HeroServerProto) GetQuestion() *proto30.HeroQuestionProto {
	if m != nil {
		return m.Question
	}
	return nil
}

func (m *HeroServerProto) GetRelation() *HeroRelationServerProto {
	if m != nil {
		return m.Relation
	}
	return nil
}

func (m *HeroServerProto) GetRandomEvent() *HeroRandomEventServerProto {
	if m != nil {
		return m.RandomEvent
	}
	return nil
}

func (m *HeroServerProto) GetSurvey() *proto32.HeroSurveyProto {
	if m != nil {
		return m.Survey
	}
	return nil
}

func (m *HeroServerProto) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *HeroServerProto) GetSettings() *proto33.HeroSettingsProto {
	if m != nil {
		return m.Settings
	}
	return nil
}

func (m *HeroServerProto) GetHebi() *proto11.HeroHebiProto {
	if m != nil {
		return m.Hebi
	}
	return nil
}

func (m *HeroServerProto) GetShop() *HeroShopServerProto {
	if m != nil {
		return m.Shop
	}
	return nil
}

func (m *HeroServerProto) GetReservation() *HeroReservationProto {
	if m != nil {
		return m.Reservation
	}
	return nil
}

func (m *HeroServerProto) GetVip() *HeroVipServerProto {
	if m != nil {
		return m.Vip
	}
	return nil
}

func (m *HeroServerProto) GetMcBuild() *HeroMcBuildServerProto {
	if m != nil {
		return m.McBuild
	}
	return nil
}

func (m *HeroServerProto) GetRedPacket() *HeroRedPacketServerProto {
	if m != nil {
		return m.RedPacket
	}
	return nil
}

func (m *HeroServerProto) GetTeach() *HeroTeachServerProto {
	if m != nil {
		return m.Teach
	}
	return nil
}

func (m *HeroServerProto) GetCountryMisc() *HeroCountryMiscServerProto {
	if m != nil {
		return m.CountryMisc
	}
	return nil
}

func (m *HeroServerProto) GetHeroMaps() []*HeroMapServerProto {
	if m != nil {
		return m.HeroMaps
	}
	return nil
}

func (m *HeroServerProto) GetHeroKeys() []*HeroKeysServerProto {
	if m != nil {
		return m.HeroKeys
	}
	return nil
}

func (m *HeroServerProto) GetHeroBools() []uint64 {
	if m != nil {
		return m.HeroBools
	}
	return nil
}

func (m *HeroServerProto) GetMisc() *HeroMiscServerProto {
	if m != nil {
		return m.Misc
	}
	return nil
}

func (m *HeroServerProto) GetPromotion() *HeroPromotionServerProto {
	if m != nil {
		return m.Promotion
	}
	return nil
}

func (m *HeroServerProto) GetActivity() *HeroActivityServerProto {
	if m != nil {
		return m.Activity
	}
	return nil
}

func (m *HeroServerProto) GetHeroGen() *HeroGenServerProto {
	if m != nil {
		return m.HeroGen
	}
	return nil
}

type BlackMarketGoodsItemServerProto struct {
	Goods    uint64 `protobuf:"varint,1,opt,name=goods,proto3" json:"goods,omitempty"`
	Discount uint64 `protobuf:"varint,2,opt,name=discount,proto3" json:"discount,omitempty"`
	Buy      bool   `protobuf:"varint,3,opt,name=buy,proto3" json:"buy,omitempty"`
}

func (m *BlackMarketGoodsItemServerProto) Reset()         { *m = BlackMarketGoodsItemServerProto{} }
func (m *BlackMarketGoodsItemServerProto) String() string { return proto.CompactTextString(m) }
func (*BlackMarketGoodsItemServerProto) ProtoMessage()    {}
func (*BlackMarketGoodsItemServerProto) Descriptor() ([]byte, []int) {
	return fileDescriptorHero, []int{1}
}

func (m *BlackMarketGoodsItemServerProto) GetGoods() uint64 {
	if m != nil {
		return m.Goods
	}
	return 0
}

func (m *BlackMarketGoodsItemServerProto) GetDiscount() uint64 {
	if m != nil {
		return m.Discount
	}
	return 0
}

func (m *BlackMarketGoodsItemServerProto) GetBuy() bool {
	if m != nil {
		return m.Buy
	}
	return false
}

type HeroShopServerProto struct {
	Item []*BlackMarketGoodsItemServerProto `protobuf:"bytes,1,rep,name=item" json:"item,omitempty"`
}

func (m *HeroShopServerProto) Reset()                    { *m = HeroShopServerProto{} }
func (m *HeroShopServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroShopServerProto) ProtoMessage()               {}
func (*HeroShopServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{2} }

func (m *HeroShopServerProto) GetItem() []*BlackMarketGoodsItemServerProto {
	if m != nil {
		return m.Item
	}
	return nil
}

// 玩家零碎的额外数据
type HeroMiscServerProto struct {
	FarmShowUnlockAnimationBaseLevel uint64           `protobuf:"varint,1,opt,name=farm_show_unlock_animation_base_level,json=farmShowUnlockAnimationBaseLevel,proto3" json:"farm_show_unlock_animation_base_level,omitempty"`
	ChargeAmount                     uint64           `protobuf:"varint,2,opt,name=charge_amount,json=chargeAmount,proto3" json:"charge_amount,omitempty"`
	LastChargeTime                   int64            `protobuf:"varint,3,opt,name=last_charge_time,json=lastChargeTime,proto3" json:"last_charge_time,omitempty"`
	DurationCards                    map[uint64]int64 `protobuf:"bytes,4,rep,name=duration_cards,json=durationCards" json:"duration_cards,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *HeroMiscServerProto) Reset()                    { *m = HeroMiscServerProto{} }
func (m *HeroMiscServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroMiscServerProto) ProtoMessage()               {}
func (*HeroMiscServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{3} }

func (m *HeroMiscServerProto) GetFarmShowUnlockAnimationBaseLevel() uint64 {
	if m != nil {
		return m.FarmShowUnlockAnimationBaseLevel
	}
	return 0
}

func (m *HeroMiscServerProto) GetChargeAmount() uint64 {
	if m != nil {
		return m.ChargeAmount
	}
	return 0
}

func (m *HeroMiscServerProto) GetLastChargeTime() int64 {
	if m != nil {
		return m.LastChargeTime
	}
	return 0
}

func (m *HeroMiscServerProto) GetDurationCards() map[uint64]int64 {
	if m != nil {
		return m.DurationCards
	}
	return nil
}

type HeroPromotionServerProto struct {
	BuyTimeLimitGift []*proto34.TimeLimitGiftBoughtProto `protobuf:"bytes,1,rep,name=buy_time_limit_gift,json=buyTimeLimitGift" json:"buy_time_limit_gift,omitempty"`
	EventLimitGifts  []*proto34.EventLimitGiftProto      `protobuf:"bytes,2,rep,name=event_limit_gifts,json=eventLimitGifts" json:"event_limit_gifts,omitempty"`
}

func (m *HeroPromotionServerProto) Reset()                    { *m = HeroPromotionServerProto{} }
func (m *HeroPromotionServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroPromotionServerProto) ProtoMessage()               {}
func (*HeroPromotionServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{4} }

func (m *HeroPromotionServerProto) GetBuyTimeLimitGift() []*proto34.TimeLimitGiftBoughtProto {
	if m != nil {
		return m.BuyTimeLimitGift
	}
	return nil
}

func (m *HeroPromotionServerProto) GetEventLimitGifts() []*proto34.EventLimitGiftProto {
	if m != nil {
		return m.EventLimitGifts
	}
	return nil
}

type HeroActivityServerProto struct {
	Collections map[uint64]*HeroCollectionServerProto `protobuf:"bytes,3,rep,name=collections" json:"collections,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *HeroActivityServerProto) Reset()                    { *m = HeroActivityServerProto{} }
func (m *HeroActivityServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroActivityServerProto) ProtoMessage()               {}
func (*HeroActivityServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{5} }

func (m *HeroActivityServerProto) GetCollections() map[uint64]*HeroCollectionServerProto {
	if m != nil {
		return m.Collections
	}
	return nil
}

type HeroRelationServerProto struct {
	Friend           []int64         `protobuf:"varint,1,rep,packed,name=friend" json:"friend,omitempty"`
	FriendCreateTime []int64         `protobuf:"varint,5,rep,packed,name=friend_create_time,json=friendCreateTime" json:"friend_create_time,omitempty"`
	Black            []int64         `protobuf:"varint,2,rep,packed,name=black" json:"black,omitempty"`
	BlackCreateTime  []int64         `protobuf:"varint,6,rep,packed,name=black_create_time,json=blackCreateTime" json:"black_create_time,omitempty"`
	Enemy            map[int64]int64 `protobuf:"bytes,3,rep,name=enemy" json:"enemy,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Important        map[int64]int64 `protobuf:"bytes,4,rep,name=important" json:"important,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *HeroRelationServerProto) Reset()                    { *m = HeroRelationServerProto{} }
func (m *HeroRelationServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroRelationServerProto) ProtoMessage()               {}
func (*HeroRelationServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{6} }

func (m *HeroRelationServerProto) GetFriend() []int64 {
	if m != nil {
		return m.Friend
	}
	return nil
}

func (m *HeroRelationServerProto) GetFriendCreateTime() []int64 {
	if m != nil {
		return m.FriendCreateTime
	}
	return nil
}

func (m *HeroRelationServerProto) GetBlack() []int64 {
	if m != nil {
		return m.Black
	}
	return nil
}

func (m *HeroRelationServerProto) GetBlackCreateTime() []int64 {
	if m != nil {
		return m.BlackCreateTime
	}
	return nil
}

func (m *HeroRelationServerProto) GetEnemy() map[int64]int64 {
	if m != nil {
		return m.Enemy
	}
	return nil
}

func (m *HeroRelationServerProto) GetImportant() map[int64]int64 {
	if m != nil {
		return m.Important
	}
	return nil
}

type HeroRandomEventServerProto struct {
	Events           []*EventPositionServerProto `protobuf:"bytes,1,rep,name=events" json:"events,omitempty"`
	BigRefreshTime   int64                       `protobuf:"varint,2,opt,name=big_refresh_time,json=bigRefreshTime,proto3" json:"big_refresh_time,omitempty"`
	SmallRefreshTime int64                       `protobuf:"varint,3,opt,name=small_refresh_time,json=smallRefreshTime,proto3" json:"small_refresh_time,omitempty"`
	Handbooks        []uint64                    `protobuf:"varint,4,rep,packed,name=handbooks" json:"handbooks,omitempty"`
}

func (m *HeroRandomEventServerProto) Reset()                    { *m = HeroRandomEventServerProto{} }
func (m *HeroRandomEventServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroRandomEventServerProto) ProtoMessage()               {}
func (*HeroRandomEventServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{7} }

func (m *HeroRandomEventServerProto) GetEvents() []*EventPositionServerProto {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *HeroRandomEventServerProto) GetBigRefreshTime() int64 {
	if m != nil {
		return m.BigRefreshTime
	}
	return 0
}

func (m *HeroRandomEventServerProto) GetSmallRefreshTime() int64 {
	if m != nil {
		return m.SmallRefreshTime
	}
	return 0
}

func (m *HeroRandomEventServerProto) GetHandbooks() []uint64 {
	if m != nil {
		return m.Handbooks
	}
	return nil
}

type HeroTreasuryTreeServerProto struct {
	WaterTimes     uint64         `protobuf:"varint,1,opt,name=water_times,json=waterTimes,proto3" json:"water_times,omitempty"`
	CollectSession proto27.Season `protobuf:"varint,2,opt,name=collect_session,json=collectSession,proto3,enum=proto.Season" json:"collect_session,omitempty"`
	CollectTime    int64          `protobuf:"varint,3,opt,name=collect_time,json=collectTime,proto3" json:"collect_time,omitempty"`
	WaterHeroIds   []int64        `protobuf:"varint,4,rep,packed,name=water_hero_ids,json=waterHeroIds" json:"water_hero_ids,omitempty"`
	HelpMeHeroIds  []int64        `protobuf:"varint,5,rep,packed,name=help_me_hero_ids,json=helpMeHeroIds" json:"help_me_hero_ids,omitempty"`
}

func (m *HeroTreasuryTreeServerProto) Reset()                    { *m = HeroTreasuryTreeServerProto{} }
func (m *HeroTreasuryTreeServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroTreasuryTreeServerProto) ProtoMessage()               {}
func (*HeroTreasuryTreeServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{8} }

func (m *HeroTreasuryTreeServerProto) GetWaterTimes() uint64 {
	if m != nil {
		return m.WaterTimes
	}
	return 0
}

func (m *HeroTreasuryTreeServerProto) GetCollectSession() proto27.Season {
	if m != nil {
		return m.CollectSession
	}
	return proto27.Season_InvalidSeason
}

func (m *HeroTreasuryTreeServerProto) GetCollectTime() int64 {
	if m != nil {
		return m.CollectTime
	}
	return 0
}

func (m *HeroTreasuryTreeServerProto) GetWaterHeroIds() []int64 {
	if m != nil {
		return m.WaterHeroIds
	}
	return nil
}

func (m *HeroTreasuryTreeServerProto) GetHelpMeHeroIds() []int64 {
	if m != nil {
		return m.HelpMeHeroIds
	}
	return nil
}

type HeroGuildEventPrizeServerProto struct {
	DataId     uint64 `protobuf:"varint,2,opt,name=data_id,json=dataId,proto3" json:"data_id,omitempty"`
	SendHeroId int64  `protobuf:"varint,3,opt,name=send_hero_id,json=sendHeroId,proto3" json:"send_hero_id,omitempty"`
	ExpireTime int64  `protobuf:"varint,4,opt,name=expire_time,json=expireTime,proto3" json:"expire_time,omitempty"`
	HideGiver  bool   `protobuf:"varint,1,opt,name=hide_giver,json=hideGiver,proto3" json:"hide_giver,omitempty"`
}

func (m *HeroGuildEventPrizeServerProto) Reset()         { *m = HeroGuildEventPrizeServerProto{} }
func (m *HeroGuildEventPrizeServerProto) String() string { return proto.CompactTextString(m) }
func (*HeroGuildEventPrizeServerProto) ProtoMessage()    {}
func (*HeroGuildEventPrizeServerProto) Descriptor() ([]byte, []int) {
	return fileDescriptorHero, []int{9}
}

func (m *HeroGuildEventPrizeServerProto) GetDataId() uint64 {
	if m != nil {
		return m.DataId
	}
	return 0
}

func (m *HeroGuildEventPrizeServerProto) GetSendHeroId() int64 {
	if m != nil {
		return m.SendHeroId
	}
	return 0
}

func (m *HeroGuildEventPrizeServerProto) GetExpireTime() int64 {
	if m != nil {
		return m.ExpireTime
	}
	return 0
}

func (m *HeroGuildEventPrizeServerProto) GetHideGiver() bool {
	if m != nil {
		return m.HideGiver
	}
	return false
}

type HeroMapServerProto struct {
	Category HeroMapCategory   `protobuf:"varint,2,opt,name=category,proto3,enum=proto.HeroMapCategory" json:"category,omitempty"`
	DataMap  map[uint64]uint64 `protobuf:"bytes,3,rep,name=data_map,json=dataMap" json:"data_map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *HeroMapServerProto) Reset()                    { *m = HeroMapServerProto{} }
func (m *HeroMapServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroMapServerProto) ProtoMessage()               {}
func (*HeroMapServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{10} }

func (m *HeroMapServerProto) GetCategory() HeroMapCategory {
	if m != nil {
		return m.Category
	}
	return HeroMapCategory_invalid_hero_map_category
}

func (m *HeroMapServerProto) GetDataMap() map[uint64]uint64 {
	if m != nil {
		return m.DataMap
	}
	return nil
}

type HeroKeysServerProto struct {
	Category HeroMapCategory `protobuf:"varint,2,opt,name=category,proto3,enum=proto.HeroMapCategory" json:"category,omitempty"`
	Keys     []uint64        `protobuf:"varint,3,rep,packed,name=keys" json:"keys,omitempty"`
}

func (m *HeroKeysServerProto) Reset()                    { *m = HeroKeysServerProto{} }
func (m *HeroKeysServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroKeysServerProto) ProtoMessage()               {}
func (*HeroKeysServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{11} }

func (m *HeroKeysServerProto) GetCategory() HeroMapCategory {
	if m != nil {
		return m.Category
	}
	return HeroMapCategory_invalid_hero_map_category
}

func (m *HeroKeysServerProto) GetKeys() []uint64 {
	if m != nil {
		return m.Keys
	}
	return nil
}

type HeroClientDatasServerProto struct {
	// 每一位表示一个bool值
	IntValue []int32 `protobuf:"varint,1,rep,packed,name=int_value,json=intValue" json:"int_value,omitempty"`
}

func (m *HeroClientDatasServerProto) Reset()                    { *m = HeroClientDatasServerProto{} }
func (m *HeroClientDatasServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroClientDatasServerProto) ProtoMessage()               {}
func (*HeroClientDatasServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{12} }

func (m *HeroClientDatasServerProto) GetIntValue() []int32 {
	if m != nil {
		return m.IntValue
	}
	return nil
}

type HeroReservationProto struct {
	// 资源
	Gold    uint64 `protobuf:"varint,1,opt,name=gold,proto3" json:"gold,omitempty"`
	Food    uint64 `protobuf:"varint,2,opt,name=food,proto3" json:"food,omitempty"`
	Wood    uint64 `protobuf:"varint,3,opt,name=wood,proto3" json:"wood,omitempty"`
	Stone   uint64 `protobuf:"varint,4,opt,name=stone,proto3" json:"stone,omitempty"`
	Jade    uint64 `protobuf:"varint,7,opt,name=jade,proto3" json:"jade,omitempty"`
	JadeOre uint64 `protobuf:"varint,8,opt,name=jade_ore,json=jadeOre,proto3" json:"jade_ore,omitempty"`
	// 元宝
	Yuanbao uint64 `protobuf:"varint,5,opt,name=yuanbao,proto3" json:"yuanbao,omitempty"`
	// 点券
	Dianquan uint64 `protobuf:"varint,9,opt,name=dianquan,proto3" json:"dianquan,omitempty"`
	// 银两
	Yinliang uint64 `protobuf:"varint,10,opt,name=yinliang,proto3" json:"yinliang,omitempty"`
	// 帮贡币
	GuildContributionCoin uint64 `protobuf:"varint,6,opt,name=guild_contribution_coin,json=guildContributionCoin,proto3" json:"guild_contribution_coin,omitempty"`
	// 物品
	Goods           map[uint64]uint64 `protobuf:"bytes,51,rep,name=goods" json:"goods,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	LastReserveTime int64             `protobuf:"varint,99,opt,name=last_reserve_time,json=lastReserveTime,proto3" json:"last_reserve_time,omitempty"`
}

func (m *HeroReservationProto) Reset()                    { *m = HeroReservationProto{} }
func (m *HeroReservationProto) String() string            { return proto.CompactTextString(m) }
func (*HeroReservationProto) ProtoMessage()               {}
func (*HeroReservationProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{13} }

func (m *HeroReservationProto) GetGold() uint64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *HeroReservationProto) GetFood() uint64 {
	if m != nil {
		return m.Food
	}
	return 0
}

func (m *HeroReservationProto) GetWood() uint64 {
	if m != nil {
		return m.Wood
	}
	return 0
}

func (m *HeroReservationProto) GetStone() uint64 {
	if m != nil {
		return m.Stone
	}
	return 0
}

func (m *HeroReservationProto) GetJade() uint64 {
	if m != nil {
		return m.Jade
	}
	return 0
}

func (m *HeroReservationProto) GetJadeOre() uint64 {
	if m != nil {
		return m.JadeOre
	}
	return 0
}

func (m *HeroReservationProto) GetYuanbao() uint64 {
	if m != nil {
		return m.Yuanbao
	}
	return 0
}

func (m *HeroReservationProto) GetDianquan() uint64 {
	if m != nil {
		return m.Dianquan
	}
	return 0
}

func (m *HeroReservationProto) GetYinliang() uint64 {
	if m != nil {
		return m.Yinliang
	}
	return 0
}

func (m *HeroReservationProto) GetGuildContributionCoin() uint64 {
	if m != nil {
		return m.GuildContributionCoin
	}
	return 0
}

func (m *HeroReservationProto) GetGoods() map[uint64]uint64 {
	if m != nil {
		return m.Goods
	}
	return nil
}

func (m *HeroReservationProto) GetLastReserveTime() int64 {
	if m != nil {
		return m.LastReserveTime
	}
	return 0
}

type RoBaseProto struct {
	Id                int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Level             uint64 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
	X                 int32  `protobuf:"varint,3,opt,name=x,proto3" json:"x,omitempty"`
	Y                 int32  `protobuf:"varint,4,opt,name=y,proto3" json:"y,omitempty"`
	Prosperity        uint64 `protobuf:"varint,5,opt,name=prosperity,proto3" json:"prosperity,omitempty"`
	ProsperityCapcity uint64 `protobuf:"varint,6,opt,name=prosperity_capcity,json=prosperityCapcity,proto3" json:"prosperity_capcity,omitempty"`
	BaseType          int32  `protobuf:"varint,7,opt,name=base_type,json=baseType,proto3" json:"base_type,omitempty"`
	Name              string `protobuf:"bytes,12,opt,name=name,proto3" json:"name,omitempty"`
	GuildId           int64  `protobuf:"varint,13,opt,name=guild_id,json=guildId,proto3" json:"guild_id,omitempty"`
	HeroType          int32  `protobuf:"varint,14,opt,name=hero_type,json=heroType,proto3" json:"hero_type,omitempty"`
	HeroId            int64  `protobuf:"varint,15,opt,name=hero_id,json=heroId,proto3" json:"hero_id,omitempty"`
	HeroEndTime       int32  `protobuf:"varint,16,opt,name=hero_end_time,json=heroEndTime,proto3" json:"hero_end_time,omitempty"`
	// Npc城池
	NpcDataId uint64 `protobuf:"varint,21,opt,name=npc_data_id,json=npcDataId,proto3" json:"npc_data_id,omitempty"`
	NpcType   int32  `protobuf:"varint,22,opt,name=npc_type,json=npcType,proto3" json:"npc_type,omitempty"`
	// 宝藏Npc专用
	Soldier        uint64   `protobuf:"varint,31,opt,name=soldier,proto3" json:"soldier,omitempty"`
	FightAmount    uint64   `protobuf:"varint,32,opt,name=fight_amount,json=fightAmount,proto3" json:"fight_amount,omitempty"`
	CaptainSoldier []uint64 `protobuf:"varint,35,rep,packed,name=captain_soldier,json=captainSoldier" json:"captain_soldier,omitempty"`
	// 军团怪
	TroopCount int32 `protobuf:"varint,41,opt,name=troop_count,json=troopCount,proto3" json:"troop_count,omitempty"`
}

func (m *RoBaseProto) Reset()                    { *m = RoBaseProto{} }
func (m *RoBaseProto) String() string            { return proto.CompactTextString(m) }
func (*RoBaseProto) ProtoMessage()               {}
func (*RoBaseProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{14} }

func (m *RoBaseProto) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RoBaseProto) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *RoBaseProto) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *RoBaseProto) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *RoBaseProto) GetProsperity() uint64 {
	if m != nil {
		return m.Prosperity
	}
	return 0
}

func (m *RoBaseProto) GetProsperityCapcity() uint64 {
	if m != nil {
		return m.ProsperityCapcity
	}
	return 0
}

func (m *RoBaseProto) GetBaseType() int32 {
	if m != nil {
		return m.BaseType
	}
	return 0
}

func (m *RoBaseProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RoBaseProto) GetGuildId() int64 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *RoBaseProto) GetHeroType() int32 {
	if m != nil {
		return m.HeroType
	}
	return 0
}

func (m *RoBaseProto) GetHeroId() int64 {
	if m != nil {
		return m.HeroId
	}
	return 0
}

func (m *RoBaseProto) GetHeroEndTime() int32 {
	if m != nil {
		return m.HeroEndTime
	}
	return 0
}

func (m *RoBaseProto) GetNpcDataId() uint64 {
	if m != nil {
		return m.NpcDataId
	}
	return 0
}

func (m *RoBaseProto) GetNpcType() int32 {
	if m != nil {
		return m.NpcType
	}
	return 0
}

func (m *RoBaseProto) GetSoldier() uint64 {
	if m != nil {
		return m.Soldier
	}
	return 0
}

func (m *RoBaseProto) GetFightAmount() uint64 {
	if m != nil {
		return m.FightAmount
	}
	return 0
}

func (m *RoBaseProto) GetCaptainSoldier() []uint64 {
	if m != nil {
		return m.CaptainSoldier
	}
	return nil
}

func (m *RoBaseProto) GetTroopCount() int32 {
	if m != nil {
		return m.TroopCount
	}
	return 0
}

type HeroBase struct {
	BaseRegion int64  `protobuf:"varint,1,opt,name=base_region,json=baseRegion,proto3" json:"base_region,omitempty"`
	BaseLevel  uint64 `protobuf:"varint,2,opt,name=base_level,json=baseLevel,proto3" json:"base_level,omitempty"`
	BaseX      int32  `protobuf:"varint,3,opt,name=base_x,json=baseX,proto3" json:"base_x,omitempty"`
	BaseY      int32  `protobuf:"varint,4,opt,name=base_y,json=baseY,proto3" json:"base_y,omitempty"`
	Prosperity uint64 `protobuf:"varint,5,opt,name=prosperity,proto3" json:"prosperity,omitempty"`
}

func (m *HeroBase) Reset()                    { *m = HeroBase{} }
func (m *HeroBase) String() string            { return proto.CompactTextString(m) }
func (*HeroBase) ProtoMessage()               {}
func (*HeroBase) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{15} }

func (m *HeroBase) GetBaseRegion() int64 {
	if m != nil {
		return m.BaseRegion
	}
	return 0
}

func (m *HeroBase) GetBaseLevel() uint64 {
	if m != nil {
		return m.BaseLevel
	}
	return 0
}

func (m *HeroBase) GetBaseX() int32 {
	if m != nil {
		return m.BaseX
	}
	return 0
}

func (m *HeroBase) GetBaseY() int32 {
	if m != nil {
		return m.BaseY
	}
	return 0
}

func (m *HeroBase) GetProsperity() uint64 {
	if m != nil {
		return m.Prosperity
	}
	return 0
}

type HeroHome struct {
	Base                                *HeroBase `protobuf:"bytes,1,opt,name=base" json:"base,omitempty"`
	LostProsperity                      uint64    `protobuf:"varint,2,opt,name=lost_prosperity,json=lostProsperity,proto3" json:"lost_prosperity,omitempty"`
	NextResetLostProsperityTime         int32     `protobuf:"varint,3,opt,name=next_reset_lost_prosperity_time,json=nextResetLostProsperityTime,proto3" json:"next_reset_lost_prosperity_time,omitempty"`
	StopLostProsperity                  bool      `protobuf:"varint,4,opt,name=stop_lost_prosperity,json=stopLostProsperity,proto3" json:"stop_lost_prosperity,omitempty"`
	MaxBaseLevel                        uint64    `protobuf:"varint,7,opt,name=max_base_level,json=maxBaseLevel,proto3" json:"max_base_level,omitempty"`
	WhiteFlagHeroId                     int64     `protobuf:"varint,31,opt,name=white_flag_hero_id,json=whiteFlagHeroId,proto3" json:"white_flag_hero_id,omitempty"`
	WhiteFlagGuildId                    int64     `protobuf:"varint,32,opt,name=white_flag_guild_id,json=whiteFlagGuildId,proto3" json:"white_flag_guild_id,omitempty"`
	WhiteFlagDisappearTime              int64     `protobuf:"varint,33,opt,name=white_flag_disappear_time,json=whiteFlagDisappearTime,proto3" json:"white_flag_disappear_time,omitempty"`
	MianStartTime                       int64     `protobuf:"varint,38,opt,name=mian_start_time,json=mianStartTime,proto3" json:"mian_start_time,omitempty"`
	MianDisappearTime                   int64     `protobuf:"varint,34,opt,name=mian_disappear_time,json=mianDisappearTime,proto3" json:"mian_disappear_time,omitempty"`
	NewHeroMianDisappearTime            int64     `protobuf:"varint,36,opt,name=new_hero_mian_disappear_time,json=newHeroMianDisappearTime,proto3" json:"new_hero_mian_disappear_time,omitempty"`
	NextUseMianGoodsTime                int64     `protobuf:"varint,37,opt,name=next_use_mian_goods_time,json=nextUseMianGoodsTime,proto3" json:"next_use_mian_goods_time,omitempty"`
	MianRebackTime                      int64     `protobuf:"varint,39,opt,name=mian_reback_time,json=mianRebackTime,proto3" json:"mian_reback_time,omitempty"`
	MoveBaseRestoreProsperityBufEndTime int64     `protobuf:"varint,35,opt,name=move_base_restore_prosperity_buf_end_time,json=moveBaseRestoreProsperityBufEndTime,proto3" json:"move_base_restore_prosperity_buf_end_time,omitempty"`
}

func (m *HeroHome) Reset()                    { *m = HeroHome{} }
func (m *HeroHome) String() string            { return proto.CompactTextString(m) }
func (*HeroHome) ProtoMessage()               {}
func (*HeroHome) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{16} }

func (m *HeroHome) GetBase() *HeroBase {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *HeroHome) GetLostProsperity() uint64 {
	if m != nil {
		return m.LostProsperity
	}
	return 0
}

func (m *HeroHome) GetNextResetLostProsperityTime() int32 {
	if m != nil {
		return m.NextResetLostProsperityTime
	}
	return 0
}

func (m *HeroHome) GetStopLostProsperity() bool {
	if m != nil {
		return m.StopLostProsperity
	}
	return false
}

func (m *HeroHome) GetMaxBaseLevel() uint64 {
	if m != nil {
		return m.MaxBaseLevel
	}
	return 0
}

func (m *HeroHome) GetWhiteFlagHeroId() int64 {
	if m != nil {
		return m.WhiteFlagHeroId
	}
	return 0
}

func (m *HeroHome) GetWhiteFlagGuildId() int64 {
	if m != nil {
		return m.WhiteFlagGuildId
	}
	return 0
}

func (m *HeroHome) GetWhiteFlagDisappearTime() int64 {
	if m != nil {
		return m.WhiteFlagDisappearTime
	}
	return 0
}

func (m *HeroHome) GetMianStartTime() int64 {
	if m != nil {
		return m.MianStartTime
	}
	return 0
}

func (m *HeroHome) GetMianDisappearTime() int64 {
	if m != nil {
		return m.MianDisappearTime
	}
	return 0
}

func (m *HeroHome) GetNewHeroMianDisappearTime() int64 {
	if m != nil {
		return m.NewHeroMianDisappearTime
	}
	return 0
}

func (m *HeroHome) GetNextUseMianGoodsTime() int64 {
	if m != nil {
		return m.NextUseMianGoodsTime
	}
	return 0
}

func (m *HeroHome) GetMianRebackTime() int64 {
	if m != nil {
		return m.MianRebackTime
	}
	return 0
}

func (m *HeroHome) GetMoveBaseRestoreProsperityBufEndTime() int64 {
	if m != nil {
		return m.MoveBaseRestoreProsperityBufEndTime
	}
	return 0
}

type HeroRegionServerProto struct {
	// 野外相关
	Home                       *HeroHome          `protobuf:"bytes,1,opt,name=home" json:"home,omitempty"`
	HomeDefenseTroopIndex      uint64             `protobuf:"varint,11,opt,name=home_defense_troop_index,json=homeDefenseTroopIndex,proto3" json:"home_defense_troop_index,omitempty"`
	HomeTroopDefeatedMailProto *proto26.MailProto `protobuf:"bytes,13,opt,name=home_troop_defeated_mail_proto,json=homeTroopDefeatedMailProto" json:"home_troop_defeated_mail_proto,omitempty"`
	// pve野怪
	CreateHomeNpcBaseIds                    []uint64                                    `protobuf:"varint,21,rep,packed,name=create_home_npc_base_ids,json=createHomeNpcBaseIds" json:"create_home_npc_base_ids,omitempty"`
	HomeNpcBase                             []*HeroHomeNpcBaseServerProto               `protobuf:"bytes,23,rep,name=home_npc_base,json=homeNpcBase" json:"home_npc_base,omitempty"`
	FavoritePoses                           *proto42.FavoritePosesProto                 `protobuf:"bytes,26,opt,name=favorite_poses,json=favoritePoses" json:"favorite_poses,omitempty"`
	NextInvestigateTime                     int64                                       `protobuf:"varint,27,opt,name=next_investigate_time,json=nextInvestigateTime,proto3" json:"next_investigate_time,omitempty"`
	MultiLevelNpc                           []*HeroMultiLevelNpcServerProto             `protobuf:"bytes,24,rep,name=multi_level_npc,json=multiLevelNpc" json:"multi_level_npc,omitempty"`
	MultiLevelNpcPassLevel                  uint64                                      `protobuf:"varint,25,opt,name=multi_level_npc_pass_level,json=multiLevelNpcPassLevel,proto3" json:"multi_level_npc_pass_level,omitempty"`
	MultiLevelNpcStartRecoveryTime          *proto1.RecoverableTimesWithExtraTimesProto `protobuf:"bytes,28,opt,name=multi_level_npc_start_recovery_time,json=multiLevelNpcStartRecoveryTime" json:"multi_level_npc_start_recovery_time,omitempty"`
	MultiLevelNpcStartTime                  int64                                       `protobuf:"varint,30,opt,name=multi_level_npc_start_time,json=multiLevelNpcStartTime,proto3" json:"multi_level_npc_start_time,omitempty"`
	InvaseHeroStartTime                     int64                                       `protobuf:"varint,36,opt,name=invase_hero_start_time,json=invaseHeroStartTime,proto3" json:"invase_hero_start_time,omitempty"`
	JunTuanNpcStartTime                     int64                                       `protobuf:"varint,39,opt,name=jun_tuan_npc_start_time,json=junTuanNpcStartTime,proto3" json:"jun_tuan_npc_start_time,omitempty"`
	Investigation                           []*HeroInvestigationServerProto             `protobuf:"bytes,29,rep,name=investigation" json:"investigation,omitempty"`
	CopyDefenserCaptainId                   []uint64                                    `protobuf:"varint,31,rep,packed,name=copy_defenser_captain_id,json=copyDefenserCaptainId" json:"copy_defenser_captain_id,omitempty"`
	CopyDefenserCaptainSoldier              []uint64                                    `protobuf:"varint,32,rep,packed,name=copy_defenser_captain_soldier,json=copyDefenserCaptainSoldier" json:"copy_defenser_captain_soldier,omitempty"`
	CopyDefenserCaptainTotalSoldier         []uint64                                    `protobuf:"varint,33,rep,packed,name=copy_defenser_captain_total_soldier,json=copyDefenserCaptainTotalSoldier" json:"copy_defenser_captain_total_soldier,omitempty"`
	CopyDefenserCaptainIndex                []uint64                                    `protobuf:"varint,34,rep,packed,name=copy_defenser_captain_index,json=copyDefenserCaptainIndex" json:"copy_defenser_captain_index,omitempty"`
	CopyDefenserCaptainXIndex               []int32                                     `protobuf:"varint,37,rep,packed,name=copy_defenser_captain_x_index,json=copyDefenserCaptainXIndex" json:"copy_defenser_captain_x_index,omitempty"`
	CopyDefenserCaptainStat                 []*proto1.SpriteStatProto                   `protobuf:"bytes,40,rep,name=copy_defenser_captain_stat,json=copyDefenserCaptainStat" json:"copy_defenser_captain_stat,omitempty"`
	CopyDefenserCaptainSpellFightAmountCoef []uint64                                    `protobuf:"varint,41,rep,packed,name=copy_defenser_captain_spell_fight_amount_coef,json=copyDefenserCaptainSpellFightAmountCoef" json:"copy_defenser_captain_spell_fight_amount_coef,omitempty"`
	CopyDefenserEndTime                     int64                                       `protobuf:"varint,35,opt,name=copy_defenser_end_time,json=copyDefenserEndTime,proto3" json:"copy_defenser_end_time,omitempty"`
	CopyDefenserTroopIndex                  uint64                                      `protobuf:"varint,38,opt,name=copy_defenser_troop_index,json=copyDefenserTroopIndex,proto3" json:"copy_defenser_troop_index,omitempty"`
}

func (m *HeroRegionServerProto) Reset()                    { *m = HeroRegionServerProto{} }
func (m *HeroRegionServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroRegionServerProto) ProtoMessage()               {}
func (*HeroRegionServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{17} }

func (m *HeroRegionServerProto) GetHome() *HeroHome {
	if m != nil {
		return m.Home
	}
	return nil
}

func (m *HeroRegionServerProto) GetHomeDefenseTroopIndex() uint64 {
	if m != nil {
		return m.HomeDefenseTroopIndex
	}
	return 0
}

func (m *HeroRegionServerProto) GetHomeTroopDefeatedMailProto() *proto26.MailProto {
	if m != nil {
		return m.HomeTroopDefeatedMailProto
	}
	return nil
}

func (m *HeroRegionServerProto) GetCreateHomeNpcBaseIds() []uint64 {
	if m != nil {
		return m.CreateHomeNpcBaseIds
	}
	return nil
}

func (m *HeroRegionServerProto) GetHomeNpcBase() []*HeroHomeNpcBaseServerProto {
	if m != nil {
		return m.HomeNpcBase
	}
	return nil
}

func (m *HeroRegionServerProto) GetFavoritePoses() *proto42.FavoritePosesProto {
	if m != nil {
		return m.FavoritePoses
	}
	return nil
}

func (m *HeroRegionServerProto) GetNextInvestigateTime() int64 {
	if m != nil {
		return m.NextInvestigateTime
	}
	return 0
}

func (m *HeroRegionServerProto) GetMultiLevelNpc() []*HeroMultiLevelNpcServerProto {
	if m != nil {
		return m.MultiLevelNpc
	}
	return nil
}

func (m *HeroRegionServerProto) GetMultiLevelNpcPassLevel() uint64 {
	if m != nil {
		return m.MultiLevelNpcPassLevel
	}
	return 0
}

func (m *HeroRegionServerProto) GetMultiLevelNpcStartRecoveryTime() *proto1.RecoverableTimesWithExtraTimesProto {
	if m != nil {
		return m.MultiLevelNpcStartRecoveryTime
	}
	return nil
}

func (m *HeroRegionServerProto) GetMultiLevelNpcStartTime() int64 {
	if m != nil {
		return m.MultiLevelNpcStartTime
	}
	return 0
}

func (m *HeroRegionServerProto) GetInvaseHeroStartTime() int64 {
	if m != nil {
		return m.InvaseHeroStartTime
	}
	return 0
}

func (m *HeroRegionServerProto) GetJunTuanNpcStartTime() int64 {
	if m != nil {
		return m.JunTuanNpcStartTime
	}
	return 0
}

func (m *HeroRegionServerProto) GetInvestigation() []*HeroInvestigationServerProto {
	if m != nil {
		return m.Investigation
	}
	return nil
}

func (m *HeroRegionServerProto) GetCopyDefenserCaptainId() []uint64 {
	if m != nil {
		return m.CopyDefenserCaptainId
	}
	return nil
}

func (m *HeroRegionServerProto) GetCopyDefenserCaptainSoldier() []uint64 {
	if m != nil {
		return m.CopyDefenserCaptainSoldier
	}
	return nil
}

func (m *HeroRegionServerProto) GetCopyDefenserCaptainTotalSoldier() []uint64 {
	if m != nil {
		return m.CopyDefenserCaptainTotalSoldier
	}
	return nil
}

func (m *HeroRegionServerProto) GetCopyDefenserCaptainIndex() []uint64 {
	if m != nil {
		return m.CopyDefenserCaptainIndex
	}
	return nil
}

func (m *HeroRegionServerProto) GetCopyDefenserCaptainXIndex() []int32 {
	if m != nil {
		return m.CopyDefenserCaptainXIndex
	}
	return nil
}

func (m *HeroRegionServerProto) GetCopyDefenserCaptainStat() []*proto1.SpriteStatProto {
	if m != nil {
		return m.CopyDefenserCaptainStat
	}
	return nil
}

func (m *HeroRegionServerProto) GetCopyDefenserCaptainSpellFightAmountCoef() []uint64 {
	if m != nil {
		return m.CopyDefenserCaptainSpellFightAmountCoef
	}
	return nil
}

func (m *HeroRegionServerProto) GetCopyDefenserEndTime() int64 {
	if m != nil {
		return m.CopyDefenserEndTime
	}
	return 0
}

func (m *HeroRegionServerProto) GetCopyDefenserTroopIndex() uint64 {
	if m != nil {
		return m.CopyDefenserTroopIndex
	}
	return 0
}

type HeroInvestigationServerProto struct {
	TargetId   int64  `protobuf:"varint,1,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
	ExpireTime int64  `protobuf:"varint,2,opt,name=expire_time,json=expireTime,proto3" json:"expire_time,omitempty"`
	MailId     uint64 `protobuf:"varint,3,opt,name=mail_id,json=mailId,proto3" json:"mail_id,omitempty"`
}

func (m *HeroInvestigationServerProto) Reset()         { *m = HeroInvestigationServerProto{} }
func (m *HeroInvestigationServerProto) String() string { return proto.CompactTextString(m) }
func (*HeroInvestigationServerProto) ProtoMessage()    {}
func (*HeroInvestigationServerProto) Descriptor() ([]byte, []int) {
	return fileDescriptorHero, []int{18}
}

func (m *HeroInvestigationServerProto) GetTargetId() int64 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

func (m *HeroInvestigationServerProto) GetExpireTime() int64 {
	if m != nil {
		return m.ExpireTime
	}
	return 0
}

func (m *HeroInvestigationServerProto) GetMailId() uint64 {
	if m != nil {
		return m.MailId
	}
	return 0
}

type HeroMultiLevelNpcServerProto struct {
	Type         proto12.MultiLevelNpcType `protobuf:"varint,1,opt,name=type,proto3,enum=proto.MultiLevelNpcType" json:"type,omitempty"`
	PassLevel    uint64                    `protobuf:"varint,2,opt,name=pass_level,json=passLevel,proto3" json:"pass_level,omitempty"`
	Hate         uint64                    `protobuf:"varint,3,opt,name=hate,proto3" json:"hate,omitempty"`
	RevengeLevel uint64                    `protobuf:"varint,4,opt,name=revenge_level,json=revengeLevel,proto3" json:"revenge_level,omitempty"`
}

func (m *HeroMultiLevelNpcServerProto) Reset()         { *m = HeroMultiLevelNpcServerProto{} }
func (m *HeroMultiLevelNpcServerProto) String() string { return proto.CompactTextString(m) }
func (*HeroMultiLevelNpcServerProto) ProtoMessage()    {}
func (*HeroMultiLevelNpcServerProto) Descriptor() ([]byte, []int) {
	return fileDescriptorHero, []int{19}
}

func (m *HeroMultiLevelNpcServerProto) GetType() proto12.MultiLevelNpcType {
	if m != nil {
		return m.Type
	}
	return proto12.MultiLevelNpcType_InvalidMultiLevelNpcType
}

func (m *HeroMultiLevelNpcServerProto) GetPassLevel() uint64 {
	if m != nil {
		return m.PassLevel
	}
	return 0
}

func (m *HeroMultiLevelNpcServerProto) GetHate() uint64 {
	if m != nil {
		return m.Hate
	}
	return 0
}

func (m *HeroMultiLevelNpcServerProto) GetRevengeLevel() uint64 {
	if m != nil {
		return m.RevengeLevel
	}
	return 0
}

type HeroHomeNpcBaseServerProto struct {
	Sequence   uint64 `protobuf:"varint,1,opt,name=sequence,proto3" json:"sequence,omitempty"`
	DataId     uint64 `protobuf:"varint,2,opt,name=data_id,json=dataId,proto3" json:"data_id,omitempty"`
	Prosperity uint64 `protobuf:"varint,3,opt,name=prosperity,proto3" json:"prosperity,omitempty"`
}

func (m *HeroHomeNpcBaseServerProto) Reset()                    { *m = HeroHomeNpcBaseServerProto{} }
func (m *HeroHomeNpcBaseServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroHomeNpcBaseServerProto) ProtoMessage()               {}
func (*HeroHomeNpcBaseServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{20} }

func (m *HeroHomeNpcBaseServerProto) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *HeroHomeNpcBaseServerProto) GetDataId() uint64 {
	if m != nil {
		return m.DataId
	}
	return 0
}

func (m *HeroHomeNpcBaseServerProto) GetProsperity() uint64 {
	if m != nil {
		return m.Prosperity
	}
	return 0
}

type HeroTowerServerProto struct {
	ChallengeTimes         uint64   `protobuf:"varint,1,opt,name=challenge_times,json=challengeTimes,proto3" json:"challenge_times,omitempty"`
	NextResetChallengeTime int64    `protobuf:"varint,8,opt,name=next_reset_challenge_time,json=nextResetChallengeTime,proto3" json:"next_reset_challenge_time,omitempty"`
	CurrentFloor           uint64   `protobuf:"varint,2,opt,name=current_floor,json=currentFloor,proto3" json:"current_floor,omitempty"`
	HistoryMaxFloor        uint64   `protobuf:"varint,3,opt,name=history_max_floor,json=historyMaxFloor,proto3" json:"history_max_floor,omitempty"`
	HistoryMaxFloorTime    int64    `protobuf:"varint,6,opt,name=history_max_floor_time,json=historyMaxFloorTime,proto3" json:"history_max_floor_time,omitempty"`
	AutoMaxFloor           uint64   `protobuf:"varint,4,opt,name=auto_max_floor,json=autoMaxFloor,proto3" json:"auto_max_floor,omitempty"`
	CollectedBoxFloors     []uint64 `protobuf:"varint,7,rep,packed,name=collected_box_floors,json=collectedBoxFloors" json:"collected_box_floors,omitempty"`
}

func (m *HeroTowerServerProto) Reset()                    { *m = HeroTowerServerProto{} }
func (m *HeroTowerServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroTowerServerProto) ProtoMessage()               {}
func (*HeroTowerServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{21} }

func (m *HeroTowerServerProto) GetChallengeTimes() uint64 {
	if m != nil {
		return m.ChallengeTimes
	}
	return 0
}

func (m *HeroTowerServerProto) GetNextResetChallengeTime() int64 {
	if m != nil {
		return m.NextResetChallengeTime
	}
	return 0
}

func (m *HeroTowerServerProto) GetCurrentFloor() uint64 {
	if m != nil {
		return m.CurrentFloor
	}
	return 0
}

func (m *HeroTowerServerProto) GetHistoryMaxFloor() uint64 {
	if m != nil {
		return m.HistoryMaxFloor
	}
	return 0
}

func (m *HeroTowerServerProto) GetHistoryMaxFloorTime() int64 {
	if m != nil {
		return m.HistoryMaxFloorTime
	}
	return 0
}

func (m *HeroTowerServerProto) GetAutoMaxFloor() uint64 {
	if m != nil {
		return m.AutoMaxFloor
	}
	return 0
}

func (m *HeroTowerServerProto) GetCollectedBoxFloors() []uint64 {
	if m != nil {
		return m.CollectedBoxFloors
	}
	return nil
}

// 密室数据
type HeroSecretTowerServerProto struct {
	ChallengeTimes                   uint64                       `protobuf:"varint,11,opt,name=challenge_times,json=challengeTimes,proto3" json:"challenge_times,omitempty"`
	HelpTimes                        uint64                       `protobuf:"varint,1,opt,name=help_times,json=helpTimes,proto3" json:"help_times,omitempty"`
	MaxOpenSecretTowerId             uint64                       `protobuf:"varint,2,opt,name=max_open_secret_tower_id,json=maxOpenSecretTowerId,proto3" json:"max_open_secret_tower_id,omitempty"`
	FirstPassSecretTowerId           []uint64                     `protobuf:"varint,4,rep,packed,name=first_pass_secret_tower_id,json=firstPassSecretTowerId" json:"first_pass_secret_tower_id,omitempty"`
	TodayAddCollectGuildContribution uint64                       `protobuf:"varint,5,opt,name=today_add_collect_guild_contribution,json=todayAddCollectGuildContribution,proto3" json:"today_add_collect_guild_contribution,omitempty"`
	HistoryChallengeTimes            uint64                       `protobuf:"varint,6,opt,name=history_challenge_times,json=historyChallengeTimes,proto3" json:"history_challenge_times,omitempty"`
	Records                          []*proto18.SecretRecordProto `protobuf:"bytes,7,rep,name=records" json:"records,omitempty"`
}

func (m *HeroSecretTowerServerProto) Reset()                    { *m = HeroSecretTowerServerProto{} }
func (m *HeroSecretTowerServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroSecretTowerServerProto) ProtoMessage()               {}
func (*HeroSecretTowerServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{22} }

func (m *HeroSecretTowerServerProto) GetChallengeTimes() uint64 {
	if m != nil {
		return m.ChallengeTimes
	}
	return 0
}

func (m *HeroSecretTowerServerProto) GetHelpTimes() uint64 {
	if m != nil {
		return m.HelpTimes
	}
	return 0
}

func (m *HeroSecretTowerServerProto) GetMaxOpenSecretTowerId() uint64 {
	if m != nil {
		return m.MaxOpenSecretTowerId
	}
	return 0
}

func (m *HeroSecretTowerServerProto) GetFirstPassSecretTowerId() []uint64 {
	if m != nil {
		return m.FirstPassSecretTowerId
	}
	return nil
}

func (m *HeroSecretTowerServerProto) GetTodayAddCollectGuildContribution() uint64 {
	if m != nil {
		return m.TodayAddCollectGuildContribution
	}
	return 0
}

func (m *HeroSecretTowerServerProto) GetHistoryChallengeTimes() uint64 {
	if m != nil {
		return m.HistoryChallengeTimes
	}
	return 0
}

func (m *HeroSecretTowerServerProto) GetRecords() []*proto18.SecretRecordProto {
	if m != nil {
		return m.Records
	}
	return nil
}

// 玩家副本
type HeroDungeonServerProto struct {
	// 保存章节已经领过的奖励
	ChapterStarPrizes []*proto22.CollectedChapterStarPrizes `protobuf:"bytes,16,rep,name=chapter_star_prizes,json=chapterStarPrizes" json:"chapter_star_prizes,omitempty"`
	// 保存章节的总星数
	ChapterStars []*proto22.DungeonChapterStar `protobuf:"bytes,14,rep,name=chapter_stars,json=chapterStars" json:"chapter_stars,omitempty"`
	// 保存通过星数的副本以及对应星数
	DungeonStars []*proto22.DungeonStar `protobuf:"bytes,12,rep,name=dungeon_stars,json=dungeonStars" json:"dungeon_stars,omitempty"`
	// 保存每日通过次数限制的副本的次数
	DungeonLimits []*proto22.DungeonPassLimit `protobuf:"bytes,13,rep,name=dungeon_limits,json=dungeonLimits" json:"dungeon_limits,omitempty"`
	// 通关了的副本
	PassDungeons []uint64 `protobuf:"varint,1,rep,packed,name=pass_dungeons,json=passDungeons" json:"pass_dungeons,omitempty"`
	// 领取了的通关副本奖励，该值是：DungeonDataProto.id 副本id
	CollectedPassDungeonPrizes []uint64 `protobuf:"varint,5,rep,packed,name=collected_pass_dungeon_prizes,json=collectedPassDungeonPrizes" json:"collected_pass_dungeon_prizes,omitempty"`
	// 领取了的章节奖励，该值是：DungeonChapterDifficultProto.id
	CollectedChapterPrizes  []uint64          `protobuf:"varint,2,rep,packed,name=collected_chapter_prizes,json=collectedChapterPrizes" json:"collected_chapter_prizes,omitempty"`
	AutoRecoverStartTime    int64             `protobuf:"varint,3,opt,name=auto_recover_start_time,json=autoRecoverStartTime,proto3" json:"auto_recover_start_time,omitempty"`
	CollectAutoTimesIndex   uint64            `protobuf:"varint,4,opt,name=collect_auto_times_index,json=collectAutoTimesIndex,proto3" json:"collect_auto_times_index,omitempty"`
	VipAddPassLimit         map[uint64]uint64 `protobuf:"bytes,8,rep,name=vip_add_pass_limit,json=vipAddPassLimit" json:"vip_add_pass_limit,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	VipAddPassBoughtTimes   map[uint64]uint64 `protobuf:"bytes,9,rep,name=vip_add_pass_bought_times,json=vipAddPassBoughtTimes" json:"vip_add_pass_bought_times,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	VipPassLimitBoughtTimes uint64            `protobuf:"varint,7,opt,name=vip_pass_limit_bought_times,json=vipPassLimitBoughtTimes,proto3" json:"vip_pass_limit_bought_times,omitempty"`
}

func (m *HeroDungeonServerProto) Reset()                    { *m = HeroDungeonServerProto{} }
func (m *HeroDungeonServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroDungeonServerProto) ProtoMessage()               {}
func (*HeroDungeonServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{23} }

func (m *HeroDungeonServerProto) GetChapterStarPrizes() []*proto22.CollectedChapterStarPrizes {
	if m != nil {
		return m.ChapterStarPrizes
	}
	return nil
}

func (m *HeroDungeonServerProto) GetChapterStars() []*proto22.DungeonChapterStar {
	if m != nil {
		return m.ChapterStars
	}
	return nil
}

func (m *HeroDungeonServerProto) GetDungeonStars() []*proto22.DungeonStar {
	if m != nil {
		return m.DungeonStars
	}
	return nil
}

func (m *HeroDungeonServerProto) GetDungeonLimits() []*proto22.DungeonPassLimit {
	if m != nil {
		return m.DungeonLimits
	}
	return nil
}

func (m *HeroDungeonServerProto) GetPassDungeons() []uint64 {
	if m != nil {
		return m.PassDungeons
	}
	return nil
}

func (m *HeroDungeonServerProto) GetCollectedPassDungeonPrizes() []uint64 {
	if m != nil {
		return m.CollectedPassDungeonPrizes
	}
	return nil
}

func (m *HeroDungeonServerProto) GetCollectedChapterPrizes() []uint64 {
	if m != nil {
		return m.CollectedChapterPrizes
	}
	return nil
}

func (m *HeroDungeonServerProto) GetAutoRecoverStartTime() int64 {
	if m != nil {
		return m.AutoRecoverStartTime
	}
	return 0
}

func (m *HeroDungeonServerProto) GetCollectAutoTimesIndex() uint64 {
	if m != nil {
		return m.CollectAutoTimesIndex
	}
	return 0
}

func (m *HeroDungeonServerProto) GetVipAddPassLimit() map[uint64]uint64 {
	if m != nil {
		return m.VipAddPassLimit
	}
	return nil
}

func (m *HeroDungeonServerProto) GetVipAddPassBoughtTimes() map[uint64]uint64 {
	if m != nil {
		return m.VipAddPassBoughtTimes
	}
	return nil
}

func (m *HeroDungeonServerProto) GetVipPassLimitBoughtTimes() uint64 {
	if m != nil {
		return m.VipPassLimitBoughtTimes
	}
	return 0
}

type HeroTaskServerProto struct {
	MainTask                uint64                                      `protobuf:"varint,1,opt,name=main_task,json=mainTask,proto3" json:"main_task,omitempty"`
	MainTaskProgress        uint64                                      `protobuf:"varint,2,opt,name=main_task_progress,json=mainTaskProgress,proto3" json:"main_task_progress,omitempty"`
	BranchTask              []uint64                                    `protobuf:"varint,11,rep,packed,name=branch_task,json=branchTask" json:"branch_task,omitempty"`
	BranchTaskProgress      []uint64                                    `protobuf:"varint,12,rep,packed,name=branch_task_progress,json=branchTaskProgress" json:"branch_task_progress,omitempty"`
	BaYeStage               *HeroBaYeStageServerProto                   `protobuf:"bytes,20,opt,name=ba_ye_stage,json=baYeStage" json:"ba_ye_stage,omitempty"`
	LastCompleteBaYeStage   uint64                                      `protobuf:"varint,21,opt,name=last_complete_ba_ye_stage,json=lastCompleteBaYeStage,proto3" json:"last_complete_ba_ye_stage,omitempty"`
	AchieveTaskList         *AchieveTaskListServerProto                 `protobuf:"bytes,30,opt,name=achieve_task_list,json=achieveTaskList" json:"achieve_task_list,omitempty"`
	ActiveDegreeTaskList    *ActiveDegreeTaskListServerProto            `protobuf:"bytes,31,opt,name=active_degree_task_list,json=activeDegreeTaskList" json:"active_degree_task_list,omitempty"`
	BwzlTaskList            *BwzlTaskListServerProto                    `protobuf:"bytes,40,opt,name=bwzl_task_list,json=bwzlTaskList" json:"bwzl_task_list,omitempty"`
	TitleTaskList           *TitleTaskListServerProto                   `protobuf:"bytes,45,opt,name=title_task_list,json=titleTaskList" json:"title_task_list,omitempty"`
	ActivityTaskListModeMap map[uint64]*ActivityTaskListModeServerProto `protobuf:"bytes,47,rep,name=activity_task_list_mode_map,json=activityTaskListModeMap" json:"activity_task_list_mode_map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// 任务野怪
	TaskMonster       []uint64 `protobuf:"varint,50,rep,packed,name=task_monster,json=taskMonster" json:"task_monster,omitempty"`
	TaskMonsterCreate []bool   `protobuf:"varint,51,rep,packed,name=task_monster_create,json=taskMonsterCreate" json:"task_monster_create,omitempty"`
	CollectTaskBoxId  uint64   `protobuf:"varint,99,opt,name=collect_task_box_id,json=collectTaskBoxId,proto3" json:"collect_task_box_id,omitempty"`
}

func (m *HeroTaskServerProto) Reset()                    { *m = HeroTaskServerProto{} }
func (m *HeroTaskServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroTaskServerProto) ProtoMessage()               {}
func (*HeroTaskServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{24} }

func (m *HeroTaskServerProto) GetMainTask() uint64 {
	if m != nil {
		return m.MainTask
	}
	return 0
}

func (m *HeroTaskServerProto) GetMainTaskProgress() uint64 {
	if m != nil {
		return m.MainTaskProgress
	}
	return 0
}

func (m *HeroTaskServerProto) GetBranchTask() []uint64 {
	if m != nil {
		return m.BranchTask
	}
	return nil
}

func (m *HeroTaskServerProto) GetBranchTaskProgress() []uint64 {
	if m != nil {
		return m.BranchTaskProgress
	}
	return nil
}

func (m *HeroTaskServerProto) GetBaYeStage() *HeroBaYeStageServerProto {
	if m != nil {
		return m.BaYeStage
	}
	return nil
}

func (m *HeroTaskServerProto) GetLastCompleteBaYeStage() uint64 {
	if m != nil {
		return m.LastCompleteBaYeStage
	}
	return 0
}

func (m *HeroTaskServerProto) GetAchieveTaskList() *AchieveTaskListServerProto {
	if m != nil {
		return m.AchieveTaskList
	}
	return nil
}

func (m *HeroTaskServerProto) GetActiveDegreeTaskList() *ActiveDegreeTaskListServerProto {
	if m != nil {
		return m.ActiveDegreeTaskList
	}
	return nil
}

func (m *HeroTaskServerProto) GetBwzlTaskList() *BwzlTaskListServerProto {
	if m != nil {
		return m.BwzlTaskList
	}
	return nil
}

func (m *HeroTaskServerProto) GetTitleTaskList() *TitleTaskListServerProto {
	if m != nil {
		return m.TitleTaskList
	}
	return nil
}

func (m *HeroTaskServerProto) GetActivityTaskListModeMap() map[uint64]*ActivityTaskListModeServerProto {
	if m != nil {
		return m.ActivityTaskListModeMap
	}
	return nil
}

func (m *HeroTaskServerProto) GetTaskMonster() []uint64 {
	if m != nil {
		return m.TaskMonster
	}
	return nil
}

func (m *HeroTaskServerProto) GetTaskMonsterCreate() []bool {
	if m != nil {
		return m.TaskMonsterCreate
	}
	return nil
}

func (m *HeroTaskServerProto) GetCollectTaskBoxId() uint64 {
	if m != nil {
		return m.CollectTaskBoxId
	}
	return 0
}

type AchieveTaskListServerProto struct {
	List               []*AchieveTaskServerProto `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
	CollectStarCount   []uint64                  `protobuf:"varint,2,rep,packed,name=collect_star_count,json=collectStarCount" json:"collect_star_count,omitempty"`
	SelectShowAchieves []uint64                  `protobuf:"varint,3,rep,packed,name=select_show_achieves,json=selectShowAchieves" json:"select_show_achieves,omitempty"`
}

func (m *AchieveTaskListServerProto) Reset()                    { *m = AchieveTaskListServerProto{} }
func (m *AchieveTaskListServerProto) String() string            { return proto.CompactTextString(m) }
func (*AchieveTaskListServerProto) ProtoMessage()               {}
func (*AchieveTaskListServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{25} }

func (m *AchieveTaskListServerProto) GetList() []*AchieveTaskServerProto {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *AchieveTaskListServerProto) GetCollectStarCount() []uint64 {
	if m != nil {
		return m.CollectStarCount
	}
	return nil
}

func (m *AchieveTaskListServerProto) GetSelectShowAchieves() []uint64 {
	if m != nil {
		return m.SelectShowAchieves
	}
	return nil
}

type AchieveTaskServerProto struct {
	Id          uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Progress    uint64 `protobuf:"varint,2,opt,name=progress,proto3" json:"progress,omitempty"`
	IsCollected bool   `protobuf:"varint,3,opt,name=is_collected,json=isCollected,proto3" json:"is_collected,omitempty"`
	ReachTime   int64  `protobuf:"varint,4,opt,name=reach_time,json=reachTime,proto3" json:"reach_time,omitempty"`
}

func (m *AchieveTaskServerProto) Reset()                    { *m = AchieveTaskServerProto{} }
func (m *AchieveTaskServerProto) String() string            { return proto.CompactTextString(m) }
func (*AchieveTaskServerProto) ProtoMessage()               {}
func (*AchieveTaskServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{26} }

func (m *AchieveTaskServerProto) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AchieveTaskServerProto) GetProgress() uint64 {
	if m != nil {
		return m.Progress
	}
	return 0
}

func (m *AchieveTaskServerProto) GetIsCollected() bool {
	if m != nil {
		return m.IsCollected
	}
	return false
}

func (m *AchieveTaskServerProto) GetReachTime() int64 {
	if m != nil {
		return m.ReachTime
	}
	return 0
}

type ActiveDegreeTaskListServerProto struct {
	List                []*ActiveDegreeTaskServerProto `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
	CollectedPrizeIndex []int32                        `protobuf:"varint,3,rep,packed,name=collected_prize_index,json=collectedPrizeIndex" json:"collected_prize_index,omitempty"`
}

func (m *ActiveDegreeTaskListServerProto) Reset()         { *m = ActiveDegreeTaskListServerProto{} }
func (m *ActiveDegreeTaskListServerProto) String() string { return proto.CompactTextString(m) }
func (*ActiveDegreeTaskListServerProto) ProtoMessage()    {}
func (*ActiveDegreeTaskListServerProto) Descriptor() ([]byte, []int) {
	return fileDescriptorHero, []int{27}
}

func (m *ActiveDegreeTaskListServerProto) GetList() []*ActiveDegreeTaskServerProto {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *ActiveDegreeTaskListServerProto) GetCollectedPrizeIndex() []int32 {
	if m != nil {
		return m.CollectedPrizeIndex
	}
	return nil
}

type ActiveDegreeTaskServerProto struct {
	Id       uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Progress uint64 `protobuf:"varint,2,opt,name=progress,proto3" json:"progress,omitempty"`
}

func (m *ActiveDegreeTaskServerProto) Reset()                    { *m = ActiveDegreeTaskServerProto{} }
func (m *ActiveDegreeTaskServerProto) String() string            { return proto.CompactTextString(m) }
func (*ActiveDegreeTaskServerProto) ProtoMessage()               {}
func (*ActiveDegreeTaskServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{28} }

func (m *ActiveDegreeTaskServerProto) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ActiveDegreeTaskServerProto) GetProgress() uint64 {
	if m != nil {
		return m.Progress
	}
	return 0
}

// 玩家霸业数据
type HeroBaYeStageServerProto struct {
	Stage        uint64   `protobuf:"varint,1,opt,name=stage,proto3" json:"stage,omitempty"`
	TaskId       []uint64 `protobuf:"varint,11,rep,packed,name=task_id,json=taskId" json:"task_id,omitempty"`
	TaskProgress []uint64 `protobuf:"varint,12,rep,packed,name=task_progress,json=taskProgress" json:"task_progress,omitempty"`
	IsCollected  []bool   `protobuf:"varint,13,rep,packed,name=is_collected,json=isCollected" json:"is_collected,omitempty"`
}

func (m *HeroBaYeStageServerProto) Reset()                    { *m = HeroBaYeStageServerProto{} }
func (m *HeroBaYeStageServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroBaYeStageServerProto) ProtoMessage()               {}
func (*HeroBaYeStageServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{29} }

func (m *HeroBaYeStageServerProto) GetStage() uint64 {
	if m != nil {
		return m.Stage
	}
	return 0
}

func (m *HeroBaYeStageServerProto) GetTaskId() []uint64 {
	if m != nil {
		return m.TaskId
	}
	return nil
}

func (m *HeroBaYeStageServerProto) GetTaskProgress() []uint64 {
	if m != nil {
		return m.TaskProgress
	}
	return nil
}

func (m *HeroBaYeStageServerProto) GetIsCollected() []bool {
	if m != nil {
		return m.IsCollected
	}
	return nil
}

type BwzlTaskListServerProto struct {
	List            []*BwzlTaskServerProto `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
	CollectedPrizes []uint64               `protobuf:"varint,2,rep,packed,name=collected_prizes,json=collectedPrizes" json:"collected_prizes,omitempty"`
}

func (m *BwzlTaskListServerProto) Reset()                    { *m = BwzlTaskListServerProto{} }
func (m *BwzlTaskListServerProto) String() string            { return proto.CompactTextString(m) }
func (*BwzlTaskListServerProto) ProtoMessage()               {}
func (*BwzlTaskListServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{30} }

func (m *BwzlTaskListServerProto) GetList() []*BwzlTaskServerProto {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *BwzlTaskListServerProto) GetCollectedPrizes() []uint64 {
	if m != nil {
		return m.CollectedPrizes
	}
	return nil
}

type BwzlTaskServerProto struct {
	Id          uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Progress    uint64 `protobuf:"varint,2,opt,name=progress,proto3" json:"progress,omitempty"`
	IsCollected bool   `protobuf:"varint,3,opt,name=is_collected,json=isCollected,proto3" json:"is_collected,omitempty"`
}

func (m *BwzlTaskServerProto) Reset()                    { *m = BwzlTaskServerProto{} }
func (m *BwzlTaskServerProto) String() string            { return proto.CompactTextString(m) }
func (*BwzlTaskServerProto) ProtoMessage()               {}
func (*BwzlTaskServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{31} }

func (m *BwzlTaskServerProto) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BwzlTaskServerProto) GetProgress() uint64 {
	if m != nil {
		return m.Progress
	}
	return 0
}

func (m *BwzlTaskServerProto) GetIsCollected() bool {
	if m != nil {
		return m.IsCollected
	}
	return false
}

type TitleTaskListServerProto struct {
	CompletedTitleId uint64                  `protobuf:"varint,1,opt,name=completed_title_id,json=completedTitleId,proto3" json:"completed_title_id,omitempty"`
	List             []*TitleTaskServerProto `protobuf:"bytes,2,rep,name=list" json:"list,omitempty"`
}

func (m *TitleTaskListServerProto) Reset()                    { *m = TitleTaskListServerProto{} }
func (m *TitleTaskListServerProto) String() string            { return proto.CompactTextString(m) }
func (*TitleTaskListServerProto) ProtoMessage()               {}
func (*TitleTaskListServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{32} }

func (m *TitleTaskListServerProto) GetCompletedTitleId() uint64 {
	if m != nil {
		return m.CompletedTitleId
	}
	return 0
}

func (m *TitleTaskListServerProto) GetList() []*TitleTaskServerProto {
	if m != nil {
		return m.List
	}
	return nil
}

type TitleTaskServerProto struct {
	Id       uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Progress uint64 `protobuf:"varint,2,opt,name=progress,proto3" json:"progress,omitempty"`
}

func (m *TitleTaskServerProto) Reset()                    { *m = TitleTaskServerProto{} }
func (m *TitleTaskServerProto) String() string            { return proto.CompactTextString(m) }
func (*TitleTaskServerProto) ProtoMessage()               {}
func (*TitleTaskServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{33} }

func (m *TitleTaskServerProto) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TitleTaskServerProto) GetProgress() uint64 {
	if m != nil {
		return m.Progress
	}
	return 0
}

// 列表示活动任务
type ActivityTaskListModeServerProto struct {
	Tasks     []*ActivityTaskServerProto `protobuf:"bytes,1,rep,name=tasks" json:"tasks,omitempty"`
	StartTime int64                      `protobuf:"varint,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   int64                      `protobuf:"varint,3,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (m *ActivityTaskListModeServerProto) Reset()         { *m = ActivityTaskListModeServerProto{} }
func (m *ActivityTaskListModeServerProto) String() string { return proto.CompactTextString(m) }
func (*ActivityTaskListModeServerProto) ProtoMessage()    {}
func (*ActivityTaskListModeServerProto) Descriptor() ([]byte, []int) {
	return fileDescriptorHero, []int{34}
}

func (m *ActivityTaskListModeServerProto) GetTasks() []*ActivityTaskServerProto {
	if m != nil {
		return m.Tasks
	}
	return nil
}

func (m *ActivityTaskListModeServerProto) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *ActivityTaskListModeServerProto) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type ActivityTaskServerProto struct {
	Id          uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Progress    uint64 `protobuf:"varint,2,opt,name=progress,proto3" json:"progress,omitempty"`
	IsCollected bool   `protobuf:"varint,3,opt,name=is_collected,json=isCollected,proto3" json:"is_collected,omitempty"`
}

func (m *ActivityTaskServerProto) Reset()                    { *m = ActivityTaskServerProto{} }
func (m *ActivityTaskServerProto) String() string            { return proto.CompactTextString(m) }
func (*ActivityTaskServerProto) ProtoMessage()               {}
func (*ActivityTaskServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{35} }

func (m *ActivityTaskServerProto) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ActivityTaskServerProto) GetProgress() uint64 {
	if m != nil {
		return m.Progress
	}
	return 0
}

func (m *ActivityTaskServerProto) GetIsCollected() bool {
	if m != nil {
		return m.IsCollected
	}
	return false
}

type StratagemServerProto struct {
	Id              uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	DailyUsedTimes  uint64 `protobuf:"varint,2,opt,name=daily_used_times,json=dailyUsedTimes,proto3" json:"daily_used_times,omitempty"`
	NextUseableTime int64  `protobuf:"varint,3,opt,name=next_useable_time,json=nextUseableTime,proto3" json:"next_useable_time,omitempty"`
}

func (m *StratagemServerProto) Reset()                    { *m = StratagemServerProto{} }
func (m *StratagemServerProto) String() string            { return proto.CompactTextString(m) }
func (*StratagemServerProto) ProtoMessage()               {}
func (*StratagemServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{36} }

func (m *StratagemServerProto) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StratagemServerProto) GetDailyUsedTimes() uint64 {
	if m != nil {
		return m.DailyUsedTimes
	}
	return 0
}

func (m *StratagemServerProto) GetNextUseableTime() int64 {
	if m != nil {
		return m.NextUseableTime
	}
	return 0
}

type TrappedStratagemServerProto struct {
	Id      uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	EndTime int64  `protobuf:"varint,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (m *TrappedStratagemServerProto) Reset()                    { *m = TrappedStratagemServerProto{} }
func (m *TrappedStratagemServerProto) String() string            { return proto.CompactTextString(m) }
func (*TrappedStratagemServerProto) ProtoMessage()               {}
func (*TrappedStratagemServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{37} }

func (m *TrappedStratagemServerProto) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrappedStratagemServerProto) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type StratagemTargetTimesServerProto struct {
	Id    int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Times uint64 `protobuf:"varint,2,opt,name=times,proto3" json:"times,omitempty"`
}

func (m *StratagemTargetTimesServerProto) Reset()         { *m = StratagemTargetTimesServerProto{} }
func (m *StratagemTargetTimesServerProto) String() string { return proto.CompactTextString(m) }
func (*StratagemTargetTimesServerProto) ProtoMessage()    {}
func (*StratagemTargetTimesServerProto) Descriptor() ([]byte, []int) {
	return fileDescriptorHero, []int{38}
}

func (m *StratagemTargetTimesServerProto) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StratagemTargetTimesServerProto) GetTimes() uint64 {
	if m != nil {
		return m.Times
	}
	return 0
}

type HeroStrategyServerProto struct {
	Stratagems        []*StratagemServerProto            `protobuf:"bytes,5,rep,name=stratagems" json:"stratagems,omitempty"`
	TrappedStratagems []*TrappedStratagemServerProto     `protobuf:"bytes,2,rep,name=trapped_stratagems,json=trappedStratagems" json:"trapped_stratagems,omitempty"`
	TodayTargetTimes  []*StratagemTargetTimesServerProto `protobuf:"bytes,3,rep,name=today_target_times,json=todayTargetTimes" json:"today_target_times,omitempty"`
	TodayTrappedTimes uint64                             `protobuf:"varint,4,opt,name=today_trapped_times,json=todayTrappedTimes,proto3" json:"today_trapped_times,omitempty"`
}

func (m *HeroStrategyServerProto) Reset()                    { *m = HeroStrategyServerProto{} }
func (m *HeroStrategyServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroStrategyServerProto) ProtoMessage()               {}
func (*HeroStrategyServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{39} }

func (m *HeroStrategyServerProto) GetStratagems() []*StratagemServerProto {
	if m != nil {
		return m.Stratagems
	}
	return nil
}

func (m *HeroStrategyServerProto) GetTrappedStratagems() []*TrappedStratagemServerProto {
	if m != nil {
		return m.TrappedStratagems
	}
	return nil
}

func (m *HeroStrategyServerProto) GetTodayTargetTimes() []*StratagemTargetTimesServerProto {
	if m != nil {
		return m.TodayTargetTimes
	}
	return nil
}

func (m *HeroStrategyServerProto) GetTodayTrappedTimes() uint64 {
	if m != nil {
		return m.TodayTrappedTimes
	}
	return 0
}

type HeroBufferServerProto struct {
	Buf *proto43.HeroBufferProto `protobuf:"bytes,1,opt,name=buf" json:"buf,omitempty"`
}

func (m *HeroBufferServerProto) Reset()                    { *m = HeroBufferServerProto{} }
func (m *HeroBufferServerProto) String() string            { return proto.CompactTextString(m) }
func (*HeroBufferServerProto) ProtoMessage()               {}
func (*HeroBufferServerProto) Descriptor() ([]byte, []int) { return fileDescriptorHero, []int{40} }

func (m *HeroBufferServerProto) GetBuf() *proto43.HeroBufferProto {
	if m != nil {
		return m.Buf
	}
	return nil
}

func init() {
	proto.RegisterType((*HeroServerProto)(nil), "proto.HeroServerProto")
	proto.RegisterType((*BlackMarketGoodsItemServerProto)(nil), "proto.BlackMarketGoodsItemServerProto")
	proto.RegisterType((*HeroShopServerProto)(nil), "proto.HeroShopServerProto")
	proto.RegisterType((*HeroMiscServerProto)(nil), "proto.HeroMiscServerProto")
	proto.RegisterType((*HeroPromotionServerProto)(nil), "proto.HeroPromotionServerProto")
	proto.RegisterType((*HeroActivityServerProto)(nil), "proto.HeroActivityServerProto")
	proto.RegisterType((*HeroRelationServerProto)(nil), "proto.HeroRelationServerProto")
	proto.RegisterType((*HeroRandomEventServerProto)(nil), "proto.HeroRandomEventServerProto")
	proto.RegisterType((*HeroTreasuryTreeServerProto)(nil), "proto.HeroTreasuryTreeServerProto")
	proto.RegisterType((*HeroGuildEventPrizeServerProto)(nil), "proto.HeroGuildEventPrizeServerProto")
	proto.RegisterType((*HeroMapServerProto)(nil), "proto.HeroMapServerProto")
	proto.RegisterType((*HeroKeysServerProto)(nil), "proto.HeroKeysServerProto")
	proto.RegisterType((*HeroClientDatasServerProto)(nil), "proto.HeroClientDatasServerProto")
	proto.RegisterType((*HeroReservationProto)(nil), "proto.HeroReservationProto")
	proto.RegisterType((*RoBaseProto)(nil), "proto.RoBaseProto")
	proto.RegisterType((*HeroBase)(nil), "proto.HeroBase")
	proto.RegisterType((*HeroHome)(nil), "proto.HeroHome")
	proto.RegisterType((*HeroRegionServerProto)(nil), "proto.HeroRegionServerProto")
	proto.RegisterType((*HeroInvestigationServerProto)(nil), "proto.HeroInvestigationServerProto")
	proto.RegisterType((*HeroMultiLevelNpcServerProto)(nil), "proto.HeroMultiLevelNpcServerProto")
	proto.RegisterType((*HeroHomeNpcBaseServerProto)(nil), "proto.HeroHomeNpcBaseServerProto")
	proto.RegisterType((*HeroTowerServerProto)(nil), "proto.HeroTowerServerProto")
	proto.RegisterType((*HeroSecretTowerServerProto)(nil), "proto.HeroSecretTowerServerProto")
	proto.RegisterType((*HeroDungeonServerProto)(nil), "proto.HeroDungeonServerProto")
	proto.RegisterType((*HeroTaskServerProto)(nil), "proto.HeroTaskServerProto")
	proto.RegisterType((*AchieveTaskListServerProto)(nil), "proto.AchieveTaskListServerProto")
	proto.RegisterType((*AchieveTaskServerProto)(nil), "proto.AchieveTaskServerProto")
	proto.RegisterType((*ActiveDegreeTaskListServerProto)(nil), "proto.ActiveDegreeTaskListServerProto")
	proto.RegisterType((*ActiveDegreeTaskServerProto)(nil), "proto.ActiveDegreeTaskServerProto")
	proto.RegisterType((*HeroBaYeStageServerProto)(nil), "proto.HeroBaYeStageServerProto")
	proto.RegisterType((*BwzlTaskListServerProto)(nil), "proto.BwzlTaskListServerProto")
	proto.RegisterType((*BwzlTaskServerProto)(nil), "proto.BwzlTaskServerProto")
	proto.RegisterType((*TitleTaskListServerProto)(nil), "proto.TitleTaskListServerProto")
	proto.RegisterType((*TitleTaskServerProto)(nil), "proto.TitleTaskServerProto")
	proto.RegisterType((*ActivityTaskListModeServerProto)(nil), "proto.ActivityTaskListModeServerProto")
	proto.RegisterType((*ActivityTaskServerProto)(nil), "proto.ActivityTaskServerProto")
	proto.RegisterType((*StratagemServerProto)(nil), "proto.StratagemServerProto")
	proto.RegisterType((*TrappedStratagemServerProto)(nil), "proto.TrappedStratagemServerProto")
	proto.RegisterType((*StratagemTargetTimesServerProto)(nil), "proto.StratagemTargetTimesServerProto")
	proto.RegisterType((*HeroStrategyServerProto)(nil), "proto.HeroStrategyServerProto")
	proto.RegisterType((*HeroBufferServerProto)(nil), "proto.HeroBufferServerProto")
	proto.RegisterEnum("proto.HeroMapCategory", HeroMapCategory_name, HeroMapCategory_value)
	proto.RegisterEnum("proto.HistoryAmountType", HistoryAmountType_name, HistoryAmountType_value)
}
func (m *HeroServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Domestic != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Domestic.Size()))
		n1, err := m.Domestic.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Military != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Military.Size()))
		n2, err := m.Military.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.OldName) > 0 {
		for _, s := range m.OldName {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Level != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Level))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Exp))
	}
	if m.Male {
		dAtA[i] = 0x70
		i++
		if m.Male {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NextChangeNameTime != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.NextChangeNameTime))
	}
	if m.LastOfflineTime != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.LastOfflineTime))
	}
	if m.ChangeHeroNameTimes != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ChangeHeroNameTimes))
	}
	if m.GiveFirstChangeHeroNamePrize {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.GiveFirstChangeHeroNamePrize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Body != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Body))
	}
	if m.SafeGold != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.SafeGold))
	}
	if m.SafeFood != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.SafeFood))
	}
	if m.SafeWood != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.SafeWood))
	}
	if m.SafeStone != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.SafeStone))
	}
	if len(m.Head) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.Head)))
		i += copy(dAtA[i:], m.Head)
	}
	if m.Region != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Region.Size()))
		n3, err := m.Region.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.GuildId != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.GuildId))
	}
	if m.JoinGuildTime != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.JoinGuildTime))
	}
	if m.CollectedDailyGuildRankPrize {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		if m.CollectedDailyGuildRankPrize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ContributionCoin != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ContributionCoin))
	}
	if len(m.GuildDonateTimes) > 0 {
		dAtA5 := make([]byte, len(m.GuildDonateTimes)*10)
		var j4 int
		for _, num := range m.GuildDonateTimes {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if len(m.JoinGuildIds) > 0 {
		dAtA7 := make([]byte, len(m.JoinGuildIds)*10)
		var j6 int
		for _, num1 := range m.JoinGuildIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if len(m.BeenInvateGuildIds) > 0 {
		dAtA9 := make([]byte, len(m.BeenInvateGuildIds)*10)
		var j8 int
		for _, num1 := range m.BeenInvateGuildIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	if m.NextNotifyGuildTime != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.NextNotifyGuildTime))
	}
	if m.CollectedFirstJoinGuildPrize {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		if m.CollectedFirstJoinGuildPrize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Yuanbao != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Yuanbao))
	}
	if m.Gold != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Gold))
	}
	if m.Food != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Food))
	}
	if m.Wood != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Wood))
	}
	if m.Stone != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Stone))
	}
	if m.Jade != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Jade))
	}
	if m.JadeOre != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.JadeOre))
	}
	if m.HistoryJade != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.HistoryJade))
	}
	if m.TodayObtainJade != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.TodayObtainJade))
	}
	if m.Depot != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Depot.Size()))
		n10, err := m.Depot.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Tower != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Tower.Size()))
		n11, err := m.Tower.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Task != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Task.Size()))
		n12, err := m.Task.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.CaptainSoul != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CaptainSoul.Size()))
		n13, err := m.CaptainSoul.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.OpenCombineEquip != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.OpenCombineEquip.Size()))
		n14, err := m.OpenCombineEquip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.SecretTower != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.SecretTower.Size()))
		n15, err := m.SecretTower.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Dungeon != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Dungeon.Size()))
		n16, err := m.Dungeon.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.BufEffect != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.BufEffect.Size()))
		n17, err := m.BufEffect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Tag != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Tag.Size()))
		n18, err := m.Tag.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Strategy != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Strategy.Size()))
		n19, err := m.Strategy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.ClientDatas != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ClientDatas.Size()))
		n20, err := m.ClientDatas.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Fishing != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Fishing.Size()))
		n21, err := m.Fishing.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Function != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Function.Size()))
		n22, err := m.Function.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.GuiZu != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.GuiZu.Size()))
		n23, err := m.GuiZu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if len(m.GuildEventPrizes) > 0 {
		for _, msg := range m.GuildEventPrizes {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x4
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TreasuryTree != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.TreasuryTree.Size()))
		n24, err := m.TreasuryTree.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.ZhengWu != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ZhengWu.Size()))
		n25, err := m.ZhengWu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.ZhanJiang != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ZhanJiang.Size()))
		n26, err := m.ZhanJiang.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Question != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Question.Size()))
		n27, err := m.Question.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Relation != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Relation.Size()))
		n28, err := m.Relation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.Survey != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Survey.Size()))
		n29, err := m.Survey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CreateTime))
	}
	if m.Settings != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Settings.Size()))
		n30, err := m.Settings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.Hebi != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Hebi.Size()))
		n31, err := m.Hebi.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.Location != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Location))
	}
	if m.Shop != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Shop.Size()))
		n32, err := m.Shop.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.RandomEvent != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.RandomEvent.Size()))
		n33, err := m.RandomEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.Buff != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Buff.Size()))
		n34, err := m.Buff.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.WorkshopOutputStartTime != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.WorkshopOutputStartTime))
	}
	if len(m.CollectedGuildTaskStages) > 0 {
		for k, _ := range m.CollectedGuildTaskStages {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x5
			i++
			v := m.CollectedGuildTaskStages[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovHero(uint64(msgSize))
			}
			mapSize := 1 + sovHero(uint64(k)) + msgSize
			i = encodeVarintHero(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintHero(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintHero(dAtA, i, uint64(v.Size()))
				n35, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n35
			}
		}
	}
	if m.Reservation != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Reservation.Size()))
		n36, err := m.Reservation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.TotalOnlineTime != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.TotalOnlineTime))
	}
	if m.LoginTime != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.LoginTime))
	}
	if len(m.HeroMaps) > 0 {
		for _, msg := range m.HeroMaps {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.HeroBools) > 0 {
		dAtA38 := make([]byte, len(m.HeroBools)*10)
		var j37 int
		for _, num := range m.HeroBools {
			for num >= 1<<7 {
				dAtA38[j37] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j37++
			}
			dAtA38[j37] = uint8(num)
			j37++
		}
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(j37))
		i += copy(dAtA[i:], dAtA38[:j37])
	}
	if m.Misc != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Misc.Size()))
		n39, err := m.Misc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.Dianquan != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Dianquan))
	}
	if m.NextResDecayTime != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.NextResDecayTime))
	}
	if m.HeroGen != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.HeroGen.Size()))
		n40, err := m.HeroGen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if len(m.HeroKeys) > 0 {
		for _, msg := range m.HeroKeys {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Yinliang != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Yinliang))
	}
	if m.Sp != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Sp))
	}
	if m.LastRecoverSpTime != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.LastRecoverSpTime))
	}
	if m.BuySpTimes != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.BuySpTimes))
	}
	if m.Vip != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Vip.Size()))
		n41, err := m.Vip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.Promotion != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Promotion.Size()))
		n42, err := m.Promotion.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.McBuild != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.McBuild.Size()))
		n43, err := m.McBuild.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.RedPacket != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.RedPacket.Size()))
		n44, err := m.RedPacket.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.Teach != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Teach.Size()))
		n45, err := m.Teach.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.CountryMisc != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CountryMisc.Size()))
		n46, err := m.CountryMisc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.Activity != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Activity.Size()))
		n47, err := m.Activity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func (m *BlackMarketGoodsItemServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlackMarketGoodsItemServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Goods != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Goods))
	}
	if m.Discount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Discount))
	}
	if m.Buy {
		dAtA[i] = 0x18
		i++
		if m.Buy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *HeroShopServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroShopServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Item) > 0 {
		for _, msg := range m.Item {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HeroMiscServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroMiscServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FarmShowUnlockAnimationBaseLevel != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.FarmShowUnlockAnimationBaseLevel))
	}
	if m.ChargeAmount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ChargeAmount))
	}
	if m.LastChargeTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.LastChargeTime))
	}
	if len(m.DurationCards) > 0 {
		for k, _ := range m.DurationCards {
			dAtA[i] = 0x22
			i++
			v := m.DurationCards[k]
			mapSize := 1 + sovHero(uint64(k)) + 1 + sovHero(uint64(v))
			i = encodeVarintHero(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintHero(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintHero(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *HeroPromotionServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroPromotionServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BuyTimeLimitGift) > 0 {
		for _, msg := range m.BuyTimeLimitGift {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EventLimitGifts) > 0 {
		for _, msg := range m.EventLimitGifts {
			dAtA[i] = 0x12
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HeroActivityServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroActivityServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Collections) > 0 {
		for k, _ := range m.Collections {
			dAtA[i] = 0x1a
			i++
			v := m.Collections[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovHero(uint64(msgSize))
			}
			mapSize := 1 + sovHero(uint64(k)) + msgSize
			i = encodeVarintHero(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintHero(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintHero(dAtA, i, uint64(v.Size()))
				n48, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n48
			}
		}
	}
	return i, nil
}

func (m *HeroRelationServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroRelationServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Friend) > 0 {
		dAtA50 := make([]byte, len(m.Friend)*10)
		var j49 int
		for _, num1 := range m.Friend {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA50[j49] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j49++
			}
			dAtA50[j49] = uint8(num)
			j49++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintHero(dAtA, i, uint64(j49))
		i += copy(dAtA[i:], dAtA50[:j49])
	}
	if len(m.Black) > 0 {
		dAtA52 := make([]byte, len(m.Black)*10)
		var j51 int
		for _, num1 := range m.Black {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA52[j51] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j51++
			}
			dAtA52[j51] = uint8(num)
			j51++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintHero(dAtA, i, uint64(j51))
		i += copy(dAtA[i:], dAtA52[:j51])
	}
	if len(m.Enemy) > 0 {
		for k, _ := range m.Enemy {
			dAtA[i] = 0x1a
			i++
			v := m.Enemy[k]
			mapSize := 1 + sovHero(uint64(k)) + 1 + sovHero(uint64(v))
			i = encodeVarintHero(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintHero(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintHero(dAtA, i, uint64(v))
		}
	}
	if len(m.Important) > 0 {
		for k, _ := range m.Important {
			dAtA[i] = 0x22
			i++
			v := m.Important[k]
			mapSize := 1 + sovHero(uint64(k)) + 1 + sovHero(uint64(v))
			i = encodeVarintHero(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintHero(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintHero(dAtA, i, uint64(v))
		}
	}
	if len(m.FriendCreateTime) > 0 {
		dAtA54 := make([]byte, len(m.FriendCreateTime)*10)
		var j53 int
		for _, num1 := range m.FriendCreateTime {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA54[j53] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j53++
			}
			dAtA54[j53] = uint8(num)
			j53++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHero(dAtA, i, uint64(j53))
		i += copy(dAtA[i:], dAtA54[:j53])
	}
	if len(m.BlackCreateTime) > 0 {
		dAtA56 := make([]byte, len(m.BlackCreateTime)*10)
		var j55 int
		for _, num1 := range m.BlackCreateTime {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA56[j55] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j55++
			}
			dAtA56[j55] = uint8(num)
			j55++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintHero(dAtA, i, uint64(j55))
		i += copy(dAtA[i:], dAtA56[:j55])
	}
	return i, nil
}

func (m *HeroRandomEventServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroRandomEventServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.BigRefreshTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.BigRefreshTime))
	}
	if m.SmallRefreshTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.SmallRefreshTime))
	}
	if len(m.Handbooks) > 0 {
		dAtA58 := make([]byte, len(m.Handbooks)*10)
		var j57 int
		for _, num := range m.Handbooks {
			for num >= 1<<7 {
				dAtA58[j57] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j57++
			}
			dAtA58[j57] = uint8(num)
			j57++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintHero(dAtA, i, uint64(j57))
		i += copy(dAtA[i:], dAtA58[:j57])
	}
	return i, nil
}

func (m *HeroTreasuryTreeServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroTreasuryTreeServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WaterTimes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.WaterTimes))
	}
	if m.CollectSession != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CollectSession))
	}
	if m.CollectTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CollectTime))
	}
	if len(m.WaterHeroIds) > 0 {
		dAtA60 := make([]byte, len(m.WaterHeroIds)*10)
		var j59 int
		for _, num1 := range m.WaterHeroIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA60[j59] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j59++
			}
			dAtA60[j59] = uint8(num)
			j59++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintHero(dAtA, i, uint64(j59))
		i += copy(dAtA[i:], dAtA60[:j59])
	}
	if len(m.HelpMeHeroIds) > 0 {
		dAtA62 := make([]byte, len(m.HelpMeHeroIds)*10)
		var j61 int
		for _, num1 := range m.HelpMeHeroIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA62[j61] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j61++
			}
			dAtA62[j61] = uint8(num)
			j61++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHero(dAtA, i, uint64(j61))
		i += copy(dAtA[i:], dAtA62[:j61])
	}
	return i, nil
}

func (m *HeroGuildEventPrizeServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroGuildEventPrizeServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HideGiver {
		dAtA[i] = 0x8
		i++
		if m.HideGiver {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DataId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.DataId))
	}
	if m.SendHeroId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.SendHeroId))
	}
	if m.ExpireTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ExpireTime))
	}
	return i, nil
}

func (m *HeroMapServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroMapServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Category != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Category))
	}
	if len(m.DataMap) > 0 {
		for k, _ := range m.DataMap {
			dAtA[i] = 0x1a
			i++
			v := m.DataMap[k]
			mapSize := 1 + sovHero(uint64(k)) + 1 + sovHero(uint64(v))
			i = encodeVarintHero(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintHero(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintHero(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *HeroKeysServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroKeysServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Category != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Category))
	}
	if len(m.Keys) > 0 {
		dAtA64 := make([]byte, len(m.Keys)*10)
		var j63 int
		for _, num := range m.Keys {
			for num >= 1<<7 {
				dAtA64[j63] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j63++
			}
			dAtA64[j63] = uint8(num)
			j63++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHero(dAtA, i, uint64(j63))
		i += copy(dAtA[i:], dAtA64[:j63])
	}
	return i, nil
}

func (m *HeroClientDatasServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroClientDatasServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IntValue) > 0 {
		dAtA66 := make([]byte, len(m.IntValue)*10)
		var j65 int
		for _, num1 := range m.IntValue {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA66[j65] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j65++
			}
			dAtA66[j65] = uint8(num)
			j65++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintHero(dAtA, i, uint64(j65))
		i += copy(dAtA[i:], dAtA66[:j65])
	}
	return i, nil
}

func (m *HeroReservationProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroReservationProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gold != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Gold))
	}
	if m.Food != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Food))
	}
	if m.Wood != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Wood))
	}
	if m.Stone != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Stone))
	}
	if m.Yuanbao != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Yuanbao))
	}
	if m.GuildContributionCoin != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.GuildContributionCoin))
	}
	if m.Jade != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Jade))
	}
	if m.JadeOre != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.JadeOre))
	}
	if m.Dianquan != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Dianquan))
	}
	if m.Yinliang != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Yinliang))
	}
	if len(m.Goods) > 0 {
		for k, _ := range m.Goods {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x3
			i++
			v := m.Goods[k]
			mapSize := 1 + sovHero(uint64(k)) + 1 + sovHero(uint64(v))
			i = encodeVarintHero(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintHero(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintHero(dAtA, i, uint64(v))
		}
	}
	if m.LastReserveTime != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.LastReserveTime))
	}
	return i, nil
}

func (m *RoBaseProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoBaseProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Id))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Level))
	}
	if m.X != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Y))
	}
	if m.Prosperity != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Prosperity))
	}
	if m.ProsperityCapcity != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ProsperityCapcity))
	}
	if m.BaseType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.BaseType))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.GuildId))
	}
	if m.HeroType != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.HeroType))
	}
	if m.HeroId != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.HeroId))
	}
	if m.HeroEndTime != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.HeroEndTime))
	}
	if m.NpcDataId != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.NpcDataId))
	}
	if m.NpcType != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.NpcType))
	}
	if m.Soldier != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Soldier))
	}
	if m.FightAmount != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.FightAmount))
	}
	if len(m.CaptainSoldier) > 0 {
		dAtA68 := make([]byte, len(m.CaptainSoldier)*10)
		var j67 int
		for _, num := range m.CaptainSoldier {
			for num >= 1<<7 {
				dAtA68[j67] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j67++
			}
			dAtA68[j67] = uint8(num)
			j67++
		}
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(j67))
		i += copy(dAtA[i:], dAtA68[:j67])
	}
	if m.TroopCount != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.TroopCount))
	}
	return i, nil
}

func (m *HeroBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroBase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BaseRegion != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.BaseRegion))
	}
	if m.BaseLevel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.BaseLevel))
	}
	if m.BaseX != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.BaseX))
	}
	if m.BaseY != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.BaseY))
	}
	if m.Prosperity != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Prosperity))
	}
	return i, nil
}

func (m *HeroHome) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroHome) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Base != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Base.Size()))
		n69, err := m.Base.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if m.LostProsperity != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.LostProsperity))
	}
	if m.NextResetLostProsperityTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.NextResetLostProsperityTime))
	}
	if m.StopLostProsperity {
		dAtA[i] = 0x20
		i++
		if m.StopLostProsperity {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxBaseLevel != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MaxBaseLevel))
	}
	if m.WhiteFlagHeroId != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.WhiteFlagHeroId))
	}
	if m.WhiteFlagGuildId != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.WhiteFlagGuildId))
	}
	if m.WhiteFlagDisappearTime != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.WhiteFlagDisappearTime))
	}
	if m.MianDisappearTime != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MianDisappearTime))
	}
	if m.MoveBaseRestoreProsperityBufEndTime != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MoveBaseRestoreProsperityBufEndTime))
	}
	if m.NewHeroMianDisappearTime != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.NewHeroMianDisappearTime))
	}
	if m.NextUseMianGoodsTime != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.NextUseMianGoodsTime))
	}
	if m.MianStartTime != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MianStartTime))
	}
	if m.MianRebackTime != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MianRebackTime))
	}
	return i, nil
}

func (m *HeroRegionServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroRegionServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Home != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Home.Size()))
		n70, err := m.Home.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	if m.HomeDefenseTroopIndex != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.HomeDefenseTroopIndex))
	}
	if m.HomeTroopDefeatedMailProto != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.HomeTroopDefeatedMailProto.Size()))
		n71, err := m.HomeTroopDefeatedMailProto.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if len(m.CreateHomeNpcBaseIds) > 0 {
		dAtA73 := make([]byte, len(m.CreateHomeNpcBaseIds)*10)
		var j72 int
		for _, num := range m.CreateHomeNpcBaseIds {
			for num >= 1<<7 {
				dAtA73[j72] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j72++
			}
			dAtA73[j72] = uint8(num)
			j72++
		}
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(j72))
		i += copy(dAtA[i:], dAtA73[:j72])
	}
	if len(m.HomeNpcBase) > 0 {
		for _, msg := range m.HomeNpcBase {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MultiLevelNpc) > 0 {
		for _, msg := range m.MultiLevelNpc {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MultiLevelNpcPassLevel != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MultiLevelNpcPassLevel))
	}
	if m.FavoritePoses != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.FavoritePoses.Size()))
		n74, err := m.FavoritePoses.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if m.NextInvestigateTime != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.NextInvestigateTime))
	}
	if m.MultiLevelNpcStartRecoveryTime != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MultiLevelNpcStartRecoveryTime.Size()))
		n75, err := m.MultiLevelNpcStartRecoveryTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	if len(m.Investigation) > 0 {
		for _, msg := range m.Investigation {
			dAtA[i] = 0xea
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MultiLevelNpcStartTime != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MultiLevelNpcStartTime))
	}
	if len(m.CopyDefenserCaptainId) > 0 {
		dAtA77 := make([]byte, len(m.CopyDefenserCaptainId)*10)
		var j76 int
		for _, num := range m.CopyDefenserCaptainId {
			for num >= 1<<7 {
				dAtA77[j76] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j76++
			}
			dAtA77[j76] = uint8(num)
			j76++
		}
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(j76))
		i += copy(dAtA[i:], dAtA77[:j76])
	}
	if len(m.CopyDefenserCaptainSoldier) > 0 {
		dAtA79 := make([]byte, len(m.CopyDefenserCaptainSoldier)*10)
		var j78 int
		for _, num := range m.CopyDefenserCaptainSoldier {
			for num >= 1<<7 {
				dAtA79[j78] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j78++
			}
			dAtA79[j78] = uint8(num)
			j78++
		}
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(j78))
		i += copy(dAtA[i:], dAtA79[:j78])
	}
	if len(m.CopyDefenserCaptainTotalSoldier) > 0 {
		dAtA81 := make([]byte, len(m.CopyDefenserCaptainTotalSoldier)*10)
		var j80 int
		for _, num := range m.CopyDefenserCaptainTotalSoldier {
			for num >= 1<<7 {
				dAtA81[j80] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j80++
			}
			dAtA81[j80] = uint8(num)
			j80++
		}
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(j80))
		i += copy(dAtA[i:], dAtA81[:j80])
	}
	if len(m.CopyDefenserCaptainIndex) > 0 {
		dAtA83 := make([]byte, len(m.CopyDefenserCaptainIndex)*10)
		var j82 int
		for _, num := range m.CopyDefenserCaptainIndex {
			for num >= 1<<7 {
				dAtA83[j82] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j82++
			}
			dAtA83[j82] = uint8(num)
			j82++
		}
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(j82))
		i += copy(dAtA[i:], dAtA83[:j82])
	}
	if m.CopyDefenserEndTime != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CopyDefenserEndTime))
	}
	if m.InvaseHeroStartTime != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.InvaseHeroStartTime))
	}
	if len(m.CopyDefenserCaptainXIndex) > 0 {
		dAtA85 := make([]byte, len(m.CopyDefenserCaptainXIndex)*10)
		var j84 int
		for _, num1 := range m.CopyDefenserCaptainXIndex {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA85[j84] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j84++
			}
			dAtA85[j84] = uint8(num)
			j84++
		}
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(j84))
		i += copy(dAtA[i:], dAtA85[:j84])
	}
	if m.CopyDefenserTroopIndex != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CopyDefenserTroopIndex))
	}
	if m.JunTuanNpcStartTime != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.JunTuanNpcStartTime))
	}
	if len(m.CopyDefenserCaptainStat) > 0 {
		for _, msg := range m.CopyDefenserCaptainStat {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CopyDefenserCaptainSpellFightAmountCoef) > 0 {
		dAtA87 := make([]byte, len(m.CopyDefenserCaptainSpellFightAmountCoef)*10)
		var j86 int
		for _, num := range m.CopyDefenserCaptainSpellFightAmountCoef {
			for num >= 1<<7 {
				dAtA87[j86] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j86++
			}
			dAtA87[j86] = uint8(num)
			j86++
		}
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(j86))
		i += copy(dAtA[i:], dAtA87[:j86])
	}
	return i, nil
}

func (m *HeroInvestigationServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroInvestigationServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TargetId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.TargetId))
	}
	if m.ExpireTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ExpireTime))
	}
	if m.MailId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MailId))
	}
	return i, nil
}

func (m *HeroMultiLevelNpcServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroMultiLevelNpcServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Type))
	}
	if m.PassLevel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.PassLevel))
	}
	if m.Hate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Hate))
	}
	if m.RevengeLevel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.RevengeLevel))
	}
	return i, nil
}

func (m *HeroHomeNpcBaseServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroHomeNpcBaseServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sequence != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Sequence))
	}
	if m.DataId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.DataId))
	}
	if m.Prosperity != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Prosperity))
	}
	return i, nil
}

func (m *HeroTowerServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroTowerServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChallengeTimes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ChallengeTimes))
	}
	if m.CurrentFloor != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CurrentFloor))
	}
	if m.HistoryMaxFloor != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.HistoryMaxFloor))
	}
	if m.AutoMaxFloor != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.AutoMaxFloor))
	}
	if m.HistoryMaxFloorTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.HistoryMaxFloorTime))
	}
	if len(m.CollectedBoxFloors) > 0 {
		dAtA89 := make([]byte, len(m.CollectedBoxFloors)*10)
		var j88 int
		for _, num := range m.CollectedBoxFloors {
			for num >= 1<<7 {
				dAtA89[j88] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j88++
			}
			dAtA89[j88] = uint8(num)
			j88++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintHero(dAtA, i, uint64(j88))
		i += copy(dAtA[i:], dAtA89[:j88])
	}
	if m.NextResetChallengeTime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.NextResetChallengeTime))
	}
	return i, nil
}

func (m *HeroSecretTowerServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroSecretTowerServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HelpTimes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.HelpTimes))
	}
	if m.MaxOpenSecretTowerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MaxOpenSecretTowerId))
	}
	if len(m.FirstPassSecretTowerId) > 0 {
		dAtA91 := make([]byte, len(m.FirstPassSecretTowerId)*10)
		var j90 int
		for _, num := range m.FirstPassSecretTowerId {
			for num >= 1<<7 {
				dAtA91[j90] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j90++
			}
			dAtA91[j90] = uint8(num)
			j90++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintHero(dAtA, i, uint64(j90))
		i += copy(dAtA[i:], dAtA91[:j90])
	}
	if m.TodayAddCollectGuildContribution != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.TodayAddCollectGuildContribution))
	}
	if m.HistoryChallengeTimes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.HistoryChallengeTimes))
	}
	if len(m.Records) > 0 {
		for _, msg := range m.Records {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ChallengeTimes != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ChallengeTimes))
	}
	return i, nil
}

func (m *HeroDungeonServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroDungeonServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PassDungeons) > 0 {
		dAtA93 := make([]byte, len(m.PassDungeons)*10)
		var j92 int
		for _, num := range m.PassDungeons {
			for num >= 1<<7 {
				dAtA93[j92] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j92++
			}
			dAtA93[j92] = uint8(num)
			j92++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintHero(dAtA, i, uint64(j92))
		i += copy(dAtA[i:], dAtA93[:j92])
	}
	if len(m.CollectedChapterPrizes) > 0 {
		dAtA95 := make([]byte, len(m.CollectedChapterPrizes)*10)
		var j94 int
		for _, num := range m.CollectedChapterPrizes {
			for num >= 1<<7 {
				dAtA95[j94] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j94++
			}
			dAtA95[j94] = uint8(num)
			j94++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintHero(dAtA, i, uint64(j94))
		i += copy(dAtA[i:], dAtA95[:j94])
	}
	if m.AutoRecoverStartTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.AutoRecoverStartTime))
	}
	if m.CollectAutoTimesIndex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CollectAutoTimesIndex))
	}
	if len(m.CollectedPassDungeonPrizes) > 0 {
		dAtA97 := make([]byte, len(m.CollectedPassDungeonPrizes)*10)
		var j96 int
		for _, num := range m.CollectedPassDungeonPrizes {
			for num >= 1<<7 {
				dAtA97[j96] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j96++
			}
			dAtA97[j96] = uint8(num)
			j96++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHero(dAtA, i, uint64(j96))
		i += copy(dAtA[i:], dAtA97[:j96])
	}
	if m.VipPassLimitBoughtTimes != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.VipPassLimitBoughtTimes))
	}
	if len(m.VipAddPassLimit) > 0 {
		for k, _ := range m.VipAddPassLimit {
			dAtA[i] = 0x42
			i++
			v := m.VipAddPassLimit[k]
			mapSize := 1 + sovHero(uint64(k)) + 1 + sovHero(uint64(v))
			i = encodeVarintHero(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintHero(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintHero(dAtA, i, uint64(v))
		}
	}
	if len(m.VipAddPassBoughtTimes) > 0 {
		for k, _ := range m.VipAddPassBoughtTimes {
			dAtA[i] = 0x4a
			i++
			v := m.VipAddPassBoughtTimes[k]
			mapSize := 1 + sovHero(uint64(k)) + 1 + sovHero(uint64(v))
			i = encodeVarintHero(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintHero(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintHero(dAtA, i, uint64(v))
		}
	}
	if len(m.DungeonStars) > 0 {
		for _, msg := range m.DungeonStars {
			dAtA[i] = 0x62
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DungeonLimits) > 0 {
		for _, msg := range m.DungeonLimits {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ChapterStars) > 0 {
		for _, msg := range m.ChapterStars {
			dAtA[i] = 0x72
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ChapterStarPrizes) > 0 {
		for _, msg := range m.ChapterStarPrizes {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HeroTaskServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroTaskServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MainTask != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MainTask))
	}
	if m.MainTaskProgress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.MainTaskProgress))
	}
	if len(m.BranchTask) > 0 {
		dAtA99 := make([]byte, len(m.BranchTask)*10)
		var j98 int
		for _, num := range m.BranchTask {
			for num >= 1<<7 {
				dAtA99[j98] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j98++
			}
			dAtA99[j98] = uint8(num)
			j98++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintHero(dAtA, i, uint64(j98))
		i += copy(dAtA[i:], dAtA99[:j98])
	}
	if len(m.BranchTaskProgress) > 0 {
		dAtA101 := make([]byte, len(m.BranchTaskProgress)*10)
		var j100 int
		for _, num := range m.BranchTaskProgress {
			for num >= 1<<7 {
				dAtA101[j100] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j100++
			}
			dAtA101[j100] = uint8(num)
			j100++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintHero(dAtA, i, uint64(j100))
		i += copy(dAtA[i:], dAtA101[:j100])
	}
	if m.BaYeStage != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.BaYeStage.Size()))
		n102, err := m.BaYeStage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n102
	}
	if m.LastCompleteBaYeStage != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.LastCompleteBaYeStage))
	}
	if m.AchieveTaskList != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.AchieveTaskList.Size()))
		n103, err := m.AchieveTaskList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n103
	}
	if m.ActiveDegreeTaskList != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ActiveDegreeTaskList.Size()))
		n104, err := m.ActiveDegreeTaskList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n104
	}
	if m.BwzlTaskList != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.BwzlTaskList.Size()))
		n105, err := m.BwzlTaskList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n105
	}
	if m.TitleTaskList != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.TitleTaskList.Size()))
		n106, err := m.TitleTaskList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n106
	}
	if len(m.ActivityTaskListModeMap) > 0 {
		for k, _ := range m.ActivityTaskListModeMap {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x2
			i++
			v := m.ActivityTaskListModeMap[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovHero(uint64(msgSize))
			}
			mapSize := 1 + sovHero(uint64(k)) + msgSize
			i = encodeVarintHero(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintHero(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintHero(dAtA, i, uint64(v.Size()))
				n107, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n107
			}
		}
	}
	if len(m.TaskMonster) > 0 {
		dAtA109 := make([]byte, len(m.TaskMonster)*10)
		var j108 int
		for _, num := range m.TaskMonster {
			for num >= 1<<7 {
				dAtA109[j108] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j108++
			}
			dAtA109[j108] = uint8(num)
			j108++
		}
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(j108))
		i += copy(dAtA[i:], dAtA109[:j108])
	}
	if len(m.TaskMonsterCreate) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.TaskMonsterCreate)))
		for _, b := range m.TaskMonsterCreate {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if m.CollectTaskBoxId != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CollectTaskBoxId))
	}
	return i, nil
}

func (m *AchieveTaskListServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AchieveTaskListServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CollectStarCount) > 0 {
		dAtA111 := make([]byte, len(m.CollectStarCount)*10)
		var j110 int
		for _, num := range m.CollectStarCount {
			for num >= 1<<7 {
				dAtA111[j110] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j110++
			}
			dAtA111[j110] = uint8(num)
			j110++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintHero(dAtA, i, uint64(j110))
		i += copy(dAtA[i:], dAtA111[:j110])
	}
	if len(m.SelectShowAchieves) > 0 {
		dAtA113 := make([]byte, len(m.SelectShowAchieves)*10)
		var j112 int
		for _, num := range m.SelectShowAchieves {
			for num >= 1<<7 {
				dAtA113[j112] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j112++
			}
			dAtA113[j112] = uint8(num)
			j112++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHero(dAtA, i, uint64(j112))
		i += copy(dAtA[i:], dAtA113[:j112])
	}
	return i, nil
}

func (m *AchieveTaskServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AchieveTaskServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Id))
	}
	if m.Progress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Progress))
	}
	if m.IsCollected {
		dAtA[i] = 0x18
		i++
		if m.IsCollected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReachTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.ReachTime))
	}
	return i, nil
}

func (m *ActiveDegreeTaskListServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveDegreeTaskListServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CollectedPrizeIndex) > 0 {
		dAtA115 := make([]byte, len(m.CollectedPrizeIndex)*10)
		var j114 int
		for _, num1 := range m.CollectedPrizeIndex {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA115[j114] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j114++
			}
			dAtA115[j114] = uint8(num)
			j114++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHero(dAtA, i, uint64(j114))
		i += copy(dAtA[i:], dAtA115[:j114])
	}
	return i, nil
}

func (m *ActiveDegreeTaskServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveDegreeTaskServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Id))
	}
	if m.Progress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Progress))
	}
	return i, nil
}

func (m *HeroBaYeStageServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroBaYeStageServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Stage != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Stage))
	}
	if len(m.TaskId) > 0 {
		dAtA117 := make([]byte, len(m.TaskId)*10)
		var j116 int
		for _, num := range m.TaskId {
			for num >= 1<<7 {
				dAtA117[j116] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j116++
			}
			dAtA117[j116] = uint8(num)
			j116++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintHero(dAtA, i, uint64(j116))
		i += copy(dAtA[i:], dAtA117[:j116])
	}
	if len(m.TaskProgress) > 0 {
		dAtA119 := make([]byte, len(m.TaskProgress)*10)
		var j118 int
		for _, num := range m.TaskProgress {
			for num >= 1<<7 {
				dAtA119[j118] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j118++
			}
			dAtA119[j118] = uint8(num)
			j118++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintHero(dAtA, i, uint64(j118))
		i += copy(dAtA[i:], dAtA119[:j118])
	}
	if len(m.IsCollected) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintHero(dAtA, i, uint64(len(m.IsCollected)))
		for _, b := range m.IsCollected {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	return i, nil
}

func (m *BwzlTaskListServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BwzlTaskListServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CollectedPrizes) > 0 {
		dAtA121 := make([]byte, len(m.CollectedPrizes)*10)
		var j120 int
		for _, num := range m.CollectedPrizes {
			for num >= 1<<7 {
				dAtA121[j120] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j120++
			}
			dAtA121[j120] = uint8(num)
			j120++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintHero(dAtA, i, uint64(j120))
		i += copy(dAtA[i:], dAtA121[:j120])
	}
	return i, nil
}

func (m *BwzlTaskServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BwzlTaskServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Id))
	}
	if m.Progress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Progress))
	}
	if m.IsCollected {
		dAtA[i] = 0x18
		i++
		if m.IsCollected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *TitleTaskListServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TitleTaskListServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CompletedTitleId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.CompletedTitleId))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x12
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TitleTaskServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TitleTaskServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Id))
	}
	if m.Progress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Progress))
	}
	return i, nil
}

func (m *ActivityTaskListModeServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityTaskListModeServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tasks) > 0 {
		for _, msg := range m.Tasks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *ActivityTaskServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityTaskServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Id))
	}
	if m.Progress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Progress))
	}
	if m.IsCollected {
		dAtA[i] = 0x18
		i++
		if m.IsCollected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *StratagemServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StratagemServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Id))
	}
	if m.DailyUsedTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.DailyUsedTimes))
	}
	if m.NextUseableTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.NextUseableTime))
	}
	return i, nil
}

func (m *TrappedStratagemServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrappedStratagemServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Id))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.EndTime))
	}
	return i, nil
}

func (m *StratagemTargetTimesServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StratagemTargetTimesServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Id))
	}
	if m.Times != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Times))
	}
	return i, nil
}

func (m *HeroStrategyServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroStrategyServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TrappedStratagems) > 0 {
		for _, msg := range m.TrappedStratagems {
			dAtA[i] = 0x12
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TodayTargetTimes) > 0 {
		for _, msg := range m.TodayTargetTimes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TodayTrappedTimes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.TodayTrappedTimes))
	}
	if len(m.Stratagems) > 0 {
		for _, msg := range m.Stratagems {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintHero(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HeroBufferServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroBufferServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Buf != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHero(dAtA, i, uint64(m.Buf.Size()))
		n122, err := m.Buf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n122
	}
	return i, nil
}

func encodeFixed64Hero(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Hero(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintHero(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HeroServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovHero(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovHero(uint64(l))
	}
	if m.Domestic != nil {
		l = m.Domestic.Size()
		n += 1 + l + sovHero(uint64(l))
	}
	if m.Military != nil {
		l = m.Military.Size()
		n += 1 + l + sovHero(uint64(l))
	}
	if len(m.OldName) > 0 {
		for _, s := range m.OldName {
			l = len(s)
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if m.Level != 0 {
		n += 1 + sovHero(uint64(m.Level))
	}
	if m.Exp != 0 {
		n += 1 + sovHero(uint64(m.Exp))
	}
	if m.Male {
		n += 2
	}
	if m.NextChangeNameTime != 0 {
		n += 1 + sovHero(uint64(m.NextChangeNameTime))
	}
	if m.LastOfflineTime != 0 {
		n += 2 + sovHero(uint64(m.LastOfflineTime))
	}
	if m.ChangeHeroNameTimes != 0 {
		n += 2 + sovHero(uint64(m.ChangeHeroNameTimes))
	}
	if m.GiveFirstChangeHeroNamePrize {
		n += 3
	}
	if m.Body != 0 {
		n += 2 + sovHero(uint64(m.Body))
	}
	if m.SafeGold != 0 {
		n += 2 + sovHero(uint64(m.SafeGold))
	}
	if m.SafeFood != 0 {
		n += 2 + sovHero(uint64(m.SafeFood))
	}
	if m.SafeWood != 0 {
		n += 2 + sovHero(uint64(m.SafeWood))
	}
	if m.SafeStone != 0 {
		n += 2 + sovHero(uint64(m.SafeStone))
	}
	l = len(m.Head)
	if l > 0 {
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Region != nil {
		l = m.Region.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.GuildId != 0 {
		n += 2 + sovHero(uint64(m.GuildId))
	}
	if m.JoinGuildTime != 0 {
		n += 2 + sovHero(uint64(m.JoinGuildTime))
	}
	if m.CollectedDailyGuildRankPrize {
		n += 3
	}
	if m.ContributionCoin != 0 {
		n += 2 + sovHero(uint64(m.ContributionCoin))
	}
	if len(m.GuildDonateTimes) > 0 {
		l = 0
		for _, e := range m.GuildDonateTimes {
			l += sovHero(uint64(e))
		}
		n += 2 + sovHero(uint64(l)) + l
	}
	if len(m.JoinGuildIds) > 0 {
		l = 0
		for _, e := range m.JoinGuildIds {
			l += sovHero(uint64(e))
		}
		n += 2 + sovHero(uint64(l)) + l
	}
	if len(m.BeenInvateGuildIds) > 0 {
		l = 0
		for _, e := range m.BeenInvateGuildIds {
			l += sovHero(uint64(e))
		}
		n += 2 + sovHero(uint64(l)) + l
	}
	if m.NextNotifyGuildTime != 0 {
		n += 2 + sovHero(uint64(m.NextNotifyGuildTime))
	}
	if m.CollectedFirstJoinGuildPrize {
		n += 3
	}
	if m.Yuanbao != 0 {
		n += 2 + sovHero(uint64(m.Yuanbao))
	}
	if m.Gold != 0 {
		n += 2 + sovHero(uint64(m.Gold))
	}
	if m.Food != 0 {
		n += 2 + sovHero(uint64(m.Food))
	}
	if m.Wood != 0 {
		n += 2 + sovHero(uint64(m.Wood))
	}
	if m.Stone != 0 {
		n += 2 + sovHero(uint64(m.Stone))
	}
	if m.Jade != 0 {
		n += 2 + sovHero(uint64(m.Jade))
	}
	if m.JadeOre != 0 {
		n += 2 + sovHero(uint64(m.JadeOre))
	}
	if m.HistoryJade != 0 {
		n += 2 + sovHero(uint64(m.HistoryJade))
	}
	if m.TodayObtainJade != 0 {
		n += 2 + sovHero(uint64(m.TodayObtainJade))
	}
	if m.Depot != nil {
		l = m.Depot.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Tower != nil {
		l = m.Tower.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Task != nil {
		l = m.Task.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.CaptainSoul != nil {
		l = m.CaptainSoul.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.OpenCombineEquip != nil {
		l = m.OpenCombineEquip.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.SecretTower != nil {
		l = m.SecretTower.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Dungeon != nil {
		l = m.Dungeon.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.BufEffect != nil {
		l = m.BufEffect.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Tag != nil {
		l = m.Tag.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Strategy != nil {
		l = m.Strategy.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.ClientDatas != nil {
		l = m.ClientDatas.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Fishing != nil {
		l = m.Fishing.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Function != nil {
		l = m.Function.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.GuiZu != nil {
		l = m.GuiZu.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if len(m.GuildEventPrizes) > 0 {
		for _, e := range m.GuildEventPrizes {
			l = e.Size()
			n += 2 + l + sovHero(uint64(l))
		}
	}
	if m.TreasuryTree != nil {
		l = m.TreasuryTree.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.ZhengWu != nil {
		l = m.ZhengWu.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.ZhanJiang != nil {
		l = m.ZhanJiang.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Question != nil {
		l = m.Question.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Relation != nil {
		l = m.Relation.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Survey != nil {
		l = m.Survey.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.CreateTime != 0 {
		n += 2 + sovHero(uint64(m.CreateTime))
	}
	if m.Settings != nil {
		l = m.Settings.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Hebi != nil {
		l = m.Hebi.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Location != 0 {
		n += 2 + sovHero(uint64(m.Location))
	}
	if m.Shop != nil {
		l = m.Shop.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.RandomEvent != nil {
		l = m.RandomEvent.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Buff != nil {
		l = m.Buff.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.WorkshopOutputStartTime != 0 {
		n += 2 + sovHero(uint64(m.WorkshopOutputStartTime))
	}
	if len(m.CollectedGuildTaskStages) > 0 {
		for k, v := range m.CollectedGuildTaskStages {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovHero(uint64(l))
			}
			mapEntrySize := 1 + sovHero(uint64(k)) + l
			n += mapEntrySize + 2 + sovHero(uint64(mapEntrySize))
		}
	}
	if m.Reservation != nil {
		l = m.Reservation.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.TotalOnlineTime != 0 {
		n += 2 + sovHero(uint64(m.TotalOnlineTime))
	}
	if m.LoginTime != 0 {
		n += 2 + sovHero(uint64(m.LoginTime))
	}
	if len(m.HeroMaps) > 0 {
		for _, e := range m.HeroMaps {
			l = e.Size()
			n += 2 + l + sovHero(uint64(l))
		}
	}
	if len(m.HeroBools) > 0 {
		l = 0
		for _, e := range m.HeroBools {
			l += sovHero(uint64(e))
		}
		n += 2 + sovHero(uint64(l)) + l
	}
	if m.Misc != nil {
		l = m.Misc.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Dianquan != 0 {
		n += 2 + sovHero(uint64(m.Dianquan))
	}
	if m.NextResDecayTime != 0 {
		n += 2 + sovHero(uint64(m.NextResDecayTime))
	}
	if m.HeroGen != nil {
		l = m.HeroGen.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if len(m.HeroKeys) > 0 {
		for _, e := range m.HeroKeys {
			l = e.Size()
			n += 2 + l + sovHero(uint64(l))
		}
	}
	if m.Yinliang != 0 {
		n += 2 + sovHero(uint64(m.Yinliang))
	}
	if m.Sp != 0 {
		n += 2 + sovHero(uint64(m.Sp))
	}
	if m.LastRecoverSpTime != 0 {
		n += 2 + sovHero(uint64(m.LastRecoverSpTime))
	}
	if m.BuySpTimes != 0 {
		n += 2 + sovHero(uint64(m.BuySpTimes))
	}
	if m.Vip != nil {
		l = m.Vip.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Promotion != nil {
		l = m.Promotion.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.McBuild != nil {
		l = m.McBuild.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.RedPacket != nil {
		l = m.RedPacket.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Teach != nil {
		l = m.Teach.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.CountryMisc != nil {
		l = m.CountryMisc.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.Activity != nil {
		l = m.Activity.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	return n
}

func (m *BlackMarketGoodsItemServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Goods != 0 {
		n += 1 + sovHero(uint64(m.Goods))
	}
	if m.Discount != 0 {
		n += 1 + sovHero(uint64(m.Discount))
	}
	if m.Buy {
		n += 2
	}
	return n
}

func (m *HeroShopServerProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Item) > 0 {
		for _, e := range m.Item {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	return n
}

func (m *HeroMiscServerProto) Size() (n int) {
	var l int
	_ = l
	if m.FarmShowUnlockAnimationBaseLevel != 0 {
		n += 1 + sovHero(uint64(m.FarmShowUnlockAnimationBaseLevel))
	}
	if m.ChargeAmount != 0 {
		n += 1 + sovHero(uint64(m.ChargeAmount))
	}
	if m.LastChargeTime != 0 {
		n += 1 + sovHero(uint64(m.LastChargeTime))
	}
	if len(m.DurationCards) > 0 {
		for k, v := range m.DurationCards {
			_ = k
			_ = v
			mapEntrySize := 1 + sovHero(uint64(k)) + 1 + sovHero(uint64(v))
			n += mapEntrySize + 1 + sovHero(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *HeroPromotionServerProto) Size() (n int) {
	var l int
	_ = l
	if len(m.BuyTimeLimitGift) > 0 {
		for _, e := range m.BuyTimeLimitGift {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if len(m.EventLimitGifts) > 0 {
		for _, e := range m.EventLimitGifts {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	return n
}

func (m *HeroActivityServerProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Collections) > 0 {
		for k, v := range m.Collections {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovHero(uint64(l))
			}
			mapEntrySize := 1 + sovHero(uint64(k)) + l
			n += mapEntrySize + 1 + sovHero(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *HeroRelationServerProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Friend) > 0 {
		l = 0
		for _, e := range m.Friend {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	if len(m.Black) > 0 {
		l = 0
		for _, e := range m.Black {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	if len(m.Enemy) > 0 {
		for k, v := range m.Enemy {
			_ = k
			_ = v
			mapEntrySize := 1 + sovHero(uint64(k)) + 1 + sovHero(uint64(v))
			n += mapEntrySize + 1 + sovHero(uint64(mapEntrySize))
		}
	}
	if len(m.Important) > 0 {
		for k, v := range m.Important {
			_ = k
			_ = v
			mapEntrySize := 1 + sovHero(uint64(k)) + 1 + sovHero(uint64(v))
			n += mapEntrySize + 1 + sovHero(uint64(mapEntrySize))
		}
	}
	if len(m.FriendCreateTime) > 0 {
		l = 0
		for _, e := range m.FriendCreateTime {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	if len(m.BlackCreateTime) > 0 {
		l = 0
		for _, e := range m.BlackCreateTime {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	return n
}

func (m *HeroRandomEventServerProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if m.BigRefreshTime != 0 {
		n += 1 + sovHero(uint64(m.BigRefreshTime))
	}
	if m.SmallRefreshTime != 0 {
		n += 1 + sovHero(uint64(m.SmallRefreshTime))
	}
	if len(m.Handbooks) > 0 {
		l = 0
		for _, e := range m.Handbooks {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	return n
}

func (m *HeroTreasuryTreeServerProto) Size() (n int) {
	var l int
	_ = l
	if m.WaterTimes != 0 {
		n += 1 + sovHero(uint64(m.WaterTimes))
	}
	if m.CollectSession != 0 {
		n += 1 + sovHero(uint64(m.CollectSession))
	}
	if m.CollectTime != 0 {
		n += 1 + sovHero(uint64(m.CollectTime))
	}
	if len(m.WaterHeroIds) > 0 {
		l = 0
		for _, e := range m.WaterHeroIds {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	if len(m.HelpMeHeroIds) > 0 {
		l = 0
		for _, e := range m.HelpMeHeroIds {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	return n
}

func (m *HeroGuildEventPrizeServerProto) Size() (n int) {
	var l int
	_ = l
	if m.HideGiver {
		n += 2
	}
	if m.DataId != 0 {
		n += 1 + sovHero(uint64(m.DataId))
	}
	if m.SendHeroId != 0 {
		n += 1 + sovHero(uint64(m.SendHeroId))
	}
	if m.ExpireTime != 0 {
		n += 1 + sovHero(uint64(m.ExpireTime))
	}
	return n
}

func (m *HeroMapServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Category != 0 {
		n += 1 + sovHero(uint64(m.Category))
	}
	if len(m.DataMap) > 0 {
		for k, v := range m.DataMap {
			_ = k
			_ = v
			mapEntrySize := 1 + sovHero(uint64(k)) + 1 + sovHero(uint64(v))
			n += mapEntrySize + 1 + sovHero(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *HeroKeysServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Category != 0 {
		n += 1 + sovHero(uint64(m.Category))
	}
	if len(m.Keys) > 0 {
		l = 0
		for _, e := range m.Keys {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	return n
}

func (m *HeroClientDatasServerProto) Size() (n int) {
	var l int
	_ = l
	if len(m.IntValue) > 0 {
		l = 0
		for _, e := range m.IntValue {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	return n
}

func (m *HeroReservationProto) Size() (n int) {
	var l int
	_ = l
	if m.Gold != 0 {
		n += 1 + sovHero(uint64(m.Gold))
	}
	if m.Food != 0 {
		n += 1 + sovHero(uint64(m.Food))
	}
	if m.Wood != 0 {
		n += 1 + sovHero(uint64(m.Wood))
	}
	if m.Stone != 0 {
		n += 1 + sovHero(uint64(m.Stone))
	}
	if m.Yuanbao != 0 {
		n += 1 + sovHero(uint64(m.Yuanbao))
	}
	if m.GuildContributionCoin != 0 {
		n += 1 + sovHero(uint64(m.GuildContributionCoin))
	}
	if m.Jade != 0 {
		n += 1 + sovHero(uint64(m.Jade))
	}
	if m.JadeOre != 0 {
		n += 1 + sovHero(uint64(m.JadeOre))
	}
	if m.Dianquan != 0 {
		n += 1 + sovHero(uint64(m.Dianquan))
	}
	if m.Yinliang != 0 {
		n += 1 + sovHero(uint64(m.Yinliang))
	}
	if len(m.Goods) > 0 {
		for k, v := range m.Goods {
			_ = k
			_ = v
			mapEntrySize := 1 + sovHero(uint64(k)) + 1 + sovHero(uint64(v))
			n += mapEntrySize + 2 + sovHero(uint64(mapEntrySize))
		}
	}
	if m.LastReserveTime != 0 {
		n += 2 + sovHero(uint64(m.LastReserveTime))
	}
	return n
}

func (m *RoBaseProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovHero(uint64(m.Id))
	}
	if m.Level != 0 {
		n += 1 + sovHero(uint64(m.Level))
	}
	if m.X != 0 {
		n += 1 + sovHero(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovHero(uint64(m.Y))
	}
	if m.Prosperity != 0 {
		n += 1 + sovHero(uint64(m.Prosperity))
	}
	if m.ProsperityCapcity != 0 {
		n += 1 + sovHero(uint64(m.ProsperityCapcity))
	}
	if m.BaseType != 0 {
		n += 1 + sovHero(uint64(m.BaseType))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovHero(uint64(l))
	}
	if m.GuildId != 0 {
		n += 1 + sovHero(uint64(m.GuildId))
	}
	if m.HeroType != 0 {
		n += 1 + sovHero(uint64(m.HeroType))
	}
	if m.HeroId != 0 {
		n += 1 + sovHero(uint64(m.HeroId))
	}
	if m.HeroEndTime != 0 {
		n += 2 + sovHero(uint64(m.HeroEndTime))
	}
	if m.NpcDataId != 0 {
		n += 2 + sovHero(uint64(m.NpcDataId))
	}
	if m.NpcType != 0 {
		n += 2 + sovHero(uint64(m.NpcType))
	}
	if m.Soldier != 0 {
		n += 2 + sovHero(uint64(m.Soldier))
	}
	if m.FightAmount != 0 {
		n += 2 + sovHero(uint64(m.FightAmount))
	}
	if len(m.CaptainSoldier) > 0 {
		l = 0
		for _, e := range m.CaptainSoldier {
			l += sovHero(uint64(e))
		}
		n += 2 + sovHero(uint64(l)) + l
	}
	if m.TroopCount != 0 {
		n += 2 + sovHero(uint64(m.TroopCount))
	}
	return n
}

func (m *HeroBase) Size() (n int) {
	var l int
	_ = l
	if m.BaseRegion != 0 {
		n += 1 + sovHero(uint64(m.BaseRegion))
	}
	if m.BaseLevel != 0 {
		n += 1 + sovHero(uint64(m.BaseLevel))
	}
	if m.BaseX != 0 {
		n += 1 + sovHero(uint64(m.BaseX))
	}
	if m.BaseY != 0 {
		n += 1 + sovHero(uint64(m.BaseY))
	}
	if m.Prosperity != 0 {
		n += 1 + sovHero(uint64(m.Prosperity))
	}
	return n
}

func (m *HeroHome) Size() (n int) {
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovHero(uint64(l))
	}
	if m.LostProsperity != 0 {
		n += 1 + sovHero(uint64(m.LostProsperity))
	}
	if m.NextResetLostProsperityTime != 0 {
		n += 1 + sovHero(uint64(m.NextResetLostProsperityTime))
	}
	if m.StopLostProsperity {
		n += 2
	}
	if m.MaxBaseLevel != 0 {
		n += 1 + sovHero(uint64(m.MaxBaseLevel))
	}
	if m.WhiteFlagHeroId != 0 {
		n += 2 + sovHero(uint64(m.WhiteFlagHeroId))
	}
	if m.WhiteFlagGuildId != 0 {
		n += 2 + sovHero(uint64(m.WhiteFlagGuildId))
	}
	if m.WhiteFlagDisappearTime != 0 {
		n += 2 + sovHero(uint64(m.WhiteFlagDisappearTime))
	}
	if m.MianDisappearTime != 0 {
		n += 2 + sovHero(uint64(m.MianDisappearTime))
	}
	if m.MoveBaseRestoreProsperityBufEndTime != 0 {
		n += 2 + sovHero(uint64(m.MoveBaseRestoreProsperityBufEndTime))
	}
	if m.NewHeroMianDisappearTime != 0 {
		n += 2 + sovHero(uint64(m.NewHeroMianDisappearTime))
	}
	if m.NextUseMianGoodsTime != 0 {
		n += 2 + sovHero(uint64(m.NextUseMianGoodsTime))
	}
	if m.MianStartTime != 0 {
		n += 2 + sovHero(uint64(m.MianStartTime))
	}
	if m.MianRebackTime != 0 {
		n += 2 + sovHero(uint64(m.MianRebackTime))
	}
	return n
}

func (m *HeroRegionServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Home != nil {
		l = m.Home.Size()
		n += 1 + l + sovHero(uint64(l))
	}
	if m.HomeDefenseTroopIndex != 0 {
		n += 1 + sovHero(uint64(m.HomeDefenseTroopIndex))
	}
	if m.HomeTroopDefeatedMailProto != nil {
		l = m.HomeTroopDefeatedMailProto.Size()
		n += 1 + l + sovHero(uint64(l))
	}
	if len(m.CreateHomeNpcBaseIds) > 0 {
		l = 0
		for _, e := range m.CreateHomeNpcBaseIds {
			l += sovHero(uint64(e))
		}
		n += 2 + sovHero(uint64(l)) + l
	}
	if len(m.HomeNpcBase) > 0 {
		for _, e := range m.HomeNpcBase {
			l = e.Size()
			n += 2 + l + sovHero(uint64(l))
		}
	}
	if len(m.MultiLevelNpc) > 0 {
		for _, e := range m.MultiLevelNpc {
			l = e.Size()
			n += 2 + l + sovHero(uint64(l))
		}
	}
	if m.MultiLevelNpcPassLevel != 0 {
		n += 2 + sovHero(uint64(m.MultiLevelNpcPassLevel))
	}
	if m.FavoritePoses != nil {
		l = m.FavoritePoses.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.NextInvestigateTime != 0 {
		n += 2 + sovHero(uint64(m.NextInvestigateTime))
	}
	if m.MultiLevelNpcStartRecoveryTime != nil {
		l = m.MultiLevelNpcStartRecoveryTime.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if len(m.Investigation) > 0 {
		for _, e := range m.Investigation {
			l = e.Size()
			n += 2 + l + sovHero(uint64(l))
		}
	}
	if m.MultiLevelNpcStartTime != 0 {
		n += 2 + sovHero(uint64(m.MultiLevelNpcStartTime))
	}
	if len(m.CopyDefenserCaptainId) > 0 {
		l = 0
		for _, e := range m.CopyDefenserCaptainId {
			l += sovHero(uint64(e))
		}
		n += 2 + sovHero(uint64(l)) + l
	}
	if len(m.CopyDefenserCaptainSoldier) > 0 {
		l = 0
		for _, e := range m.CopyDefenserCaptainSoldier {
			l += sovHero(uint64(e))
		}
		n += 2 + sovHero(uint64(l)) + l
	}
	if len(m.CopyDefenserCaptainTotalSoldier) > 0 {
		l = 0
		for _, e := range m.CopyDefenserCaptainTotalSoldier {
			l += sovHero(uint64(e))
		}
		n += 2 + sovHero(uint64(l)) + l
	}
	if len(m.CopyDefenserCaptainIndex) > 0 {
		l = 0
		for _, e := range m.CopyDefenserCaptainIndex {
			l += sovHero(uint64(e))
		}
		n += 2 + sovHero(uint64(l)) + l
	}
	if m.CopyDefenserEndTime != 0 {
		n += 2 + sovHero(uint64(m.CopyDefenserEndTime))
	}
	if m.InvaseHeroStartTime != 0 {
		n += 2 + sovHero(uint64(m.InvaseHeroStartTime))
	}
	if len(m.CopyDefenserCaptainXIndex) > 0 {
		l = 0
		for _, e := range m.CopyDefenserCaptainXIndex {
			l += sovHero(uint64(e))
		}
		n += 2 + sovHero(uint64(l)) + l
	}
	if m.CopyDefenserTroopIndex != 0 {
		n += 2 + sovHero(uint64(m.CopyDefenserTroopIndex))
	}
	if m.JunTuanNpcStartTime != 0 {
		n += 2 + sovHero(uint64(m.JunTuanNpcStartTime))
	}
	if len(m.CopyDefenserCaptainStat) > 0 {
		for _, e := range m.CopyDefenserCaptainStat {
			l = e.Size()
			n += 2 + l + sovHero(uint64(l))
		}
	}
	if len(m.CopyDefenserCaptainSpellFightAmountCoef) > 0 {
		l = 0
		for _, e := range m.CopyDefenserCaptainSpellFightAmountCoef {
			l += sovHero(uint64(e))
		}
		n += 2 + sovHero(uint64(l)) + l
	}
	return n
}

func (m *HeroInvestigationServerProto) Size() (n int) {
	var l int
	_ = l
	if m.TargetId != 0 {
		n += 1 + sovHero(uint64(m.TargetId))
	}
	if m.ExpireTime != 0 {
		n += 1 + sovHero(uint64(m.ExpireTime))
	}
	if m.MailId != 0 {
		n += 1 + sovHero(uint64(m.MailId))
	}
	return n
}

func (m *HeroMultiLevelNpcServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovHero(uint64(m.Type))
	}
	if m.PassLevel != 0 {
		n += 1 + sovHero(uint64(m.PassLevel))
	}
	if m.Hate != 0 {
		n += 1 + sovHero(uint64(m.Hate))
	}
	if m.RevengeLevel != 0 {
		n += 1 + sovHero(uint64(m.RevengeLevel))
	}
	return n
}

func (m *HeroHomeNpcBaseServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Sequence != 0 {
		n += 1 + sovHero(uint64(m.Sequence))
	}
	if m.DataId != 0 {
		n += 1 + sovHero(uint64(m.DataId))
	}
	if m.Prosperity != 0 {
		n += 1 + sovHero(uint64(m.Prosperity))
	}
	return n
}

func (m *HeroTowerServerProto) Size() (n int) {
	var l int
	_ = l
	if m.ChallengeTimes != 0 {
		n += 1 + sovHero(uint64(m.ChallengeTimes))
	}
	if m.CurrentFloor != 0 {
		n += 1 + sovHero(uint64(m.CurrentFloor))
	}
	if m.HistoryMaxFloor != 0 {
		n += 1 + sovHero(uint64(m.HistoryMaxFloor))
	}
	if m.AutoMaxFloor != 0 {
		n += 1 + sovHero(uint64(m.AutoMaxFloor))
	}
	if m.HistoryMaxFloorTime != 0 {
		n += 1 + sovHero(uint64(m.HistoryMaxFloorTime))
	}
	if len(m.CollectedBoxFloors) > 0 {
		l = 0
		for _, e := range m.CollectedBoxFloors {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	if m.NextResetChallengeTime != 0 {
		n += 1 + sovHero(uint64(m.NextResetChallengeTime))
	}
	return n
}

func (m *HeroSecretTowerServerProto) Size() (n int) {
	var l int
	_ = l
	if m.HelpTimes != 0 {
		n += 1 + sovHero(uint64(m.HelpTimes))
	}
	if m.MaxOpenSecretTowerId != 0 {
		n += 1 + sovHero(uint64(m.MaxOpenSecretTowerId))
	}
	if len(m.FirstPassSecretTowerId) > 0 {
		l = 0
		for _, e := range m.FirstPassSecretTowerId {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	if m.TodayAddCollectGuildContribution != 0 {
		n += 1 + sovHero(uint64(m.TodayAddCollectGuildContribution))
	}
	if m.HistoryChallengeTimes != 0 {
		n += 1 + sovHero(uint64(m.HistoryChallengeTimes))
	}
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if m.ChallengeTimes != 0 {
		n += 1 + sovHero(uint64(m.ChallengeTimes))
	}
	return n
}

func (m *HeroDungeonServerProto) Size() (n int) {
	var l int
	_ = l
	if len(m.PassDungeons) > 0 {
		l = 0
		for _, e := range m.PassDungeons {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	if len(m.CollectedChapterPrizes) > 0 {
		l = 0
		for _, e := range m.CollectedChapterPrizes {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	if m.AutoRecoverStartTime != 0 {
		n += 1 + sovHero(uint64(m.AutoRecoverStartTime))
	}
	if m.CollectAutoTimesIndex != 0 {
		n += 1 + sovHero(uint64(m.CollectAutoTimesIndex))
	}
	if len(m.CollectedPassDungeonPrizes) > 0 {
		l = 0
		for _, e := range m.CollectedPassDungeonPrizes {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	if m.VipPassLimitBoughtTimes != 0 {
		n += 1 + sovHero(uint64(m.VipPassLimitBoughtTimes))
	}
	if len(m.VipAddPassLimit) > 0 {
		for k, v := range m.VipAddPassLimit {
			_ = k
			_ = v
			mapEntrySize := 1 + sovHero(uint64(k)) + 1 + sovHero(uint64(v))
			n += mapEntrySize + 1 + sovHero(uint64(mapEntrySize))
		}
	}
	if len(m.VipAddPassBoughtTimes) > 0 {
		for k, v := range m.VipAddPassBoughtTimes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovHero(uint64(k)) + 1 + sovHero(uint64(v))
			n += mapEntrySize + 1 + sovHero(uint64(mapEntrySize))
		}
	}
	if len(m.DungeonStars) > 0 {
		for _, e := range m.DungeonStars {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if len(m.DungeonLimits) > 0 {
		for _, e := range m.DungeonLimits {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if len(m.ChapterStars) > 0 {
		for _, e := range m.ChapterStars {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if len(m.ChapterStarPrizes) > 0 {
		for _, e := range m.ChapterStarPrizes {
			l = e.Size()
			n += 2 + l + sovHero(uint64(l))
		}
	}
	return n
}

func (m *HeroTaskServerProto) Size() (n int) {
	var l int
	_ = l
	if m.MainTask != 0 {
		n += 1 + sovHero(uint64(m.MainTask))
	}
	if m.MainTaskProgress != 0 {
		n += 1 + sovHero(uint64(m.MainTaskProgress))
	}
	if len(m.BranchTask) > 0 {
		l = 0
		for _, e := range m.BranchTask {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	if len(m.BranchTaskProgress) > 0 {
		l = 0
		for _, e := range m.BranchTaskProgress {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	if m.BaYeStage != nil {
		l = m.BaYeStage.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.LastCompleteBaYeStage != 0 {
		n += 2 + sovHero(uint64(m.LastCompleteBaYeStage))
	}
	if m.AchieveTaskList != nil {
		l = m.AchieveTaskList.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.ActiveDegreeTaskList != nil {
		l = m.ActiveDegreeTaskList.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.BwzlTaskList != nil {
		l = m.BwzlTaskList.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if m.TitleTaskList != nil {
		l = m.TitleTaskList.Size()
		n += 2 + l + sovHero(uint64(l))
	}
	if len(m.ActivityTaskListModeMap) > 0 {
		for k, v := range m.ActivityTaskListModeMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovHero(uint64(l))
			}
			mapEntrySize := 1 + sovHero(uint64(k)) + l
			n += mapEntrySize + 2 + sovHero(uint64(mapEntrySize))
		}
	}
	if len(m.TaskMonster) > 0 {
		l = 0
		for _, e := range m.TaskMonster {
			l += sovHero(uint64(e))
		}
		n += 2 + sovHero(uint64(l)) + l
	}
	if len(m.TaskMonsterCreate) > 0 {
		n += 2 + sovHero(uint64(len(m.TaskMonsterCreate))) + len(m.TaskMonsterCreate)*1
	}
	if m.CollectTaskBoxId != 0 {
		n += 2 + sovHero(uint64(m.CollectTaskBoxId))
	}
	return n
}

func (m *AchieveTaskListServerProto) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if len(m.CollectStarCount) > 0 {
		l = 0
		for _, e := range m.CollectStarCount {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	if len(m.SelectShowAchieves) > 0 {
		l = 0
		for _, e := range m.SelectShowAchieves {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	return n
}

func (m *AchieveTaskServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovHero(uint64(m.Id))
	}
	if m.Progress != 0 {
		n += 1 + sovHero(uint64(m.Progress))
	}
	if m.IsCollected {
		n += 2
	}
	if m.ReachTime != 0 {
		n += 1 + sovHero(uint64(m.ReachTime))
	}
	return n
}

func (m *ActiveDegreeTaskListServerProto) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if len(m.CollectedPrizeIndex) > 0 {
		l = 0
		for _, e := range m.CollectedPrizeIndex {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	return n
}

func (m *ActiveDegreeTaskServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovHero(uint64(m.Id))
	}
	if m.Progress != 0 {
		n += 1 + sovHero(uint64(m.Progress))
	}
	return n
}

func (m *HeroBaYeStageServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Stage != 0 {
		n += 1 + sovHero(uint64(m.Stage))
	}
	if len(m.TaskId) > 0 {
		l = 0
		for _, e := range m.TaskId {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	if len(m.TaskProgress) > 0 {
		l = 0
		for _, e := range m.TaskProgress {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	if len(m.IsCollected) > 0 {
		n += 1 + sovHero(uint64(len(m.IsCollected))) + len(m.IsCollected)*1
	}
	return n
}

func (m *BwzlTaskListServerProto) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if len(m.CollectedPrizes) > 0 {
		l = 0
		for _, e := range m.CollectedPrizes {
			l += sovHero(uint64(e))
		}
		n += 1 + sovHero(uint64(l)) + l
	}
	return n
}

func (m *BwzlTaskServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovHero(uint64(m.Id))
	}
	if m.Progress != 0 {
		n += 1 + sovHero(uint64(m.Progress))
	}
	if m.IsCollected {
		n += 2
	}
	return n
}

func (m *TitleTaskListServerProto) Size() (n int) {
	var l int
	_ = l
	if m.CompletedTitleId != 0 {
		n += 1 + sovHero(uint64(m.CompletedTitleId))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	return n
}

func (m *TitleTaskServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovHero(uint64(m.Id))
	}
	if m.Progress != 0 {
		n += 1 + sovHero(uint64(m.Progress))
	}
	return n
}

func (m *ActivityTaskListModeServerProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Tasks) > 0 {
		for _, e := range m.Tasks {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if m.StartTime != 0 {
		n += 1 + sovHero(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovHero(uint64(m.EndTime))
	}
	return n
}

func (m *ActivityTaskServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovHero(uint64(m.Id))
	}
	if m.Progress != 0 {
		n += 1 + sovHero(uint64(m.Progress))
	}
	if m.IsCollected {
		n += 2
	}
	return n
}

func (m *StratagemServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovHero(uint64(m.Id))
	}
	if m.DailyUsedTimes != 0 {
		n += 1 + sovHero(uint64(m.DailyUsedTimes))
	}
	if m.NextUseableTime != 0 {
		n += 1 + sovHero(uint64(m.NextUseableTime))
	}
	return n
}

func (m *TrappedStratagemServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovHero(uint64(m.Id))
	}
	if m.EndTime != 0 {
		n += 1 + sovHero(uint64(m.EndTime))
	}
	return n
}

func (m *StratagemTargetTimesServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovHero(uint64(m.Id))
	}
	if m.Times != 0 {
		n += 1 + sovHero(uint64(m.Times))
	}
	return n
}

func (m *HeroStrategyServerProto) Size() (n int) {
	var l int
	_ = l
	if len(m.TrappedStratagems) > 0 {
		for _, e := range m.TrappedStratagems {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if len(m.TodayTargetTimes) > 0 {
		for _, e := range m.TodayTargetTimes {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	if m.TodayTrappedTimes != 0 {
		n += 1 + sovHero(uint64(m.TodayTrappedTimes))
	}
	if len(m.Stratagems) > 0 {
		for _, e := range m.Stratagems {
			l = e.Size()
			n += 1 + l + sovHero(uint64(l))
		}
	}
	return n
}

func (m *HeroBufferServerProto) Size() (n int) {
	var l int
	_ = l
	if m.Buf != nil {
		l = m.Buf.Size()
		n += 1 + l + sovHero(uint64(l))
	}
	return n
}

func sovHero(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozHero(x uint64) (n int) {
	return sovHero(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HeroServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domestic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Domestic == nil {
				m.Domestic = &HeroDomesticServerProto{}
			}
			if err := m.Domestic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Military", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Military == nil {
				m.Military = &HeroMilitaryServerProto{}
			}
			if err := m.Military.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldName = append(m.OldName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Male", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Male = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextChangeNameTime", wireType)
			}
			m.NextChangeNameTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextChangeNameTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastOfflineTime", wireType)
			}
			m.LastOfflineTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastOfflineTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeHeroNameTimes", wireType)
			}
			m.ChangeHeroNameTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeHeroNameTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiveFirstChangeHeroNamePrize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GiveFirstChangeHeroNamePrize = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			m.Body = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Body |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeGold", wireType)
			}
			m.SafeGold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafeGold |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeFood", wireType)
			}
			m.SafeFood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafeFood |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeWood", wireType)
			}
			m.SafeWood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafeWood |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeStone", wireType)
			}
			m.SafeStone = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafeStone |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Region == nil {
				m.Region = &HeroRegionServerProto{}
			}
			if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinGuildTime", wireType)
			}
			m.JoinGuildTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinGuildTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedDailyGuildRankPrize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CollectedDailyGuildRankPrize = bool(v != 0)
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContributionCoin", wireType)
			}
			m.ContributionCoin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContributionCoin |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GuildDonateTimes = append(m.GuildDonateTimes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GuildDonateTimes = append(m.GuildDonateTimes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildDonateTimes", wireType)
			}
		case 37:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.JoinGuildIds = append(m.JoinGuildIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.JoinGuildIds = append(m.JoinGuildIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinGuildIds", wireType)
			}
		case 38:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BeenInvateGuildIds = append(m.BeenInvateGuildIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BeenInvateGuildIds = append(m.BeenInvateGuildIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BeenInvateGuildIds", wireType)
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextNotifyGuildTime", wireType)
			}
			m.NextNotifyGuildTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextNotifyGuildTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedFirstJoinGuildPrize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CollectedFirstJoinGuildPrize = bool(v != 0)
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yuanbao", wireType)
			}
			m.Yuanbao = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Yuanbao |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Food", wireType)
			}
			m.Food = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Food |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wood", wireType)
			}
			m.Wood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Wood |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stone", wireType)
			}
			m.Stone = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stone |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jade", wireType)
			}
			m.Jade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Jade |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JadeOre", wireType)
			}
			m.JadeOre = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JadeOre |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryJade", wireType)
			}
			m.HistoryJade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistoryJade |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TodayObtainJade", wireType)
			}
			m.TodayObtainJade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TodayObtainJade |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Depot == nil {
				m.Depot = &HeroDepotServerProto{}
			}
			if err := m.Depot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tower", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tower == nil {
				m.Tower = &HeroTowerServerProto{}
			}
			if err := m.Tower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Task == nil {
				m.Task = &HeroTaskServerProto{}
			}
			if err := m.Task.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainSoul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CaptainSoul == nil {
				m.CaptainSoul = &HeroCaptainSoulServerProto{}
			}
			if err := m.CaptainSoul.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenCombineEquip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenCombineEquip == nil {
				m.OpenCombineEquip = &HeroOpenCombineEquipServerProto{}
			}
			if err := m.OpenCombineEquip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretTower", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecretTower == nil {
				m.SecretTower = &HeroSecretTowerServerProto{}
			}
			if err := m.SecretTower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dungeon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dungeon == nil {
				m.Dungeon = &HeroDungeonServerProto{}
			}
			if err := m.Dungeon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 59:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufEffect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BufEffect == nil {
				m.BufEffect = &HeroBufferServerProto{}
			}
			if err := m.BufEffect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tag == nil {
				m.Tag = &proto15.HeroTagProto{}
			}
			if err := m.Tag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Strategy == nil {
				m.Strategy = &HeroStrategyServerProto{}
			}
			if err := m.Strategy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 62:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientDatas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientDatas == nil {
				m.ClientDatas = &HeroClientDatasServerProto{}
			}
			if err := m.ClientDatas.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 63:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fishing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fishing == nil {
				m.Fishing = &proto23.HeroFishingProto{}
			}
			if err := m.Fishing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 64:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Function == nil {
				m.Function = &HeroFunctionServerProto{}
			}
			if err := m.Function.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 65:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuiZu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GuiZu == nil {
				m.GuiZu = &HeroGuiZuServerProto{}
			}
			if err := m.GuiZu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 66:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildEventPrizes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildEventPrizes = append(m.GuildEventPrizes, &HeroGuildEventPrizeServerProto{})
			if err := m.GuildEventPrizes[len(m.GuildEventPrizes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 67:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasuryTree", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TreasuryTree == nil {
				m.TreasuryTree = &HeroTreasuryTreeServerProto{}
			}
			if err := m.TreasuryTree.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 68:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZhengWu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZhengWu == nil {
				m.ZhengWu = &HeroZhengWuServerProto{}
			}
			if err := m.ZhengWu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 69:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZhanJiang", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZhanJiang == nil {
				m.ZhanJiang = &HeroZhanJiangServerProto{}
			}
			if err := m.ZhanJiang.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Question", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Question == nil {
				m.Question = &proto30.HeroQuestionProto{}
			}
			if err := m.Question.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 71:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Relation == nil {
				m.Relation = &HeroRelationServerProto{}
			}
			if err := m.Relation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 72:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Survey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Survey == nil {
				m.Survey = &proto32.HeroSurveyProto{}
			}
			if err := m.Survey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 73:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 74:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Settings == nil {
				m.Settings = &proto33.HeroSettingsProto{}
			}
			if err := m.Settings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 75:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hebi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hebi == nil {
				m.Hebi = &proto11.HeroHebiProto{}
			}
			if err := m.Hebi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 76:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			m.Location = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Location |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 77:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shop == nil {
				m.Shop = &HeroShopServerProto{}
			}
			if err := m.Shop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 78:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RandomEvent == nil {
				m.RandomEvent = &HeroRandomEventServerProto{}
			}
			if err := m.RandomEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 79:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Buff == nil {
				m.Buff = &HeroBuffServerProto{}
			}
			if err := m.Buff.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopOutputStartTime", wireType)
			}
			m.WorkshopOutputStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopOutputStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 81:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedGuildTaskStages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.CollectedGuildTaskStages == nil {
				m.CollectedGuildTaskStages = make(map[uint64]*proto1.Int32ArrayProto)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthHero
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthHero
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &proto1.Int32ArrayProto{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.CollectedGuildTaskStages[mapkey] = mapvalue
			} else {
				var mapvalue *proto1.Int32ArrayProto
				m.CollectedGuildTaskStages[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 97:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reservation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reservation == nil {
				m.Reservation = &HeroReservationProto{}
			}
			if err := m.Reservation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 98:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalOnlineTime", wireType)
			}
			m.TotalOnlineTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalOnlineTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginTime", wireType)
			}
			m.LoginTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoginTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroMaps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeroMaps = append(m.HeroMaps, &HeroMapServerProto{})
			if err := m.HeroMaps[len(m.HeroMaps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 102:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.HeroBools = append(m.HeroBools, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.HeroBools = append(m.HeroBools, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroBools", wireType)
			}
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Misc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Misc == nil {
				m.Misc = &HeroMiscServerProto{}
			}
			if err := m.Misc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 104:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dianquan", wireType)
			}
			m.Dianquan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dianquan |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 105:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextResDecayTime", wireType)
			}
			m.NextResDecayTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextResDecayTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 106:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroGen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeroGen == nil {
				m.HeroGen = &HeroGenServerProto{}
			}
			if err := m.HeroGen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 107:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeroKeys = append(m.HeroKeys, &HeroKeysServerProto{})
			if err := m.HeroKeys[len(m.HeroKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 108:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yinliang", wireType)
			}
			m.Yinliang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Yinliang |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 109:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sp", wireType)
			}
			m.Sp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 110:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRecoverSpTime", wireType)
			}
			m.LastRecoverSpTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastRecoverSpTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 111:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuySpTimes", wireType)
			}
			m.BuySpTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuySpTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 112:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vip == nil {
				m.Vip = &HeroVipServerProto{}
			}
			if err := m.Vip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 113:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Promotion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Promotion == nil {
				m.Promotion = &HeroPromotionServerProto{}
			}
			if err := m.Promotion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 114:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McBuild", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.McBuild == nil {
				m.McBuild = &HeroMcBuildServerProto{}
			}
			if err := m.McBuild.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 115:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedPacket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RedPacket == nil {
				m.RedPacket = &HeroRedPacketServerProto{}
			}
			if err := m.RedPacket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 116:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Teach", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Teach == nil {
				m.Teach = &HeroTeachServerProto{}
			}
			if err := m.Teach.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 117:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryMisc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CountryMisc == nil {
				m.CountryMisc = &HeroCountryMiscServerProto{}
			}
			if err := m.CountryMisc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 141:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Activity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Activity == nil {
				m.Activity = &HeroActivityServerProto{}
			}
			if err := m.Activity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlackMarketGoodsItemServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlackMarketGoodsItemServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlackMarketGoodsItemServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			m.Goods = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Goods |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discount", wireType)
			}
			m.Discount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Discount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Buy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroShopServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroShopServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroShopServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Item = append(m.Item, &BlackMarketGoodsItemServerProto{})
			if err := m.Item[len(m.Item)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroMiscServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroMiscServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroMiscServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FarmShowUnlockAnimationBaseLevel", wireType)
			}
			m.FarmShowUnlockAnimationBaseLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FarmShowUnlockAnimationBaseLevel |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargeAmount", wireType)
			}
			m.ChargeAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChargeAmount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastChargeTime", wireType)
			}
			m.LastChargeTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastChargeTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.DurationCards == nil {
				m.DurationCards = make(map[uint64]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DurationCards[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.DurationCards[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroPromotionServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroPromotionServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroPromotionServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyTimeLimitGift", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuyTimeLimitGift = append(m.BuyTimeLimitGift, &proto34.TimeLimitGiftBoughtProto{})
			if err := m.BuyTimeLimitGift[len(m.BuyTimeLimitGift)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventLimitGifts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventLimitGifts = append(m.EventLimitGifts, &proto34.EventLimitGiftProto{})
			if err := m.EventLimitGifts[len(m.EventLimitGifts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroActivityServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroActivityServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroActivityServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Collections == nil {
				m.Collections = make(map[uint64]*HeroCollectionServerProto)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthHero
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthHero
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &HeroCollectionServerProto{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Collections[mapkey] = mapvalue
			} else {
				var mapvalue *HeroCollectionServerProto
				m.Collections[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroRelationServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroRelationServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroRelationServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Friend = append(m.Friend, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Friend = append(m.Friend, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Friend", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Black = append(m.Black, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Black = append(m.Black, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Black", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enemy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Enemy == nil {
				m.Enemy = make(map[int64]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Enemy[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.Enemy[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Important", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Important == nil {
				m.Important = make(map[int64]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Important[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.Important[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FriendCreateTime = append(m.FriendCreateTime, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FriendCreateTime = append(m.FriendCreateTime, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendCreateTime", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BlackCreateTime = append(m.BlackCreateTime, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BlackCreateTime = append(m.BlackCreateTime, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BlackCreateTime", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroRandomEventServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroRandomEventServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroRandomEventServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &EventPositionServerProto{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigRefreshTime", wireType)
			}
			m.BigRefreshTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BigRefreshTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmallRefreshTime", wireType)
			}
			m.SmallRefreshTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SmallRefreshTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Handbooks = append(m.Handbooks, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Handbooks = append(m.Handbooks, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Handbooks", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroTreasuryTreeServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroTreasuryTreeServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroTreasuryTreeServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaterTimes", wireType)
			}
			m.WaterTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaterTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectSession", wireType)
			}
			m.CollectSession = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectSession |= (proto27.Season(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectTime", wireType)
			}
			m.CollectTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WaterHeroIds = append(m.WaterHeroIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WaterHeroIds = append(m.WaterHeroIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WaterHeroIds", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.HelpMeHeroIds = append(m.HelpMeHeroIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.HelpMeHeroIds = append(m.HelpMeHeroIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HelpMeHeroIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroGuildEventPrizeServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroGuildEventPrizeServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroGuildEventPrizeServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HideGiver", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HideGiver = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataId", wireType)
			}
			m.DataId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendHeroId", wireType)
			}
			m.SendHeroId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendHeroId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTime", wireType)
			}
			m.ExpireTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroMapServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroMapServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroMapServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			m.Category = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Category |= (HeroMapCategory(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.DataMap == nil {
				m.DataMap = make(map[uint64]uint64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DataMap[mapkey] = mapvalue
			} else {
				var mapvalue uint64
				m.DataMap[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroKeysServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroKeysServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroKeysServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			m.Category = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Category |= (HeroMapCategory(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Keys = append(m.Keys, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Keys = append(m.Keys, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroClientDatasServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroClientDatasServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroClientDatasServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IntValue = append(m.IntValue, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IntValue = append(m.IntValue, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IntValue", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroReservationProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroReservationProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroReservationProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Food", wireType)
			}
			m.Food = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Food |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wood", wireType)
			}
			m.Wood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Wood |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stone", wireType)
			}
			m.Stone = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stone |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yuanbao", wireType)
			}
			m.Yuanbao = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Yuanbao |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildContributionCoin", wireType)
			}
			m.GuildContributionCoin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildContributionCoin |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jade", wireType)
			}
			m.Jade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Jade |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JadeOre", wireType)
			}
			m.JadeOre = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JadeOre |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dianquan", wireType)
			}
			m.Dianquan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dianquan |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yinliang", wireType)
			}
			m.Yinliang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Yinliang |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Goods == nil {
				m.Goods = make(map[uint64]uint64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Goods[mapkey] = mapvalue
			} else {
				var mapvalue uint64
				m.Goods[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 99:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastReserveTime", wireType)
			}
			m.LastReserveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastReserveTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoBaseProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoBaseProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoBaseProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prosperity", wireType)
			}
			m.Prosperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prosperity |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProsperityCapcity", wireType)
			}
			m.ProsperityCapcity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProsperityCapcity |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseType", wireType)
			}
			m.BaseType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroType", wireType)
			}
			m.HeroType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroId", wireType)
			}
			m.HeroId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroEndTime", wireType)
			}
			m.HeroEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroEndTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NpcDataId", wireType)
			}
			m.NpcDataId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NpcDataId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NpcType", wireType)
			}
			m.NpcType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NpcType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Soldier", wireType)
			}
			m.Soldier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Soldier |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightAmount", wireType)
			}
			m.FightAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightAmount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainSoldier = append(m.CaptainSoldier, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainSoldier = append(m.CaptainSoldier, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainSoldier", wireType)
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TroopCount", wireType)
			}
			m.TroopCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TroopCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseRegion", wireType)
			}
			m.BaseRegion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseRegion |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseLevel", wireType)
			}
			m.BaseLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseLevel |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseX", wireType)
			}
			m.BaseX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseY", wireType)
			}
			m.BaseY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prosperity", wireType)
			}
			m.Prosperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prosperity |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroHome) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroHome: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroHome: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &HeroBase{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LostProsperity", wireType)
			}
			m.LostProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LostProsperity |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextResetLostProsperityTime", wireType)
			}
			m.NextResetLostProsperityTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextResetLostProsperityTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopLostProsperity", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StopLostProsperity = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBaseLevel", wireType)
			}
			m.MaxBaseLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBaseLevel |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhiteFlagHeroId", wireType)
			}
			m.WhiteFlagHeroId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WhiteFlagHeroId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhiteFlagGuildId", wireType)
			}
			m.WhiteFlagGuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WhiteFlagGuildId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhiteFlagDisappearTime", wireType)
			}
			m.WhiteFlagDisappearTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WhiteFlagDisappearTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MianDisappearTime", wireType)
			}
			m.MianDisappearTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MianDisappearTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveBaseRestoreProsperityBufEndTime", wireType)
			}
			m.MoveBaseRestoreProsperityBufEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveBaseRestoreProsperityBufEndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewHeroMianDisappearTime", wireType)
			}
			m.NewHeroMianDisappearTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewHeroMianDisappearTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextUseMianGoodsTime", wireType)
			}
			m.NextUseMianGoodsTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextUseMianGoodsTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MianStartTime", wireType)
			}
			m.MianStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MianStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MianRebackTime", wireType)
			}
			m.MianRebackTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MianRebackTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroRegionServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroRegionServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroRegionServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Home", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Home == nil {
				m.Home = &HeroHome{}
			}
			if err := m.Home.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeDefenseTroopIndex", wireType)
			}
			m.HomeDefenseTroopIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HomeDefenseTroopIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeTroopDefeatedMailProto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HomeTroopDefeatedMailProto == nil {
				m.HomeTroopDefeatedMailProto = &proto26.MailProto{}
			}
			if err := m.HomeTroopDefeatedMailProto.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CreateHomeNpcBaseIds = append(m.CreateHomeNpcBaseIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CreateHomeNpcBaseIds = append(m.CreateHomeNpcBaseIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateHomeNpcBaseIds", wireType)
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeNpcBase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomeNpcBase = append(m.HomeNpcBase, &HeroHomeNpcBaseServerProto{})
			if err := m.HomeNpcBase[len(m.HomeNpcBase)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiLevelNpc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultiLevelNpc = append(m.MultiLevelNpc, &HeroMultiLevelNpcServerProto{})
			if err := m.MultiLevelNpc[len(m.MultiLevelNpc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiLevelNpcPassLevel", wireType)
			}
			m.MultiLevelNpcPassLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MultiLevelNpcPassLevel |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FavoritePoses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FavoritePoses == nil {
				m.FavoritePoses = &proto42.FavoritePosesProto{}
			}
			if err := m.FavoritePoses.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextInvestigateTime", wireType)
			}
			m.NextInvestigateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextInvestigateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiLevelNpcStartRecoveryTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MultiLevelNpcStartRecoveryTime == nil {
				m.MultiLevelNpcStartRecoveryTime = &proto1.RecoverableTimesWithExtraTimesProto{}
			}
			if err := m.MultiLevelNpcStartRecoveryTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Investigation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Investigation = append(m.Investigation, &HeroInvestigationServerProto{})
			if err := m.Investigation[len(m.Investigation)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiLevelNpcStartTime", wireType)
			}
			m.MultiLevelNpcStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MultiLevelNpcStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CopyDefenserCaptainId = append(m.CopyDefenserCaptainId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CopyDefenserCaptainId = append(m.CopyDefenserCaptainId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyDefenserCaptainId", wireType)
			}
		case 32:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CopyDefenserCaptainSoldier = append(m.CopyDefenserCaptainSoldier, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CopyDefenserCaptainSoldier = append(m.CopyDefenserCaptainSoldier, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyDefenserCaptainSoldier", wireType)
			}
		case 33:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CopyDefenserCaptainTotalSoldier = append(m.CopyDefenserCaptainTotalSoldier, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CopyDefenserCaptainTotalSoldier = append(m.CopyDefenserCaptainTotalSoldier, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyDefenserCaptainTotalSoldier", wireType)
			}
		case 34:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CopyDefenserCaptainIndex = append(m.CopyDefenserCaptainIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CopyDefenserCaptainIndex = append(m.CopyDefenserCaptainIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyDefenserCaptainIndex", wireType)
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyDefenserEndTime", wireType)
			}
			m.CopyDefenserEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CopyDefenserEndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvaseHeroStartTime", wireType)
			}
			m.InvaseHeroStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvaseHeroStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CopyDefenserCaptainXIndex = append(m.CopyDefenserCaptainXIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CopyDefenserCaptainXIndex = append(m.CopyDefenserCaptainXIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyDefenserCaptainXIndex", wireType)
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyDefenserTroopIndex", wireType)
			}
			m.CopyDefenserTroopIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CopyDefenserTroopIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JunTuanNpcStartTime", wireType)
			}
			m.JunTuanNpcStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JunTuanNpcStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyDefenserCaptainStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CopyDefenserCaptainStat = append(m.CopyDefenserCaptainStat, &proto1.SpriteStatProto{})
			if err := m.CopyDefenserCaptainStat[len(m.CopyDefenserCaptainStat)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CopyDefenserCaptainSpellFightAmountCoef = append(m.CopyDefenserCaptainSpellFightAmountCoef, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CopyDefenserCaptainSpellFightAmountCoef = append(m.CopyDefenserCaptainSpellFightAmountCoef, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyDefenserCaptainSpellFightAmountCoef", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroInvestigationServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroInvestigationServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroInvestigationServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			m.TargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTime", wireType)
			}
			m.ExpireTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailId", wireType)
			}
			m.MailId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MailId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroMultiLevelNpcServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroMultiLevelNpcServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroMultiLevelNpcServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (proto12.MultiLevelNpcType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassLevel", wireType)
			}
			m.PassLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PassLevel |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hate", wireType)
			}
			m.Hate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hate |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevengeLevel", wireType)
			}
			m.RevengeLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevengeLevel |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroHomeNpcBaseServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroHomeNpcBaseServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroHomeNpcBaseServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataId", wireType)
			}
			m.DataId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prosperity", wireType)
			}
			m.Prosperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prosperity |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroTowerServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroTowerServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroTowerServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTimes", wireType)
			}
			m.ChallengeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentFloor", wireType)
			}
			m.CurrentFloor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentFloor |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryMaxFloor", wireType)
			}
			m.HistoryMaxFloor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistoryMaxFloor |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoMaxFloor", wireType)
			}
			m.AutoMaxFloor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoMaxFloor |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryMaxFloorTime", wireType)
			}
			m.HistoryMaxFloorTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistoryMaxFloorTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CollectedBoxFloors = append(m.CollectedBoxFloors, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CollectedBoxFloors = append(m.CollectedBoxFloors, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedBoxFloors", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextResetChallengeTime", wireType)
			}
			m.NextResetChallengeTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextResetChallengeTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroSecretTowerServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroSecretTowerServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroSecretTowerServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelpTimes", wireType)
			}
			m.HelpTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HelpTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxOpenSecretTowerId", wireType)
			}
			m.MaxOpenSecretTowerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxOpenSecretTowerId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FirstPassSecretTowerId = append(m.FirstPassSecretTowerId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FirstPassSecretTowerId = append(m.FirstPassSecretTowerId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstPassSecretTowerId", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TodayAddCollectGuildContribution", wireType)
			}
			m.TodayAddCollectGuildContribution = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TodayAddCollectGuildContribution |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryChallengeTimes", wireType)
			}
			m.HistoryChallengeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistoryChallengeTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, &proto18.SecretRecordProto{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTimes", wireType)
			}
			m.ChallengeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroDungeonServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroDungeonServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroDungeonServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PassDungeons = append(m.PassDungeons, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PassDungeons = append(m.PassDungeons, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PassDungeons", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CollectedChapterPrizes = append(m.CollectedChapterPrizes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CollectedChapterPrizes = append(m.CollectedChapterPrizes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedChapterPrizes", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRecoverStartTime", wireType)
			}
			m.AutoRecoverStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoRecoverStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectAutoTimesIndex", wireType)
			}
			m.CollectAutoTimesIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectAutoTimesIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CollectedPassDungeonPrizes = append(m.CollectedPassDungeonPrizes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CollectedPassDungeonPrizes = append(m.CollectedPassDungeonPrizes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedPassDungeonPrizes", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipPassLimitBoughtTimes", wireType)
			}
			m.VipPassLimitBoughtTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipPassLimitBoughtTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipAddPassLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.VipAddPassLimit == nil {
				m.VipAddPassLimit = make(map[uint64]uint64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.VipAddPassLimit[mapkey] = mapvalue
			} else {
				var mapvalue uint64
				m.VipAddPassLimit[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipAddPassBoughtTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.VipAddPassBoughtTimes == nil {
				m.VipAddPassBoughtTimes = make(map[uint64]uint64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.VipAddPassBoughtTimes[mapkey] = mapvalue
			} else {
				var mapvalue uint64
				m.VipAddPassBoughtTimes[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DungeonStars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DungeonStars = append(m.DungeonStars, &proto22.DungeonStar{})
			if err := m.DungeonStars[len(m.DungeonStars)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DungeonLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DungeonLimits = append(m.DungeonLimits, &proto22.DungeonPassLimit{})
			if err := m.DungeonLimits[len(m.DungeonLimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapterStars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChapterStars = append(m.ChapterStars, &proto22.DungeonChapterStar{})
			if err := m.ChapterStars[len(m.ChapterStars)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapterStarPrizes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChapterStarPrizes = append(m.ChapterStarPrizes, &proto22.CollectedChapterStarPrizes{})
			if err := m.ChapterStarPrizes[len(m.ChapterStarPrizes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroTaskServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroTaskServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroTaskServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainTask", wireType)
			}
			m.MainTask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MainTask |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainTaskProgress", wireType)
			}
			m.MainTaskProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MainTaskProgress |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BranchTask = append(m.BranchTask, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BranchTask = append(m.BranchTask, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BranchTask", wireType)
			}
		case 12:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BranchTaskProgress = append(m.BranchTaskProgress, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BranchTaskProgress = append(m.BranchTaskProgress, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BranchTaskProgress", wireType)
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaYeStage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaYeStage == nil {
				m.BaYeStage = &HeroBaYeStageServerProto{}
			}
			if err := m.BaYeStage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCompleteBaYeStage", wireType)
			}
			m.LastCompleteBaYeStage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastCompleteBaYeStage |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AchieveTaskList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AchieveTaskList == nil {
				m.AchieveTaskList = &AchieveTaskListServerProto{}
			}
			if err := m.AchieveTaskList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveDegreeTaskList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActiveDegreeTaskList == nil {
				m.ActiveDegreeTaskList = &ActiveDegreeTaskListServerProto{}
			}
			if err := m.ActiveDegreeTaskList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BwzlTaskList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BwzlTaskList == nil {
				m.BwzlTaskList = &BwzlTaskListServerProto{}
			}
			if err := m.BwzlTaskList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TitleTaskList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TitleTaskList == nil {
				m.TitleTaskList = &TitleTaskListServerProto{}
			}
			if err := m.TitleTaskList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityTaskListModeMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.ActivityTaskListModeMap == nil {
				m.ActivityTaskListModeMap = make(map[uint64]*ActivityTaskListModeServerProto)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthHero
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthHero
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &ActivityTaskListModeServerProto{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.ActivityTaskListModeMap[mapkey] = mapvalue
			} else {
				var mapvalue *ActivityTaskListModeServerProto
				m.ActivityTaskListModeMap[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 50:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TaskMonster = append(m.TaskMonster, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TaskMonster = append(m.TaskMonster, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskMonster", wireType)
			}
		case 51:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TaskMonsterCreate = append(m.TaskMonsterCreate, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TaskMonsterCreate = append(m.TaskMonsterCreate, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskMonsterCreate", wireType)
			}
		case 99:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectTaskBoxId", wireType)
			}
			m.CollectTaskBoxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectTaskBoxId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AchieveTaskListServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AchieveTaskListServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AchieveTaskListServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &AchieveTaskServerProto{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CollectStarCount = append(m.CollectStarCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CollectStarCount = append(m.CollectStarCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectStarCount", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SelectShowAchieves = append(m.SelectShowAchieves, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SelectShowAchieves = append(m.SelectShowAchieves, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectShowAchieves", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AchieveTaskServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AchieveTaskServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AchieveTaskServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			m.Progress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Progress |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCollected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCollected = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReachTime", wireType)
			}
			m.ReachTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReachTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveDegreeTaskListServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveDegreeTaskListServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveDegreeTaskListServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &ActiveDegreeTaskServerProto{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CollectedPrizeIndex = append(m.CollectedPrizeIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CollectedPrizeIndex = append(m.CollectedPrizeIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedPrizeIndex", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveDegreeTaskServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveDegreeTaskServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveDegreeTaskServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			m.Progress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Progress |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroBaYeStageServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroBaYeStageServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroBaYeStageServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			m.Stage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stage |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TaskId = append(m.TaskId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TaskId = append(m.TaskId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
		case 12:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TaskProgress = append(m.TaskProgress, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TaskProgress = append(m.TaskProgress, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskProgress", wireType)
			}
		case 13:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IsCollected = append(m.IsCollected, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IsCollected = append(m.IsCollected, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCollected", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BwzlTaskListServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BwzlTaskListServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BwzlTaskListServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &BwzlTaskServerProto{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CollectedPrizes = append(m.CollectedPrizes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHero
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHero
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHero
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CollectedPrizes = append(m.CollectedPrizes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedPrizes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BwzlTaskServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BwzlTaskServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BwzlTaskServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			m.Progress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Progress |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCollected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCollected = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TitleTaskListServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TitleTaskListServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TitleTaskListServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedTitleId", wireType)
			}
			m.CompletedTitleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletedTitleId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &TitleTaskServerProto{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TitleTaskServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TitleTaskServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TitleTaskServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			m.Progress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Progress |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityTaskListModeServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivityTaskListModeServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivityTaskListModeServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tasks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tasks = append(m.Tasks, &ActivityTaskServerProto{})
			if err := m.Tasks[len(m.Tasks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityTaskServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivityTaskServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivityTaskServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			m.Progress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Progress |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCollected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCollected = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StratagemServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StratagemServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StratagemServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyUsedTimes", wireType)
			}
			m.DailyUsedTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailyUsedTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextUseableTime", wireType)
			}
			m.NextUseableTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextUseableTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrappedStratagemServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrappedStratagemServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrappedStratagemServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StratagemTargetTimesServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StratagemTargetTimesServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StratagemTargetTimesServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Times", wireType)
			}
			m.Times = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Times |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroStrategyServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroStrategyServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroStrategyServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrappedStratagems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrappedStratagems = append(m.TrappedStratagems, &TrappedStratagemServerProto{})
			if err := m.TrappedStratagems[len(m.TrappedStratagems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TodayTargetTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TodayTargetTimes = append(m.TodayTargetTimes, &StratagemTargetTimesServerProto{})
			if err := m.TodayTargetTimes[len(m.TodayTargetTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TodayTrappedTimes", wireType)
			}
			m.TodayTrappedTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TodayTrappedTimes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stratagems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stratagems = append(m.Stratagems, &StratagemServerProto{})
			if err := m.Stratagems[len(m.Stratagems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroBufferServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHero
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroBufferServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroBufferServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHero
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHero
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Buf == nil {
				m.Buf = &proto43.HeroBufferProto{}
			}
			if err := m.Buf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHero(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHero
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHero(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHero
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHero
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHero
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthHero
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowHero
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipHero(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthHero = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHero   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/server_proto/hero.proto", fileDescriptorHero)
}

var fileDescriptorHero = []byte{
	// 6757 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x7c, 0x4b, 0x6f, 0x1c, 0x49,
	0xd2, 0xd8, 0x36, 0x1f, 0x62, 0x33, 0xf9, 0x2a, 0x26, 0x29, 0xb2, 0x44, 0xea, 0x41, 0xb5, 0x1e,
	0x43, 0x69, 0x24, 0x6a, 0x46, 0xd2, 0x48, 0x1a, 0xcd, 0x93, 0x0f, 0x91, 0xa2, 0x46, 0x94, 0x34,
	0x4d, 0xcd, 0x68, 0x76, 0x80, 0x75, 0x39, 0xbb, 0x2a, 0xbb, 0xbb, 0x86, 0xd5, 0x55, 0x35, 0x95,
	0x55, 0x24, 0x5b, 0xf6, 0x79, 0x6f, 0x7b, 0x30, 0xe0, 0xc3, 0x02, 0xbe, 0xd9, 0x06, 0xec, 0xdb,
	0x02, 0xfe, 0x0f, 0x86, 0x0d, 0x18, 0x36, 0x7c, 0x34, 0x60, 0xe0, 0xfb, 0x16, 0xfb, 0x5d, 0xbe,
	0x9f, 0xf1, 0x21, 0x22, 0xb2, 0x5e, 0xdd, 0x4d, 0x49, 0x1c, 0xec, 0x49, 0xac, 0x78, 0x65, 0x64,
	0x64, 0x64, 0x64, 0x64, 0x44, 0xb6, 0xd8, 0xfd, 0x96, 0x1b, 0xb7, 0x93, 0xc6, 0x9a, 0x1d, 0x74,
	0xee, 0x78, 0x6e, 0xab, 0x1d, 0x87, 0xe2, 0xe8, 0x4e, 0x47, 0x78, 0xf2, 0xe1, 0x9d, 0xb0, 0x71,
	0x47, 0xc9, 0xe8, 0x50, 0x46, 0x56, 0x18, 0x05, 0x71, 0x70, 0xa7, 0x2d, 0xa3, 0x60, 0x0d, 0xff,
	0xe4, 0xa3, 0xf8, 0xcf, 0xd2, 0xa3, 0xd3, 0x31, 0x5b, 0x2d, 0xe9, 0xaf, 0x9d, 0x9a, 0xd3, 0x09,
	0x3a, 0x52, 0xc5, 0xae, 0x7d, 0x7a, 0xce, 0x8e, 0xeb, 0xb9, 0xb1, 0x88, 0xba, 0x9a, 0xf3, 0xb3,
	0x53, 0x8c, 0x29, 0xc3, 0x20, 0xd6, 0x6c, 0x5f, 0x7e, 0x38, 0x9b, 0x2d, 0xc2, 0x58, 0xb8, 0xbe,
	0xa5, 0x82, 0xc4, 0xd3, 0xdc, 0x0f, 0x3f, 0x9c, 0xfb, 0x6d, 0x5b, 0xfa, 0xad, 0xa3, 0x44, 0x33,
	0x7e, 0x7e, 0x1a, 0x46, 0xe1, 0xff, 0xe2, 0x0a, 0xbf, 0x75, 0x7a, 0x8d, 0x23, 0xe1, 0x3b, 0x41,
	0xc7, 0x92, 0x87, 0xd2, 0x8f, 0x4f, 0x6f, 0xe0, 0x66, 0xe2, 0xdb, 0xb1, 0x1b, 0xf8, 0xa7, 0x37,
	0x70, 0x2b, 0x71, 0xdf, 0xa6, 0x33, 0x3d, 0x85, 0x0b, 0x36, 0x92, 0x66, 0x53, 0x73, 0xdd, 0xfb,
	0x70, 0xae, 0x43, 0x37, 0xd4, 0x4c, 0x8f, 0x4f, 0x61, 0x19, 0xe9, 0x58, 0xa1, 0xb0, 0x0f, 0x64,
	0x7c, 0xfa, 0xd9, 0x75, 0x5c, 0xbf, 0x65, 0x9f, 0x9e, 0x2d, 0x96, 0xc2, 0x6e, 0x9f, 0xde, 0x6f,
	0xec, 0x20, 0xf1, 0xe3, 0xcc, 0xcb, 0x4f, 0xb1, 0x7c, 0xc2, 0x8e, 0xdd, 0x43, 0x37, 0xee, 0x7e,
	0x98, 0x45, 0xdb, 0x02, 0x4d, 0x42, 0x9a, 0x8a, 0xd6, 0x87, 0x2d, 0x5e, 0x91, 0x29, 0x8f, 0x1f,
	0xef, 0x9b, 0x5d, 0x91, 0xab, 0xe9, 0xaa, 0xb6, 0xeb, 0xff, 0x86, 0xe1, 0x3a, 0xc2, 0x4d, 0x37,
	0xe1, 0x83, 0x0f, 0xe7, 0x8a, 0x64, 0x2b, 0x77, 0xe8, 0x47, 0x1f, 0xce, 0xf7, 0x6b, 0x02, 0x41,
	0x2a, 0xe3, 0x3c, 0xc5, 0x88, 0x4a, 0x0a, 0xf5, 0x9b, 0xf8, 0x92, 0xe8, 0x50, 0x76, 0x4f, 0x6f,
	0x97, 0x86, 0x50, 0xf2, 0xf4, 0xcb, 0xa0, 0x64, 0x1c, 0xe7, 0xcb, 0xf0, 0xd9, 0x29, 0x5c, 0x25,
	0x38, 0x92, 0xd1, 0x6f, 0x71, 0x96, 0x86, 0x7b, 0x7a, 0x2d, 0x9d, 0xc4, 0x6f, 0xc9, 0xdf, 0x62,
	0x4c, 0x08, 0x2c, 0x99, 0x9a, 0x9f, 0x7f, 0x38, 0x5f, 0x18, 0x05, 0x9d, 0x20, 0x5f, 0xf7, 0xda,
	0x7f, 0xba, 0xcc, 0x66, 0x9e, 0xca, 0x28, 0xd8, 0xc7, 0x7d, 0xf6, 0x0a, 0x0f, 0xcb, 0x69, 0x36,
	0xe4, 0x3a, 0x66, 0x65, 0xa5, 0xb2, 0x3a, 0x5c, 0x1f, 0x72, 0x1d, 0xce, 0xd9, 0x88, 0x2f, 0x3a,
	0xd2, 0x1c, 0x5a, 0xa9, 0xac, 0x8e, 0xd7, 0xf1, 0x6f, 0xfe, 0x98, 0x55, 0xd3, 0x73, 0xce, 0x1c,
	0x5e, 0xa9, 0xac, 0x4e, 0xdc, 0xbd, 0x48, 0x12, 0xd7, 0x40, 0xda, 0x96, 0x46, 0x15, 0xa4, 0xd6,
	0x33, 0x7a, 0xe0, 0x4d, 0x4f, 0x3a, 0x73, 0xa4, 0x8f, 0x77, 0x4f, 0xa3, 0x4a, 0xbc, 0x29, 0x3d,
	0x3f, 0xc7, 0xaa, 0x81, 0xe7, 0x58, 0xa8, 0xcf, 0xe8, 0xca, 0xf0, 0xea, 0x78, 0x7d, 0x2c, 0xf0,
	0x9c, 0x17, 0xa0, 0xd2, 0x3c, 0x1b, 0xf5, 0xe4, 0xa1, 0xf4, 0xcc, 0xc9, 0x95, 0xca, 0xea, 0x48,
	0x9d, 0x3e, 0xb8, 0xc1, 0x86, 0xe5, 0x71, 0x68, 0x4e, 0x21, 0x0c, 0xfe, 0x84, 0xe9, 0x80, 0x6d,
	0xcc, 0xe9, 0x95, 0xca, 0x6a, 0xb5, 0x8e, 0x7f, 0xf3, 0x4f, 0xd9, 0x59, 0x5f, 0x1e, 0xc7, 0x96,
	0xdd, 0x16, 0x7e, 0x4b, 0xa2, 0x78, 0x2b, 0x76, 0x3b, 0xd2, 0x9c, 0x41, 0x2b, 0x70, 0x40, 0x6e,
	0x22, 0x0e, 0x86, 0x7a, 0xed, 0x76, 0x24, 0xbf, 0xc9, 0x66, 0x3d, 0xa1, 0x62, 0x2b, 0x68, 0x36,
	0x3d, 0xd7, 0xd7, 0xe4, 0xb3, 0x48, 0x3e, 0x03, 0x88, 0x97, 0x04, 0x47, 0xda, 0x7b, 0x6c, 0x41,
	0x4b, 0xc6, 0xb4, 0x22, 0x13, 0xaf, 0x4c, 0x8e, 0x7a, 0xcd, 0x11, 0x16, 0xa6, 0x9f, 0xca, 0x57,
	0x7c, 0x87, 0x5d, 0x6e, 0xb9, 0x87, 0xd2, 0x6a, 0xba, 0x91, 0xca, 0x34, 0xcb, 0xf9, 0xc3, 0xc8,
	0x7d, 0x2b, 0xcd, 0x39, 0x9c, 0xc4, 0x79, 0x20, 0xdc, 0x06, 0xba, 0xcd, 0x92, 0xa0, 0x57, 0x40,
	0x03, 0x13, 0x6e, 0x04, 0x4e, 0xd7, 0x3c, 0x8b, 0x63, 0xe1, 0xdf, 0x7c, 0x99, 0x8d, 0x2b, 0xd1,
	0x94, 0x56, 0x2b, 0xf0, 0x1c, 0x73, 0x01, 0x11, 0x55, 0x00, 0xec, 0x04, 0x9e, 0x93, 0x21, 0x9b,
	0x41, 0xe0, 0x98, 0x8b, 0x39, 0x72, 0x3b, 0x08, 0x72, 0xe4, 0x11, 0x20, 0xcd, 0x1c, 0xf9, 0x06,
	0x90, 0x17, 0x18, 0x43, 0xa4, 0x8a, 0x03, 0x5f, 0x9a, 0xe7, 0x10, 0x8b, 0xe4, 0xfb, 0x00, 0x00,
	0x4d, 0xda, 0x52, 0x38, 0xe6, 0x12, 0x79, 0x12, 0xfc, 0xcd, 0xef, 0xb3, 0x33, 0x14, 0xc3, 0xcc,
	0x8b, 0xe8, 0x0b, 0xe7, 0x0b, 0xbe, 0x50, 0x47, 0x44, 0xd1, 0x13, 0x34, 0x2d, 0xf8, 0x41, 0x2b,
	0x71, 0x3d, 0xc7, 0x72, 0x1d, 0xf3, 0x12, 0x1a, 0x7d, 0x0c, 0xbf, 0x77, 0x1d, 0x7e, 0x9d, 0xcd,
	0xfc, 0x12, 0xb8, 0xbe, 0x45, 0x78, 0x5c, 0x96, 0x15, 0xa4, 0x98, 0x02, 0xf0, 0x0e, 0x40, 0x71,
	0x51, 0xb6, 0xd9, 0x8a, 0x1d, 0x78, 0x9e, 0xb4, 0x63, 0xe9, 0x58, 0x8e, 0x70, 0xbd, 0xae, 0x66,
	0x89, 0x84, 0x7f, 0xa0, 0xcd, 0x7b, 0x99, 0xcc, 0x9b, 0xd1, 0x6d, 0x01, 0x19, 0x8a, 0xa8, 0x0b,
	0xff, 0x80, 0xcc, 0xfb, 0x31, 0x9b, 0xb5, 0x03, 0x3f, 0x8e, 0xdc, 0x46, 0x02, 0x1b, 0xcb, 0xb2,
	0x03, 0xd7, 0x37, 0xaf, 0xe0, 0xd4, 0x8d, 0x22, 0x62, 0x33, 0x70, 0x7d, 0x7e, 0x8b, 0x71, 0x1a,
	0xc4, 0x09, 0x7c, 0x11, 0xa7, 0x5e, 0x70, 0x75, 0x65, 0x18, 0xa8, 0x11, 0xb3, 0x85, 0x08, 0x72,
	0x81, 0xab, 0x6c, 0xba, 0x30, 0x15, 0xd7, 0x51, 0xe6, 0xb5, 0x95, 0xe1, 0xd5, 0xe1, 0xfa, 0x64,
	0x36, 0x93, 0x5d, 0x47, 0x81, 0xf3, 0x36, 0xa4, 0xf4, 0x2d, 0xd7, 0x3f, 0x04, 0x91, 0x39, 0xf1,
	0x75, 0x24, 0xe6, 0x80, 0xdc, 0x45, 0x5c, 0xc6, 0x72, 0x8f, 0x2d, 0xa0, 0xbf, 0xfb, 0x41, 0xec,
	0x36, 0xbb, 0x45, 0x53, 0x7d, 0x84, 0xa6, 0x9a, 0x03, 0xec, 0x0b, 0x44, 0x9e, 0x60, 0x30, 0xf2,
	0xca, 0x82, 0x76, 0x64, 0xb0, 0xd5, 0x1e, 0x83, 0xa1, 0x53, 0x3e, 0x4b, 0xb5, 0x25, 0x83, 0x99,
	0x6c, 0xac, 0x9b, 0x08, 0xbf, 0x21, 0x02, 0xf3, 0x06, 0x9a, 0x29, 0xfd, 0x04, 0xff, 0x40, 0x87,
	0xbc, 0x49, 0x9e, 0x0a, 0x7f, 0x03, 0x0c, 0xfd, 0xf0, 0x63, 0x82, 0xc1, 0xdf, 0x00, 0x43, 0xf7,
	0xbb, 0x45, 0x30, 0xf8, 0x1b, 0xb6, 0x3f, 0x79, 0xdd, 0x6d, 0xda, 0xfe, 0x2a, 0xf5, 0xb8, 0x5f,
	0x84, 0x23, 0xcd, 0x35, 0xa2, 0x84, 0xbf, 0xc1, 0x77, 0xe0, 0x5f, 0x2b, 0x88, 0xa4, 0x79, 0x87,
	0x14, 0x80, 0xef, 0x97, 0x91, 0xe4, 0x97, 0xd9, 0x64, 0xdb, 0x55, 0x71, 0x10, 0x75, 0x2d, 0x64,
	0xfb, 0x04, 0xd1, 0x13, 0x1a, 0xf6, 0x0c, 0xb8, 0x6f, 0xb2, 0xd9, 0x38, 0x70, 0x44, 0xd7, 0x0a,
	0x1a, 0x98, 0x3b, 0x23, 0xdd, 0xa7, 0x48, 0x37, 0x83, 0x88, 0x97, 0x08, 0x47, 0xda, 0x4f, 0xd9,
	0x28, 0x66, 0xe6, 0xe6, 0x3d, 0x74, 0xed, 0xe5, 0x62, 0x88, 0x04, 0x78, 0xd1, 0xb3, 0x89, 0x12,
	0x58, 0xf0, 0x04, 0x32, 0xef, 0xf7, 0xb1, 0xbc, 0x06, 0x78, 0x89, 0x05, 0x29, 0xf9, 0x1a, 0x1b,
	0x89, 0x85, 0x3a, 0x30, 0x3f, 0x43, 0x8e, 0xa5, 0x22, 0x87, 0x50, 0x07, 0x45, 0x06, 0xa4, 0xe3,
	0x4f, 0xd9, 0x64, 0x31, 0xf1, 0x37, 0x1f, 0x20, 0xdf, 0xe5, 0x02, 0xdf, 0x26, 0xa1, 0xf7, 0x83,
	0xc4, 0x2b, 0xb0, 0x6f, 0x0c, 0x99, 0x95, 0xfa, 0x84, 0x9d, 0xe3, 0xf8, 0x6b, 0xc6, 0x83, 0x50,
	0x82, 0xcb, 0x77, 0x1a, 0x10, 0x03, 0xe5, 0xaf, 0x89, 0x1b, 0x9a, 0x0f, 0x51, 0xde, 0xf5, 0x82,
	0xbc, 0x97, 0xa1, 0xf4, 0x37, 0x89, 0xe6, 0x09, 0x90, 0x14, 0x75, 0x32, 0x82, 0x1e, 0x24, 0xdf,
	0x62, 0x93, 0x4a, 0xda, 0x91, 0x8c, 0x2d, 0xb2, 0xc4, 0xa3, 0x3e, 0xfd, 0xf6, 0x11, 0xdd, 0x67,
	0x8f, 0x09, 0x95, 0xc3, 0xf9, 0x43, 0x36, 0xa6, 0x4f, 0x57, 0xf3, 0x31, 0x0a, 0xb8, 0x50, 0xb4,
	0x3e, 0x61, 0x8a, 0xcc, 0x29, 0x35, 0xff, 0x86, 0xb1, 0x46, 0xd2, 0xb4, 0x64, 0xb3, 0x29, 0xed,
	0xd8, 0xfc, 0xa2, 0x2f, 0x28, 0x6d, 0xe0, 0xd1, 0xdb, 0x6b, 0x97, 0xf1, 0x46, 0xd2, 0x7c, 0x82,
	0x2c, 0xfc, 0x1a, 0x1b, 0x8e, 0x45, 0xcb, 0xfc, 0x12, 0x39, 0xe7, 0x4a, 0xcb, 0xd1, 0xa2, 0xb1,
	0x00, 0x0f, 0xc7, 0xa0, 0x8a, 0x23, 0x11, 0xcb, 0x56, 0xd7, 0xfc, 0xaa, 0xef, 0x18, 0xdc, 0xd7,
	0xa8, 0xd2, 0x31, 0x98, 0xd2, 0x83, 0x89, 0x6c, 0xcf, 0x95, 0x7e, 0x6c, 0x39, 0x22, 0x16, 0xca,
	0xfc, 0xba, 0x7f, 0x09, 0x11, 0xbd, 0x05, 0xd8, 0x92, 0x89, 0xec, 0x1c, 0xce, 0x3f, 0x65, 0x63,
	0x3a, 0x5b, 0x35, 0xbf, 0x41, 0x01, 0x8b, 0x05, 0x01, 0xdb, 0x84, 0xd1, 0xc6, 0xd1, 0x74, 0xa0,
	0x74, 0x7a, 0x89, 0x32, 0xbf, 0xed, 0x53, 0x7a, 0x5b, 0xa3, 0x4a, 0x4a, 0xa7, 0xf4, 0xfc, 0x2e,
	0x3b, 0xd3, 0x4a, 0x5c, 0xeb, 0x6d, 0x62, 0xae, 0xf7, 0xf9, 0xf6, 0x4e, 0xe2, 0xfe, 0x9c, 0x94,
	0x7c, 0xbb, 0x05, 0x10, 0xbe, 0x9f, 0xc6, 0x4b, 0xbc, 0xf1, 0x51, 0x90, 0x51, 0xe6, 0xc6, 0xca,
	0xf0, 0xea, 0xc4, 0xdd, 0x6b, 0x65, 0x7e, 0xcf, 0x79, 0x02, 0x34, 0x18, 0x63, 0x4a, 0x0e, 0xd6,
	0x2a, 0xe3, 0xe0, 0x64, 0x9d, 0x8a, 0x23, 0x29, 0x54, 0x12, 0x75, 0xad, 0x38, 0x92, 0xd2, 0xdc,
	0x44, 0x7d, 0x6a, 0xc5, 0xa5, 0xd2, 0xf8, 0xd7, 0x91, 0x2c, 0x09, 0x9b, 0x8c, 0x0b, 0x08, 0xfe,
	0x88, 0x55, 0xf1, 0x12, 0x6c, 0x1d, 0x25, 0xe6, 0x56, 0x9f, 0x93, 0xfd, 0x0c, 0xa8, 0x37, 0xa5,
	0x59, 0x8d, 0xbd, 0x25, 0x18, 0xff, 0x9a, 0x31, 0xb8, 0x05, 0x5b, 0x78, 0x0d, 0x36, 0x9f, 0x20,
	0xef, 0xa5, 0x12, 0xaf, 0xf0, 0x9f, 0x01, 0xae, 0xc8, 0x3d, 0xfe, 0x36, 0x85, 0xf2, 0xfb, 0xac,
	0x9a, 0x66, 0xf0, 0xe6, 0x36, 0x72, 0x9b, 0x05, 0xee, 0xef, 0x35, 0x4a, 0xaf, 0x40, 0x4a, 0x09,
	0xab, 0x17, 0x49, 0x4f, 0x20, 0xd7, 0x4e, 0xdf, 0xea, 0xd5, 0x35, 0xaa, 0xb4, 0x7a, 0x29, 0x3d,
	0x5f, 0x63, 0x67, 0x28, 0x83, 0x37, 0x9f, 0x22, 0xe7, 0x42, 0xd1, 0x59, 0x11, 0xa1, 0x4f, 0x68,
	0xa2, 0xe2, 0x97, 0xd8, 0x84, 0x1d, 0xc9, 0xf4, 0x8c, 0x33, 0x77, 0xf1, 0x5c, 0x61, 0x04, 0xc2,
	0xe3, 0xe4, 0x3e, 0xab, 0xea, 0x24, 0x5d, 0x99, 0xcf, 0xfa, 0xa6, 0xb0, 0xaf, 0x51, 0xa9, 0xe7,
	0xeb, 0x4f, 0xbe, 0x0a, 0x29, 0x44, 0xc3, 0x35, 0xbf, 0x43, 0x8e, 0xf9, 0x02, 0xc7, 0x53, 0xd9,
	0x70, 0x75, 0x98, 0x03, 0x0a, 0xbe, 0xc4, 0xaa, 0x5e, 0x60, 0xd3, 0x64, 0x9f, 0x53, 0x9e, 0x92,
	0x7e, 0x43, 0xc8, 0x54, 0xed, 0x20, 0x34, 0xf7, 0xfa, 0x42, 0xe6, 0x7e, 0x3b, 0x28, 0x85, 0x27,
	0xa4, 0x83, 0xfd, 0x56, 0xac, 0x3c, 0x98, 0x2f, 0xfa, 0xf6, 0x5b, 0x1d, 0xd1, 0xe8, 0x65, 0xa5,
	0xfd, 0x16, 0xe5, 0x70, 0x18, 0x15, 0xf2, 0x76, 0xf3, 0x65, 0xdf, 0xa8, 0x10, 0x53, 0x4a, 0xa3,
	0x02, 0x1d, 0xff, 0x82, 0x2d, 0x1d, 0x05, 0xd1, 0x01, 0x68, 0x60, 0x05, 0x49, 0x1c, 0x26, 0xb1,
	0xa5, 0x62, 0x11, 0xc5, 0x64, 0xd1, 0x57, 0x68, 0xd1, 0xc5, 0x94, 0xe2, 0x25, 0x12, 0xec, 0x03,
	0x1e, 0xcd, 0xab, 0xd8, 0x72, 0x7e, 0x5a, 0xeb, 0x03, 0x5e, 0xa8, 0x03, 0x90, 0xd0, 0x92, 0xca,
	0xfc, 0x1e, 0xb7, 0xd0, 0xfd, 0x92, 0xc5, 0xb3, 0xf1, 0xd7, 0x36, 0x53, 0x4e, 0x3a, 0xfd, 0xe1,
	0x18, 0x41, 0xb6, 0x27, 0x70, 0x71, 0xaf, 0x9b, 0xf6, 0x09, 0x68, 0xfe, 0x15, 0x9b, 0x88, 0x24,
	0xdc, 0xd9, 0xc9, 0xec, 0xa2, 0x6f, 0x9f, 0xd7, 0x73, 0x6c, 0x6a, 0xa0, 0x1c, 0x42, 0x67, 0x6b,
	0x2c, 0x3c, 0x2b, 0xf0, 0xf3, 0x9c, 0xba, 0x41, 0x39, 0x35, 0x22, 0x5e, 0xfa, 0x59, 0x4e, 0x7d,
	0x81, 0x31, 0x2f, 0x68, 0xb9, 0x3e, 0x11, 0x39, 0x48, 0x34, 0x8e, 0x10, 0x44, 0x3f, 0x60, 0xe3,
	0x98, 0x2b, 0x77, 0x44, 0xa8, 0x4c, 0x89, 0x93, 0x3d, 0x57, 0xbc, 0x65, 0x88, 0xd2, 0x2a, 0x57,
	0xdb, 0x04, 0x53, 0x20, 0x16, 0xf9, 0x1a, 0x41, 0xe0, 0x29, 0xb3, 0x89, 0x89, 0x19, 0x4a, 0xda,
	0x00, 0x00, 0x2c, 0x61, 0xc7, 0x55, 0xb6, 0xd9, 0xea, 0x5b, 0xc2, 0x3d, 0x57, 0x95, 0xee, 0x3b,
	0x48, 0x07, 0x4e, 0xe8, 0xb8, 0xc2, 0xff, 0x35, 0x11, 0xbe, 0xd9, 0x26, 0x27, 0x4c, 0xbf, 0xf9,
	0x6d, 0x86, 0x69, 0x96, 0x15, 0x49, 0x65, 0x39, 0xd2, 0x16, 0x5d, 0x9a, 0x8a, 0x8b, 0x53, 0x31,
	0x00, 0x55, 0x97, 0x6a, 0x0b, 0x10, 0xe9, 0x7e, 0x49, 0x8b, 0x92, 0xe6, 0x2f, 0x38, 0x7c, 0x71,
	0x42, 0x3b, 0xb2, 0x7c, 0x9a, 0xb5, 0x09, 0xc6, 0x1f, 0x6a, 0x3b, 0x1c, 0xc8, 0xae, 0x32, 0x0f,
	0xd0, 0x0e, 0x45, 0xad, 0xbf, 0x93, 0x5d, 0xd5, 0x67, 0x08, 0x00, 0x82, 0xe6, 0x5d, 0xd7, 0xf7,
	0x30, 0x3e, 0x79, 0xa4, 0x79, 0xfa, 0x0d, 0x37, 0x44, 0x15, 0x9a, 0x1d, 0x84, 0x0e, 0xa9, 0x90,
	0xdf, 0x61, 0xf3, 0x78, 0x17, 0x8a, 0xa4, 0x1d, 0x1c, 0xca, 0xc8, 0x52, 0x21, 0x4d, 0xc5, 0xc7,
	0xa9, 0xe0, 0x3d, 0xa9, 0x4e, 0xa8, 0xfd, 0x10, 0xe7, 0xb2, 0xc2, 0x26, 0x1b, 0x49, 0x37, 0xa5,
	0x53, 0x66, 0x80, 0xa2, 0x58, 0x23, 0xe9, 0x12, 0x81, 0xe2, 0x1f, 0xb3, 0xe1, 0x43, 0x37, 0x34,
	0xc3, 0xbe, 0x89, 0xfe, 0x58, 0x4e, 0x1f, 0x80, 0x8a, 0x7f, 0xc5, 0xc6, 0xb3, 0x8b, 0xad, 0xf9,
	0x6b, 0x5f, 0x30, 0x7d, 0x95, 0xe2, 0x4a, 0xc1, 0x34, 0xe3, 0x80, 0x30, 0xde, 0xb1, 0xad, 0x06,
	0xf8, 0xb2, 0x19, 0xf5, 0x85, 0xf1, 0x3d, 0x7b, 0x03, 0x30, 0x25, 0xeb, 0x76, 0x08, 0x06, 0x61,
	0x3c, 0xaf, 0xbb, 0x99, 0xaa, 0x6f, 0xe4, 0xba, 0x74, 0x5e, 0x21, 0xae, 0x34, 0x72, 0x94, 0x42,
	0x31, 0xdb, 0x93, 0xc2, 0x6e, 0x9b, 0x71, 0x7f, 0xb6, 0x07, 0xf0, 0x72, 0xb6, 0x07, 0x10, 0x3c,
	0xfa, 0xa9, 0x80, 0x66, 0xa1, 0x27, 0x26, 0xfd, 0x47, 0x3f, 0xa1, 0x7b, 0x1d, 0x72, 0xc2, 0xce,
	0xe1, 0xfc, 0x0b, 0x56, 0x4d, 0xab, 0x69, 0xe6, 0x9f, 0x2a, 0x7d, 0x47, 0xc1, 0xba, 0xc6, 0x95,
	0x5c, 0x23, 0x65, 0x58, 0xb2, 0xd9, 0x85, 0x77, 0x06, 0x08, 0xb8, 0x74, 0x1f, 0xc8, 0x2e, 0x96,
	0x10, 0x46, 0xea, 0xf0, 0x27, 0xbf, 0xc5, 0x46, 0x0f, 0x85, 0x97, 0x50, 0x11, 0x21, 0x3f, 0x3c,
	0x76, 0xfd, 0xf8, 0xde, 0xdd, 0xf5, 0x28, 0x12, 0xfa, 0xf0, 0x20, 0xa2, 0xc7, 0x43, 0x8f, 0x2a,
	0xcf, 0x46, 0xaa, 0x9f, 0x1b, 0x8f, 0x9f, 0x8d, 0x54, 0x6d, 0xc3, 0xa9, 0x49, 0x76, 0x69, 0xc3,
	0x13, 0xf6, 0xc1, 0x9e, 0x88, 0x0e, 0x64, 0xbc, 0x13, 0x04, 0x8e, 0xda, 0x8d, 0x65, 0xa7, 0x58,
	0xb4, 0x98, 0x67, 0xa3, 0x2d, 0x80, 0xeb, 0x41, 0xe9, 0x83, 0xb6, 0x9f, 0xc2, 0x89, 0xe3, 0xc8,
	0xb8, 0xfd, 0xe8, 0x1b, 0x94, 0x6c, 0x24, 0x5d, 0xac, 0x5e, 0x54, 0xeb, 0xf0, 0x67, 0xed, 0x7b,
	0x36, 0x37, 0xe0, 0x08, 0xe0, 0x8f, 0xd9, 0x88, 0x1b, 0xcb, 0x8e, 0x59, 0xc1, 0xdd, 0x93, 0xe6,
	0xb5, 0xef, 0x51, 0xa8, 0x8e, 0x3c, 0xb5, 0xff, 0x3d, 0x44, 0x32, 0x7b, 0x16, 0x83, 0xbf, 0x64,
	0xd7, 0x9a, 0x22, 0xea, 0x58, 0xaa, 0x1d, 0x1c, 0x59, 0x89, 0xef, 0x05, 0xf6, 0x81, 0x25, 0x7c,
	0xb7, 0x83, 0x71, 0xd0, 0x6a, 0x08, 0x25, 0x2d, 0x2a, 0x66, 0xd0, 0x74, 0x56, 0x80, 0x78, 0xbf,
	0x1d, 0x1c, 0xfd, 0x80, 0xa4, 0xeb, 0x29, 0xe5, 0x86, 0x50, 0xf2, 0x39, 0xd6, 0x39, 0xae, 0xb0,
	0x29, 0xbb, 0x2d, 0xa2, 0x96, 0xb4, 0x44, 0xa7, 0x30, 0xdd, 0x49, 0x02, 0xae, 0x23, 0x8c, 0xaf,
	0x32, 0x03, 0xf7, 0xa9, 0xa6, 0xc4, 0x3d, 0x3a, 0x8c, 0x7b, 0x74, 0x1a, 0xe0, 0x9b, 0x08, 0xc6,
	0x0d, 0xfa, 0x9a, 0x4d, 0x3b, 0x49, 0x44, 0xda, 0xd8, 0x22, 0x72, 0x94, 0x39, 0x82, 0xb3, 0xbf,
	0x7d, 0x72, 0xc4, 0x5b, 0xdb, 0xd2, 0x0c, 0x9b, 0x40, 0x4f, 0x27, 0xc5, 0x94, 0x53, 0x84, 0x2d,
	0x7d, 0xcb, 0x78, 0x3f, 0xd1, 0x00, 0x6f, 0x99, 0x2f, 0x7a, 0xcb, 0x70, 0xc1, 0x2b, 0x6a, 0xff,
	0xad, 0xc2, 0xcc, 0x93, 0xb6, 0x34, 0x7f, 0xc1, 0xe6, 0x20, 0xaa, 0xc0, 0xb4, 0x2c, 0xcf, 0xed,
	0xb8, 0xb1, 0xd5, 0x72, 0x9b, 0xb1, 0x5e, 0xb7, 0x74, 0x5b, 0xc2, 0xf4, 0x9e, 0x03, 0x72, 0xc7,
	0x6d, 0xc6, 0x1b, 0x41, 0xd2, 0x6a, 0xc7, 0x3a, 0x4f, 0x6c, 0x24, 0xdd, 0x12, 0x92, 0x6f, 0xb3,
	0x59, 0x4a, 0x3b, 0x73, 0x61, 0xca, 0x1c, 0x2a, 0xc5, 0x50, 0x3c, 0xd8, 0x33, 0x0e, 0x12, 0x34,
	0x23, 0x4b, 0x40, 0x55, 0xfb, 0x3f, 0x15, 0xb6, 0x78, 0xc2, 0xae, 0xe2, 0xdf, 0xb3, 0x09, 0x7d,
	0x9a, 0xba, 0x81, 0xaf, 0xcc, 0x61, 0x94, 0x7e, 0xe7, 0xdd, 0x5b, 0x31, 0x3d, 0x9e, 0x81, 0x83,
	0xec, 0x5c, 0x94, 0xb1, 0xf4, 0xaf, 0x99, 0xd1, 0x4b, 0x30, 0xc0, 0xc6, 0x0f, 0xca, 0x3b, 0x72,
	0xa5, 0x14, 0x40, 0x52, 0xee, 0x52, 0xfc, 0xc9, 0x57, 0xe1, 0xbf, 0x0c, 0xd3, 0x84, 0x06, 0x64,
	0x8c, 0x7c, 0x81, 0x9d, 0x69, 0x46, 0xae, 0xf4, 0x1d, 0xb4, 0xfb, 0x70, 0x5d, 0x7f, 0xc1, 0x9a,
	0x36, 0x60, 0xcb, 0xa0, 0x01, 0x87, 0xeb, 0xf4, 0xc1, 0xbf, 0x61, 0xa3, 0xd2, 0x97, 0x9d, 0xae,
	0x9e, 0xf8, 0x8d, 0x77, 0xa7, 0xa3, 0x6b, 0x4f, 0x80, 0x96, 0xa6, 0x4c, 0x7c, 0xfc, 0x3b, 0x36,
	0xee, 0x76, 0xc2, 0x20, 0x8a, 0x85, 0x1f, 0x0f, 0xf0, 0xd1, 0x41, 0x42, 0x76, 0x53, 0x7a, 0x12,
	0x94, 0xf3, 0xf3, 0x5b, 0x8c, 0x93, 0xb6, 0x56, 0x31, 0x75, 0x1d, 0x45, 0x85, 0x0d, 0xc2, 0x6c,
	0xe6, 0x09, 0xec, 0x4d, 0x36, 0x8b, 0x93, 0x28, 0x11, 0x9f, 0x41, 0xe2, 0x19, 0x44, 0xe4, 0xb4,
	0x4b, 0x8f, 0x18, 0xcb, 0x75, 0x2f, 0xae, 0xc6, 0xf0, 0x7b, 0x3c, 0x7e, 0xe9, 0x4b, 0x36, 0x5d,
	0x56, 0xf8, 0x34, 0xdc, 0xb5, 0xff, 0x55, 0x61, 0x4b, 0x27, 0xa7, 0xa7, 0xfc, 0x21, 0x3b, 0x83,
	0xce, 0xaa, 0x7a, 0x36, 0x09, 0xdd, 0x96, 0x02, 0xe5, 0xf6, 0x3a, 0x81, 0x26, 0x87, 0x48, 0xd2,
	0x70, 0x5b, 0x56, 0x24, 0x9b, 0x91, 0x54, 0x6d, 0x9a, 0x3a, 0x0d, 0x3e, 0xdd, 0x70, 0x5b, 0x75,
	0x02, 0xa3, 0x95, 0x6e, 0x31, 0xae, 0x3a, 0xc2, 0xf3, 0xca, 0xb4, 0x14, 0x75, 0x0c, 0xc4, 0x14,
	0xa9, 0xcf, 0xb3, 0xf1, 0xb6, 0xf0, 0x9d, 0x46, 0x10, 0x1c, 0x50, 0xc8, 0x81, 0xec, 0x2b, 0x05,
	0xd4, 0xfe, 0xb9, 0xc2, 0x96, 0xdf, 0x71, 0x3b, 0x83, 0x3b, 0xc7, 0x91, 0x88, 0x65, 0xa4, 0xb3,
	0x0a, 0xf2, 0x76, 0x86, 0x20, 0xca, 0x2a, 0x1e, 0xb0, 0x19, 0xbd, 0x53, 0x2c, 0x25, 0x95, 0x82,
	0x74, 0x01, 0xb4, 0x9e, 0xbe, 0x3b, 0xa5, 0x27, 0xbe, 0x8f, 0xcd, 0x8d, 0xfa, 0xb4, 0xa6, 0xda,
	0x27, 0x22, 0x7e, 0x19, 0x0e, 0x5d, 0xe2, 0x2b, 0xa8, 0x9f, 0xee, 0x3a, 0xd4, 0xfc, 0x2a, 0x9b,
	0xa6, 0xb1, 0x31, 0xdd, 0x72, 0x75, 0xc4, 0x1c, 0xae, 0x4f, 0x22, 0x14, 0xb4, 0xde, 0x75, 0x14,
	0xff, 0x88, 0x19, 0x6d, 0xe9, 0x85, 0x56, 0x47, 0xe6, 0x74, 0xe4, 0x5f, 0x53, 0x00, 0xdf, 0x93,
	0x9a, 0xb0, 0xf6, 0x1f, 0x2a, 0xec, 0xe2, 0xbb, 0x2f, 0xb6, 0x98, 0xaa, 0xba, 0x8e, 0xb4, 0x5a,
	0xee, 0xa1, 0x8c, 0x70, 0xb2, 0xd5, 0xfa, 0x38, 0x40, 0x76, 0x00, 0xc0, 0x17, 0xd9, 0x98, 0x23,
	0x62, 0x61, 0xb9, 0x8e, 0x3e, 0x0b, 0xce, 0xc0, 0xe7, 0xae, 0x03, 0xc9, 0x97, 0x02, 0x1f, 0xd7,
	0x0a, 0xe8, 0xc9, 0x30, 0x80, 0xd1, 0xe8, 0x60, 0x47, 0x79, 0x1c, 0xba, 0x91, 0xf6, 0xe9, 0x11,
	0x22, 0x20, 0x10, 0x4c, 0xb6, 0xf6, 0x3f, 0x2a, 0x8c, 0xf7, 0xa7, 0xd1, 0xfc, 0x2e, 0xab, 0xda,
	0x22, 0x96, 0xad, 0x20, 0xea, 0x6a, 0xbb, 0x2e, 0x94, 0x73, 0xee, 0x4d, 0x8d, 0xad, 0x67, 0x74,
	0x7c, 0x9d, 0x55, 0x51, 0xcd, 0x8e, 0x08, 0x75, 0x10, 0xb8, 0x7e, 0x62, 0x9e, 0xbe, 0xb6, 0x25,
	0x62, 0xb1, 0x27, 0x42, 0xda, 0xb8, 0x38, 0xbd, 0x3d, 0x11, 0x2e, 0x3d, 0x66, 0x93, 0x45, 0xc4,
	0xfb, 0x0e, 0x94, 0x91, 0xe2, 0x06, 0xf9, 0x03, 0x9d, 0xcf, 0x3d, 0x79, 0xf0, 0x6f, 0x9a, 0x09,
	0x67, 0x23, 0x98, 0x65, 0x0f, 0xa3, 0xdb, 0xe2, 0xdf, 0xb5, 0xcf, 0x69, 0xfb, 0x0d, 0xae, 0xc6,
	0xf0, 0x65, 0x36, 0xee, 0xfa, 0xb1, 0x45, 0xaa, 0xc1, 0x0e, 0x1c, 0xad, 0x57, 0x5d, 0x3f, 0xfe,
	0x11, 0xbe, 0x6b, 0xff, 0x7d, 0x98, 0xcd, 0x0f, 0xba, 0x32, 0x65, 0x55, 0xd2, 0xca, 0x80, 0x2a,
	0xe9, 0xd0, 0x80, 0x2a, 0xe9, 0xf0, 0xa0, 0x2a, 0xe9, 0x48, 0xb1, 0x4a, 0x5a, 0xa8, 0xc8, 0x8e,
	0x96, 0x2b, 0xb2, 0x0f, 0xd8, 0x22, 0xdd, 0x1d, 0xfb, 0x4b, 0xdc, 0x67, 0x90, 0xf2, 0x2c, 0xa2,
	0x37, 0x7b, 0xeb, 0xdc, 0x69, 0xdd, 0x75, 0xec, 0x84, 0xba, 0x6b, 0xb5, 0x5c, 0x77, 0x2d, 0x5e,
	0x93, 0xc6, 0x7b, 0xae, 0x49, 0xc5, 0x8b, 0x08, 0xeb, 0xb9, 0x88, 0x7c, 0x99, 0x66, 0x7d, 0xf7,
	0xfa, 0x3c, 0xa7, 0xd7, 0x6c, 0x6b, 0x98, 0xa5, 0xe9, 0xb3, 0x83, 0xb2, 0xc3, 0xb4, 0x85, 0x43,
	0x57, 0x50, 0xed, 0xec, 0x76, 0xde, 0xc2, 0x21, 0x11, 0x59, 0x00, 0xcf, 0x05, 0x9c, 0xca, 0xc3,
	0xfe, 0x38, 0xc2, 0x26, 0xea, 0x01, 0x64, 0x6a, 0x83, 0xdb, 0x6b, 0x59, 0xdf, 0x6a, 0xa8, 0xd8,
	0xb7, 0x9a, 0x64, 0x95, 0x63, 0x5c, 0xb9, 0xd1, 0x7a, 0xe5, 0x18, 0xbe, 0xa8, 0x57, 0x36, 0x5a,
	0xaf, 0x74, 0xf9, 0x45, 0xc6, 0xc2, 0x28, 0x50, 0xa1, 0x8c, 0x20, 0x7d, 0xa7, 0x15, 0x2b, 0x40,
	0xf8, 0x6d, 0xc6, 0xf3, 0x2f, 0xcb, 0x16, 0xa1, 0x0d, 0x74, 0xb4, 0x5e, 0xb3, 0x39, 0x66, 0x93,
	0x10, 0xe0, 0x85, 0x98, 0x70, 0xc6, 0xdd, 0x90, 0x16, 0x6c, 0xb4, 0x5e, 0x05, 0xc0, 0xeb, 0x6e,
	0x28, 0xb3, 0xe6, 0xdf, 0x64, 0xa1, 0xf9, 0x57, 0x6c, 0xbe, 0x4c, 0x95, 0x9b, 0x2f, 0xcb, 0xfa,
	0xba, 0x89, 0xb2, 0xa6, 0x49, 0x16, 0x00, 0x50, 0xd6, 0x22, 0x1b, 0x4b, 0x63, 0x0e, 0xf5, 0xd5,
	0xce, 0xb4, 0x29, 0xde, 0xd4, 0xd8, 0x14, 0x22, 0x20, 0x2a, 0xe1, 0x22, 0x18, 0xc8, 0x39, 0x01,
	0xc0, 0x27, 0x3e, 0x75, 0x1f, 0x2e, 0xb2, 0x09, 0x3f, 0xb4, 0xad, 0x34, 0xa4, 0x51, 0x33, 0x6b,
	0xdc, 0x0f, 0xed, 0x2d, 0x8a, 0x6a, 0xe7, 0x58, 0x15, 0xf0, 0x38, 0xf0, 0x02, 0xb2, 0x8f, 0xf9,
	0xa1, 0x8d, 0xe3, 0x9a, 0x6c, 0x4c, 0x05, 0x9e, 0xe3, 0xca, 0x08, 0x7b, 0x45, 0x23, 0xf5, 0xf4,
	0x13, 0xe2, 0x7a, 0xd3, 0x6d, 0xb5, 0xe3, 0x34, 0x69, 0x5e, 0xa1, 0x7a, 0x3f, 0xc2, 0x74, 0xce,
	0xfc, 0x11, 0x9b, 0xc9, 0xab, 0xe5, 0x24, 0xe4, 0x0a, 0x6e, 0xf0, 0xe9, 0xac, 0x12, 0x4e, 0xb2,
	0x2e, 0xb1, 0x89, 0x38, 0x0a, 0x82, 0xd0, 0xa2, 0xeb, 0xc6, 0x0d, 0xd4, 0x81, 0x21, 0x08, 0x6f,
	0x64, 0xb5, 0x3f, 0x57, 0x58, 0x15, 0x8b, 0x3d, 0x42, 0x49, 0xa0, 0x46, 0xa3, 0xeb, 0xde, 0x17,
	0xb9, 0x03, 0x03, 0x10, 0x35, 0xbd, 0x20, 0xba, 0x17, 0xae, 0x01, 0xe4, 0x1b, 0xb8, 0x4e, 0x94,
	0xef, 0x9f, 0x65, 0x67, 0x10, 0x9d, 0x3a, 0xc9, 0x28, 0x7c, 0xfd, 0x94, 0x81, 0x53, 0x6f, 0x41,
	0xf0, 0xef, 0xdf, 0xe7, 0x31, 0xb5, 0x7f, 0x1c, 0x25, 0xd5, 0x9e, 0x06, 0x1d, 0xc9, 0xaf, 0xb0,
	0x11, 0xe0, 0x32, 0xe9, 0x5a, 0x38, 0x53, 0x2c, 0x53, 0x81, 0x7a, 0x88, 0x04, 0xb3, 0x78, 0x81,
	0x8a, 0xad, 0x82, 0x58, 0xd2, 0x71, 0x1a, 0xc0, 0xaf, 0x72, 0x67, 0xdc, 0x62, 0x97, 0xd2, 0x2a,
	0x87, 0x8c, 0xad, 0x1e, 0x9e, 0xfc, 0x34, 0x1d, 0xad, 0x2f, 0xeb, 0x8a, 0x87, 0x8c, 0x9f, 0x97,
	0x24, 0xe0, 0xea, 0x7f, 0xc2, 0xe6, 0x55, 0x1c, 0x84, 0xbd, 0xfc, 0x38, 0xcb, 0x6a, 0x9d, 0x03,
	0xae, 0xcc, 0x05, 0xe7, 0x71, 0x47, 0x1c, 0x17, 0xaf, 0x52, 0x14, 0x8b, 0x26, 0x3b, 0xe2, 0x38,
	0xbf, 0x36, 0x7d, 0xcc, 0xf8, 0x51, 0xdb, 0x8d, 0xa5, 0xd5, 0xf4, 0x44, 0x2b, 0x3b, 0x11, 0xa9,
	0xa3, 0x38, 0x83, 0x98, 0x6d, 0x4f, 0xb4, 0xf4, 0xb1, 0x78, 0x9b, 0xcd, 0x15, 0x88, 0xb3, 0x2d,
	0x40, 0xdd, 0x45, 0x23, 0xa3, 0xd6, 0x5d, 0x36, 0xfe, 0x39, 0x3b, 0x57, 0x20, 0x77, 0x5c, 0x25,
	0xc2, 0x50, 0x0a, 0x4a, 0x4e, 0xb0, 0xb3, 0x38, 0x5c, 0x5f, 0xc8, 0x98, 0xb6, 0x52, 0x34, 0x4e,
	0x77, 0x8d, 0xcd, 0x75, 0x5c, 0xe1, 0xf7, 0x32, 0xd5, 0xa8, 0x9e, 0x02, 0xa8, 0x32, 0xfd, 0x8f,
	0xec, 0x46, 0x27, 0x38, 0x94, 0x96, 0x76, 0x29, 0x15, 0x07, 0x91, 0x2c, 0x9a, 0x19, 0x1b, 0x1a,
	0xe9, 0xe6, 0xba, 0x82, 0x52, 0xae, 0x00, 0x03, 0x2e, 0x28, 0x91, 0xe7, 0xa6, 0xdb, 0x48, 0x9a,
	0xe9, 0xa6, 0xfb, 0x9a, 0x9d, 0xf7, 0xe5, 0x11, 0xd9, 0x65, 0x90, 0x42, 0x57, 0x51, 0x94, 0xe9,
	0xcb, 0x23, 0xba, 0x10, 0xf6, 0xea, 0xf5, 0x80, 0x99, 0xb8, 0xf8, 0x89, 0x92, 0xc4, 0x8f, 0x81,
	0x97, 0x78, 0xaf, 0x21, 0xef, 0x3c, 0xe0, 0x7f, 0x50, 0x12, 0x78, 0x31, 0xc0, 0x22, 0xdf, 0x75,
	0x36, 0x83, 0xe4, 0x85, 0x72, 0xe7, 0x75, 0xea, 0xe1, 0x02, 0x38, 0x2f, 0x72, 0xae, 0x32, 0x03,
	0xe9, 0x22, 0xd9, 0x80, 0x44, 0xbc, 0xd0, 0xc1, 0x9c, 0x06, 0x78, 0x1d, 0xc1, 0x98, 0xb1, 0xfc,
	0xd7, 0x49, 0x76, 0x76, 0x60, 0x4b, 0x19, 0xdc, 0xbd, 0x1d, 0x74, 0x06, 0xb9, 0x3b, 0xec, 0x86,
	0x3a, 0x22, 0xf9, 0x43, 0x66, 0xc2, 0xbf, 0x96, 0x23, 0x9b, 0xd2, 0x87, 0x58, 0x89, 0x3b, 0xdd,
	0xf5, 0x1d, 0x79, 0x6c, 0x4e, 0xd0, 0x41, 0x08, 0xf8, 0x2d, 0x42, 0xbf, 0x06, 0xec, 0x2e, 0x20,
	0xf9, 0x6b, 0x76, 0x11, 0x19, 0x89, 0x01, 0xd8, 0x45, 0x2c, 0x1d, 0xab, 0x23, 0x5c, 0x8f, 0x9e,
	0x64, 0x60, 0x04, 0x9d, 0xb8, 0x6b, 0xe8, 0x71, 0xf7, 0x84, 0xeb, 0x51, 0xaa, 0xbd, 0x04, 0x7c,
	0x28, 0x69, 0x4b, 0x73, 0x65, 0x38, 0xb0, 0xab, 0xbe, 0x74, 0xa0, 0x70, 0x08, 0x7c, 0xb8, 0xf4,
	0x90, 0x4e, 0x9e, 0xc5, 0xe8, 0x34, 0x4f, 0x78, 0x98, 0xc2, 0x8b, 0xd0, 0x86, 0x75, 0x86, 0xf4,
	0xf3, 0x09, 0x9b, 0x2a, 0x31, 0x98, 0x8b, 0x78, 0x6e, 0x5e, 0xee, 0x99, 0xb4, 0xe6, 0x28, 0x55,
	0x8f, 0xda, 0x39, 0x9c, 0x7f, 0xc7, 0x66, 0x3a, 0x89, 0x17, 0xbb, 0xb4, 0xb1, 0x40, 0x9a, 0x69,
	0xa2, 0xa0, 0x2b, 0xc5, 0x24, 0x09, 0x28, 0x70, 0x97, 0xbd, 0x08, 0x4b, 0x85, 0xa8, 0xa9, 0x4e,
	0x11, 0xc3, 0x1f, 0xb3, 0xa5, 0x1e, 0x61, 0x56, 0x28, 0x94, 0xd2, 0x9b, 0x96, 0xde, 0x10, 0x2c,
	0x94, 0x58, 0x5e, 0x09, 0xa5, 0x68, 0xfb, 0x7e, 0xcb, 0xa6, 0x9b, 0xe2, 0x30, 0x88, 0x60, 0x97,
	0x85, 0x81, 0x92, 0x0a, 0x9f, 0x16, 0xe4, 0x05, 0xc3, 0x6d, 0x8d, 0x7c, 0x05, 0x38, 0x3d, 0x7a,
	0xb3, 0x08, 0xe3, 0x77, 0xf5, 0xcb, 0x0f, 0xd7, 0x3f, 0x94, 0x2a, 0x76, 0x5b, 0xd9, 0x45, 0x6e,
	0x39, 0x6f, 0x84, 0xef, 0xe6, 0x38, 0xf4, 0xba, 0x7f, 0xc3, 0xae, 0xf4, 0x6a, 0x4c, 0x8e, 0xaa,
	0xeb, 0x9f, 0x3a, 0xac, 0x9d, 0x47, 0x55, 0x6e, 0x6a, 0x55, 0x74, 0x01, 0x54, 0x34, 0x3c, 0x6a,
	0xee, 0xbf, 0x71, 0xe3, 0xf6, 0x93, 0xe3, 0x38, 0x12, 0xf8, 0x95, 0x37, 0x12, 0x2f, 0x96, 0xa6,
	0x8a, 0xae, 0xae, 0x59, 0x29, 0x12, 0xee, 0xb2, 0xa9, 0x5c, 0x57, 0x38, 0x3a, 0x2e, 0xf4, 0x59,
	0x7e, 0xb7, 0x88, 0x2f, 0x59, 0xbe, 0xc4, 0x39, 0xc8, 0xf2, 0x85, 0x0d, 0x77, 0x91, 0x22, 0x54,
	0xbf, 0x3a, 0xa8, 0xc6, 0x43, 0x66, 0xda, 0x41, 0xd8, 0x4d, 0x37, 0x44, 0x64, 0xa5, 0x87, 0x24,
	0x86, 0x4f, 0xf0, 0xc0, 0xb3, 0x80, 0xd7, 0x1b, 0x22, 0xd2, 0x1d, 0xe5, 0x5d, 0x87, 0xaf, 0xb3,
	0x0b, 0x83, 0x19, 0xd3, 0xd3, 0x75, 0x05, 0xb9, 0x97, 0x06, 0x70, 0xa7, 0x27, 0xed, 0x73, 0x76,
	0x65, 0xb0, 0x08, 0x6a, 0x1e, 0xa4, 0x82, 0x2e, 0xa3, 0xa0, 0x4b, 0x03, 0x04, 0xbd, 0x06, 0xba,
	0x54, 0xda, 0x57, 0x6c, 0xf9, 0x84, 0x99, 0xe0, 0xee, 0xae, 0xa1, 0x14, 0x73, 0xd0, 0x64, 0x70,
	0x83, 0xdf, 0x63, 0x0b, 0x65, 0xf6, 0x9e, 0x38, 0x3b, 0x57, 0xe4, 0x4c, 0xe3, 0xea, 0x3d, 0xb6,
	0xe0, 0xfa, 0x87, 0xb0, 0x63, 0x31, 0xb4, 0x16, 0xac, 0x4e, 0x11, 0x75, 0x8e, 0xb0, 0xd4, 0x08,
	0x4e, 0x4d, 0xfe, 0xed, 0x49, 0x96, 0x3b, 0xd6, 0xaa, 0x5e, 0xc3, 0x1b, 0xc4, 0xb9, 0x01, 0xaa,
	0xfe, 0x44, 0xba, 0x7e, 0xce, 0xce, 0x95, 0x25, 0x14, 0xc3, 0xd8, 0x75, 0xda, 0x69, 0x45, 0xee,
	0x42, 0x1c, 0xbb, 0xcf, 0x16, 0x7f, 0x49, 0x7c, 0x2b, 0x4e, 0x84, 0xdf, 0xeb, 0x28, 0xfa, 0xc9,
	0xc8, 0x2f, 0x89, 0xff, 0x3a, 0x11, 0x7e, 0xc9, 0x4b, 0xf6, 0xd9, 0xd2, 0x09, 0x8b, 0x1d, 0x8b,
	0xd8, 0x5c, 0x45, 0xcf, 0x4d, 0x2f, 0x56, 0xfb, 0x21, 0xec, 0xca, 0xfd, 0x58, 0xe8, 0x32, 0xda,
	0xe2, 0x20, 0x0f, 0x88, 0x45, 0xcc, 0xff, 0x15, 0xbb, 0x7d, 0x82, 0xd0, 0x50, 0x7a, 0x9e, 0x55,
	0x4c, 0xe8, 0x2c, 0x3b, 0x90, 0x4d, 0xf3, 0x06, 0x2e, 0xe1, 0x47, 0x83, 0xe4, 0x01, 0xc7, 0x76,
	0x9e, 0xed, 0x6d, 0x06, 0xb2, 0x59, 0x4b, 0xd8, 0xf9, 0x77, 0xed, 0x22, 0xc8, 0x71, 0x63, 0x11,
	0xb5, 0x64, 0x6c, 0x65, 0x79, 0x7c, 0x95, 0x00, 0xfd, 0x57, 0xe7, 0xa1, 0xde, 0xab, 0x33, 0x24,
	0xc1, 0x18, 0xfc, 0xdd, 0xf4, 0x62, 0x76, 0x06, 0x3e, 0x77, 0x9d, 0xda, 0x7f, 0xae, 0xd0, 0xb8,
	0x27, 0xc5, 0x4d, 0x7e, 0x8b, 0x8d, 0x60, 0x76, 0x5b, 0xc1, 0xfb, 0x68, 0xda, 0x2c, 0x2d, 0x91,
	0x43, 0xba, 0x5b, 0x47, 0x2a, 0xc8, 0x1f, 0x0b, 0x61, 0x54, 0xe7, 0x8f, 0x61, 0x16, 0x39, 0x39,
	0x1b, 0x69, 0x8b, 0x58, 0xa6, 0x97, 0x43, 0xf8, 0x9b, 0x5f, 0x61, 0x53, 0x91, 0x3c, 0x94, 0x7e,
	0x2b, 0xcd, 0x98, 0xe8, 0x92, 0x38, 0xa9, 0x81, 0xc8, 0x58, 0xfb, 0x95, 0x6e, 0xb4, 0x83, 0x8f,
	0x09, 0xb8, 0xac, 0x29, 0xf9, 0x6b, 0x22, 0x7d, 0x5b, 0xea, 0xdb, 0x51, 0xf6, 0x7d, 0x72, 0x41,
	0xa2, 0x9c, 0x9d, 0x0e, 0xf7, 0x65, 0xa7, 0xff, 0x30, 0x44, 0x37, 0xe1, 0xde, 0x07, 0x1f, 0x98,
	0x9b, 0xb7, 0x85, 0xe7, 0xa1, 0xca, 0xc5, 0x9a, 0xcf, 0x74, 0x06, 0xa6, 0xba, 0xcf, 0x15, 0x36,
	0x65, 0x27, 0x51, 0x24, 0xfd, 0xd8, 0x6a, 0x7a, 0x41, 0x10, 0x65, 0xd5, 0x71, 0x02, 0x6e, 0x03,
	0x0c, 0xae, 0x83, 0xe9, 0xe3, 0x1f, 0xc8, 0x1c, 0x89, 0x90, 0xb4, 0x99, 0xd1, 0x88, 0x3d, 0x71,
	0x4c, 0xb4, 0x57, 0xd9, 0xb4, 0x48, 0xe2, 0xa0, 0x40, 0xa8, 0x6d, 0x05, 0xd0, 0x8c, 0xea, 0x1e,
	0x5b, 0xe8, 0x93, 0x98, 0x96, 0x09, 0x71, 0xcf, 0xf4, 0x88, 0x4d, 0x53, 0xdd, 0xbc, 0x71, 0xdb,
	0x08, 0x34, 0x9b, 0x32, 0xc7, 0xd0, 0x8b, 0x79, 0x86, 0xdb, 0x08, 0x88, 0x49, 0xc1, 0xb6, 0x2e,
	0xa4, 0xd8, 0x65, 0x8b, 0xe0, 0x4d, 0x7b, 0xb8, 0xbe, 0x90, 0x25, 0xd7, 0x9b, 0x45, 0xcb, 0x3c,
	0x1b, 0xa9, 0x8e, 0x1a, 0x67, 0x6a, 0xff, 0x7e, 0x98, 0x16, 0x75, 0xf0, 0xbb, 0x1a, 0xea, 0x89,
	0x7a, 0x61, 0xc9, 0xc2, 0xe3, 0x00, 0x49, 0x8b, 0x6a, 0x26, 0xcc, 0x0e, 0x5f, 0x02, 0x15, 0x1f,
	0xee, 0xe4, 0x0b, 0x3d, 0xdf, 0x11, 0xc7, 0x2f, 0x43, 0xe9, 0x17, 0xe4, 0xef, 0x3a, 0x70, 0xfc,
	0xd0, 0x2b, 0x32, 0xf4, 0xd3, 0x5e, 0x4e, 0x2a, 0xfe, 0x2d, 0x20, 0x05, 0x1c, 0xf8, 0x65, 0xde,
	0x17, 0xec, 0x2a, 0xbd, 0xc2, 0x12, 0x8e, 0x63, 0xa5, 0xa5, 0xb9, 0xfe, 0x4a, 0x85, 0xbe, 0xea,
	0xac, 0x20, 0xed, 0xba, 0xe3, 0xe8, 0xca, 0xf6, 0x4e, 0x6f, 0xcd, 0x82, 0x3f, 0x60, 0x8b, 0xe9,
	0x4a, 0xf5, 0x7a, 0x94, 0xae, 0x73, 0x68, 0xf4, 0x66, 0xd9, 0xb1, 0xee, 0xb2, 0x31, 0x38, 0xf4,
	0x23, 0x87, 0xd6, 0x27, 0x7f, 0xc3, 0x40, 0xea, 0xd6, 0x11, 0xa7, 0x9b, 0x86, 0x9a, 0x70, 0x90,
	0xd7, 0x4e, 0x0c, 0xf2, 0xda, 0xda, 0xff, 0x1f, 0x63, 0x0b, 0x83, 0x5f, 0x2b, 0x81, 0x43, 0xa3,
	0xd5, 0xf4, 0xa3, 0x25, 0xaa, 0xdf, 0x8e, 0xd4, 0x27, 0x01, 0xa8, 0xc9, 0x15, 0x7f, 0xc4, 0xf2,
	0x4e, 0x3d, 0x4c, 0x2b, 0x8c, 0xf1, 0x29, 0x3d, 0x3e, 0xa1, 0x19, 0x22, 0xf3, 0x66, 0xf8, 0x4d,
	0x42, 0xeb, 0x17, 0x32, 0x9f, 0xb1, 0x45, 0x74, 0xef, 0xac, 0xa1, 0x9b, 0x47, 0x7b, 0xaa, 0x16,
	0xce, 0x03, 0x3a, 0xed, 0xe9, 0x96, 0x93, 0x02, 0x5a, 0x0b, 0x64, 0xc7, 0xc9, 0xe9, 0xe3, 0x85,
	0xf6, 0xc7, 0x59, 0x8d, 0x5f, 0x4f, 0xe2, 0x00, 0x27, 0x49, 0xa7, 0x0b, 0x26, 0x05, 0xa9, 0xa6,
	0xc5, 0x89, 0xa5, 0xea, 0x8e, 0xa6, 0x49, 0x81, 0x26, 0x7a, 0x95, 0xcf, 0x53, 0xab, 0xfc, 0x2d,
	0x5b, 0x3e, 0x74, 0x43, 0x9d, 0x3a, 0x62, 0xbf, 0xa6, 0x81, 0xcd, 0x1d, 0x6d, 0x61, 0xbc, 0xfc,
	0x61, 0x82, 0xb5, 0x78, 0xe8, 0x86, 0x98, 0x41, 0x02, 0x11, 0x35, 0x80, 0x68, 0x2d, 0x2d, 0xc6,
	0x41, 0x02, 0x78, 0x54, 0x2e, 0xc5, 0xac, 0xe2, 0xb2, 0xde, 0x7d, 0xe7, 0xe3, 0xb1, 0xb5, 0x1f,
	0xdd, 0x70, 0xdd, 0x71, 0x32, 0xa9, 0x54, 0x65, 0x9a, 0x39, 0x2c, 0x43, 0x79, 0xc4, 0xce, 0x95,
	0x06, 0x28, 0x29, 0x38, 0x8e, 0xe3, 0x3c, 0xfa, 0xd0, 0x71, 0x0a, 0x8a, 0xd3, 0x68, 0x67, 0x0f,
	0x07, 0xe1, 0xf8, 0x43, 0x36, 0x95, 0x9a, 0x12, 0x16, 0x51, 0x99, 0x93, 0x38, 0x0e, 0xd7, 0xe3,
	0xa4, 0x63, 0xc4, 0x22, 0xaa, 0x4f, 0x3a, 0xf9, 0x87, 0xe2, 0x5f, 0xb3, 0xe9, 0x94, 0x11, 0x0d,
	0xa1, 0xcc, 0x29, 0xe4, 0x5c, 0x2c, 0x73, 0x66, 0xb3, 0xab, 0xa7, 0xe3, 0xe0, 0x17, 0xf0, 0x4f,
	0xa5, 0x2e, 0x47, 0x03, 0x4f, 0x97, 0x1e, 0x61, 0x68, 0x76, 0xed, 0x76, 0x34, 0xbe, 0x9d, 0x7f,
	0x28, 0xfe, 0x3d, 0x9b, 0x2b, 0xf2, 0xa7, 0x8e, 0x60, 0x94, 0x2e, 0x2c, 0x9b, 0x3d, 0xee, 0x0b,
	0xac, 0xe4, 0x0f, 0xf5, 0x59, 0xbb, 0x17, 0xb4, 0xb4, 0xc1, 0xe6, 0x07, 0x2d, 0xd4, 0x69, 0xaa,
	0x79, 0x4b, 0x4f, 0xd9, 0xd2, 0xc9, 0x8b, 0x70, 0xaa, 0xba, 0xe0, 0xff, 0x1b, 0xa3, 0xd2, 0x73,
	0xcf, 0x23, 0x4d, 0x48, 0x2f, 0x3a, 0x98, 0xcc, 0x0a, 0x75, 0x90, 0x9e, 0xa1, 0x00, 0x00, 0x3a,
	0x7e, 0x8b, 0xf1, 0x0c, 0x09, 0xf7, 0xc7, 0x56, 0x24, 0x95, 0xd2, 0xb2, 0x8d, 0x94, 0xea, 0x95,
	0x86, 0x63, 0x91, 0x29, 0x12, 0xbe, 0xdd, 0x26, 0x61, 0x13, 0xb8, 0x89, 0x18, 0x81, 0x50, 0xdc,
	0x27, 0x6c, 0xbe, 0x40, 0x90, 0x0b, 0x9c, 0xa4, 0xb3, 0x26, 0xa7, 0xcc, 0x44, 0x7e, 0xc3, 0x26,
	0x1a, 0xc2, 0xea, 0x4a, 0x7a, 0x47, 0x64, 0xce, 0xf7, 0x3d, 0x79, 0xd8, 0x10, 0xbf, 0x97, 0xf8,
	0x16, 0xa0, 0xf4, 0xe4, 0xa1, 0x91, 0x42, 0xf9, 0x23, 0x76, 0x8e, 0x7a, 0xd0, 0x41, 0x27, 0xf4,
	0x64, 0x2c, 0xad, 0xa2, 0x38, 0xaa, 0xea, 0x9d, 0xc5, 0x66, 0xb4, 0xc6, 0x67, 0xf2, 0xf8, 0x1e,
	0x9b, 0x15, 0x76, 0xdb, 0x95, 0x87, 0x92, 0xb4, 0xf5, 0x5c, 0x15, 0xeb, 0x47, 0xe3, 0xa9, 0x3f,
	0xac, 0x13, 0x1e, 0x34, 0x7e, 0xee, 0xaa, 0xd2, 0xab, 0x8b, 0x19, 0x51, 0xc6, 0xf1, 0x3f, 0xb0,
	0x45, 0x7c, 0xd1, 0x00, 0x97, 0xfa, 0x56, 0x24, 0x8b, 0x42, 0x2f, 0x95, 0x5e, 0xb0, 0x62, 0x07,
	0x56, 0x6e, 0x21, 0xd1, 0x20, 0xc9, 0xf3, 0x62, 0x00, 0x01, 0xdf, 0x62, 0xd3, 0x8d, 0xa3, 0xb7,
	0x5e, 0x41, 0xea, 0x6a, 0xe9, 0x99, 0xc5, 0xc6, 0xd1, 0x5b, 0x6f, 0x90, 0xb4, 0xc9, 0x46, 0x01,
	0xc1, 0x77, 0xd8, 0x4c, 0xec, 0xc6, 0x5e, 0x51, 0xb9, 0xdb, 0x25, 0x93, 0xbf, 0x06, 0xec, 0x20,
	0x39, 0x53, 0x71, 0x11, 0xc3, 0x13, 0xb6, 0x9c, 0xbe, 0xdf, 0xc8, 0x65, 0x59, 0x9d, 0xc0, 0x91,
	0xd8, 0x79, 0xb9, 0x83, 0xdb, 0xea, 0xe1, 0xc9, 0x6f, 0x87, 0xd7, 0xd2, 0x3e, 0x74, 0x2a, 0x71,
	0x2f, 0x70, 0x64, 0xd6, 0x8a, 0x59, 0x14, 0x83, 0xb1, 0xfc, 0x32, 0x9b, 0xc4, 0xd1, 0x3a, 0x81,
	0xaf, 0x62, 0x19, 0x99, 0x77, 0xd1, 0xb1, 0x26, 0x00, 0xb6, 0x47, 0x20, 0xbe, 0xc6, 0xe6, 0x8a,
	0x24, 0xba, 0x9b, 0x8a, 0x15, 0xfd, 0x6a, 0x7d, 0xb6, 0x40, 0x49, 0xed, 0x54, 0x7e, 0x9b, 0xcd,
	0x65, 0xbd, 0x38, 0xe0, 0x83, 0x14, 0xc9, 0x75, 0xb0, 0x6e, 0x8f, 0x2f, 0xee, 0xa9, 0x25, 0x27,
	0xd4, 0xc1, 0x46, 0x70, 0xbc, 0xeb, 0x2c, 0x45, 0xec, 0xfc, 0xbb, 0x54, 0x1f, 0xb0, 0x65, 0xbf,
	0x2c, 0x77, 0xc6, 0x4b, 0x6e, 0xd0, 0x23, 0xe5, 0x84, 0xfe, 0xf8, 0x5f, 0x2a, 0x6c, 0xe9, 0x64,
	0x57, 0xe4, 0x9f, 0xb2, 0x11, 0x5c, 0x49, 0xea, 0xb9, 0x5e, 0xe8, 0xf7, 0xdd, 0xd2, 0x3b, 0x12,
	0x20, 0x85, 0x7d, 0x9f, 0x35, 0x2e, 0x21, 0x1a, 0xa6, 0x4f, 0x5a, 0x86, 0x0b, 0x73, 0x86, 0x48,
	0x87, 0x95, 0x66, 0xac, 0x96, 0x4a, 0x22, 0x6e, 0x07, 0x47, 0x96, 0xf6, 0xfc, 0xb4, 0x33, 0xc5,
	0x09, 0xb7, 0xdf, 0x0e, 0x8e, 0xf4, 0x98, 0xaa, 0xf6, 0xc7, 0x0a, 0x5b, 0x18, 0xac, 0x40, 0xa1,
	0x5f, 0x31, 0x82, 0xfd, 0x8a, 0x25, 0x56, 0xed, 0x09, 0x3c, 0xd9, 0x37, 0x2c, 0xb7, 0xab, 0xac,
	0xec, 0x94, 0xd6, 0x8f, 0x6b, 0x26, 0x5c, 0x95, 0x05, 0x6a, 0x48, 0x26, 0x23, 0x29, 0xec, 0x76,
	0xb1, 0xb5, 0x38, 0x8e, 0x10, 0xac, 0xd3, 0xfd, 0xa9, 0xc2, 0x2e, 0xbd, 0x67, 0xc3, 0xf1, 0x07,
	0x25, 0xfb, 0xd5, 0x4e, 0xd8, 0xa6, 0xfd, 0x46, 0xbc, 0xcb, 0xce, 0x16, 0xb2, 0x0c, 0x38, 0x13,
	0x74, 0x6e, 0x32, 0x8c, 0x17, 0xe7, 0xb9, 0x3c, 0xbb, 0x00, 0x1c, 0x66, 0x26, 0xb5, 0x5d, 0xb6,
	0xfc, 0x0e, 0xc1, 0xa7, 0x31, 0x4e, 0xed, 0xdf, 0xe9, 0xb7, 0x2b, 0x83, 0x22, 0x24, 0x35, 0xe6,
	0x20, 0x04, 0x56, 0xd2, 0xc6, 0x1c, 0x84, 0xbc, 0x45, 0x36, 0x86, 0x3e, 0xee, 0x3a, 0x3a, 0x78,
	0x9f, 0x81, 0xcf, 0x5d, 0x07, 0xf2, 0xbf, 0x41, 0x11, 0x1b, 0x37, 0xdb, 0xab, 0x93, 0x56, 0x63,
	0x0a, 0xb7, 0x54, 0x71, 0x35, 0x6a, 0x31, 0x5b, 0x3c, 0x21, 0x10, 0xf1, 0xb5, 0x92, 0x95, 0x97,
	0x7a, 0xc2, 0x56, 0xbf, 0x75, 0x6f, 0x30, 0xa3, 0xc7, 0xba, 0x69, 0x96, 0x39, 0x53, 0x36, 0xac,
	0xaa, 0x39, 0x6c, 0x6e, 0x80, 0x9c, 0xbf, 0xb3, 0xa7, 0xd5, 0xba, 0xcc, 0x3c, 0x29, 0x3a, 0xd2,
	0x7e, 0xa2, 0x03, 0xc6, 0xb1, 0x28, 0xc2, 0x66, 0x43, 0x1b, 0x19, 0x06, 0xd9, 0x77, 0x1d, 0x7e,
	0x47, 0x9b, 0x82, 0xde, 0xfe, 0x2c, 0xf7, 0x86, 0xde, 0x3e, 0x5b, 0xd4, 0x36, 0xd8, 0xfc, 0x20,
	0xec, 0x69, 0xdd, 0xe5, 0xd2, 0x7b, 0x62, 0x0e, 0xbf, 0xcf, 0x46, 0x61, 0xc5, 0xd3, 0xe7, 0x1b,
	0x17, 0x07, 0x84, 0xaa, 0xf2, 0x13, 0x42, 0x20, 0xc6, 0x5f, 0x69, 0xe5, 0x09, 0x3d, 0x95, 0x28,
	0xc6, 0x55, 0x96, 0xc5, 0x9f, 0x63, 0xd5, 0xac, 0x86, 0x45, 0xd9, 0xfe, 0x98, 0xa4, 0xba, 0x55,
	0xad, 0xcd, 0x16, 0x4f, 0x90, 0xfd, 0xf7, 0x5e, 0xbc, 0x7f, 0xcb, 0xe6, 0xf1, 0x27, 0x10, 0xa2,
	0x55, 0x7e, 0xe7, 0xd7, 0x3b, 0xcc, 0x2a, 0x33, 0xe8, 0xb7, 0x5b, 0x89, 0x92, 0x8e, 0x4e, 0xa5,
	0x75, 0x23, 0x0a, 0xe1, 0x3f, 0x28, 0xe9, 0x50, 0x26, 0x7c, 0x93, 0xcd, 0xa6, 0xbd, 0x08, 0xd1,
	0xf0, 0x4a, 0xaf, 0xdf, 0x66, 0x74, 0x13, 0x22, 0x2d, 0xce, 0xd6, 0x9e, 0xb2, 0xe5, 0xd7, 0x91,
	0x08, 0x43, 0xe9, 0x7c, 0x90, 0x12, 0x45, 0x8b, 0x0d, 0x95, 0x2d, 0xb6, 0xc3, 0x2e, 0x65, 0x22,
	0x5e, 0x63, 0x91, 0x08, 0xb5, 0x79, 0xd7, 0xef, 0x2d, 0xe7, 0xd9, 0x68, 0x71, 0x1e, 0xf4, 0x51,
	0xfb, 0xcb, 0x10, 0xbd, 0xb9, 0x1a, 0xf0, 0xc3, 0x10, 0xfe, 0x3d, 0xe3, 0x31, 0xa9, 0x6b, 0xa9,
	0x74, 0xb0, 0xf4, 0xa5, 0x5a, 0x1a, 0x1e, 0xdf, 0x31, 0x9f, 0xfa, 0x6c, 0xdc, 0x83, 0x54, 0xfc,
	0x35, 0xe3, 0x74, 0xc1, 0xd6, 0xa5, 0x2e, 0xd2, 0xa8, 0xfc, 0x40, 0xe3, 0x3d, 0x13, 0xab, 0x1b,
	0x28, 0xa1, 0x80, 0xc4, 0xb3, 0x9e, 0xa4, 0x6a, 0x75, 0x49, 0x2c, 0xdd, 0x0d, 0xe9, 0x77, 0x55,
	0x5a, 0x4f, 0xa2, 0xff, 0x02, 0x3c, 0x35, 0x9b, 0xd0, 0x68, 0x69, 0xfb, 0x0d, 0x9c, 0x49, 0x81,
	0xbc, 0xb6, 0x4e, 0x1d, 0x9f, 0xbe, 0xdf, 0xeb, 0xf0, 0x55, 0x36, 0xdc, 0x48, 0x9a, 0xba, 0xe1,
	0xb3, 0xd0, 0xf7, 0xd3, 0x1e, 0xfd, 0xb0, 0xb8, 0x91, 0x34, 0x6f, 0xfe, 0xc7, 0x51, 0xfa, 0x79,
	0x6c, 0xe1, 0xc1, 0x07, 0xbf, 0xc0, 0xce, 0xb9, 0xfe, 0xa1, 0xf0, 0x5c, 0xfd, 0x82, 0xa6, 0x23,
	0x42, 0x2b, 0x7d, 0x03, 0x62, 0xfc, 0x8e, 0xcf, 0xa7, 0x0e, 0x89, 0xcf, 0xf6, 0xb1, 0xdf, 0x65,
	0x54, 0x38, 0x67, 0xd3, 0x69, 0x7d, 0x81, 0x2a, 0x93, 0xc6, 0x10, 0x37, 0xd8, 0x24, 0x51, 0x6a,
	0xc8, 0x19, 0x7e, 0x83, 0x5d, 0x2b, 0xfe, 0x10, 0xb1, 0xf0, 0x9b, 0x17, 0x2b, 0x8e, 0xdc, 0x56,
	0x2b, 0x7d, 0xd9, 0x64, 0x0c, 0xf3, 0x8f, 0xd9, 0x47, 0xa9, 0xc0, 0xf7, 0x11, 0x8f, 0xbc, 0x4b,
	0x6e, 0xf1, 0x59, 0x93, 0x32, 0x46, 0xf9, 0x2d, 0xb6, 0x5a, 0x24, 0x0d, 0x23, 0xac, 0x81, 0x4a,
	0xcd, 0x53, 0x16, 0x3c, 0xce, 0x97, 0xd9, 0xa2, 0xea, 0x2a, 0xab, 0x11, 0x05, 0xc2, 0xb1, 0x21,
	0xab, 0xc7, 0x87, 0x45, 0x71, 0x37, 0x94, 0xc6, 0x18, 0x5f, 0x62, 0x0b, 0x24, 0xaa, 0xf7, 0x11,
	0xa5, 0x51, 0xe5, 0x33, 0x4c, 0xff, 0x12, 0x09, 0x1f, 0xa6, 0x1b, 0x8c, 0xcf, 0xb1, 0x19, 0x7a,
	0xce, 0x0f, 0xde, 0x81, 0xaa, 0x19, 0x13, 0x00, 0x44, 0x13, 0x53, 0x7f, 0xa2, 0x99, 0xf8, 0x8e,
	0x31, 0xc9, 0x17, 0xd9, 0x9c, 0x36, 0x70, 0x68, 0xe5, 0xcf, 0x1e, 0x8d, 0x29, 0x7e, 0x91, 0x2d,
	0x11, 0xa2, 0x09, 0xd9, 0x3c, 0x0c, 0x54, 0xc4, 0x4f, 0x73, 0x93, 0xcd, 0x0f, 0xc4, 0xcc, 0xc0,
	0x92, 0xf6, 0x3c, 0x1a, 0xb5, 0xd2, 0x87, 0xa4, 0xca, 0x30, 0x40, 0x70, 0xef, 0x14, 0x0a, 0xf8,
	0x59, 0xb0, 0x42, 0xa9, 0xce, 0x12, 0xb5, 0xf4, 0xcf, 0x73, 0x95, 0xc1, 0x73, 0xad, 0xf4, 0x6d,
	0xbf, 0x21, 0xa2, 0x96, 0xd0, 0x3f, 0x5b, 0x50, 0xc6, 0x1c, 0x5f, 0x65, 0x57, 0x09, 0x5f, 0xf8,
	0x31, 0x6a, 0xf1, 0xe5, 0x6d, 0x2a, 0x69, 0x9e, 0x2f, 0x30, 0x9e, 0xfd, 0x16, 0x38, 0x6a, 0x49,
	0xc7, 0x0a, 0x1a, 0xbf, 0x28, 0xe3, 0xec, 0xcd, 0xbf, 0x4e, 0xb2, 0xd9, 0xa7, 0xe4, 0x0b, 0x54,
	0xc5, 0xd6, 0x8f, 0x2d, 0xe6, 0x74, 0x91, 0xbb, 0x2e, 0x9b, 0xae, 0xaf, 0x77, 0x94, 0xf1, 0x3b,
	0x30, 0xaa, 0x0e, 0xb3, 0x75, 0xa9, 0x82, 0x24, 0xb2, 0xa5, 0x51, 0x41, 0xea, 0x32, 0x70, 0x27,
	0xf0, 0x1c, 0x63, 0x68, 0x00, 0x62, 0x3b, 0x08, 0x1c, 0x63, 0x78, 0x00, 0xe2, 0x0d, 0x20, 0x46,
	0xc0, 0xcc, 0x3d, 0x08, 0xfc, 0xf1, 0xaf, 0x31, 0x0a, 0x2c, 0x75, 0x69, 0x47, 0x89, 0x1b, 0xeb,
	0xde, 0xcb, 0xa6, 0xf6, 0xfb, 0x79, 0x66, 0x3c, 0x95, 0x59, 0x47, 0x86, 0xa0, 0x63, 0x7c, 0x8a,
	0x8d, 0xc3, 0x21, 0x43, 0x9f, 0x55, 0x3e, 0xcd, 0x58, 0x3d, 0x68, 0x3c, 0xa3, 0x17, 0x43, 0xc6,
	0x38, 0xaf, 0xb2, 0x11, 0xf8, 0x30, 0x18, 0x3f, 0xc7, 0xce, 0xee, 0x0c, 0x7a, 0x85, 0x64, 0x4c,
	0x80, 0x9f, 0xed, 0xe4, 0xbf, 0xaa, 0x35, 0x26, 0xf9, 0x59, 0x36, 0xdb, 0xd7, 0xf0, 0x36, 0xa6,
	0xf8, 0x38, 0x1b, 0x7d, 0x72, 0x1c, 0x4a, 0xcf, 0x98, 0xe6, 0x13, 0x6c, 0x6c, 0x33, 0xf0, 0x55,
	0xe2, 0xc5, 0xc6, 0x0c, 0x18, 0x6b, 0x4f, 0x1c, 0x3f, 0x4b, 0xfc, 0x9f, 0x5c, 0xe1, 0x63, 0x01,
	0xdc, 0x30, 0x60, 0xe3, 0x16, 0x7f, 0xb0, 0x68, 0xcc, 0xc2, 0x30, 0xdf, 0xb9, 0x9e, 0xa7, 0x8b,
	0xe2, 0x06, 0x07, 0x21, 0xfa, 0x07, 0x74, 0xc6, 0x1c, 0x4c, 0x64, 0x5f, 0x7a, 0xde, 0x86, 0x08,
	0x8e, 0x12, 0x63, 0x1e, 0xd8, 0xd7, 0x6d, 0x3b, 0xe9, 0x6c, 0x08, 0xf7, 0xe7, 0xb6, 0xf0, 0x8d,
	0xb3, 0x30, 0xb5, 0xfd, 0x8e, 0xf4, 0x62, 0x12, 0xb7, 0x00, 0xf6, 0xd0, 0x26, 0xa4, 0xdc, 0x73,
	0x23, 0x38, 0x36, 0x16, 0xd1, 0xb0, 0x69, 0x81, 0xb0, 0x50, 0x0d, 0x35, 0x4c, 0xd0, 0xf2, 0xa9,
	0xf4, 0xc2, 0x22, 0x70, 0x03, 0x54, 0xd8, 0x6f, 0x07, 0xe1, 0x46, 0xd2, 0x35, 0xce, 0xc1, 0x98,
	0xf0, 0x81, 0x1d, 0x76, 0x80, 0x2c, 0xe9, 0x99, 0x15, 0x73, 0x5b, 0x63, 0x19, 0x3c, 0x79, 0xd7,
	0x3f, 0x14, 0x8e, 0xcc, 0xbb, 0x0a, 0xfa, 0xf2, 0x65, 0x9c, 0x87, 0xf1, 0xdf, 0xb8, 0x7e, 0x3f,
	0xe6, 0x02, 0xb0, 0xd5, 0x83, 0x46, 0x1f, 0xa6, 0x2e, 0x95, 0xf1, 0x0d, 0x58, 0x1c, 0x4d, 0x8b,
	0x6d, 0x96, 0x94, 0x67, 0x1d, 0xc6, 0xaf, 0x4b, 0xe1, 0x75, 0x5e, 0x1d, 0x86, 0xfb, 0x89, 0x6d,
	0x4b, 0xa5, 0x8c, 0x8b, 0xa0, 0x66, 0x0a, 0xdc, 0x16, 0xae, 0x67, 0x5c, 0x82, 0xc0, 0xb9, 0xeb,
	0x1f, 0xca, 0x28, 0xeb, 0xc4, 0x18, 0x2b, 0xb0, 0x11, 0x36, 0xe8, 0x37, 0xcd, 0x45, 0xf8, 0x65,
	0xa0, 0x4d, 0xb9, 0xd7, 0x95, 0x72, 0x55, 0x6c, 0xd4, 0x80, 0x36, 0x85, 0x01, 0x8f, 0x86, 0x5f,
	0xa1, 0x5d, 0x40, 0x69, 0x9e, 0xfe, 0x9d, 0x9e, 0x71, 0x15, 0x86, 0x2f, 0x3e, 0x2d, 0x35, 0xae,
	0x81, 0xf2, 0xbb, 0xd8, 0x8a, 0x83, 0xe5, 0xd5, 0xfe, 0x69, 0x5c, 0x07, 0x30, 0x49, 0x2a, 0x82,
	0x3f, 0x82, 0xc1, 0x74, 0x83, 0xa9, 0x08, 0x7f, 0x08, 0x8e, 0x9f, 0xfe, 0x24, 0xaf, 0x9e, 0x37,
	0x9b, 0x8c, 0x55, 0x60, 0x40, 0x57, 0xc0, 0x12, 0x6a, 0x4a, 0x62, 0xdc, 0x80, 0x99, 0x20, 0xfc,
	0x39, 0x84, 0xc4, 0x2d, 0xd1, 0x55, 0xc6, 0xcd, 0x0c, 0x06, 0x2b, 0xfd, 0x46, 0x80, 0x11, 0x3f,
	0xe6, 0xb3, 0x6c, 0x4a, 0xbb, 0x92, 0x92, 0x5b, 0x52, 0x38, 0xc6, 0xad, 0x0c, 0xb4, 0xa7, 0x9f,
	0x77, 0x18, 0xb7, 0xc1, 0x9d, 0x10, 0xb4, 0x25, 0x55, 0x1c, 0x05, 0x5d, 0x84, 0xae, 0x41, 0x78,
	0x2e, 0x42, 0x0b, 0xdb, 0xe1, 0x0e, 0x58, 0x07, 0x71, 0xf5, 0xa0, 0xd1, 0x70, 0xfd, 0x16, 0x2c,
	0xe4, 0x27, 0x30, 0x0b, 0x04, 0x6e, 0x8b, 0xa8, 0xf3, 0x54, 0x44, 0x87, 0x12, 0x5f, 0xc8, 0x19,
	0x9f, 0xc2, 0xfe, 0x43, 0x44, 0xf6, 0xa3, 0xc5, 0x9d, 0x44, 0xf8, 0xbf, 0xba, 0xc2, 0xb8, 0x8b,
	0x86, 0x02, 0xd4, 0x4f, 0x6e, 0xe0, 0xb7, 0x5e, 0x24, 0x38, 0x4f, 0xe3, 0x5e, 0x06, 0x06, 0x51,
	0xfb, 0xb1, 0x14, 0x1e, 0x08, 0xba, 0xcf, 0xcf, 0x33, 0x93, 0x54, 0xa2, 0xe2, 0xe0, 0x7a, 0x12,
	0x07, 0xe9, 0x22, 0x19, 0x9f, 0x65, 0x58, 0x0c, 0x08, 0x5b, 0xc1, 0x11, 0x55, 0x7e, 0x29, 0xac,
	0x3d, 0x00, 0x53, 0xfe, 0xa0, 0xe4, 0xeb, 0x64, 0x5b, 0xba, 0xe8, 0xe5, 0x14, 0x36, 0x1e, 0xa5,
	0x7b, 0x03, 0xa3, 0xc0, 0x9e, 0xec, 0x34, 0x64, 0x64, 0x7c, 0x0e, 0xfb, 0x95, 0x7e, 0x49, 0x41,
	0x7b, 0xf2, 0x31, 0x9f, 0x64, 0xd5, 0x7a, 0xd0, 0xa0, 0xaf, 0x2f, 0x00, 0x5d, 0x0f, 0x1a, 0xd8,
	0xde, 0x02, 0xc0, 0xb7, 0x30, 0xf5, 0x9f, 0x12, 0xe1, 0x77, 0x13, 0xe1, 0x3f, 0x75, 0xd5, 0x9e,
	0x38, 0xde, 0xb7, 0x83, 0x48, 0x1a, 0x5f, 0xe2, 0xd6, 0x86, 0x39, 0x3d, 0x95, 0x0d, 0xd7, 0xf8,
	0x0a, 0xf6, 0x5c, 0x3d, 0x68, 0xe0, 0xc7, 0xd7, 0xc0, 0xb4, 0x27, 0x8e, 0xb1, 0x87, 0x5a, 0x68,
	0x31, 0x1a, 0x9b, 0xb0, 0x1e, 0x7b, 0xf6, 0x1b, 0x11, 0x69, 0x27, 0x71, 0x1d, 0x19, 0x19, 0x5b,
	0xa0, 0x02, 0x42, 0xdf, 0xb8, 0xbe, 0xf1, 0x04, 0x36, 0x1b, 0x7e, 0xa5, 0x6b, 0x06, 0xea, 0x43,
	0x34, 0xd9, 0x86, 0x21, 0x11, 0xf3, 0x0c, 0x22, 0xdc, 0x77, 0xc4, 0xf6, 0xd2, 0xb6, 0x93, 0xb0,
	0x6b, 0x3c, 0x2f, 0x44, 0xfd, 0x27, 0xc7, 0xb4, 0xdb, 0x21, 0x01, 0x36, 0x76, 0x30, 0x00, 0xe8,
	0xcc, 0x11, 0x21, 0x4f, 0x41, 0x8b, 0xc2, 0x4a, 0x92, 0x19, 0x77, 0x01, 0x0a, 0x6a, 0x3d, 0xa3,
	0x66, 0x2e, 0x41, 0x9f, 0x6d, 0xac, 0xfc, 0xcf, 0xbf, 0x5d, 0xac, 0xfc, 0xdf, 0xbf, 0x5d, 0xac,
	0xfc, 0xf5, 0x6f, 0x17, 0x2b, 0x7f, 0xfe, 0xa7, 0x8b, 0xbf, 0x7b, 0x5a, 0xf9, 0x79, 0xb2, 0xf8,
	0x7f, 0xf3, 0x34, 0xce, 0xe0, 0x3f, 0xf7, 0xfe, 0x25, 0x00, 0x00, 0xff, 0xff, 0xe8, 0xd9, 0x47,
	0x37, 0xa0, 0x4b, 0x00, 0x00,
}
