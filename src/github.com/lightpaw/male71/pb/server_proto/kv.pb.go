// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/server_proto/kv.proto
// DO NOT EDIT!

package server_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import proto18 "github.com/lightpaw/male7/pb/shared_proto"
import proto1 "github.com/lightpaw/male7/pb/shared_proto"
import proto4 "github.com/lightpaw/male7/pb/shared_proto"
import proto5 "github.com/lightpaw/male7/pb/shared_proto"
import proto12 "github.com/lightpaw/male7/pb/shared_proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Key int32

const (
	Key_Tower           Key = 0
	Key_Region          Key = 1
	Key_ServerStartTime Key = 2
	Key_ServerStopTime  Key = 3
	Key_Rank            Key = 4
	Key_BaiZhan         Key = 5
	Key_Country         Key = 6
	Key_XiongNu         Key = 7
	Key_GuildRcmdHeros  Key = 8
	Key_Xuanyuan        Key = 9
	Key_Hebi            Key = 10
	Key_NewCountry      Key = 11
	Key_Mingc           Key = 12
	Key_MingcWar        Key = 13
	Key_NewHebi         Key = 14
	Key_AstDefendLog    Key = 15
	Key_TimeLimitGifts  Key = 16
	Key_RedPacket       Key = 17
	Key_UNIT_TEST       Key = 100
)

var Key_name = map[int32]string{
	0:   "Tower",
	1:   "Region",
	2:   "ServerStartTime",
	3:   "ServerStopTime",
	4:   "Rank",
	5:   "BaiZhan",
	6:   "Country",
	7:   "XiongNu",
	8:   "GuildRcmdHeros",
	9:   "Xuanyuan",
	10:  "Hebi",
	11:  "NewCountry",
	12:  "Mingc",
	13:  "MingcWar",
	14:  "NewHebi",
	15:  "AstDefendLog",
	16:  "TimeLimitGifts",
	17:  "RedPacket",
	100: "UNIT_TEST",
}
var Key_value = map[string]int32{
	"Tower":           0,
	"Region":          1,
	"ServerStartTime": 2,
	"ServerStopTime":  3,
	"Rank":            4,
	"BaiZhan":         5,
	"Country":         6,
	"XiongNu":         7,
	"GuildRcmdHeros":  8,
	"Xuanyuan":        9,
	"Hebi":            10,
	"NewCountry":      11,
	"Mingc":           12,
	"MingcWar":        13,
	"NewHebi":         14,
	"AstDefendLog":    15,
	"TimeLimitGifts":  16,
	"RedPacket":       17,
	"UNIT_TEST":       100,
}

func (x Key) String() string {
	return proto.EnumName(Key_name, int32(x))
}
func (Key) EnumDescriptor() ([]byte, []int) { return fileDescriptorKv, []int{0} }

type TowerModuleProto struct {
	Replay []*proto18.TowerReplayProto `protobuf:"bytes,1,rep,name=replay" json:"replay,omitempty"`
}

func (m *TowerModuleProto) Reset()                    { *m = TowerModuleProto{} }
func (m *TowerModuleProto) String() string            { return proto.CompactTextString(m) }
func (*TowerModuleProto) ProtoMessage()               {}
func (*TowerModuleProto) Descriptor() ([]byte, []int) { return fileDescriptorKv, []int{0} }

func (m *TowerModuleProto) GetReplay() []*proto18.TowerReplayProto {
	if m != nil {
		return m.Replay
	}
	return nil
}

type InviteGuildRecommendHerosProto struct {
	HeroId                 []int64 `protobuf:"varint,1,rep,packed,name=hero_id,json=heroId" json:"hero_id,omitempty"`
	InitGuildMemberCountry bool    `protobuf:"varint,2,opt,name=init_guild_member_country,json=initGuildMemberCountry,proto3" json:"init_guild_member_country,omitempty"`
}

func (m *InviteGuildRecommendHerosProto) Reset()                    { *m = InviteGuildRecommendHerosProto{} }
func (m *InviteGuildRecommendHerosProto) String() string            { return proto.CompactTextString(m) }
func (*InviteGuildRecommendHerosProto) ProtoMessage()               {}
func (*InviteGuildRecommendHerosProto) Descriptor() ([]byte, []int) { return fileDescriptorKv, []int{1} }

func (m *InviteGuildRecommendHerosProto) GetHeroId() []int64 {
	if m != nil {
		return m.HeroId
	}
	return nil
}

func (m *InviteGuildRecommendHerosProto) GetInitGuildMemberCountry() bool {
	if m != nil {
		return m.InitGuildMemberCountry
	}
	return false
}

type RegionModuleProto struct {
	HomeNpcBaseSequence   uint64                         `protobuf:"varint,3,opt,name=home_npc_base_sequence,json=homeNpcBaseSequence,proto3" json:"home_npc_base_sequence,omitempty"`
	RealmRuins            []*RealmRuinsBasePosInfosProto `protobuf:"bytes,4,rep,name=realm_ruins,json=realmRuins" json:"realm_ruins,omitempty"`
	Radius                uint64                         `protobuf:"varint,5,opt,name=radius,proto3" json:"radius,omitempty"`
	NpcBaseList           []*NpcBaseProto                `protobuf:"bytes,6,rep,name=npc_base_list,json=npcBaseList" json:"npc_base_list,omitempty"`
	TroopList             []*TroopServerProto            `protobuf:"bytes,7,rep,name=troop_list,json=troopList" json:"troop_list,omitempty"`
	BaoZangNpcRefreshTime int64                          `protobuf:"varint,8,opt,name=bao_zang_npc_refresh_time,json=baoZangNpcRefreshTime,proto3" json:"bao_zang_npc_refresh_time,omitempty"`
	JunTuanNpcRefreshTime int64                          `protobuf:"varint,9,opt,name=jun_tuan_npc_refresh_time,json=junTuanNpcRefreshTime,proto3" json:"jun_tuan_npc_refresh_time,omitempty"`
}

func (m *RegionModuleProto) Reset()                    { *m = RegionModuleProto{} }
func (m *RegionModuleProto) String() string            { return proto.CompactTextString(m) }
func (*RegionModuleProto) ProtoMessage()               {}
func (*RegionModuleProto) Descriptor() ([]byte, []int) { return fileDescriptorKv, []int{2} }

func (m *RegionModuleProto) GetHomeNpcBaseSequence() uint64 {
	if m != nil {
		return m.HomeNpcBaseSequence
	}
	return 0
}

func (m *RegionModuleProto) GetRealmRuins() []*RealmRuinsBasePosInfosProto {
	if m != nil {
		return m.RealmRuins
	}
	return nil
}

func (m *RegionModuleProto) GetRadius() uint64 {
	if m != nil {
		return m.Radius
	}
	return 0
}

func (m *RegionModuleProto) GetNpcBaseList() []*NpcBaseProto {
	if m != nil {
		return m.NpcBaseList
	}
	return nil
}

func (m *RegionModuleProto) GetTroopList() []*TroopServerProto {
	if m != nil {
		return m.TroopList
	}
	return nil
}

func (m *RegionModuleProto) GetBaoZangNpcRefreshTime() int64 {
	if m != nil {
		return m.BaoZangNpcRefreshTime
	}
	return 0
}

func (m *RegionModuleProto) GetJunTuanNpcRefreshTime() int64 {
	if m != nil {
		return m.JunTuanNpcRefreshTime
	}
	return 0
}

type RealmRuinsBasePosInfosProto struct {
	RealmId int64                    `protobuf:"varint,1,opt,name=realm_id,json=realmId,proto3" json:"realm_id,omitempty"`
	Infos   []*RuinsBasePosInfoProto `protobuf:"bytes,2,rep,name=infos" json:"infos,omitempty"`
}

func (m *RealmRuinsBasePosInfosProto) Reset()                    { *m = RealmRuinsBasePosInfosProto{} }
func (m *RealmRuinsBasePosInfosProto) String() string            { return proto.CompactTextString(m) }
func (*RealmRuinsBasePosInfosProto) ProtoMessage()               {}
func (*RealmRuinsBasePosInfosProto) Descriptor() ([]byte, []int) { return fileDescriptorKv, []int{3} }

func (m *RealmRuinsBasePosInfosProto) GetRealmId() int64 {
	if m != nil {
		return m.RealmId
	}
	return 0
}

func (m *RealmRuinsBasePosInfosProto) GetInfos() []*RuinsBasePosInfoProto {
	if m != nil {
		return m.Infos
	}
	return nil
}

type RuinsBasePosInfoProto struct {
	Id   int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Time int64 `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	PosX int32 `protobuf:"varint,3,opt,name=pos_x,json=posX,proto3" json:"pos_x,omitempty"`
	PosY int32 `protobuf:"varint,4,opt,name=pos_y,json=posY,proto3" json:"pos_y,omitempty"`
}

func (m *RuinsBasePosInfoProto) Reset()                    { *m = RuinsBasePosInfoProto{} }
func (m *RuinsBasePosInfoProto) String() string            { return proto.CompactTextString(m) }
func (*RuinsBasePosInfoProto) ProtoMessage()               {}
func (*RuinsBasePosInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorKv, []int{4} }

func (m *RuinsBasePosInfoProto) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RuinsBasePosInfoProto) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *RuinsBasePosInfoProto) GetPosX() int32 {
	if m != nil {
		return m.PosX
	}
	return 0
}

func (m *RuinsBasePosInfoProto) GetPosY() int32 {
	if m != nil {
		return m.PosY
	}
	return 0
}

type Int64ArrayProto struct {
	V []int64 `protobuf:"varint,1,rep,packed,name=v" json:"v,omitempty"`
}

func (m *Int64ArrayProto) Reset()                    { *m = Int64ArrayProto{} }
func (m *Int64ArrayProto) String() string            { return proto.CompactTextString(m) }
func (*Int64ArrayProto) ProtoMessage()               {}
func (*Int64ArrayProto) Descriptor() ([]byte, []int) { return fileDescriptorKv, []int{5} }

func (m *Int64ArrayProto) GetV() []int64 {
	if m != nil {
		return m.V
	}
	return nil
}

type UInt64ArrayProto struct {
	V []uint64 `protobuf:"varint,1,rep,packed,name=v" json:"v,omitempty"`
}

func (m *UInt64ArrayProto) Reset()                    { *m = UInt64ArrayProto{} }
func (m *UInt64ArrayProto) String() string            { return proto.CompactTextString(m) }
func (*UInt64ArrayProto) ProtoMessage()               {}
func (*UInt64ArrayProto) Descriptor() ([]byte, []int) { return fileDescriptorKv, []int{6} }

func (m *UInt64ArrayProto) GetV() []uint64 {
	if m != nil {
		return m.V
	}
	return nil
}

type TimeProto struct {
	Time int64 `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *TimeProto) Reset()                    { *m = TimeProto{} }
func (m *TimeProto) String() string            { return proto.CompactTextString(m) }
func (*TimeProto) ProtoMessage()               {}
func (*TimeProto) Descriptor() ([]byte, []int) { return fileDescriptorKv, []int{7} }

func (m *TimeProto) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type UserMiscProto struct {
	TutorialProgress   int32 `protobuf:"varint,1,opt,name=tutorial_progress,json=tutorialProgress,proto3" json:"tutorial_progress,omitempty"`
	IsTutorialComplete bool  `protobuf:"varint,2,opt,name=is_tutorial_complete,json=isTutorialComplete,proto3" json:"is_tutorial_complete,omitempty"`
	Created            bool  `protobuf:"varint,3,opt,name=created,proto3" json:"created,omitempty"`
}

func (m *UserMiscProto) Reset()                    { *m = UserMiscProto{} }
func (m *UserMiscProto) String() string            { return proto.CompactTextString(m) }
func (*UserMiscProto) ProtoMessage()               {}
func (*UserMiscProto) Descriptor() ([]byte, []int) { return fileDescriptorKv, []int{8} }

func (m *UserMiscProto) GetTutorialProgress() int32 {
	if m != nil {
		return m.TutorialProgress
	}
	return 0
}

func (m *UserMiscProto) GetIsTutorialComplete() bool {
	if m != nil {
		return m.IsTutorialComplete
	}
	return false
}

func (m *UserMiscProto) GetCreated() bool {
	if m != nil {
		return m.Created
	}
	return false
}

// npc主城类型
type NpcBaseProto struct {
	BaseRegion     int64   `protobuf:"varint,1,opt,name=base_region,json=baseRegion,proto3" json:"base_region,omitempty"`
	BaseId         int64   `protobuf:"varint,2,opt,name=base_id,json=baseId,proto3" json:"base_id,omitempty"`
	BaseX          int32   `protobuf:"varint,3,opt,name=base_x,json=baseX,proto3" json:"base_x,omitempty"`
	BaseY          int32   `protobuf:"varint,4,opt,name=base_y,json=baseY,proto3" json:"base_y,omitempty"`
	Prosperity     uint64  `protobuf:"varint,7,opt,name=prosperity,proto3" json:"prosperity,omitempty"`
	CaptainIndex   []int32 `protobuf:"varint,5,rep,packed,name=captain_index,json=captainIndex" json:"captain_index,omitempty"`
	CaptainSoldier []int32 `protobuf:"varint,6,rep,packed,name=captain_soldier,json=captainSoldier" json:"captain_soldier,omitempty"`
	GuildId        int64   `protobuf:"varint,10,opt,name=guild_id,json=guildId,proto3" json:"guild_id,omitempty"`
	// 创建者
	HeroType    int32 `protobuf:"varint,13,opt,name=hero_type,json=heroType,proto3" json:"hero_type,omitempty"`
	HeroId      int64 `protobuf:"varint,12,opt,name=hero_id,json=heroId,proto3" json:"hero_id,omitempty"`
	HeroEndTime int64 `protobuf:"varint,14,opt,name=hero_end_time,json=heroEndTime,proto3" json:"hero_end_time,omitempty"`
	// 防守怪
	DefendingTroop []*NpcDefendingTroopProto `protobuf:"bytes,11,rep,name=defending_troop,json=defendingTroop" json:"defending_troop,omitempty"`
}

func (m *NpcBaseProto) Reset()                    { *m = NpcBaseProto{} }
func (m *NpcBaseProto) String() string            { return proto.CompactTextString(m) }
func (*NpcBaseProto) ProtoMessage()               {}
func (*NpcBaseProto) Descriptor() ([]byte, []int) { return fileDescriptorKv, []int{9} }

func (m *NpcBaseProto) GetBaseRegion() int64 {
	if m != nil {
		return m.BaseRegion
	}
	return 0
}

func (m *NpcBaseProto) GetBaseId() int64 {
	if m != nil {
		return m.BaseId
	}
	return 0
}

func (m *NpcBaseProto) GetBaseX() int32 {
	if m != nil {
		return m.BaseX
	}
	return 0
}

func (m *NpcBaseProto) GetBaseY() int32 {
	if m != nil {
		return m.BaseY
	}
	return 0
}

func (m *NpcBaseProto) GetProsperity() uint64 {
	if m != nil {
		return m.Prosperity
	}
	return 0
}

func (m *NpcBaseProto) GetCaptainIndex() []int32 {
	if m != nil {
		return m.CaptainIndex
	}
	return nil
}

func (m *NpcBaseProto) GetCaptainSoldier() []int32 {
	if m != nil {
		return m.CaptainSoldier
	}
	return nil
}

func (m *NpcBaseProto) GetGuildId() int64 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *NpcBaseProto) GetHeroType() int32 {
	if m != nil {
		return m.HeroType
	}
	return 0
}

func (m *NpcBaseProto) GetHeroId() int64 {
	if m != nil {
		return m.HeroId
	}
	return 0
}

func (m *NpcBaseProto) GetHeroEndTime() int64 {
	if m != nil {
		return m.HeroEndTime
	}
	return 0
}

func (m *NpcBaseProto) GetDefendingTroop() []*NpcDefendingTroopProto {
	if m != nil {
		return m.DefendingTroop
	}
	return nil
}

type NpcDefendingTroopProto struct {
	Id             int64   `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	DataId         uint64  `protobuf:"varint,3,opt,name=data_id,json=dataId,proto3" json:"data_id,omitempty"`
	CaptainIndex   []int32 `protobuf:"varint,5,rep,packed,name=captain_index,json=captainIndex" json:"captain_index,omitempty"`
	CaptainSoldier []int32 `protobuf:"varint,6,rep,packed,name=captain_soldier,json=captainSoldier" json:"captain_soldier,omitempty"`
}

func (m *NpcDefendingTroopProto) Reset()                    { *m = NpcDefendingTroopProto{} }
func (m *NpcDefendingTroopProto) String() string            { return proto.CompactTextString(m) }
func (*NpcDefendingTroopProto) ProtoMessage()               {}
func (*NpcDefendingTroopProto) Descriptor() ([]byte, []int) { return fileDescriptorKv, []int{10} }

func (m *NpcDefendingTroopProto) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *NpcDefendingTroopProto) GetDataId() uint64 {
	if m != nil {
		return m.DataId
	}
	return 0
}

func (m *NpcDefendingTroopProto) GetCaptainIndex() []int32 {
	if m != nil {
		return m.CaptainIndex
	}
	return nil
}

func (m *NpcDefendingTroopProto) GetCaptainSoldier() []int32 {
	if m != nil {
		return m.CaptainSoldier
	}
	return nil
}

type TroopServerProto struct {
	StartingBaseId           int64                      `protobuf:"varint,100,opt,name=starting_base_id,json=startingBaseId,proto3" json:"starting_base_id,omitempty"`
	StartingBaseLevel        uint64                     `protobuf:"varint,101,opt,name=starting_base_level,json=startingBaseLevel,proto3" json:"starting_base_level,omitempty"`
	RealmId                  int64                      `protobuf:"varint,1,opt,name=realm_id,json=realmId,proto3" json:"realm_id,omitempty"`
	Id                       int64                      `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	TargetBaseId             int64                      `protobuf:"varint,3,opt,name=target_base_id,json=targetBaseId,proto3" json:"target_base_id,omitempty"`
	TargetBaseLevel          uint64                     `protobuf:"varint,4,opt,name=target_base_level,json=targetBaseLevel,proto3" json:"target_base_level,omitempty"`
	TroopState               uint32                     `protobuf:"varint,6,opt,name=troop_state,json=troopState,proto3" json:"troop_state,omitempty"`
	OriginTargetId           int64                      `protobuf:"varint,10,opt,name=origin_target_id,json=originTargetId,proto3" json:"origin_target_id,omitempty"`
	BackHomeTargetX          int32                      `protobuf:"varint,11,opt,name=back_home_target_x,json=backHomeTargetX,proto3" json:"back_home_target_x,omitempty"`
	BackHomeTargetY          int32                      `protobuf:"varint,12,opt,name=back_home_target_y,json=backHomeTargetY,proto3" json:"back_home_target_y,omitempty"`
	TargetIsOwnerCanSee      bool                       `protobuf:"varint,13,opt,name=target_is_owner_can_see,json=targetIsOwnerCanSee,proto3" json:"target_is_owner_can_see,omitempty"`
	CreateTime               int64                      `protobuf:"varint,15,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	MoveSpeedRate            float64                    `protobuf:"fixed64,16,opt,name=move_speed_rate,json=moveSpeedRate,proto3" json:"move_speed_rate,omitempty"`
	MoveStartTime            int64                      `protobuf:"varint,17,opt,name=move_start_time,json=moveStartTime,proto3" json:"move_start_time,omitempty"`
	MoveArriveTime           int64                      `protobuf:"varint,18,opt,name=move_arrive_time,json=moveArriveTime,proto3" json:"move_arrive_time,omitempty"`
	RobbingEndTime           int64                      `protobuf:"varint,19,opt,name=robbing_end_time,json=robbingEndTime,proto3" json:"robbing_end_time,omitempty"`
	NextReduceProsperityTime int64                      `protobuf:"varint,20,opt,name=next_reduce_prosperity_time,json=nextReduceProsperityTime,proto3" json:"next_reduce_prosperity_time,omitempty"`
	NextAddHateTime          int64                      `protobuf:"varint,21,opt,name=next_add_hate_time,json=nextAddHateTime,proto3" json:"next_add_hate_time,omitempty"`
	AccumRobPrize            *proto1.PrizeProto         `protobuf:"bytes,25,opt,name=accum_rob_prize,json=accumRobPrize" json:"accum_rob_prize,omitempty"`
	AccumReduceProsperity    uint64                     `protobuf:"varint,26,opt,name=accum_reduce_prosperity,json=accumReduceProsperity,proto3" json:"accum_reduce_prosperity,omitempty"`
	Captains                 []*proto4.CaptainInfoProto `protobuf:"bytes,27,rep,name=captains" json:"captains,omitempty"`
	CaptainIndex             []int32                    `protobuf:"varint,28,rep,name=captain_index,json=captainIndex" json:"captain_index,omitempty"`
	MonsterMasterId          uint64                     `protobuf:"varint,29,opt,name=monster_master_id,json=monsterMasterId,proto3" json:"monster_master_id,omitempty"`
	AssistDefendStartTime    int64                      `protobuf:"varint,30,opt,name=assist_defend_start_time,json=assistDefendStartTime,proto3" json:"assist_defend_start_time,omitempty"`
	MultiLevelMonsterCount   uint64                     `protobuf:"varint,31,opt,name=multi_level_monster_count,json=multiLevelMonsterCount,proto3" json:"multi_level_monster_count,omitempty"`
}

func (m *TroopServerProto) Reset()                    { *m = TroopServerProto{} }
func (m *TroopServerProto) String() string            { return proto.CompactTextString(m) }
func (*TroopServerProto) ProtoMessage()               {}
func (*TroopServerProto) Descriptor() ([]byte, []int) { return fileDescriptorKv, []int{11} }

func (m *TroopServerProto) GetStartingBaseId() int64 {
	if m != nil {
		return m.StartingBaseId
	}
	return 0
}

func (m *TroopServerProto) GetStartingBaseLevel() uint64 {
	if m != nil {
		return m.StartingBaseLevel
	}
	return 0
}

func (m *TroopServerProto) GetRealmId() int64 {
	if m != nil {
		return m.RealmId
	}
	return 0
}

func (m *TroopServerProto) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TroopServerProto) GetTargetBaseId() int64 {
	if m != nil {
		return m.TargetBaseId
	}
	return 0
}

func (m *TroopServerProto) GetTargetBaseLevel() uint64 {
	if m != nil {
		return m.TargetBaseLevel
	}
	return 0
}

func (m *TroopServerProto) GetTroopState() uint32 {
	if m != nil {
		return m.TroopState
	}
	return 0
}

func (m *TroopServerProto) GetOriginTargetId() int64 {
	if m != nil {
		return m.OriginTargetId
	}
	return 0
}

func (m *TroopServerProto) GetBackHomeTargetX() int32 {
	if m != nil {
		return m.BackHomeTargetX
	}
	return 0
}

func (m *TroopServerProto) GetBackHomeTargetY() int32 {
	if m != nil {
		return m.BackHomeTargetY
	}
	return 0
}

func (m *TroopServerProto) GetTargetIsOwnerCanSee() bool {
	if m != nil {
		return m.TargetIsOwnerCanSee
	}
	return false
}

func (m *TroopServerProto) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *TroopServerProto) GetMoveSpeedRate() float64 {
	if m != nil {
		return m.MoveSpeedRate
	}
	return 0
}

func (m *TroopServerProto) GetMoveStartTime() int64 {
	if m != nil {
		return m.MoveStartTime
	}
	return 0
}

func (m *TroopServerProto) GetMoveArriveTime() int64 {
	if m != nil {
		return m.MoveArriveTime
	}
	return 0
}

func (m *TroopServerProto) GetRobbingEndTime() int64 {
	if m != nil {
		return m.RobbingEndTime
	}
	return 0
}

func (m *TroopServerProto) GetNextReduceProsperityTime() int64 {
	if m != nil {
		return m.NextReduceProsperityTime
	}
	return 0
}

func (m *TroopServerProto) GetNextAddHateTime() int64 {
	if m != nil {
		return m.NextAddHateTime
	}
	return 0
}

func (m *TroopServerProto) GetAccumRobPrize() *proto1.PrizeProto {
	if m != nil {
		return m.AccumRobPrize
	}
	return nil
}

func (m *TroopServerProto) GetAccumReduceProsperity() uint64 {
	if m != nil {
		return m.AccumReduceProsperity
	}
	return 0
}

func (m *TroopServerProto) GetCaptains() []*proto4.CaptainInfoProto {
	if m != nil {
		return m.Captains
	}
	return nil
}

func (m *TroopServerProto) GetCaptainIndex() []int32 {
	if m != nil {
		return m.CaptainIndex
	}
	return nil
}

func (m *TroopServerProto) GetMonsterMasterId() uint64 {
	if m != nil {
		return m.MonsterMasterId
	}
	return 0
}

func (m *TroopServerProto) GetAssistDefendStartTime() int64 {
	if m != nil {
		return m.AssistDefendStartTime
	}
	return 0
}

func (m *TroopServerProto) GetMultiLevelMonsterCount() uint64 {
	if m != nil {
		return m.MultiLevelMonsterCount
	}
	return 0
}

// 轩辕会武
type XuanyuanModuleProto struct {
	RankHero   []*XuanyuanRankHeroProto `protobuf:"bytes,1,rep,name=rank_hero,json=rankHero" json:"rank_hero,omitempty"`
	Challenger []*XuanyuanRankHeroProto `protobuf:"bytes,2,rep,name=challenger" json:"challenger,omitempty"`
	UpdateTime int64                    `protobuf:"varint,3,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
}

func (m *XuanyuanModuleProto) Reset()                    { *m = XuanyuanModuleProto{} }
func (m *XuanyuanModuleProto) String() string            { return proto.CompactTextString(m) }
func (*XuanyuanModuleProto) ProtoMessage()               {}
func (*XuanyuanModuleProto) Descriptor() ([]byte, []int) { return fileDescriptorKv, []int{12} }

func (m *XuanyuanModuleProto) GetRankHero() []*XuanyuanRankHeroProto {
	if m != nil {
		return m.RankHero
	}
	return nil
}

func (m *XuanyuanModuleProto) GetChallenger() []*XuanyuanRankHeroProto {
	if m != nil {
		return m.Challenger
	}
	return nil
}

func (m *XuanyuanModuleProto) GetUpdateTime() int64 {
	if m != nil {
		return m.UpdateTime
	}
	return 0
}

type XuanyuanRankHeroProto struct {
	HeroId    int64                     `protobuf:"varint,1,opt,name=hero_id,json=heroId,proto3" json:"hero_id,omitempty"`
	Score     uint64                    `protobuf:"varint,2,opt,name=score,proto3" json:"score,omitempty"`
	RankScore uint64                    `protobuf:"varint,3,opt,name=rank_score,json=rankScore,proto3" json:"rank_score,omitempty"`
	Win       uint64                    `protobuf:"varint,4,opt,name=win,proto3" json:"win,omitempty"`
	Lose      uint64                    `protobuf:"varint,5,opt,name=lose,proto3" json:"lose,omitempty"`
	Mirror    *proto5.CombatPlayerProto `protobuf:"bytes,6,opt,name=mirror" json:"mirror,omitempty"`
}

func (m *XuanyuanRankHeroProto) Reset()                    { *m = XuanyuanRankHeroProto{} }
func (m *XuanyuanRankHeroProto) String() string            { return proto.CompactTextString(m) }
func (*XuanyuanRankHeroProto) ProtoMessage()               {}
func (*XuanyuanRankHeroProto) Descriptor() ([]byte, []int) { return fileDescriptorKv, []int{13} }

func (m *XuanyuanRankHeroProto) GetHeroId() int64 {
	if m != nil {
		return m.HeroId
	}
	return 0
}

func (m *XuanyuanRankHeroProto) GetScore() uint64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *XuanyuanRankHeroProto) GetRankScore() uint64 {
	if m != nil {
		return m.RankScore
	}
	return 0
}

func (m *XuanyuanRankHeroProto) GetWin() uint64 {
	if m != nil {
		return m.Win
	}
	return 0
}

func (m *XuanyuanRankHeroProto) GetLose() uint64 {
	if m != nil {
		return m.Lose
	}
	return 0
}

func (m *XuanyuanRankHeroProto) GetMirror() *proto5.CombatPlayerProto {
	if m != nil {
		return m.Mirror
	}
	return nil
}

// 盟友驻扎恢复繁荣度日志
type AllAstDefendLogProto struct {
	Logs map[int64]*AstDefendLogListProto `protobuf:"bytes,1,rep,name=logs" json:"logs,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AllAstDefendLogProto) Reset()                    { *m = AllAstDefendLogProto{} }
func (m *AllAstDefendLogProto) String() string            { return proto.CompactTextString(m) }
func (*AllAstDefendLogProto) ProtoMessage()               {}
func (*AllAstDefendLogProto) Descriptor() ([]byte, []int) { return fileDescriptorKv, []int{14} }

func (m *AllAstDefendLogProto) GetLogs() map[int64]*AstDefendLogListProto {
	if m != nil {
		return m.Logs
	}
	return nil
}

type AstDefendLogListProto struct {
	HeroId int64                        `protobuf:"varint,1,opt,name=hero_id,json=heroId,proto3" json:"hero_id,omitempty"`
	Log    []*proto12.AstDefendLogProto `protobuf:"bytes,2,rep,name=log" json:"log,omitempty"`
}

func (m *AstDefendLogListProto) Reset()                    { *m = AstDefendLogListProto{} }
func (m *AstDefendLogListProto) String() string            { return proto.CompactTextString(m) }
func (*AstDefendLogListProto) ProtoMessage()               {}
func (*AstDefendLogListProto) Descriptor() ([]byte, []int) { return fileDescriptorKv, []int{15} }

func (m *AstDefendLogListProto) GetHeroId() int64 {
	if m != nil {
		return m.HeroId
	}
	return 0
}

func (m *AstDefendLogListProto) GetLog() []*proto12.AstDefendLogProto {
	if m != nil {
		return m.Log
	}
	return nil
}

func init() {
	proto.RegisterType((*TowerModuleProto)(nil), "proto.TowerModuleProto")
	proto.RegisterType((*InviteGuildRecommendHerosProto)(nil), "proto.InviteGuildRecommendHerosProto")
	proto.RegisterType((*RegionModuleProto)(nil), "proto.RegionModuleProto")
	proto.RegisterType((*RealmRuinsBasePosInfosProto)(nil), "proto.RealmRuinsBasePosInfosProto")
	proto.RegisterType((*RuinsBasePosInfoProto)(nil), "proto.RuinsBasePosInfoProto")
	proto.RegisterType((*Int64ArrayProto)(nil), "proto.Int64ArrayProto")
	proto.RegisterType((*UInt64ArrayProto)(nil), "proto.UInt64ArrayProto")
	proto.RegisterType((*TimeProto)(nil), "proto.TimeProto")
	proto.RegisterType((*UserMiscProto)(nil), "proto.UserMiscProto")
	proto.RegisterType((*NpcBaseProto)(nil), "proto.NpcBaseProto")
	proto.RegisterType((*NpcDefendingTroopProto)(nil), "proto.NpcDefendingTroopProto")
	proto.RegisterType((*TroopServerProto)(nil), "proto.TroopServerProto")
	proto.RegisterType((*XuanyuanModuleProto)(nil), "proto.XuanyuanModuleProto")
	proto.RegisterType((*XuanyuanRankHeroProto)(nil), "proto.XuanyuanRankHeroProto")
	proto.RegisterType((*AllAstDefendLogProto)(nil), "proto.AllAstDefendLogProto")
	proto.RegisterType((*AstDefendLogListProto)(nil), "proto.AstDefendLogListProto")
	proto.RegisterEnum("proto.Key", Key_name, Key_value)
}
func (m *TowerModuleProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TowerModuleProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Replay) > 0 {
		for _, msg := range m.Replay {
			dAtA[i] = 0xa
			i++
			i = encodeVarintKv(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InviteGuildRecommendHerosProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InviteGuildRecommendHerosProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HeroId) > 0 {
		dAtA2 := make([]byte, len(m.HeroId)*10)
		var j1 int
		for _, num1 := range m.HeroId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintKv(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.InitGuildMemberCountry {
		dAtA[i] = 0x10
		i++
		if m.InitGuildMemberCountry {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RegionModuleProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionModuleProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HomeNpcBaseSequence != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.HomeNpcBaseSequence))
	}
	if len(m.RealmRuins) > 0 {
		for _, msg := range m.RealmRuins {
			dAtA[i] = 0x22
			i++
			i = encodeVarintKv(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Radius != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.Radius))
	}
	if len(m.NpcBaseList) > 0 {
		for _, msg := range m.NpcBaseList {
			dAtA[i] = 0x32
			i++
			i = encodeVarintKv(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TroopList) > 0 {
		for _, msg := range m.TroopList {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintKv(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.BaoZangNpcRefreshTime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.BaoZangNpcRefreshTime))
	}
	if m.JunTuanNpcRefreshTime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.JunTuanNpcRefreshTime))
	}
	return i, nil
}

func (m *RealmRuinsBasePosInfosProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RealmRuinsBasePosInfosProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RealmId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.RealmId))
	}
	if len(m.Infos) > 0 {
		for _, msg := range m.Infos {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKv(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RuinsBasePosInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuinsBasePosInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.Id))
	}
	if m.Time != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.Time))
	}
	if m.PosX != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.PosX))
	}
	if m.PosY != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.PosY))
	}
	return i, nil
}

func (m *Int64ArrayProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Int64ArrayProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.V) > 0 {
		dAtA4 := make([]byte, len(m.V)*10)
		var j3 int
		for _, num1 := range m.V {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintKv(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	return i, nil
}

func (m *UInt64ArrayProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UInt64ArrayProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.V) > 0 {
		dAtA6 := make([]byte, len(m.V)*10)
		var j5 int
		for _, num := range m.V {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintKv(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	return i, nil
}

func (m *TimeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.Time))
	}
	return i, nil
}

func (m *UserMiscProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMiscProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TutorialProgress != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.TutorialProgress))
	}
	if m.IsTutorialComplete {
		dAtA[i] = 0x10
		i++
		if m.IsTutorialComplete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Created {
		dAtA[i] = 0x18
		i++
		if m.Created {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *NpcBaseProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NpcBaseProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BaseRegion != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.BaseRegion))
	}
	if m.BaseId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.BaseId))
	}
	if m.BaseX != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.BaseX))
	}
	if m.BaseY != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.BaseY))
	}
	if len(m.CaptainIndex) > 0 {
		dAtA8 := make([]byte, len(m.CaptainIndex)*10)
		var j7 int
		for _, num1 := range m.CaptainIndex {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKv(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if len(m.CaptainSoldier) > 0 {
		dAtA10 := make([]byte, len(m.CaptainSoldier)*10)
		var j9 int
		for _, num1 := range m.CaptainSoldier {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintKv(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	if m.Prosperity != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.Prosperity))
	}
	if m.GuildId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.GuildId))
	}
	if len(m.DefendingTroop) > 0 {
		for _, msg := range m.DefendingTroop {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintKv(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HeroId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.HeroId))
	}
	if m.HeroType != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.HeroType))
	}
	if m.HeroEndTime != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.HeroEndTime))
	}
	return i, nil
}

func (m *NpcDefendingTroopProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NpcDefendingTroopProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.Id))
	}
	if m.DataId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.DataId))
	}
	if len(m.CaptainIndex) > 0 {
		dAtA12 := make([]byte, len(m.CaptainIndex)*10)
		var j11 int
		for _, num1 := range m.CaptainIndex {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKv(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	if len(m.CaptainSoldier) > 0 {
		dAtA14 := make([]byte, len(m.CaptainSoldier)*10)
		var j13 int
		for _, num1 := range m.CaptainSoldier {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintKv(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	return i, nil
}

func (m *TroopServerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TroopServerProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RealmId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.RealmId))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.Id))
	}
	if m.TargetBaseId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.TargetBaseId))
	}
	if m.TargetBaseLevel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.TargetBaseLevel))
	}
	if m.TroopState != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.TroopState))
	}
	if m.OriginTargetId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.OriginTargetId))
	}
	if m.BackHomeTargetX != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.BackHomeTargetX))
	}
	if m.BackHomeTargetY != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.BackHomeTargetY))
	}
	if m.TargetIsOwnerCanSee {
		dAtA[i] = 0x68
		i++
		if m.TargetIsOwnerCanSee {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.CreateTime))
	}
	if m.MoveSpeedRate != 0 {
		dAtA[i] = 0x81
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Kv(dAtA, i, uint64(math.Float64bits(float64(m.MoveSpeedRate))))
	}
	if m.MoveStartTime != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.MoveStartTime))
	}
	if m.MoveArriveTime != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.MoveArriveTime))
	}
	if m.RobbingEndTime != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.RobbingEndTime))
	}
	if m.NextReduceProsperityTime != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.NextReduceProsperityTime))
	}
	if m.NextAddHateTime != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.NextAddHateTime))
	}
	if m.AccumRobPrize != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.AccumRobPrize.Size()))
		n15, err := m.AccumRobPrize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.AccumReduceProsperity != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.AccumReduceProsperity))
	}
	if len(m.Captains) > 0 {
		for _, msg := range m.Captains {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintKv(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CaptainIndex) > 0 {
		for _, num := range m.CaptainIndex {
			dAtA[i] = 0xe0
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintKv(dAtA, i, uint64(num))
		}
	}
	if m.MonsterMasterId != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.MonsterMasterId))
	}
	if m.AssistDefendStartTime != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.AssistDefendStartTime))
	}
	if m.MultiLevelMonsterCount != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.MultiLevelMonsterCount))
	}
	if m.StartingBaseId != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.StartingBaseId))
	}
	if m.StartingBaseLevel != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.StartingBaseLevel))
	}
	return i, nil
}

func (m *XuanyuanModuleProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XuanyuanModuleProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RankHero) > 0 {
		for _, msg := range m.RankHero {
			dAtA[i] = 0xa
			i++
			i = encodeVarintKv(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Challenger) > 0 {
		for _, msg := range m.Challenger {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKv(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.UpdateTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.UpdateTime))
	}
	return i, nil
}

func (m *XuanyuanRankHeroProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XuanyuanRankHeroProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.HeroId))
	}
	if m.Score != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.Score))
	}
	if m.RankScore != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.RankScore))
	}
	if m.Win != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.Win))
	}
	if m.Lose != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.Lose))
	}
	if m.Mirror != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.Mirror.Size()))
		n16, err := m.Mirror.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *AllAstDefendLogProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllAstDefendLogProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Logs) > 0 {
		for k, _ := range m.Logs {
			dAtA[i] = 0xa
			i++
			v := m.Logs[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovKv(uint64(msgSize))
			}
			mapSize := 1 + sovKv(uint64(k)) + msgSize
			i = encodeVarintKv(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintKv(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintKv(dAtA, i, uint64(v.Size()))
				n17, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n17
			}
		}
	}
	return i, nil
}

func (m *AstDefendLogListProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AstDefendLogListProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKv(dAtA, i, uint64(m.HeroId))
	}
	if len(m.Log) > 0 {
		for _, msg := range m.Log {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKv(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Kv(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Kv(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintKv(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TowerModuleProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Replay) > 0 {
		for _, e := range m.Replay {
			l = e.Size()
			n += 1 + l + sovKv(uint64(l))
		}
	}
	return n
}

func (m *InviteGuildRecommendHerosProto) Size() (n int) {
	var l int
	_ = l
	if len(m.HeroId) > 0 {
		l = 0
		for _, e := range m.HeroId {
			l += sovKv(uint64(e))
		}
		n += 1 + sovKv(uint64(l)) + l
	}
	if m.InitGuildMemberCountry {
		n += 2
	}
	return n
}

func (m *RegionModuleProto) Size() (n int) {
	var l int
	_ = l
	if m.HomeNpcBaseSequence != 0 {
		n += 1 + sovKv(uint64(m.HomeNpcBaseSequence))
	}
	if len(m.RealmRuins) > 0 {
		for _, e := range m.RealmRuins {
			l = e.Size()
			n += 1 + l + sovKv(uint64(l))
		}
	}
	if m.Radius != 0 {
		n += 1 + sovKv(uint64(m.Radius))
	}
	if len(m.NpcBaseList) > 0 {
		for _, e := range m.NpcBaseList {
			l = e.Size()
			n += 1 + l + sovKv(uint64(l))
		}
	}
	if len(m.TroopList) > 0 {
		for _, e := range m.TroopList {
			l = e.Size()
			n += 1 + l + sovKv(uint64(l))
		}
	}
	if m.BaoZangNpcRefreshTime != 0 {
		n += 1 + sovKv(uint64(m.BaoZangNpcRefreshTime))
	}
	if m.JunTuanNpcRefreshTime != 0 {
		n += 1 + sovKv(uint64(m.JunTuanNpcRefreshTime))
	}
	return n
}

func (m *RealmRuinsBasePosInfosProto) Size() (n int) {
	var l int
	_ = l
	if m.RealmId != 0 {
		n += 1 + sovKv(uint64(m.RealmId))
	}
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovKv(uint64(l))
		}
	}
	return n
}

func (m *RuinsBasePosInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovKv(uint64(m.Id))
	}
	if m.Time != 0 {
		n += 1 + sovKv(uint64(m.Time))
	}
	if m.PosX != 0 {
		n += 1 + sovKv(uint64(m.PosX))
	}
	if m.PosY != 0 {
		n += 1 + sovKv(uint64(m.PosY))
	}
	return n
}

func (m *Int64ArrayProto) Size() (n int) {
	var l int
	_ = l
	if len(m.V) > 0 {
		l = 0
		for _, e := range m.V {
			l += sovKv(uint64(e))
		}
		n += 1 + sovKv(uint64(l)) + l
	}
	return n
}

func (m *UInt64ArrayProto) Size() (n int) {
	var l int
	_ = l
	if len(m.V) > 0 {
		l = 0
		for _, e := range m.V {
			l += sovKv(uint64(e))
		}
		n += 1 + sovKv(uint64(l)) + l
	}
	return n
}

func (m *TimeProto) Size() (n int) {
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovKv(uint64(m.Time))
	}
	return n
}

func (m *UserMiscProto) Size() (n int) {
	var l int
	_ = l
	if m.TutorialProgress != 0 {
		n += 1 + sovKv(uint64(m.TutorialProgress))
	}
	if m.IsTutorialComplete {
		n += 2
	}
	if m.Created {
		n += 2
	}
	return n
}

func (m *NpcBaseProto) Size() (n int) {
	var l int
	_ = l
	if m.BaseRegion != 0 {
		n += 1 + sovKv(uint64(m.BaseRegion))
	}
	if m.BaseId != 0 {
		n += 1 + sovKv(uint64(m.BaseId))
	}
	if m.BaseX != 0 {
		n += 1 + sovKv(uint64(m.BaseX))
	}
	if m.BaseY != 0 {
		n += 1 + sovKv(uint64(m.BaseY))
	}
	if len(m.CaptainIndex) > 0 {
		l = 0
		for _, e := range m.CaptainIndex {
			l += sovKv(uint64(e))
		}
		n += 1 + sovKv(uint64(l)) + l
	}
	if len(m.CaptainSoldier) > 0 {
		l = 0
		for _, e := range m.CaptainSoldier {
			l += sovKv(uint64(e))
		}
		n += 1 + sovKv(uint64(l)) + l
	}
	if m.Prosperity != 0 {
		n += 1 + sovKv(uint64(m.Prosperity))
	}
	if m.GuildId != 0 {
		n += 1 + sovKv(uint64(m.GuildId))
	}
	if len(m.DefendingTroop) > 0 {
		for _, e := range m.DefendingTroop {
			l = e.Size()
			n += 1 + l + sovKv(uint64(l))
		}
	}
	if m.HeroId != 0 {
		n += 1 + sovKv(uint64(m.HeroId))
	}
	if m.HeroType != 0 {
		n += 1 + sovKv(uint64(m.HeroType))
	}
	if m.HeroEndTime != 0 {
		n += 1 + sovKv(uint64(m.HeroEndTime))
	}
	return n
}

func (m *NpcDefendingTroopProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovKv(uint64(m.Id))
	}
	if m.DataId != 0 {
		n += 1 + sovKv(uint64(m.DataId))
	}
	if len(m.CaptainIndex) > 0 {
		l = 0
		for _, e := range m.CaptainIndex {
			l += sovKv(uint64(e))
		}
		n += 1 + sovKv(uint64(l)) + l
	}
	if len(m.CaptainSoldier) > 0 {
		l = 0
		for _, e := range m.CaptainSoldier {
			l += sovKv(uint64(e))
		}
		n += 1 + sovKv(uint64(l)) + l
	}
	return n
}

func (m *TroopServerProto) Size() (n int) {
	var l int
	_ = l
	if m.RealmId != 0 {
		n += 1 + sovKv(uint64(m.RealmId))
	}
	if m.Id != 0 {
		n += 1 + sovKv(uint64(m.Id))
	}
	if m.TargetBaseId != 0 {
		n += 1 + sovKv(uint64(m.TargetBaseId))
	}
	if m.TargetBaseLevel != 0 {
		n += 1 + sovKv(uint64(m.TargetBaseLevel))
	}
	if m.TroopState != 0 {
		n += 1 + sovKv(uint64(m.TroopState))
	}
	if m.OriginTargetId != 0 {
		n += 1 + sovKv(uint64(m.OriginTargetId))
	}
	if m.BackHomeTargetX != 0 {
		n += 1 + sovKv(uint64(m.BackHomeTargetX))
	}
	if m.BackHomeTargetY != 0 {
		n += 1 + sovKv(uint64(m.BackHomeTargetY))
	}
	if m.TargetIsOwnerCanSee {
		n += 2
	}
	if m.CreateTime != 0 {
		n += 1 + sovKv(uint64(m.CreateTime))
	}
	if m.MoveSpeedRate != 0 {
		n += 10
	}
	if m.MoveStartTime != 0 {
		n += 2 + sovKv(uint64(m.MoveStartTime))
	}
	if m.MoveArriveTime != 0 {
		n += 2 + sovKv(uint64(m.MoveArriveTime))
	}
	if m.RobbingEndTime != 0 {
		n += 2 + sovKv(uint64(m.RobbingEndTime))
	}
	if m.NextReduceProsperityTime != 0 {
		n += 2 + sovKv(uint64(m.NextReduceProsperityTime))
	}
	if m.NextAddHateTime != 0 {
		n += 2 + sovKv(uint64(m.NextAddHateTime))
	}
	if m.AccumRobPrize != nil {
		l = m.AccumRobPrize.Size()
		n += 2 + l + sovKv(uint64(l))
	}
	if m.AccumReduceProsperity != 0 {
		n += 2 + sovKv(uint64(m.AccumReduceProsperity))
	}
	if len(m.Captains) > 0 {
		for _, e := range m.Captains {
			l = e.Size()
			n += 2 + l + sovKv(uint64(l))
		}
	}
	if len(m.CaptainIndex) > 0 {
		for _, e := range m.CaptainIndex {
			n += 2 + sovKv(uint64(e))
		}
	}
	if m.MonsterMasterId != 0 {
		n += 2 + sovKv(uint64(m.MonsterMasterId))
	}
	if m.AssistDefendStartTime != 0 {
		n += 2 + sovKv(uint64(m.AssistDefendStartTime))
	}
	if m.MultiLevelMonsterCount != 0 {
		n += 2 + sovKv(uint64(m.MultiLevelMonsterCount))
	}
	if m.StartingBaseId != 0 {
		n += 2 + sovKv(uint64(m.StartingBaseId))
	}
	if m.StartingBaseLevel != 0 {
		n += 2 + sovKv(uint64(m.StartingBaseLevel))
	}
	return n
}

func (m *XuanyuanModuleProto) Size() (n int) {
	var l int
	_ = l
	if len(m.RankHero) > 0 {
		for _, e := range m.RankHero {
			l = e.Size()
			n += 1 + l + sovKv(uint64(l))
		}
	}
	if len(m.Challenger) > 0 {
		for _, e := range m.Challenger {
			l = e.Size()
			n += 1 + l + sovKv(uint64(l))
		}
	}
	if m.UpdateTime != 0 {
		n += 1 + sovKv(uint64(m.UpdateTime))
	}
	return n
}

func (m *XuanyuanRankHeroProto) Size() (n int) {
	var l int
	_ = l
	if m.HeroId != 0 {
		n += 1 + sovKv(uint64(m.HeroId))
	}
	if m.Score != 0 {
		n += 1 + sovKv(uint64(m.Score))
	}
	if m.RankScore != 0 {
		n += 1 + sovKv(uint64(m.RankScore))
	}
	if m.Win != 0 {
		n += 1 + sovKv(uint64(m.Win))
	}
	if m.Lose != 0 {
		n += 1 + sovKv(uint64(m.Lose))
	}
	if m.Mirror != nil {
		l = m.Mirror.Size()
		n += 1 + l + sovKv(uint64(l))
	}
	return n
}

func (m *AllAstDefendLogProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Logs) > 0 {
		for k, v := range m.Logs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovKv(uint64(l))
			}
			mapEntrySize := 1 + sovKv(uint64(k)) + l
			n += mapEntrySize + 1 + sovKv(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AstDefendLogListProto) Size() (n int) {
	var l int
	_ = l
	if m.HeroId != 0 {
		n += 1 + sovKv(uint64(m.HeroId))
	}
	if len(m.Log) > 0 {
		for _, e := range m.Log {
			l = e.Size()
			n += 1 + l + sovKv(uint64(l))
		}
	}
	return n
}

func sovKv(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozKv(x uint64) (n int) {
	return sovKv(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TowerModuleProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerModuleProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerModuleProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replay = append(m.Replay, &proto18.TowerReplayProto{})
			if err := m.Replay[len(m.Replay)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InviteGuildRecommendHerosProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InviteGuildRecommendHerosProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InviteGuildRecommendHerosProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.HeroId = append(m.HeroId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKv
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.HeroId = append(m.HeroId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroId", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitGuildMemberCountry", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InitGuildMemberCountry = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionModuleProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionModuleProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionModuleProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeNpcBaseSequence", wireType)
			}
			m.HomeNpcBaseSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HomeNpcBaseSequence |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealmRuins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RealmRuins = append(m.RealmRuins, &RealmRuinsBasePosInfosProto{})
			if err := m.RealmRuins[len(m.RealmRuins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			m.Radius = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Radius |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NpcBaseList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NpcBaseList = append(m.NpcBaseList, &NpcBaseProto{})
			if err := m.NpcBaseList[len(m.NpcBaseList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TroopList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TroopList = append(m.TroopList, &TroopServerProto{})
			if err := m.TroopList[len(m.TroopList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaoZangNpcRefreshTime", wireType)
			}
			m.BaoZangNpcRefreshTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaoZangNpcRefreshTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JunTuanNpcRefreshTime", wireType)
			}
			m.JunTuanNpcRefreshTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JunTuanNpcRefreshTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RealmRuinsBasePosInfosProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RealmRuinsBasePosInfosProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RealmRuinsBasePosInfosProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealmId", wireType)
			}
			m.RealmId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RealmId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, &RuinsBasePosInfoProto{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuinsBasePosInfoProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuinsBasePosInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuinsBasePosInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosX", wireType)
			}
			m.PosX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PosX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosY", wireType)
			}
			m.PosY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PosY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Int64ArrayProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int64ArrayProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int64ArrayProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.V = append(m.V, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKv
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.V = append(m.V, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UInt64ArrayProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UInt64ArrayProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UInt64ArrayProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.V = append(m.V, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKv
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.V = append(m.V, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserMiscProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMiscProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMiscProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TutorialProgress", wireType)
			}
			m.TutorialProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TutorialProgress |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTutorialComplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTutorialComplete = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Created = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NpcBaseProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NpcBaseProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NpcBaseProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseRegion", wireType)
			}
			m.BaseRegion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseRegion |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseId", wireType)
			}
			m.BaseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseX", wireType)
			}
			m.BaseX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseY", wireType)
			}
			m.BaseY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainIndex = append(m.CaptainIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKv
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainIndex = append(m.CaptainIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainIndex", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainSoldier = append(m.CaptainSoldier, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKv
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainSoldier = append(m.CaptainSoldier, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainSoldier", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prosperity", wireType)
			}
			m.Prosperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prosperity |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefendingTroop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefendingTroop = append(m.DefendingTroop, &NpcDefendingTroopProto{})
			if err := m.DefendingTroop[len(m.DefendingTroop)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroId", wireType)
			}
			m.HeroId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroType", wireType)
			}
			m.HeroType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroEndTime", wireType)
			}
			m.HeroEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroEndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NpcDefendingTroopProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NpcDefendingTroopProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NpcDefendingTroopProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataId", wireType)
			}
			m.DataId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainIndex = append(m.CaptainIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKv
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainIndex = append(m.CaptainIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainIndex", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainSoldier = append(m.CaptainSoldier, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKv
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainSoldier = append(m.CaptainSoldier, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainSoldier", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TroopServerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TroopServerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TroopServerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealmId", wireType)
			}
			m.RealmId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RealmId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBaseId", wireType)
			}
			m.TargetBaseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetBaseId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBaseLevel", wireType)
			}
			m.TargetBaseLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetBaseLevel |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TroopState", wireType)
			}
			m.TroopState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TroopState |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTargetId", wireType)
			}
			m.OriginTargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginTargetId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackHomeTargetX", wireType)
			}
			m.BackHomeTargetX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackHomeTargetX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackHomeTargetY", wireType)
			}
			m.BackHomeTargetY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackHomeTargetY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetIsOwnerCanSee", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TargetIsOwnerCanSee = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveSpeedRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.MoveSpeedRate = float64(math.Float64frombits(v))
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveStartTime", wireType)
			}
			m.MoveStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveArriveTime", wireType)
			}
			m.MoveArriveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveArriveTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobbingEndTime", wireType)
			}
			m.RobbingEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobbingEndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextReduceProsperityTime", wireType)
			}
			m.NextReduceProsperityTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextReduceProsperityTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextAddHateTime", wireType)
			}
			m.NextAddHateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextAddHateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccumRobPrize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccumRobPrize == nil {
				m.AccumRobPrize = &proto1.PrizeProto{}
			}
			if err := m.AccumRobPrize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccumReduceProsperity", wireType)
			}
			m.AccumReduceProsperity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccumReduceProsperity |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Captains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Captains = append(m.Captains, &proto4.CaptainInfoProto{})
			if err := m.Captains[len(m.Captains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CaptainIndex = append(m.CaptainIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKv
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CaptainIndex = append(m.CaptainIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainIndex", wireType)
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterMasterId", wireType)
			}
			m.MonsterMasterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonsterMasterId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssistDefendStartTime", wireType)
			}
			m.AssistDefendStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssistDefendStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiLevelMonsterCount", wireType)
			}
			m.MultiLevelMonsterCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MultiLevelMonsterCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartingBaseId", wireType)
			}
			m.StartingBaseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartingBaseId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartingBaseLevel", wireType)
			}
			m.StartingBaseLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartingBaseLevel |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XuanyuanModuleProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XuanyuanModuleProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XuanyuanModuleProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankHero", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RankHero = append(m.RankHero, &XuanyuanRankHeroProto{})
			if err := m.RankHero[len(m.RankHero)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Challenger = append(m.Challenger, &XuanyuanRankHeroProto{})
			if err := m.Challenger[len(m.Challenger)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			m.UpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XuanyuanRankHeroProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XuanyuanRankHeroProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XuanyuanRankHeroProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroId", wireType)
			}
			m.HeroId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankScore", wireType)
			}
			m.RankScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankScore |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			m.Win = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Win |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lose", wireType)
			}
			m.Lose = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lose |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mirror == nil {
				m.Mirror = &proto5.CombatPlayerProto{}
			}
			if err := m.Mirror.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllAstDefendLogProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllAstDefendLogProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllAstDefendLogProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Logs == nil {
				m.Logs = make(map[int64]*AstDefendLogListProto)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthKv
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthKv
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &AstDefendLogListProto{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Logs[mapkey] = mapvalue
			} else {
				var mapvalue *AstDefendLogListProto
				m.Logs[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AstDefendLogListProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AstDefendLogListProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AstDefendLogListProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroId", wireType)
			}
			m.HeroId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Log = append(m.Log, &proto12.AstDefendLogProto{})
			if err := m.Log[len(m.Log)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipKv(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowKv
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKv
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKv
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthKv
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowKv
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipKv(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthKv = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowKv   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/server_proto/kv.proto", fileDescriptorKv)
}

var fileDescriptorKv = []byte{
	// 1810 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcd, 0x6e, 0xdb, 0xca,
	0x15, 0x0e, 0xf5, 0x67, 0xf9, 0xc8, 0xb2, 0xe8, 0x71, 0x1c, 0xd3, 0xc9, 0x8d, 0x23, 0xa8, 0x3f,
	0x57, 0x48, 0x00, 0xfb, 0xc2, 0x49, 0xf3, 0x53, 0xb4, 0x0b, 0xdb, 0x4d, 0xaf, 0x85, 0xda, 0xae,
	0x41, 0x3b, 0xa8, 0x13, 0x14, 0x20, 0x46, 0xe4, 0x44, 0x9a, 0x6b, 0x92, 0xc3, 0x0e, 0x87, 0x72,
	0x74, 0x9f, 0xa0, 0xe8, 0xa6, 0xdb, 0x2e, 0xba, 0xe9, 0xae, 0xbb, 0x3e, 0x41, 0xf7, 0x5d, 0xf6,
	0x11, 0x8a, 0x14, 0xe8, 0x73, 0x14, 0x73, 0x66, 0x28, 0xcb, 0xbe, 0xbe, 0x41, 0x0a, 0x74, 0x45,
	0xce, 0x77, 0xbe, 0x73, 0x66, 0xe6, 0xf0, 0x3b, 0x67, 0x86, 0xb0, 0x33, 0xe2, 0x6a, 0x5c, 0x0c,
	0xb7, 0x42, 0x91, 0x6c, 0xc7, 0x7c, 0x34, 0x56, 0x19, 0xbd, 0xdc, 0x4e, 0x68, 0xcc, 0x5e, 0x6c,
	0x67, 0xc3, 0xed, 0x9c, 0xc9, 0x09, 0x93, 0x41, 0x26, 0x85, 0x12, 0xdb, 0x17, 0x93, 0x2d, 0x7c,
	0x21, 0x75, 0x7c, 0xdc, 0xff, 0xc9, 0xa7, 0x5d, 0xc7, 0x54, 0xb2, 0xc8, 0xba, 0x2a, 0x71, 0xc9,
	0xa4, 0xf1, 0xbe, 0xff, 0xec, 0xf3, 0xdd, 0x86, 0x34, 0x67, 0xd6, 0xeb, 0xe5, 0xe7, 0x7b, 0x25,
	0x3c, 0xe6, 0x8a, 0xca, 0xa9, 0xf5, 0x7c, 0xfe, 0xf9, 0x9e, 0xa1, 0x48, 0x86, 0x54, 0xfd, 0xef,
	0x7e, 0x92, 0x8d, 0xb8, 0x48, 0x8d, 0x5f, 0x6f, 0x1f, 0xdc, 0x33, 0xbd, 0xdd, 0x23, 0x11, 0x15,
	0x31, 0x3b, 0xc1, 0x8c, 0x6d, 0x43, 0x43, 0xb2, 0x2c, 0xa6, 0x53, 0xcf, 0xe9, 0x56, 0xfb, 0xad,
	0x9d, 0x75, 0xc3, 0xdd, 0x42, 0xa2, 0x8f, 0x16, 0x24, 0xfa, 0x96, 0xd6, 0x53, 0xb0, 0x39, 0x48,
	0x27, 0x5c, 0xb1, 0xaf, 0x0b, 0x1e, 0x47, 0x3e, 0x0b, 0x45, 0x92, 0xb0, 0x34, 0x3a, 0x60, 0x52,
	0xe4, 0x26, 0xe4, 0x3a, 0x2c, 0x8c, 0x99, 0x14, 0x01, 0x8f, 0x30, 0x66, 0xd5, 0x6f, 0xe8, 0xe1,
	0x20, 0x22, 0xaf, 0x60, 0x83, 0xa7, 0x5c, 0x05, 0x23, 0xed, 0x19, 0x24, 0x2c, 0x19, 0x32, 0x19,
	0x84, 0xa2, 0x48, 0x95, 0x9c, 0x7a, 0x95, 0xae, 0xd3, 0x6f, 0xfa, 0xf7, 0x34, 0x01, 0x23, 0x1f,
	0xa1, 0x79, 0xdf, 0x58, 0x7b, 0x7f, 0xa8, 0xc2, 0x8a, 0x8f, 0x7b, 0x99, 0x5f, 0xfc, 0x53, 0xb8,
	0x37, 0x16, 0x09, 0x0b, 0xd2, 0x2c, 0x0c, 0xf4, 0x17, 0x09, 0x72, 0xf6, 0xbb, 0x82, 0xa5, 0x21,
	0xf3, 0xaa, 0x5d, 0xa7, 0x5f, 0xf3, 0x57, 0xb5, 0xf5, 0x38, 0x0b, 0xf7, 0x68, 0xce, 0x4e, 0xad,
	0x89, 0xec, 0x43, 0x4b, 0x32, 0x1a, 0x27, 0x81, 0x2c, 0x78, 0x9a, 0x7b, 0x35, 0xdc, 0x76, 0xcf,
	0x6e, 0xdb, 0xd7, 0x16, 0x5f, 0x1b, 0xb4, 0xcf, 0x89, 0xc8, 0x07, 0xe9, 0x7b, 0xbb, 0x2f, 0x1f,
	0xe4, 0xcc, 0x48, 0xee, 0x41, 0x43, 0xd2, 0x88, 0x17, 0xb9, 0x57, 0xc7, 0x99, 0xec, 0x88, 0xbc,
	0x80, 0xf6, 0x6c, 0x31, 0x31, 0xcf, 0x95, 0xd7, 0xc0, 0xf0, 0xab, 0x36, 0xbc, 0x5d, 0x8b, 0x89,
	0xd7, 0x4a, 0xcd, 0xe8, 0x90, 0xe7, 0x8a, 0x3c, 0x07, 0x50, 0x52, 0x88, 0xcc, 0x78, 0x2d, 0x5c,
	0xff, 0x16, 0xda, 0x70, 0x8a, 0x82, 0x37, 0x9e, 0x8b, 0x48, 0x45, 0xbf, 0x97, 0xb0, 0x31, 0xa4,
	0x22, 0xf8, 0x96, 0xa6, 0x23, 0x4c, 0x83, 0x64, 0xef, 0x25, 0xcb, 0xc7, 0x81, 0xe2, 0x09, 0xf3,
	0x9a, 0x5d, 0xa7, 0x5f, 0xf5, 0xd7, 0x86, 0x54, 0xbc, 0xa3, 0xe9, 0xe8, 0x38, 0x0b, 0x7d, 0x63,
	0x3d, 0xe3, 0x09, 0xd3, 0x9e, 0xdf, 0x14, 0x69, 0xa0, 0x0a, 0x9a, 0x7e, 0xd7, 0x73, 0xd1, 0x78,
	0x7e, 0x53, 0xa4, 0x67, 0x05, 0x4d, 0xaf, 0x7b, 0xf6, 0x62, 0x78, 0xf0, 0x89, 0x3c, 0x91, 0x0d,
	0x68, 0x9a, 0x04, 0xa3, 0x00, 0x74, 0x9c, 0x05, 0x1c, 0x0f, 0x22, 0xb2, 0x03, 0x75, 0xae, 0x89,
	0x5e, 0x05, 0x37, 0xf8, 0x45, 0x99, 0xf5, 0x1b, 0x81, 0xcc, 0x2e, 0x0d, 0xb5, 0xc7, 0x60, 0xed,
	0x56, 0x3b, 0x59, 0x86, 0xca, 0x6c, 0x86, 0x0a, 0x8f, 0x08, 0x81, 0x1a, 0xae, 0xbd, 0x82, 0x08,
	0xbe, 0x93, 0x55, 0xa8, 0x67, 0x22, 0x0f, 0x3e, 0xa0, 0x20, 0xea, 0x7e, 0x2d, 0x13, 0xf9, 0x79,
	0x09, 0x4e, 0xbd, 0xda, 0x0c, 0x7c, 0xdb, 0x7b, 0x04, 0x9d, 0x41, 0xaa, 0x9e, 0x3f, 0xdb, 0x95,
	0xd2, 0x4a, 0x9e, 0x2c, 0x81, 0x33, 0xb1, 0x12, 0x76, 0x26, 0xbd, 0x2e, 0xb8, 0x6f, 0xbe, 0x97,
	0x51, 0xd3, 0x8c, 0x47, 0xb0, 0xa8, 0xf3, 0x63, 0x4c, 0xe5, 0x6a, 0x9c, 0xab, 0xd5, 0xf4, 0x7e,
	0xef, 0x40, 0xfb, 0x4d, 0xce, 0xe4, 0x11, 0xcf, 0x43, 0xc3, 0x7a, 0x02, 0x2b, 0xaa, 0x50, 0x42,
	0x72, 0x1a, 0xeb, 0x8a, 0x1d, 0x49, 0x96, 0xe7, 0xe8, 0x52, 0xf7, 0xdd, 0xd2, 0x70, 0x62, 0x71,
	0xf2, 0x15, 0xdc, 0xe5, 0x79, 0x30, 0xe3, 0x87, 0x22, 0xc9, 0x62, 0xa6, 0x98, 0x2d, 0x1d, 0xc2,
	0xf3, 0x33, 0x6b, 0xda, 0xb7, 0x16, 0xe2, 0xc1, 0x42, 0x28, 0x19, 0x55, 0x2c, 0xc2, 0x04, 0x34,
	0xfd, 0x72, 0xd8, 0xfb, 0x4b, 0x15, 0x96, 0xe6, 0xd5, 0x48, 0x1e, 0x41, 0x0b, 0x55, 0x6b, 0x3a,
	0x86, 0x5d, 0x36, 0x68, 0xc8, 0xd4, 0x9d, 0x2e, 0x6b, 0x24, 0xf0, 0xc8, 0x66, 0xb8, 0xa1, 0x87,
	0x83, 0x88, 0xac, 0x01, 0xbe, 0xcd, 0x92, 0x5c, 0xd7, 0xa3, 0xf3, 0x19, 0x5c, 0xa6, 0x19, 0xe1,
	0xb7, 0xe4, 0x07, 0xd0, 0x0e, 0x69, 0xa6, 0x28, 0x4f, 0x03, 0x9e, 0x46, 0xec, 0x83, 0x57, 0xef,
	0x56, 0xfb, 0x75, 0x7f, 0xc9, 0x82, 0x03, 0x8d, 0x91, 0x2f, 0xa1, 0x53, 0x92, 0x72, 0x11, 0x47,
	0x9c, 0x49, 0x2c, 0xa4, 0xba, 0xbf, 0x6c, 0xe1, 0x53, 0x83, 0x92, 0x4d, 0x80, 0x4c, 0x8a, 0x3c,
	0x63, 0x92, 0xab, 0xa9, 0xb7, 0x80, 0xb5, 0x38, 0x87, 0x68, 0x2d, 0x9a, 0x6e, 0xc3, 0x23, 0x0f,
	0x8c, 0x16, 0x71, 0x3c, 0x88, 0xc8, 0x2f, 0xa1, 0x13, 0xb1, 0xf7, 0x2c, 0x8d, 0x78, 0x3a, 0x0a,
	0xb0, 0xa0, 0xbc, 0x16, 0xaa, 0xf2, 0xe1, 0x55, 0xb1, 0xfe, 0xa2, 0x24, 0x60, 0x09, 0x1a, 0x59,
	0x2e, 0x47, 0xd7, 0xc0, 0xf9, 0x76, 0xb7, 0x64, 0xf2, 0x62, 0xdb, 0xdd, 0x03, 0x58, 0x44, 0x83,
	0x9a, 0x66, 0xcc, 0x6b, 0x63, 0x0e, 0x9a, 0x1a, 0x38, 0x9b, 0x66, 0x8c, 0xf4, 0xa0, 0x8d, 0x46,
	0x96, 0x46, 0xa6, 0xe2, 0x96, 0xd1, 0xb7, 0xa5, 0xc1, 0xd7, 0x69, 0x84, 0x75, 0xf6, 0x47, 0x07,
	0xee, 0xdd, 0xbe, 0x08, 0xab, 0xfd, 0xca, 0x4c, 0xfb, 0xeb, 0xb0, 0x10, 0x51, 0x45, 0xf5, 0x22,
	0x4c, 0xeb, 0x6b, 0xe8, 0xe1, 0x20, 0xfa, 0xff, 0xa6, 0xbb, 0xf7, 0x9f, 0x26, 0xb8, 0x37, 0xbb,
	0xd1, 0xa7, 0xea, 0xfd, 0xe6, 0x32, 0x7f, 0x08, 0xcb, 0x8a, 0xca, 0x11, 0x53, 0x41, 0x29, 0xa5,
	0x2a, 0xda, 0x96, 0x0c, 0xba, 0x67, 0x04, 0xf5, 0x18, 0x56, 0xe6, 0x59, 0x31, 0x9b, 0xb0, 0x18,
	0x45, 0x54, 0xf3, 0x3b, 0x57, 0xc4, 0x43, 0x0d, 0x6b, 0xd9, 0x9a, 0xbe, 0x99, 0x2b, 0xaa, 0x98,
	0xd7, 0xe8, 0x3a, 0xfd, 0xb6, 0x6f, 0x5a, 0xe9, 0xa9, 0x46, 0x48, 0x1f, 0x5c, 0x21, 0xf9, 0x88,
	0xa7, 0x81, 0x8d, 0x39, 0x53, 0xc2, 0xb2, 0xc1, 0xcf, 0x10, 0x1e, 0x44, 0xe4, 0x09, 0x90, 0x21,
	0x0d, 0x2f, 0x02, 0x3c, 0x52, 0x2c, 0xf9, 0x83, 0xd7, 0xc2, 0x0f, 0xd7, 0xd1, 0x96, 0x03, 0x91,
	0x30, 0xc3, 0x3e, 0xbf, 0x95, 0x3c, 0x45, 0x01, 0x7c, 0x87, 0xfc, 0x96, 0x3c, 0x83, 0xf5, 0x72,
	0xf2, 0x3c, 0x10, 0x97, 0xa9, 0x3e, 0xf6, 0x68, 0x1a, 0xe4, 0xcc, 0xe8, 0xa2, 0xe9, 0xaf, 0x1a,
	0xf3, 0x20, 0xff, 0xb5, 0x36, 0xee, 0xd3, 0xf4, 0x94, 0x31, 0xbd, 0x35, 0x53, 0xad, 0x46, 0x20,
	0x1d, 0x53, 0x91, 0x06, 0xc2, 0x0e, 0xfe, 0x63, 0xe8, 0x24, 0x62, 0xc2, 0x82, 0x3c, 0x63, 0x2c,
	0x0a, 0xa4, 0xde, 0xbf, 0xdb, 0x75, 0xfa, 0x8e, 0xdf, 0xd6, 0xf0, 0xa9, 0x46, 0x7d, 0x9d, 0x82,
	0x19, 0x4f, 0x51, 0xa9, 0x4c, 0xb0, 0x15, 0x0c, 0x66, 0x78, 0x1a, 0xc5, 0x78, 0x7d, 0x70, 0x91,
	0x47, 0xa5, 0xe4, 0x13, 0x3b, 0x2b, 0x31, 0xa9, 0xd2, 0xf8, 0x2e, 0xc2, 0x25, 0x53, 0x8a, 0xe1,
	0x50, 0x57, 0xce, 0x4c, 0xc0, 0xab, 0x86, 0x69, 0x71, 0xab, 0x61, 0xf2, 0x73, 0x78, 0x90, 0xb2,
	0x0f, 0x2a, 0x90, 0x2c, 0x2a, 0x42, 0x16, 0x5c, 0x95, 0xa6, 0x71, 0xba, 0x8b, 0x4e, 0x9e, 0xa6,
	0xf8, 0xc8, 0x38, 0x99, 0x11, 0xd0, 0xfd, 0x09, 0x10, 0x74, 0xa7, 0x51, 0x14, 0x8c, 0x67, 0xa9,
	0x58, 0x43, 0xaf, 0x8e, 0xb6, 0xec, 0x46, 0xd1, 0x41, 0x99, 0x8f, 0x57, 0xd0, 0xa1, 0x61, 0x58,
	0x24, 0x81, 0x14, 0xc3, 0x20, 0x93, 0xfc, 0x5b, 0xe6, 0x6d, 0x74, 0x9d, 0x7e, 0x6b, 0x67, 0xc5,
	0x56, 0xf4, 0x89, 0xc6, 0x4c, 0x15, 0xb7, 0x91, 0xe9, 0x8b, 0x21, 0x62, 0xe4, 0x39, 0xac, 0x5b,
	0xd7, 0x9b, 0xeb, 0xf4, 0xee, 0xa3, 0xf0, 0xd6, 0x0c, 0xff, 0xc6, 0x1a, 0xc9, 0x53, 0x68, 0xda,
	0x12, 0xc9, 0xbd, 0x07, 0xd7, 0x0e, 0xed, 0xfd, 0xb2, 0xc0, 0xca, 0xe3, 0x6c, 0x46, 0x24, 0x5f,
	0xde, 0xac, 0xc9, 0x2f, 0x74, 0xb1, 0xed, 0x55, 0xdc, 0x3b, 0x37, 0xea, 0xf2, 0x31, 0xac, 0x24,
	0x22, 0xcd, 0x15, 0x93, 0x41, 0x42, 0xf1, 0xc1, 0x23, 0xef, 0xa1, 0x29, 0x04, 0x6b, 0x38, 0x42,
	0x7c, 0x10, 0x91, 0x17, 0xe0, 0xd1, 0x3c, 0xe7, 0xb9, 0x0a, 0x4c, 0x7f, 0x9a, 0xff, 0xda, 0x9b,
	0xe6, 0x34, 0x37, 0x76, 0xd3, 0x4e, 0xae, 0xbe, 0xfa, 0x2b, 0xd8, 0x48, 0x8a, 0x58, 0x71, 0x53,
	0x67, 0x41, 0x39, 0x21, 0xde, 0xcb, 0xbc, 0x47, 0x38, 0xd9, 0x3d, 0x24, 0x60, 0xc1, 0x1d, 0x19,
	0x33, 0xde, 0xcb, 0xb4, 0x0c, 0x70, 0x16, 0xad, 0x83, 0xb2, 0xa0, 0x23, 0x23, 0x83, 0x12, 0xb7,
	0x25, 0xbd, 0x05, 0xab, 0xd7, 0x99, 0xa6, 0xa8, 0x19, 0x86, 0x5f, 0x99, 0x27, 0xe3, 0x2c, 0xbd,
	0xbf, 0x39, 0xb0, 0x7a, 0x5e, 0xd0, 0x74, 0x5a, 0xd0, 0x6b, 0x37, 0xbe, 0x57, 0xb0, 0x28, 0x69,
	0x7a, 0x11, 0xe8, 0x36, 0x69, 0x6f, 0xac, 0xe5, 0x25, 0xa2, 0xa4, 0xfb, 0x34, 0xbd, 0xd0, 0xb7,
	0x51, 0x9b, 0x75, 0x69, 0x87, 0xe4, 0x67, 0x00, 0xe1, 0x98, 0xc6, 0x31, 0x4b, 0x47, 0x4c, 0xde,
	0xb8, 0x80, 0xdc, 0xee, 0x3b, 0xc7, 0xd7, 0xc5, 0x58, 0x64, 0xd1, 0x4c, 0x81, 0xa6, 0x6d, 0x81,
	0x81, 0xb0, 0x59, 0xff, 0xdd, 0x81, 0xb5, 0x5b, 0xc3, 0x5c, 0xbf, 0x0f, 0xcf, 0x1f, 0x10, 0x77,
	0xa1, 0x9e, 0x87, 0x42, 0x9a, 0x03, 0xbc, 0xe6, 0x9b, 0x01, 0x79, 0x08, 0x80, 0x5b, 0x34, 0x26,
	0xd3, 0xcd, 0x71, 0xd3, 0xa7, 0x68, 0x76, 0xa1, 0x7a, 0xc9, 0x53, 0xdb, 0x0e, 0xf5, 0xab, 0xbe,
	0x69, 0xc4, 0x22, 0x67, 0xf6, 0x26, 0x8a, 0xef, 0xe4, 0x2b, 0x68, 0x24, 0x5c, 0x4a, 0x21, 0xb1,
	0x23, 0xb6, 0x76, 0xbc, 0x52, 0x95, 0xf8, 0x1f, 0x71, 0x12, 0xd3, 0x69, 0x79, 0x97, 0xb4, 0xbc,
	0xde, 0x5f, 0x1d, 0xb8, 0xbb, 0x1b, 0xc7, 0xbb, 0xa5, 0x40, 0x0e, 0xc5, 0xa8, 0x4c, 0x79, 0x2d,
	0x16, 0xa3, 0xdc, 0x66, 0xfb, 0x47, 0x36, 0xd0, 0x6d, 0xd4, 0xad, 0x43, 0x31, 0xca, 0x5f, 0xeb,
	0xfb, 0xba, 0x8f, 0x2e, 0xf7, 0xdf, 0xc0, 0xe2, 0x0c, 0xd2, 0x0b, 0xbf, 0x60, 0x53, 0x9b, 0x02,
	0xfd, 0xaa, 0x6f, 0x83, 0x13, 0x1a, 0x17, 0x66, 0xff, 0x57, 0x1f, 0x63, 0x3e, 0xae, 0xbe, 0xe3,
	0xda, 0xdb, 0x20, 0x52, 0x7f, 0x5a, 0x79, 0xe9, 0xf4, 0x7e, 0x0b, 0x6b, 0xb7, 0x72, 0xbe, 0x3f,
	0xd3, 0x8f, 0xa1, 0x1a, 0x8b, 0x91, 0xfd, 0xe8, 0xde, 0x2d, 0xf3, 0x98, 0x39, 0x34, 0xe9, 0xf1,
	0x9f, 0x2b, 0x50, 0xfd, 0x15, 0x9b, 0x92, 0x45, 0xa8, 0xe3, 0x4f, 0x90, 0x7b, 0x87, 0x00, 0x34,
	0xcc, 0x25, 0xc8, 0x75, 0xc8, 0x2a, 0x74, 0xcc, 0xe1, 0x37, 0xab, 0x20, 0xb7, 0x42, 0x08, 0x2c,
	0x97, 0xa0, 0xc8, 0x10, 0xab, 0x92, 0x26, 0xd4, 0xb4, 0x0e, 0xdc, 0x1a, 0x69, 0xc1, 0xc2, 0x1e,
	0xe5, 0xef, 0xc6, 0x34, 0x75, 0xeb, 0x7a, 0x60, 0x7f, 0x6a, 0xdc, 0x86, 0x1e, 0x9c, 0x73, 0x91,
	0x8e, 0x8e, 0x0b, 0x77, 0x41, 0x07, 0x31, 0xff, 0x54, 0x61, 0x62, 0x7e, 0xa7, 0xdc, 0x26, 0x59,
	0x82, 0x66, 0x29, 0x2a, 0x77, 0x51, 0x87, 0x3c, 0x60, 0x43, 0xee, 0x02, 0x59, 0x06, 0x38, 0x66,
	0x97, 0x65, 0xa0, 0x96, 0x5e, 0xec, 0x11, 0x4f, 0x47, 0xa1, 0xbb, 0xa4, 0x5d, 0xf0, 0xf5, 0x37,
	0x54, 0xba, 0x6d, 0x3d, 0xc3, 0x31, 0xbb, 0x44, 0xaf, 0x65, 0xe2, 0xc2, 0xd2, 0xfc, 0xa6, 0xdd,
	0x8e, 0x9e, 0x53, 0x2f, 0xf7, 0x90, 0x27, 0x5c, 0x7d, 0xcd, 0xdf, 0xab, 0xdc, 0x75, 0x49, 0x1b,
	0x16, 0x7d, 0x16, 0x9d, 0xd0, 0xf0, 0x82, 0x29, 0x77, 0x45, 0x0f, 0xdf, 0x1c, 0x0f, 0xce, 0x82,
	0xb3, 0xd7, 0xa7, 0x67, 0x6e, 0xb4, 0xd7, 0xfd, 0xc7, 0xc7, 0x4d, 0xe7, 0x9f, 0x1f, 0x37, 0x9d,
	0x7f, 0x7d, 0xdc, 0x74, 0xfe, 0xf4, 0xef, 0xcd, 0x3b, 0x07, 0xce, 0xbb, 0xa5, 0xf9, 0xbf, 0xf1,
	0x61, 0x03, 0x1f, 0x4f, 0xff, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x2d, 0xcf, 0xbb, 0x46, 0xc1, 0x0f,
	0x00, 0x00,
}
