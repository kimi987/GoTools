// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/pb/rpcpb/login2game/login2game.proto
// DO NOT EDIT!

/*
	Package login2game is a generated protocol buffer package.

	It is generated from these files:
		github.com/lightpaw/male7/pb/rpcpb/login2game/login2game.proto

	It has these top-level messages:
		C2SCompleteQuestionnaireProto
		S2CCompleteQuestionnaireProto
		C2SBuyProductProto
		S2CBuyProductProto
*/
package login2game

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type C2SCompleteQuestionnaireProto struct {
	HeroId int64  `protobuf:"varint,1,opt,name=hero_id,json=heroId,proto3" json:"hero_id,omitempty"`
	Qnid   string `protobuf:"bytes,2,opt,name=qnid,proto3" json:"qnid,omitempty"`
}

func (m *C2SCompleteQuestionnaireProto) Reset()         { *m = C2SCompleteQuestionnaireProto{} }
func (m *C2SCompleteQuestionnaireProto) String() string { return proto.CompactTextString(m) }
func (*C2SCompleteQuestionnaireProto) ProtoMessage()    {}
func (*C2SCompleteQuestionnaireProto) Descriptor() ([]byte, []int) {
	return fileDescriptorLogin2Game, []int{0}
}

func (m *C2SCompleteQuestionnaireProto) GetHeroId() int64 {
	if m != nil {
		return m.HeroId
	}
	return 0
}

func (m *C2SCompleteQuestionnaireProto) GetQnid() string {
	if m != nil {
		return m.Qnid
	}
	return ""
}

type S2CCompleteQuestionnaireProto struct {
	Success bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Msg     string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *S2CCompleteQuestionnaireProto) Reset()         { *m = S2CCompleteQuestionnaireProto{} }
func (m *S2CCompleteQuestionnaireProto) String() string { return proto.CompactTextString(m) }
func (*S2CCompleteQuestionnaireProto) ProtoMessage()    {}
func (*S2CCompleteQuestionnaireProto) Descriptor() ([]byte, []int) {
	return fileDescriptorLogin2Game, []int{1}
}

func (m *S2CCompleteQuestionnaireProto) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *S2CCompleteQuestionnaireProto) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type C2SBuyProductProto struct {
	OrderId     string `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	OrderAmount uint64 `protobuf:"varint,2,opt,name=order_amount,json=orderAmount,proto3" json:"order_amount,omitempty"`
	OrderTime   int64  `protobuf:"varint,3,opt,name=order_time,json=orderTime,proto3" json:"order_time,omitempty"`
	Pid         uint32 `protobuf:"varint,4,opt,name=pid,proto3" json:"pid,omitempty"`
	Sid         uint32 `protobuf:"varint,5,opt,name=sid,proto3" json:"sid,omitempty"`
	HeroId      int64  `protobuf:"varint,6,opt,name=hero_id,json=heroId,proto3" json:"hero_id,omitempty"`
	ProductId   uint64 `protobuf:"varint,7,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
}

func (m *C2SBuyProductProto) Reset()                    { *m = C2SBuyProductProto{} }
func (m *C2SBuyProductProto) String() string            { return proto.CompactTextString(m) }
func (*C2SBuyProductProto) ProtoMessage()               {}
func (*C2SBuyProductProto) Descriptor() ([]byte, []int) { return fileDescriptorLogin2Game, []int{2} }

func (m *C2SBuyProductProto) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *C2SBuyProductProto) GetOrderAmount() uint64 {
	if m != nil {
		return m.OrderAmount
	}
	return 0
}

func (m *C2SBuyProductProto) GetOrderTime() int64 {
	if m != nil {
		return m.OrderTime
	}
	return 0
}

func (m *C2SBuyProductProto) GetPid() uint32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *C2SBuyProductProto) GetSid() uint32 {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *C2SBuyProductProto) GetHeroId() int64 {
	if m != nil {
		return m.HeroId
	}
	return 0
}

func (m *C2SBuyProductProto) GetProductId() uint64 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

type S2CBuyProductProto struct {
	Success bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Msg     string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *S2CBuyProductProto) Reset()                    { *m = S2CBuyProductProto{} }
func (m *S2CBuyProductProto) String() string            { return proto.CompactTextString(m) }
func (*S2CBuyProductProto) ProtoMessage()               {}
func (*S2CBuyProductProto) Descriptor() ([]byte, []int) { return fileDescriptorLogin2Game, []int{3} }

func (m *S2CBuyProductProto) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *S2CBuyProductProto) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterType((*C2SCompleteQuestionnaireProto)(nil), "proto.C2SCompleteQuestionnaireProto")
	proto.RegisterType((*S2CCompleteQuestionnaireProto)(nil), "proto.S2CCompleteQuestionnaireProto")
	proto.RegisterType((*C2SBuyProductProto)(nil), "proto.C2SBuyProductProto")
	proto.RegisterType((*S2CBuyProductProto)(nil), "proto.S2CBuyProductProto")
}
func (m *C2SCompleteQuestionnaireProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SCompleteQuestionnaireProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeroId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLogin2Game(dAtA, i, uint64(m.HeroId))
	}
	if len(m.Qnid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLogin2Game(dAtA, i, uint64(len(m.Qnid)))
		i += copy(dAtA[i:], m.Qnid)
	}
	return i, nil
}

func (m *S2CCompleteQuestionnaireProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CCompleteQuestionnaireProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLogin2Game(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *C2SBuyProductProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SBuyProductProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrderId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLogin2Game(dAtA, i, uint64(len(m.OrderId)))
		i += copy(dAtA[i:], m.OrderId)
	}
	if m.OrderAmount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLogin2Game(dAtA, i, uint64(m.OrderAmount))
	}
	if m.OrderTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLogin2Game(dAtA, i, uint64(m.OrderTime))
	}
	if m.Pid != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLogin2Game(dAtA, i, uint64(m.Pid))
	}
	if m.Sid != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintLogin2Game(dAtA, i, uint64(m.Sid))
	}
	if m.HeroId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintLogin2Game(dAtA, i, uint64(m.HeroId))
	}
	if m.ProductId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintLogin2Game(dAtA, i, uint64(m.ProductId))
	}
	return i, nil
}

func (m *S2CBuyProductProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CBuyProductProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLogin2Game(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func encodeFixed64Login2Game(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Login2Game(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintLogin2Game(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *C2SCompleteQuestionnaireProto) Size() (n int) {
	var l int
	_ = l
	if m.HeroId != 0 {
		n += 1 + sovLogin2Game(uint64(m.HeroId))
	}
	l = len(m.Qnid)
	if l > 0 {
		n += 1 + l + sovLogin2Game(uint64(l))
	}
	return n
}

func (m *S2CCompleteQuestionnaireProto) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovLogin2Game(uint64(l))
	}
	return n
}

func (m *C2SBuyProductProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovLogin2Game(uint64(l))
	}
	if m.OrderAmount != 0 {
		n += 1 + sovLogin2Game(uint64(m.OrderAmount))
	}
	if m.OrderTime != 0 {
		n += 1 + sovLogin2Game(uint64(m.OrderTime))
	}
	if m.Pid != 0 {
		n += 1 + sovLogin2Game(uint64(m.Pid))
	}
	if m.Sid != 0 {
		n += 1 + sovLogin2Game(uint64(m.Sid))
	}
	if m.HeroId != 0 {
		n += 1 + sovLogin2Game(uint64(m.HeroId))
	}
	if m.ProductId != 0 {
		n += 1 + sovLogin2Game(uint64(m.ProductId))
	}
	return n
}

func (m *S2CBuyProductProto) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovLogin2Game(uint64(l))
	}
	return n
}

func sovLogin2Game(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozLogin2Game(x uint64) (n int) {
	return sovLogin2Game(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *C2SCompleteQuestionnaireProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin2Game
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SCompleteQuestionnaireProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SCompleteQuestionnaireProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroId", wireType)
			}
			m.HeroId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin2Game
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qnid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin2Game
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin2Game
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Qnid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogin2Game(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin2Game
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CCompleteQuestionnaireProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin2Game
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CCompleteQuestionnaireProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CCompleteQuestionnaireProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin2Game
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin2Game
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin2Game
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogin2Game(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin2Game
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SBuyProductProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin2Game
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SBuyProductProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SBuyProductProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin2Game
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin2Game
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderAmount", wireType)
			}
			m.OrderAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin2Game
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderAmount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderTime", wireType)
			}
			m.OrderTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin2Game
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin2Game
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin2Game
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroId", wireType)
			}
			m.HeroId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin2Game
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin2Game
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLogin2Game(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin2Game
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CBuyProductProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin2Game
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CBuyProductProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CBuyProductProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin2Game
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin2Game
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin2Game
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogin2Game(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin2Game
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLogin2Game(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLogin2Game
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLogin2Game
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLogin2Game
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthLogin2Game
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLogin2Game
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLogin2Game(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLogin2Game = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLogin2Game   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/pb/rpcpb/login2game/login2game.proto", fileDescriptorLogin2Game)
}

var fileDescriptorLogin2Game = []byte{
	// 344 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x91, 0xbd, 0x4e, 0xc3, 0x30,
	0x10, 0xc7, 0x31, 0xfd, 0x48, 0x73, 0x80, 0x84, 0xbc, 0x10, 0x86, 0x44, 0x25, 0x53, 0xa7, 0x46,
	0x0a, 0x03, 0x1b, 0x82, 0x66, 0xa1, 0x82, 0xa1, 0x24, 0x4c, 0x2c, 0x28, 0x89, 0xad, 0xd4, 0x52,
	0x1c, 0x9b, 0xd8, 0x11, 0xe2, 0x4d, 0x78, 0x24, 0x16, 0x24, 0x1e, 0x01, 0x95, 0x17, 0x41, 0x71,
	0x5a, 0x51, 0x18, 0x90, 0x98, 0xfc, 0xbf, 0xdf, 0x9d, 0xfe, 0xbe, 0x0f, 0x38, 0x2f, 0x98, 0x5e,
	0x36, 0xd9, 0x34, 0x17, 0x3c, 0x28, 0x59, 0xb1, 0xd4, 0x32, 0x7d, 0x0a, 0x78, 0x5a, 0xd2, 0xb3,
	0x40, 0x66, 0x41, 0x2d, 0x73, 0x99, 0x05, 0xa5, 0x28, 0x58, 0x15, 0x16, 0x29, 0xa7, 0x5b, 0x72,
	0x2a, 0x6b, 0xa1, 0x05, 0x1e, 0x98, 0xc7, 0xbf, 0x01, 0x37, 0x0a, 0x93, 0x48, 0x70, 0x59, 0x52,
	0x4d, 0x6f, 0x1b, 0xaa, 0x34, 0x13, 0x55, 0x95, 0xb2, 0x9a, 0x2e, 0x4c, 0xdd, 0x11, 0x58, 0x4b,
	0x5a, 0x8b, 0x07, 0x46, 0x1c, 0x34, 0x46, 0x93, 0x5e, 0x3c, 0x6c, 0xc3, 0x39, 0xc1, 0x18, 0xfa,
	0x8f, 0x15, 0x23, 0xce, 0xee, 0x18, 0x4d, 0xec, 0xd8, 0x68, 0xff, 0x1a, 0xdc, 0x24, 0x8c, 0xfe,
	0x70, 0x73, 0xc0, 0x52, 0x4d, 0x9e, 0x53, 0xa5, 0x8c, 0xdb, 0x28, 0xde, 0x84, 0xf8, 0x10, 0x7a,
	0x5c, 0x15, 0x6b, 0xb7, 0x56, 0xfa, 0x6f, 0x08, 0x70, 0x14, 0x26, 0xb3, 0xe6, 0x79, 0x51, 0x0b,
	0xd2, 0xe4, 0xba, 0xb3, 0x38, 0x86, 0x91, 0xa8, 0x09, 0xad, 0x37, 0x1d, 0xd9, 0xb1, 0x65, 0xe2,
	0x39, 0xc1, 0x27, 0xb0, 0xdf, 0xa5, 0x52, 0x2e, 0x9a, 0x4a, 0x1b, 0xb3, 0x7e, 0xbc, 0x67, 0xd8,
	0xa5, 0x41, 0xd8, 0x05, 0xe8, 0x4a, 0x34, 0xe3, 0xd4, 0xe9, 0x99, 0x89, 0x6c, 0x43, 0xee, 0x18,
	0xa7, 0x6d, 0x17, 0x92, 0x11, 0xa7, 0x3f, 0x46, 0x93, 0x83, 0xb8, 0x95, 0x2d, 0x51, 0x8c, 0x38,
	0x83, 0x8e, 0x28, 0x46, 0xb6, 0x37, 0x32, 0xfc, 0xb1, 0x11, 0x17, 0x40, 0x76, 0x9d, 0xb6, 0x39,
	0xcb, 0x7c, 0x6e, 0xaf, 0xc9, 0x9c, 0xf8, 0x17, 0x80, 0x93, 0x30, 0xfa, 0x3d, 0xce, 0x3f, 0x36,
	0x32, 0xf3, 0x5e, 0x57, 0x1e, 0x7a, 0x5f, 0x79, 0xe8, 0x63, 0xe5, 0xa1, 0x97, 0x4f, 0x6f, 0xe7,
	0x0a, 0xdd, 0xc3, 0xf7, 0x65, 0xb3, 0xa1, 0xb9, 0xe9, 0xe9, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xf1, 0x26, 0x8a, 0x3e, 0x1c, 0x02, 0x00, 0x00,
}
