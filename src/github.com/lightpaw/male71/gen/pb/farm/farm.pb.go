// Code generated by protoc-gen-gogo.
// source: github.com/lightpaw/male7/gen/pb/farm/farm.proto
// DO NOT EDIT!

/*
	Package farm is a generated protocol buffer package.

	It is generated from these files:
		github.com/lightpaw/male7/gen/pb/farm/farm.proto

	It has these top-level messages:
		C2SPlantProto
		S2CPlantProto
		C2SHarvestProto
		S2CHarvestProto
		C2SChangeProto
		S2CChangeProto
		C2SOneKeyPlantProto
		S2COneKeyPlantProto
		C2SOneKeyHarvestProto
		S2COneKeyHarvestProto
		S2COneKeyResetProto
		C2SViewFarmProto
		S2CViewFarmProto
		C2SStealProto
		S2CStealProto
		S2CWhoStealFromMeProto
		C2SOneKeyStealProto
		S2COneKeyStealProto
		S2CWhoOneKeyStealFromMeProto
		C2SStealLogListProto
		S2CStealLogListProto
		S2CCanStealListProto
*/
package farm

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type C2SPlantProto struct {
	CubeX int32 `protobuf:"varint,1,opt,name=cube_x,json=cubeX,proto3" json:"cube_x,omitempty"`
	CubeY int32 `protobuf:"varint,2,opt,name=cube_y,json=cubeY,proto3" json:"cube_y,omitempty"`
	ResId int32 `protobuf:"varint,3,opt,name=res_id,json=resId,proto3" json:"res_id,omitempty"`
}

func (m *C2SPlantProto) Reset()                    { *m = C2SPlantProto{} }
func (m *C2SPlantProto) String() string            { return proto.CompactTextString(m) }
func (*C2SPlantProto) ProtoMessage()               {}
func (*C2SPlantProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{0} }

func (m *C2SPlantProto) GetCubeX() int32 {
	if m != nil {
		return m.CubeX
	}
	return 0
}

func (m *C2SPlantProto) GetCubeY() int32 {
	if m != nil {
		return m.CubeY
	}
	return 0
}

func (m *C2SPlantProto) GetResId() int32 {
	if m != nil {
		return m.ResId
	}
	return 0
}

type S2CPlantProto struct {
	CubeX int32 `protobuf:"varint,1,opt,name=cube_x,json=cubeX,proto3" json:"cube_x,omitempty"`
	CubeY int32 `protobuf:"varint,2,opt,name=cube_y,json=cubeY,proto3" json:"cube_y,omitempty"`
	ResId int32 `protobuf:"varint,3,opt,name=res_id,json=resId,proto3" json:"res_id,omitempty"`
}

func (m *S2CPlantProto) Reset()                    { *m = S2CPlantProto{} }
func (m *S2CPlantProto) String() string            { return proto.CompactTextString(m) }
func (*S2CPlantProto) ProtoMessage()               {}
func (*S2CPlantProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{1} }

func (m *S2CPlantProto) GetCubeX() int32 {
	if m != nil {
		return m.CubeX
	}
	return 0
}

func (m *S2CPlantProto) GetCubeY() int32 {
	if m != nil {
		return m.CubeY
	}
	return 0
}

func (m *S2CPlantProto) GetResId() int32 {
	if m != nil {
		return m.ResId
	}
	return 0
}

type C2SHarvestProto struct {
	CubeX int32 `protobuf:"varint,1,opt,name=cube_x,json=cubeX,proto3" json:"cube_x,omitempty"`
	CubeY int32 `protobuf:"varint,2,opt,name=cube_y,json=cubeY,proto3" json:"cube_y,omitempty"`
}

func (m *C2SHarvestProto) Reset()                    { *m = C2SHarvestProto{} }
func (m *C2SHarvestProto) String() string            { return proto.CompactTextString(m) }
func (*C2SHarvestProto) ProtoMessage()               {}
func (*C2SHarvestProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{2} }

func (m *C2SHarvestProto) GetCubeX() int32 {
	if m != nil {
		return m.CubeX
	}
	return 0
}

func (m *C2SHarvestProto) GetCubeY() int32 {
	if m != nil {
		return m.CubeY
	}
	return 0
}

type S2CHarvestProto struct {
	CubeX         int32 `protobuf:"varint,1,opt,name=cube_x,json=cubeX,proto3" json:"cube_x,omitempty"`
	CubeY         int32 `protobuf:"varint,2,opt,name=cube_y,json=cubeY,proto3" json:"cube_y,omitempty"`
	CurrentOutput int32 `protobuf:"varint,3,opt,name=current_output,json=currentOutput,proto3" json:"current_output,omitempty"`
}

func (m *S2CHarvestProto) Reset()                    { *m = S2CHarvestProto{} }
func (m *S2CHarvestProto) String() string            { return proto.CompactTextString(m) }
func (*S2CHarvestProto) ProtoMessage()               {}
func (*S2CHarvestProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{3} }

func (m *S2CHarvestProto) GetCubeX() int32 {
	if m != nil {
		return m.CubeX
	}
	return 0
}

func (m *S2CHarvestProto) GetCubeY() int32 {
	if m != nil {
		return m.CubeY
	}
	return 0
}

func (m *S2CHarvestProto) GetCurrentOutput() int32 {
	if m != nil {
		return m.CurrentOutput
	}
	return 0
}

type C2SChangeProto struct {
	CubeX int32 `protobuf:"varint,1,opt,name=cube_x,json=cubeX,proto3" json:"cube_x,omitempty"`
	CubeY int32 `protobuf:"varint,2,opt,name=cube_y,json=cubeY,proto3" json:"cube_y,omitempty"`
	ResId int32 `protobuf:"varint,3,opt,name=res_id,json=resId,proto3" json:"res_id,omitempty"`
}

func (m *C2SChangeProto) Reset()                    { *m = C2SChangeProto{} }
func (m *C2SChangeProto) String() string            { return proto.CompactTextString(m) }
func (*C2SChangeProto) ProtoMessage()               {}
func (*C2SChangeProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{4} }

func (m *C2SChangeProto) GetCubeX() int32 {
	if m != nil {
		return m.CubeX
	}
	return 0
}

func (m *C2SChangeProto) GetCubeY() int32 {
	if m != nil {
		return m.CubeY
	}
	return 0
}

func (m *C2SChangeProto) GetResId() int32 {
	if m != nil {
		return m.ResId
	}
	return 0
}

type S2CChangeProto struct {
	CubeX     int32 `protobuf:"varint,1,opt,name=cube_x,json=cubeX,proto3" json:"cube_x,omitempty"`
	CubeY     int32 `protobuf:"varint,2,opt,name=cube_y,json=cubeY,proto3" json:"cube_y,omitempty"`
	ResId     int32 `protobuf:"varint,3,opt,name=res_id,json=resId,proto3" json:"res_id,omitempty"`
	OldResId  int32 `protobuf:"varint,5,opt,name=old_res_id,json=oldResId,proto3" json:"old_res_id,omitempty"`
	OldOutput int32 `protobuf:"varint,6,opt,name=old_output,json=oldOutput,proto3" json:"old_output,omitempty"`
}

func (m *S2CChangeProto) Reset()                    { *m = S2CChangeProto{} }
func (m *S2CChangeProto) String() string            { return proto.CompactTextString(m) }
func (*S2CChangeProto) ProtoMessage()               {}
func (*S2CChangeProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{5} }

func (m *S2CChangeProto) GetCubeX() int32 {
	if m != nil {
		return m.CubeX
	}
	return 0
}

func (m *S2CChangeProto) GetCubeY() int32 {
	if m != nil {
		return m.CubeY
	}
	return 0
}

func (m *S2CChangeProto) GetResId() int32 {
	if m != nil {
		return m.ResId
	}
	return 0
}

func (m *S2CChangeProto) GetOldResId() int32 {
	if m != nil {
		return m.OldResId
	}
	return 0
}

func (m *S2CChangeProto) GetOldOutput() int32 {
	if m != nil {
		return m.OldOutput
	}
	return 0
}

type C2SOneKeyPlantProto struct {
	GoldConfId  int32 `protobuf:"varint,1,opt,name=gold_conf_id,json=goldConfId,proto3" json:"gold_conf_id,omitempty"`
	StoneConfId int32 `protobuf:"varint,2,opt,name=stone_conf_id,json=stoneConfId,proto3" json:"stone_conf_id,omitempty"`
	GoldCount   int32 `protobuf:"varint,3,opt,name=gold_count,json=goldCount,proto3" json:"gold_count,omitempty"`
	StoneCount  int32 `protobuf:"varint,4,opt,name=stone_count,json=stoneCount,proto3" json:"stone_count,omitempty"`
}

func (m *C2SOneKeyPlantProto) Reset()                    { *m = C2SOneKeyPlantProto{} }
func (m *C2SOneKeyPlantProto) String() string            { return proto.CompactTextString(m) }
func (*C2SOneKeyPlantProto) ProtoMessage()               {}
func (*C2SOneKeyPlantProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{6} }

func (m *C2SOneKeyPlantProto) GetGoldConfId() int32 {
	if m != nil {
		return m.GoldConfId
	}
	return 0
}

func (m *C2SOneKeyPlantProto) GetStoneConfId() int32 {
	if m != nil {
		return m.StoneConfId
	}
	return 0
}

func (m *C2SOneKeyPlantProto) GetGoldCount() int32 {
	if m != nil {
		return m.GoldCount
	}
	return 0
}

func (m *C2SOneKeyPlantProto) GetStoneCount() int32 {
	if m != nil {
		return m.StoneCount
	}
	return 0
}

type S2COneKeyPlantProto struct {
	CubeX []int32 `protobuf:"varint,1,rep,name=cube_x,json=cubeX" json:"cube_x,omitempty"`
	CubeY []int32 `protobuf:"varint,2,rep,name=cube_y,json=cubeY" json:"cube_y,omitempty"`
	ResId []int32 `protobuf:"varint,3,rep,name=res_id,json=resId" json:"res_id,omitempty"`
}

func (m *S2COneKeyPlantProto) Reset()                    { *m = S2COneKeyPlantProto{} }
func (m *S2COneKeyPlantProto) String() string            { return proto.CompactTextString(m) }
func (*S2COneKeyPlantProto) ProtoMessage()               {}
func (*S2COneKeyPlantProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{7} }

func (m *S2COneKeyPlantProto) GetCubeX() []int32 {
	if m != nil {
		return m.CubeX
	}
	return nil
}

func (m *S2COneKeyPlantProto) GetCubeY() []int32 {
	if m != nil {
		return m.CubeY
	}
	return nil
}

func (m *S2COneKeyPlantProto) GetResId() []int32 {
	if m != nil {
		return m.ResId
	}
	return nil
}

type C2SOneKeyHarvestProto struct {
	ResType int32 `protobuf:"varint,1,opt,name=res_type,json=resType,proto3" json:"res_type,omitempty"`
}

func (m *C2SOneKeyHarvestProto) Reset()                    { *m = C2SOneKeyHarvestProto{} }
func (m *C2SOneKeyHarvestProto) String() string            { return proto.CompactTextString(m) }
func (*C2SOneKeyHarvestProto) ProtoMessage()               {}
func (*C2SOneKeyHarvestProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{8} }

func (m *C2SOneKeyHarvestProto) GetResType() int32 {
	if m != nil {
		return m.ResType
	}
	return 0
}

type S2COneKeyHarvestProto struct {
	CubeX       []int32 `protobuf:"varint,3,rep,name=cube_x,json=cubeX" json:"cube_x,omitempty"`
	CubeY       []int32 `protobuf:"varint,4,rep,name=cube_y,json=cubeY" json:"cube_y,omitempty"`
	GoldOutput  []int32 `protobuf:"varint,1,rep,name=gold_output,json=goldOutput" json:"gold_output,omitempty"`
	StoneOutput []int32 `protobuf:"varint,2,rep,name=stone_output,json=stoneOutput" json:"stone_output,omitempty"`
}

func (m *S2COneKeyHarvestProto) Reset()                    { *m = S2COneKeyHarvestProto{} }
func (m *S2COneKeyHarvestProto) String() string            { return proto.CompactTextString(m) }
func (*S2COneKeyHarvestProto) ProtoMessage()               {}
func (*S2COneKeyHarvestProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{9} }

func (m *S2COneKeyHarvestProto) GetCubeX() []int32 {
	if m != nil {
		return m.CubeX
	}
	return nil
}

func (m *S2COneKeyHarvestProto) GetCubeY() []int32 {
	if m != nil {
		return m.CubeY
	}
	return nil
}

func (m *S2COneKeyHarvestProto) GetGoldOutput() []int32 {
	if m != nil {
		return m.GoldOutput
	}
	return nil
}

func (m *S2COneKeyHarvestProto) GetStoneOutput() []int32 {
	if m != nil {
		return m.StoneOutput
	}
	return nil
}

type S2COneKeyResetProto struct {
	CubeX       []int32 `protobuf:"varint,1,rep,name=cube_x,json=cubeX" json:"cube_x,omitempty"`
	CubeY       []int32 `protobuf:"varint,2,rep,name=cube_y,json=cubeY" json:"cube_y,omitempty"`
	GoldOutput  []int32 `protobuf:"varint,3,rep,name=gold_output,json=goldOutput" json:"gold_output,omitempty"`
	StoneOutput []int32 `protobuf:"varint,4,rep,name=stone_output,json=stoneOutput" json:"stone_output,omitempty"`
}

func (m *S2COneKeyResetProto) Reset()                    { *m = S2COneKeyResetProto{} }
func (m *S2COneKeyResetProto) String() string            { return proto.CompactTextString(m) }
func (*S2COneKeyResetProto) ProtoMessage()               {}
func (*S2COneKeyResetProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{10} }

func (m *S2COneKeyResetProto) GetCubeX() []int32 {
	if m != nil {
		return m.CubeX
	}
	return nil
}

func (m *S2COneKeyResetProto) GetCubeY() []int32 {
	if m != nil {
		return m.CubeY
	}
	return nil
}

func (m *S2COneKeyResetProto) GetGoldOutput() []int32 {
	if m != nil {
		return m.GoldOutput
	}
	return nil
}

func (m *S2COneKeyResetProto) GetStoneOutput() []int32 {
	if m != nil {
		return m.StoneOutput
	}
	return nil
}

type C2SViewFarmProto struct {
	Target  []byte `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	OpenWin bool   `protobuf:"varint,2,opt,name=open_win,json=openWin,proto3" json:"open_win,omitempty"`
}

func (m *C2SViewFarmProto) Reset()                    { *m = C2SViewFarmProto{} }
func (m *C2SViewFarmProto) String() string            { return proto.CompactTextString(m) }
func (*C2SViewFarmProto) ProtoMessage()               {}
func (*C2SViewFarmProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{11} }

func (m *C2SViewFarmProto) GetTarget() []byte {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *C2SViewFarmProto) GetOpenWin() bool {
	if m != nil {
		return m.OpenWin
	}
	return false
}

type S2CViewFarmProto struct {
	Target         []byte  `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	TargetBasic    []byte  `protobuf:"bytes,11,opt,name=target_basic,json=targetBasic,proto3" json:"target_basic,omitempty"`
	HeroFarm       []byte  `protobuf:"bytes,2,opt,name=hero_farm,json=heroFarm,proto3" json:"hero_farm,omitempty"`
	NextLevelCubeX []int32 `protobuf:"varint,7,rep,name=next_level_cube_x,json=nextLevelCubeX" json:"next_level_cube_x,omitempty"`
	NextLevelCubeY []int32 `protobuf:"varint,8,rep,name=next_level_cube_y,json=nextLevelCubeY" json:"next_level_cube_y,omitempty"`
	CanSteal       bool    `protobuf:"varint,12,opt,name=can_steal,json=canSteal,proto3" json:"can_steal,omitempty"`
}

func (m *S2CViewFarmProto) Reset()                    { *m = S2CViewFarmProto{} }
func (m *S2CViewFarmProto) String() string            { return proto.CompactTextString(m) }
func (*S2CViewFarmProto) ProtoMessage()               {}
func (*S2CViewFarmProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{12} }

func (m *S2CViewFarmProto) GetTarget() []byte {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *S2CViewFarmProto) GetTargetBasic() []byte {
	if m != nil {
		return m.TargetBasic
	}
	return nil
}

func (m *S2CViewFarmProto) GetHeroFarm() []byte {
	if m != nil {
		return m.HeroFarm
	}
	return nil
}

func (m *S2CViewFarmProto) GetNextLevelCubeX() []int32 {
	if m != nil {
		return m.NextLevelCubeX
	}
	return nil
}

func (m *S2CViewFarmProto) GetNextLevelCubeY() []int32 {
	if m != nil {
		return m.NextLevelCubeY
	}
	return nil
}

func (m *S2CViewFarmProto) GetCanSteal() bool {
	if m != nil {
		return m.CanSteal
	}
	return false
}

type C2SStealProto struct {
	Target []byte `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	CubeX  int32  `protobuf:"varint,2,opt,name=cube_x,json=cubeX,proto3" json:"cube_x,omitempty"`
	CubeY  int32  `protobuf:"varint,3,opt,name=cube_y,json=cubeY,proto3" json:"cube_y,omitempty"`
}

func (m *C2SStealProto) Reset()                    { *m = C2SStealProto{} }
func (m *C2SStealProto) String() string            { return proto.CompactTextString(m) }
func (*C2SStealProto) ProtoMessage()               {}
func (*C2SStealProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{13} }

func (m *C2SStealProto) GetTarget() []byte {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *C2SStealProto) GetCubeX() int32 {
	if m != nil {
		return m.CubeX
	}
	return 0
}

func (m *C2SStealProto) GetCubeY() int32 {
	if m != nil {
		return m.CubeY
	}
	return 0
}

type S2CStealProto struct {
	Target      []byte `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	CubeX       int32  `protobuf:"varint,2,opt,name=cube_x,json=cubeX,proto3" json:"cube_x,omitempty"`
	CubeY       int32  `protobuf:"varint,3,opt,name=cube_y,json=cubeY,proto3" json:"cube_y,omitempty"`
	StealOutput int32  `protobuf:"varint,4,opt,name=steal_output,json=stealOutput,proto3" json:"steal_output,omitempty"`
}

func (m *S2CStealProto) Reset()                    { *m = S2CStealProto{} }
func (m *S2CStealProto) String() string            { return proto.CompactTextString(m) }
func (*S2CStealProto) ProtoMessage()               {}
func (*S2CStealProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{14} }

func (m *S2CStealProto) GetTarget() []byte {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *S2CStealProto) GetCubeX() int32 {
	if m != nil {
		return m.CubeX
	}
	return 0
}

func (m *S2CStealProto) GetCubeY() int32 {
	if m != nil {
		return m.CubeY
	}
	return 0
}

func (m *S2CStealProto) GetStealOutput() int32 {
	if m != nil {
		return m.StealOutput
	}
	return 0
}

type S2CWhoStealFromMeProto struct {
	Target      []byte `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	GoldOutput  int32  `protobuf:"varint,7,opt,name=gold_output,json=goldOutput,proto3" json:"gold_output,omitempty"`
	StoneOutput int32  `protobuf:"varint,8,opt,name=stone_output,json=stoneOutput,proto3" json:"stone_output,omitempty"`
}

func (m *S2CWhoStealFromMeProto) Reset()                    { *m = S2CWhoStealFromMeProto{} }
func (m *S2CWhoStealFromMeProto) String() string            { return proto.CompactTextString(m) }
func (*S2CWhoStealFromMeProto) ProtoMessage()               {}
func (*S2CWhoStealFromMeProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{15} }

func (m *S2CWhoStealFromMeProto) GetTarget() []byte {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *S2CWhoStealFromMeProto) GetGoldOutput() int32 {
	if m != nil {
		return m.GoldOutput
	}
	return 0
}

func (m *S2CWhoStealFromMeProto) GetStoneOutput() int32 {
	if m != nil {
		return m.StoneOutput
	}
	return 0
}

type C2SOneKeyStealProto struct {
	Target []byte `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
}

func (m *C2SOneKeyStealProto) Reset()                    { *m = C2SOneKeyStealProto{} }
func (m *C2SOneKeyStealProto) String() string            { return proto.CompactTextString(m) }
func (*C2SOneKeyStealProto) ProtoMessage()               {}
func (*C2SOneKeyStealProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{16} }

func (m *C2SOneKeyStealProto) GetTarget() []byte {
	if m != nil {
		return m.Target
	}
	return nil
}

type S2COneKeyStealProto struct {
	GoldOutput      int32   `protobuf:"varint,1,opt,name=gold_output,json=goldOutput,proto3" json:"gold_output,omitempty"`
	StoneOutput     int32   `protobuf:"varint,2,opt,name=stone_output,json=stoneOutput,proto3" json:"stone_output,omitempty"`
	CubeX           []int32 `protobuf:"varint,3,rep,name=cube_x,json=cubeX" json:"cube_x,omitempty"`
	CubeY           []int32 `protobuf:"varint,4,rep,name=cube_y,json=cubeY" json:"cube_y,omitempty"`
	CubeGoldOutput  []int32 `protobuf:"varint,5,rep,name=cube_gold_output,json=cubeGoldOutput" json:"cube_gold_output,omitempty"`
	CubeStoneOutput []int32 `protobuf:"varint,6,rep,name=cube_stone_output,json=cubeStoneOutput" json:"cube_stone_output,omitempty"`
}

func (m *S2COneKeyStealProto) Reset()                    { *m = S2COneKeyStealProto{} }
func (m *S2COneKeyStealProto) String() string            { return proto.CompactTextString(m) }
func (*S2COneKeyStealProto) ProtoMessage()               {}
func (*S2COneKeyStealProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{17} }

func (m *S2COneKeyStealProto) GetGoldOutput() int32 {
	if m != nil {
		return m.GoldOutput
	}
	return 0
}

func (m *S2COneKeyStealProto) GetStoneOutput() int32 {
	if m != nil {
		return m.StoneOutput
	}
	return 0
}

func (m *S2COneKeyStealProto) GetCubeX() []int32 {
	if m != nil {
		return m.CubeX
	}
	return nil
}

func (m *S2COneKeyStealProto) GetCubeY() []int32 {
	if m != nil {
		return m.CubeY
	}
	return nil
}

func (m *S2COneKeyStealProto) GetCubeGoldOutput() []int32 {
	if m != nil {
		return m.CubeGoldOutput
	}
	return nil
}

func (m *S2COneKeyStealProto) GetCubeStoneOutput() []int32 {
	if m != nil {
		return m.CubeStoneOutput
	}
	return nil
}

type S2CWhoOneKeyStealFromMeProto struct {
	TargetId   []byte  `protobuf:"bytes,4,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
	CubeX      []int32 `protobuf:"varint,1,rep,name=cube_x,json=cubeX" json:"cube_x,omitempty"`
	CubeY      []int32 `protobuf:"varint,2,rep,name=cube_y,json=cubeY" json:"cube_y,omitempty"`
	StealTimes []int32 `protobuf:"varint,3,rep,name=steal_times,json=stealTimes" json:"steal_times,omitempty"`
}

func (m *S2CWhoOneKeyStealFromMeProto) Reset()         { *m = S2CWhoOneKeyStealFromMeProto{} }
func (m *S2CWhoOneKeyStealFromMeProto) String() string { return proto.CompactTextString(m) }
func (*S2CWhoOneKeyStealFromMeProto) ProtoMessage()    {}
func (*S2CWhoOneKeyStealFromMeProto) Descriptor() ([]byte, []int) {
	return fileDescriptorFarm, []int{18}
}

func (m *S2CWhoOneKeyStealFromMeProto) GetTargetId() []byte {
	if m != nil {
		return m.TargetId
	}
	return nil
}

func (m *S2CWhoOneKeyStealFromMeProto) GetCubeX() []int32 {
	if m != nil {
		return m.CubeX
	}
	return nil
}

func (m *S2CWhoOneKeyStealFromMeProto) GetCubeY() []int32 {
	if m != nil {
		return m.CubeY
	}
	return nil
}

func (m *S2CWhoOneKeyStealFromMeProto) GetStealTimes() []int32 {
	if m != nil {
		return m.StealTimes
	}
	return nil
}

type C2SStealLogListProto struct {
	Target []byte `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	Newest bool   `protobuf:"varint,3,opt,name=newest,proto3" json:"newest,omitempty"`
}

func (m *C2SStealLogListProto) Reset()                    { *m = C2SStealLogListProto{} }
func (m *C2SStealLogListProto) String() string            { return proto.CompactTextString(m) }
func (*C2SStealLogListProto) ProtoMessage()               {}
func (*C2SStealLogListProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{19} }

func (m *C2SStealLogListProto) GetTarget() []byte {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *C2SStealLogListProto) GetNewest() bool {
	if m != nil {
		return m.Newest
	}
	return false
}

type S2CStealLogListProto struct {
	Newest bool   `protobuf:"varint,2,opt,name=newest,proto3" json:"newest,omitempty"`
	Logs   []byte `protobuf:"bytes,1,opt,name=logs,proto3" json:"logs,omitempty"`
}

func (m *S2CStealLogListProto) Reset()                    { *m = S2CStealLogListProto{} }
func (m *S2CStealLogListProto) String() string            { return proto.CompactTextString(m) }
func (*S2CStealLogListProto) ProtoMessage()               {}
func (*S2CStealLogListProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{20} }

func (m *S2CStealLogListProto) GetNewest() bool {
	if m != nil {
		return m.Newest
	}
	return false
}

func (m *S2CStealLogListProto) GetLogs() []byte {
	if m != nil {
		return m.Logs
	}
	return nil
}

type S2CCanStealListProto struct {
	CanStealId [][]byte `protobuf:"bytes,3,rep,name=can_steal_id,json=canStealId" json:"can_steal_id,omitempty"`
}

func (m *S2CCanStealListProto) Reset()                    { *m = S2CCanStealListProto{} }
func (m *S2CCanStealListProto) String() string            { return proto.CompactTextString(m) }
func (*S2CCanStealListProto) ProtoMessage()               {}
func (*S2CCanStealListProto) Descriptor() ([]byte, []int) { return fileDescriptorFarm, []int{21} }

func (m *S2CCanStealListProto) GetCanStealId() [][]byte {
	if m != nil {
		return m.CanStealId
	}
	return nil
}

func init() {
	proto.RegisterType((*C2SPlantProto)(nil), "proto.C2SPlantProto")
	proto.RegisterType((*S2CPlantProto)(nil), "proto.S2CPlantProto")
	proto.RegisterType((*C2SHarvestProto)(nil), "proto.C2SHarvestProto")
	proto.RegisterType((*S2CHarvestProto)(nil), "proto.S2CHarvestProto")
	proto.RegisterType((*C2SChangeProto)(nil), "proto.C2SChangeProto")
	proto.RegisterType((*S2CChangeProto)(nil), "proto.S2CChangeProto")
	proto.RegisterType((*C2SOneKeyPlantProto)(nil), "proto.C2SOneKeyPlantProto")
	proto.RegisterType((*S2COneKeyPlantProto)(nil), "proto.S2COneKeyPlantProto")
	proto.RegisterType((*C2SOneKeyHarvestProto)(nil), "proto.C2SOneKeyHarvestProto")
	proto.RegisterType((*S2COneKeyHarvestProto)(nil), "proto.S2COneKeyHarvestProto")
	proto.RegisterType((*S2COneKeyResetProto)(nil), "proto.S2COneKeyResetProto")
	proto.RegisterType((*C2SViewFarmProto)(nil), "proto.C2SViewFarmProto")
	proto.RegisterType((*S2CViewFarmProto)(nil), "proto.S2CViewFarmProto")
	proto.RegisterType((*C2SStealProto)(nil), "proto.C2SStealProto")
	proto.RegisterType((*S2CStealProto)(nil), "proto.S2CStealProto")
	proto.RegisterType((*S2CWhoStealFromMeProto)(nil), "proto.S2CWhoStealFromMeProto")
	proto.RegisterType((*C2SOneKeyStealProto)(nil), "proto.C2SOneKeyStealProto")
	proto.RegisterType((*S2COneKeyStealProto)(nil), "proto.S2COneKeyStealProto")
	proto.RegisterType((*S2CWhoOneKeyStealFromMeProto)(nil), "proto.S2CWhoOneKeyStealFromMeProto")
	proto.RegisterType((*C2SStealLogListProto)(nil), "proto.C2SStealLogListProto")
	proto.RegisterType((*S2CStealLogListProto)(nil), "proto.S2CStealLogListProto")
	proto.RegisterType((*S2CCanStealListProto)(nil), "proto.S2CCanStealListProto")
}
func (m *C2SPlantProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SPlantProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CubeX != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeX))
	}
	if m.CubeY != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeY))
	}
	if m.ResId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.ResId))
	}
	return i, nil
}

func (m *S2CPlantProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CPlantProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CubeX != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeX))
	}
	if m.CubeY != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeY))
	}
	if m.ResId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.ResId))
	}
	return i, nil
}

func (m *C2SHarvestProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SHarvestProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CubeX != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeX))
	}
	if m.CubeY != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeY))
	}
	return i, nil
}

func (m *S2CHarvestProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CHarvestProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CubeX != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeX))
	}
	if m.CubeY != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeY))
	}
	if m.CurrentOutput != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CurrentOutput))
	}
	return i, nil
}

func (m *C2SChangeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SChangeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CubeX != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeX))
	}
	if m.CubeY != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeY))
	}
	if m.ResId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.ResId))
	}
	return i, nil
}

func (m *S2CChangeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CChangeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CubeX != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeX))
	}
	if m.CubeY != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeY))
	}
	if m.ResId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.ResId))
	}
	if m.OldResId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.OldResId))
	}
	if m.OldOutput != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.OldOutput))
	}
	return i, nil
}

func (m *C2SOneKeyPlantProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SOneKeyPlantProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GoldConfId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.GoldConfId))
	}
	if m.StoneConfId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.StoneConfId))
	}
	if m.GoldCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.GoldCount))
	}
	if m.StoneCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.StoneCount))
	}
	return i, nil
}

func (m *S2COneKeyPlantProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2COneKeyPlantProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CubeX) > 0 {
		for _, num := range m.CubeX {
			dAtA[i] = 0x8
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	if len(m.CubeY) > 0 {
		for _, num := range m.CubeY {
			dAtA[i] = 0x10
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	if len(m.ResId) > 0 {
		for _, num := range m.ResId {
			dAtA[i] = 0x18
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *C2SOneKeyHarvestProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SOneKeyHarvestProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.ResType))
	}
	return i, nil
}

func (m *S2COneKeyHarvestProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2COneKeyHarvestProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GoldOutput) > 0 {
		for _, num := range m.GoldOutput {
			dAtA[i] = 0x8
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	if len(m.StoneOutput) > 0 {
		for _, num := range m.StoneOutput {
			dAtA[i] = 0x10
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	if len(m.CubeX) > 0 {
		for _, num := range m.CubeX {
			dAtA[i] = 0x18
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	if len(m.CubeY) > 0 {
		for _, num := range m.CubeY {
			dAtA[i] = 0x20
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *S2COneKeyResetProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2COneKeyResetProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CubeX) > 0 {
		for _, num := range m.CubeX {
			dAtA[i] = 0x8
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	if len(m.CubeY) > 0 {
		for _, num := range m.CubeY {
			dAtA[i] = 0x10
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	if len(m.GoldOutput) > 0 {
		for _, num := range m.GoldOutput {
			dAtA[i] = 0x18
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	if len(m.StoneOutput) > 0 {
		for _, num := range m.StoneOutput {
			dAtA[i] = 0x20
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *C2SViewFarmProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SViewFarmProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Target) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFarm(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if m.OpenWin {
		dAtA[i] = 0x10
		i++
		if m.OpenWin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *S2CViewFarmProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CViewFarmProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Target) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFarm(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if len(m.HeroFarm) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFarm(dAtA, i, uint64(len(m.HeroFarm)))
		i += copy(dAtA[i:], m.HeroFarm)
	}
	if len(m.NextLevelCubeX) > 0 {
		for _, num := range m.NextLevelCubeX {
			dAtA[i] = 0x38
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	if len(m.NextLevelCubeY) > 0 {
		for _, num := range m.NextLevelCubeY {
			dAtA[i] = 0x40
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	if len(m.TargetBasic) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintFarm(dAtA, i, uint64(len(m.TargetBasic)))
		i += copy(dAtA[i:], m.TargetBasic)
	}
	if m.CanSteal {
		dAtA[i] = 0x60
		i++
		if m.CanSteal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *C2SStealProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SStealProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Target) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFarm(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if m.CubeX != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeX))
	}
	if m.CubeY != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeY))
	}
	return i, nil
}

func (m *S2CStealProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CStealProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Target) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFarm(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if m.CubeX != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeX))
	}
	if m.CubeY != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.CubeY))
	}
	if m.StealOutput != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.StealOutput))
	}
	return i, nil
}

func (m *S2CWhoStealFromMeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CWhoStealFromMeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Target) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFarm(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if m.GoldOutput != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.GoldOutput))
	}
	if m.StoneOutput != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.StoneOutput))
	}
	return i, nil
}

func (m *C2SOneKeyStealProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SOneKeyStealProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Target) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFarm(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	return i, nil
}

func (m *S2COneKeyStealProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2COneKeyStealProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GoldOutput != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.GoldOutput))
	}
	if m.StoneOutput != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFarm(dAtA, i, uint64(m.StoneOutput))
	}
	if len(m.CubeX) > 0 {
		for _, num := range m.CubeX {
			dAtA[i] = 0x18
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	if len(m.CubeY) > 0 {
		for _, num := range m.CubeY {
			dAtA[i] = 0x20
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	if len(m.CubeGoldOutput) > 0 {
		for _, num := range m.CubeGoldOutput {
			dAtA[i] = 0x28
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	if len(m.CubeStoneOutput) > 0 {
		for _, num := range m.CubeStoneOutput {
			dAtA[i] = 0x30
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *S2CWhoOneKeyStealFromMeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CWhoOneKeyStealFromMeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CubeX) > 0 {
		for _, num := range m.CubeX {
			dAtA[i] = 0x8
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	if len(m.CubeY) > 0 {
		for _, num := range m.CubeY {
			dAtA[i] = 0x10
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	if len(m.StealTimes) > 0 {
		for _, num := range m.StealTimes {
			dAtA[i] = 0x18
			i++
			i = encodeVarintFarm(dAtA, i, uint64(num))
		}
	}
	if len(m.TargetId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFarm(dAtA, i, uint64(len(m.TargetId)))
		i += copy(dAtA[i:], m.TargetId)
	}
	return i, nil
}

func (m *C2SStealLogListProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SStealLogListProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Target) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFarm(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if m.Newest {
		dAtA[i] = 0x18
		i++
		if m.Newest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *S2CStealLogListProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CStealLogListProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Logs) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFarm(dAtA, i, uint64(len(m.Logs)))
		i += copy(dAtA[i:], m.Logs)
	}
	if m.Newest {
		dAtA[i] = 0x10
		i++
		if m.Newest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *S2CCanStealListProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CCanStealListProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CanStealId) > 0 {
		for _, b := range m.CanStealId {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintFarm(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func encodeFixed64Farm(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Farm(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintFarm(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *C2SPlantProto) Size() (n int) {
	var l int
	_ = l
	if m.CubeX != 0 {
		n += 1 + sovFarm(uint64(m.CubeX))
	}
	if m.CubeY != 0 {
		n += 1 + sovFarm(uint64(m.CubeY))
	}
	if m.ResId != 0 {
		n += 1 + sovFarm(uint64(m.ResId))
	}
	return n
}

func (m *S2CPlantProto) Size() (n int) {
	var l int
	_ = l
	if m.CubeX != 0 {
		n += 1 + sovFarm(uint64(m.CubeX))
	}
	if m.CubeY != 0 {
		n += 1 + sovFarm(uint64(m.CubeY))
	}
	if m.ResId != 0 {
		n += 1 + sovFarm(uint64(m.ResId))
	}
	return n
}

func (m *C2SHarvestProto) Size() (n int) {
	var l int
	_ = l
	if m.CubeX != 0 {
		n += 1 + sovFarm(uint64(m.CubeX))
	}
	if m.CubeY != 0 {
		n += 1 + sovFarm(uint64(m.CubeY))
	}
	return n
}

func (m *S2CHarvestProto) Size() (n int) {
	var l int
	_ = l
	if m.CubeX != 0 {
		n += 1 + sovFarm(uint64(m.CubeX))
	}
	if m.CubeY != 0 {
		n += 1 + sovFarm(uint64(m.CubeY))
	}
	if m.CurrentOutput != 0 {
		n += 1 + sovFarm(uint64(m.CurrentOutput))
	}
	return n
}

func (m *C2SChangeProto) Size() (n int) {
	var l int
	_ = l
	if m.CubeX != 0 {
		n += 1 + sovFarm(uint64(m.CubeX))
	}
	if m.CubeY != 0 {
		n += 1 + sovFarm(uint64(m.CubeY))
	}
	if m.ResId != 0 {
		n += 1 + sovFarm(uint64(m.ResId))
	}
	return n
}

func (m *S2CChangeProto) Size() (n int) {
	var l int
	_ = l
	if m.CubeX != 0 {
		n += 1 + sovFarm(uint64(m.CubeX))
	}
	if m.CubeY != 0 {
		n += 1 + sovFarm(uint64(m.CubeY))
	}
	if m.ResId != 0 {
		n += 1 + sovFarm(uint64(m.ResId))
	}
	if m.OldResId != 0 {
		n += 1 + sovFarm(uint64(m.OldResId))
	}
	if m.OldOutput != 0 {
		n += 1 + sovFarm(uint64(m.OldOutput))
	}
	return n
}

func (m *C2SOneKeyPlantProto) Size() (n int) {
	var l int
	_ = l
	if m.GoldConfId != 0 {
		n += 1 + sovFarm(uint64(m.GoldConfId))
	}
	if m.StoneConfId != 0 {
		n += 1 + sovFarm(uint64(m.StoneConfId))
	}
	if m.GoldCount != 0 {
		n += 1 + sovFarm(uint64(m.GoldCount))
	}
	if m.StoneCount != 0 {
		n += 1 + sovFarm(uint64(m.StoneCount))
	}
	return n
}

func (m *S2COneKeyPlantProto) Size() (n int) {
	var l int
	_ = l
	if len(m.CubeX) > 0 {
		for _, e := range m.CubeX {
			n += 1 + sovFarm(uint64(e))
		}
	}
	if len(m.CubeY) > 0 {
		for _, e := range m.CubeY {
			n += 1 + sovFarm(uint64(e))
		}
	}
	if len(m.ResId) > 0 {
		for _, e := range m.ResId {
			n += 1 + sovFarm(uint64(e))
		}
	}
	return n
}

func (m *C2SOneKeyHarvestProto) Size() (n int) {
	var l int
	_ = l
	if m.ResType != 0 {
		n += 1 + sovFarm(uint64(m.ResType))
	}
	return n
}

func (m *S2COneKeyHarvestProto) Size() (n int) {
	var l int
	_ = l
	if len(m.GoldOutput) > 0 {
		for _, e := range m.GoldOutput {
			n += 1 + sovFarm(uint64(e))
		}
	}
	if len(m.StoneOutput) > 0 {
		for _, e := range m.StoneOutput {
			n += 1 + sovFarm(uint64(e))
		}
	}
	if len(m.CubeX) > 0 {
		for _, e := range m.CubeX {
			n += 1 + sovFarm(uint64(e))
		}
	}
	if len(m.CubeY) > 0 {
		for _, e := range m.CubeY {
			n += 1 + sovFarm(uint64(e))
		}
	}
	return n
}

func (m *S2COneKeyResetProto) Size() (n int) {
	var l int
	_ = l
	if len(m.CubeX) > 0 {
		for _, e := range m.CubeX {
			n += 1 + sovFarm(uint64(e))
		}
	}
	if len(m.CubeY) > 0 {
		for _, e := range m.CubeY {
			n += 1 + sovFarm(uint64(e))
		}
	}
	if len(m.GoldOutput) > 0 {
		for _, e := range m.GoldOutput {
			n += 1 + sovFarm(uint64(e))
		}
	}
	if len(m.StoneOutput) > 0 {
		for _, e := range m.StoneOutput {
			n += 1 + sovFarm(uint64(e))
		}
	}
	return n
}

func (m *C2SViewFarmProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovFarm(uint64(l))
	}
	if m.OpenWin {
		n += 2
	}
	return n
}

func (m *S2CViewFarmProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovFarm(uint64(l))
	}
	l = len(m.HeroFarm)
	if l > 0 {
		n += 1 + l + sovFarm(uint64(l))
	}
	if len(m.NextLevelCubeX) > 0 {
		for _, e := range m.NextLevelCubeX {
			n += 1 + sovFarm(uint64(e))
		}
	}
	if len(m.NextLevelCubeY) > 0 {
		for _, e := range m.NextLevelCubeY {
			n += 1 + sovFarm(uint64(e))
		}
	}
	l = len(m.TargetBasic)
	if l > 0 {
		n += 1 + l + sovFarm(uint64(l))
	}
	if m.CanSteal {
		n += 2
	}
	return n
}

func (m *C2SStealProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovFarm(uint64(l))
	}
	if m.CubeX != 0 {
		n += 1 + sovFarm(uint64(m.CubeX))
	}
	if m.CubeY != 0 {
		n += 1 + sovFarm(uint64(m.CubeY))
	}
	return n
}

func (m *S2CStealProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovFarm(uint64(l))
	}
	if m.CubeX != 0 {
		n += 1 + sovFarm(uint64(m.CubeX))
	}
	if m.CubeY != 0 {
		n += 1 + sovFarm(uint64(m.CubeY))
	}
	if m.StealOutput != 0 {
		n += 1 + sovFarm(uint64(m.StealOutput))
	}
	return n
}

func (m *S2CWhoStealFromMeProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovFarm(uint64(l))
	}
	if m.GoldOutput != 0 {
		n += 1 + sovFarm(uint64(m.GoldOutput))
	}
	if m.StoneOutput != 0 {
		n += 1 + sovFarm(uint64(m.StoneOutput))
	}
	return n
}

func (m *C2SOneKeyStealProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovFarm(uint64(l))
	}
	return n
}

func (m *S2COneKeyStealProto) Size() (n int) {
	var l int
	_ = l
	if m.GoldOutput != 0 {
		n += 1 + sovFarm(uint64(m.GoldOutput))
	}
	if m.StoneOutput != 0 {
		n += 1 + sovFarm(uint64(m.StoneOutput))
	}
	if len(m.CubeX) > 0 {
		for _, e := range m.CubeX {
			n += 1 + sovFarm(uint64(e))
		}
	}
	if len(m.CubeY) > 0 {
		for _, e := range m.CubeY {
			n += 1 + sovFarm(uint64(e))
		}
	}
	if len(m.CubeGoldOutput) > 0 {
		for _, e := range m.CubeGoldOutput {
			n += 1 + sovFarm(uint64(e))
		}
	}
	if len(m.CubeStoneOutput) > 0 {
		for _, e := range m.CubeStoneOutput {
			n += 1 + sovFarm(uint64(e))
		}
	}
	return n
}

func (m *S2CWhoOneKeyStealFromMeProto) Size() (n int) {
	var l int
	_ = l
	if len(m.CubeX) > 0 {
		for _, e := range m.CubeX {
			n += 1 + sovFarm(uint64(e))
		}
	}
	if len(m.CubeY) > 0 {
		for _, e := range m.CubeY {
			n += 1 + sovFarm(uint64(e))
		}
	}
	if len(m.StealTimes) > 0 {
		for _, e := range m.StealTimes {
			n += 1 + sovFarm(uint64(e))
		}
	}
	l = len(m.TargetId)
	if l > 0 {
		n += 1 + l + sovFarm(uint64(l))
	}
	return n
}

func (m *C2SStealLogListProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovFarm(uint64(l))
	}
	if m.Newest {
		n += 2
	}
	return n
}

func (m *S2CStealLogListProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Logs)
	if l > 0 {
		n += 1 + l + sovFarm(uint64(l))
	}
	if m.Newest {
		n += 2
	}
	return n
}

func (m *S2CCanStealListProto) Size() (n int) {
	var l int
	_ = l
	if len(m.CanStealId) > 0 {
		for _, b := range m.CanStealId {
			l = len(b)
			n += 1 + l + sovFarm(uint64(l))
		}
	}
	return n
}

func sovFarm(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFarm(x uint64) (n int) {
	return sovFarm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *C2SPlantProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SPlantProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SPlantProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeX", wireType)
			}
			m.CubeX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeY", wireType)
			}
			m.CubeY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResId", wireType)
			}
			m.ResId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CPlantProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CPlantProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CPlantProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeX", wireType)
			}
			m.CubeX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeY", wireType)
			}
			m.CubeY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResId", wireType)
			}
			m.ResId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SHarvestProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SHarvestProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SHarvestProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeX", wireType)
			}
			m.CubeX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeY", wireType)
			}
			m.CubeY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CHarvestProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CHarvestProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CHarvestProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeX", wireType)
			}
			m.CubeX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeY", wireType)
			}
			m.CubeY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentOutput", wireType)
			}
			m.CurrentOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SChangeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SChangeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SChangeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeX", wireType)
			}
			m.CubeX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeY", wireType)
			}
			m.CubeY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResId", wireType)
			}
			m.ResId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CChangeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CChangeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CChangeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeX", wireType)
			}
			m.CubeX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeY", wireType)
			}
			m.CubeY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResId", wireType)
			}
			m.ResId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldResId", wireType)
			}
			m.OldResId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldResId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldOutput", wireType)
			}
			m.OldOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SOneKeyPlantProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SOneKeyPlantProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SOneKeyPlantProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldConfId", wireType)
			}
			m.GoldConfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoldConfId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoneConfId", wireType)
			}
			m.StoneConfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoneConfId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldCount", wireType)
			}
			m.GoldCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoldCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoneCount", wireType)
			}
			m.StoneCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoneCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2COneKeyPlantProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2COneKeyPlantProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2COneKeyPlantProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CubeX = append(m.CubeX, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CubeX = append(m.CubeX, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeX", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CubeY = append(m.CubeY, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CubeY = append(m.CubeY, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeY", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ResId = append(m.ResId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ResId = append(m.ResId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ResId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SOneKeyHarvestProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SOneKeyHarvestProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SOneKeyHarvestProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResType", wireType)
			}
			m.ResType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2COneKeyHarvestProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2COneKeyHarvestProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2COneKeyHarvestProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GoldOutput = append(m.GoldOutput, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GoldOutput = append(m.GoldOutput, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldOutput", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StoneOutput = append(m.StoneOutput, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StoneOutput = append(m.StoneOutput, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StoneOutput", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CubeX = append(m.CubeX, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CubeX = append(m.CubeX, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeX", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CubeY = append(m.CubeY, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CubeY = append(m.CubeY, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeY", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2COneKeyResetProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2COneKeyResetProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2COneKeyResetProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CubeX = append(m.CubeX, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CubeX = append(m.CubeX, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeX", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CubeY = append(m.CubeY, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CubeY = append(m.CubeY, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeY", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GoldOutput = append(m.GoldOutput, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GoldOutput = append(m.GoldOutput, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldOutput", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StoneOutput = append(m.StoneOutput, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StoneOutput = append(m.StoneOutput, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StoneOutput", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SViewFarmProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SViewFarmProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SViewFarmProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target[:0], dAtA[iNdEx:postIndex]...)
			if m.Target == nil {
				m.Target = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenWin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OpenWin = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CViewFarmProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CViewFarmProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CViewFarmProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target[:0], dAtA[iNdEx:postIndex]...)
			if m.Target == nil {
				m.Target = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroFarm", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeroFarm = append(m.HeroFarm[:0], dAtA[iNdEx:postIndex]...)
			if m.HeroFarm == nil {
				m.HeroFarm = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NextLevelCubeX = append(m.NextLevelCubeX, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NextLevelCubeX = append(m.NextLevelCubeX, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NextLevelCubeX", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NextLevelCubeY = append(m.NextLevelCubeY, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NextLevelCubeY = append(m.NextLevelCubeY, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NextLevelCubeY", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBasic", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetBasic = append(m.TargetBasic[:0], dAtA[iNdEx:postIndex]...)
			if m.TargetBasic == nil {
				m.TargetBasic = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSteal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSteal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SStealProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SStealProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SStealProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target[:0], dAtA[iNdEx:postIndex]...)
			if m.Target == nil {
				m.Target = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeX", wireType)
			}
			m.CubeX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeY", wireType)
			}
			m.CubeY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CStealProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CStealProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CStealProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target[:0], dAtA[iNdEx:postIndex]...)
			if m.Target == nil {
				m.Target = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeX", wireType)
			}
			m.CubeX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeX |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeY", wireType)
			}
			m.CubeY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CubeY |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StealOutput", wireType)
			}
			m.StealOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StealOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CWhoStealFromMeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CWhoStealFromMeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CWhoStealFromMeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target[:0], dAtA[iNdEx:postIndex]...)
			if m.Target == nil {
				m.Target = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldOutput", wireType)
			}
			m.GoldOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoldOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoneOutput", wireType)
			}
			m.StoneOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoneOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SOneKeyStealProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SOneKeyStealProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SOneKeyStealProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target[:0], dAtA[iNdEx:postIndex]...)
			if m.Target == nil {
				m.Target = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2COneKeyStealProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2COneKeyStealProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2COneKeyStealProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldOutput", wireType)
			}
			m.GoldOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoldOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoneOutput", wireType)
			}
			m.StoneOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoneOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CubeX = append(m.CubeX, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CubeX = append(m.CubeX, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeX", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CubeY = append(m.CubeY, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CubeY = append(m.CubeY, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeY", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CubeGoldOutput = append(m.CubeGoldOutput, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CubeGoldOutput = append(m.CubeGoldOutput, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeGoldOutput", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CubeStoneOutput = append(m.CubeStoneOutput, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CubeStoneOutput = append(m.CubeStoneOutput, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeStoneOutput", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CWhoOneKeyStealFromMeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CWhoOneKeyStealFromMeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CWhoOneKeyStealFromMeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CubeX = append(m.CubeX, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CubeX = append(m.CubeX, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeX", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CubeY = append(m.CubeY, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CubeY = append(m.CubeY, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CubeY", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StealTimes = append(m.StealTimes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFarm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFarm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StealTimes = append(m.StealTimes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StealTimes", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetId = append(m.TargetId[:0], dAtA[iNdEx:postIndex]...)
			if m.TargetId == nil {
				m.TargetId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SStealLogListProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SStealLogListProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SStealLogListProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target[:0], dAtA[iNdEx:postIndex]...)
			if m.Target == nil {
				m.Target = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Newest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Newest = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CStealLogListProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CStealLogListProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CStealLogListProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logs = append(m.Logs[:0], dAtA[iNdEx:postIndex]...)
			if m.Logs == nil {
				m.Logs = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Newest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Newest = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CCanStealListProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CCanStealListProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CCanStealListProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanStealId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFarm
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanStealId = append(m.CanStealId, make([]byte, postIndex-iNdEx))
			copy(m.CanStealId[len(m.CanStealId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFarm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFarm(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFarm
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFarm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFarm
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFarm
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFarm(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFarm = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFarm   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/lightpaw/male7/gen/pb/farm/farm.proto", fileDescriptorFarm)
}

var fileDescriptorFarm = []byte{
	// 870 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcb, 0x6e, 0xdb, 0x46,
	0x14, 0x0d, 0xf5, 0x32, 0x7d, 0x45, 0x3f, 0xc2, 0xc4, 0x86, 0x8c, 0x26, 0xb6, 0xc3, 0x22, 0x40,
	0x16, 0x8d, 0x55, 0xb0, 0x8b, 0x76, 0x57, 0x40, 0x44, 0xdd, 0x08, 0x75, 0x91, 0x80, 0x74, 0x9a,
	0xba, 0x1b, 0x82, 0x12, 0x47, 0x14, 0x01, 0x6a, 0x46, 0x20, 0x87, 0x91, 0xf5, 0x1b, 0x5d, 0xf4,
	0x81, 0xfe, 0x50, 0x97, 0xfd, 0x84, 0xc2, 0x45, 0x97, 0xfd, 0x87, 0x62, 0x1e, 0x24, 0x87, 0x8a,
	0xf3, 0x80, 0xa2, 0x8d, 0xad, 0xb9, 0xf7, 0xce, 0x99, 0x73, 0xce, 0xdc, 0xb9, 0x12, 0x7c, 0x1e,
	0xc5, 0x74, 0x9a, 0x8f, 0xce, 0xc6, 0x64, 0xd6, 0x4f, 0xe2, 0x68, 0x4a, 0xe7, 0xc1, 0xa2, 0x3f,
	0x0b, 0x12, 0xf4, 0x65, 0x3f, 0x42, 0xb8, 0x3f, 0x1f, 0xf5, 0x27, 0x41, 0x3a, 0xe3, 0x7f, 0xce,
	0xe6, 0x29, 0xa1, 0xc4, 0x6c, 0xf3, 0x7f, 0xd6, 0x25, 0xec, 0x38, 0xb6, 0xf7, 0x22, 0x09, 0x30,
	0x7d, 0xc1, 0xe3, 0x07, 0xd0, 0x19, 0xe7, 0x23, 0xe4, 0x5f, 0xf7, 0xb4, 0x53, 0xed, 0x49, 0xdb,
	0x6d, 0xb3, 0xd5, 0x8f, 0x65, 0x78, 0xd9, 0x6b, 0x54, 0xe1, 0x2b, 0x16, 0x4e, 0x51, 0xe6, 0xc7,
	0x61, 0xaf, 0x29, 0xc2, 0x29, 0xca, 0x86, 0x21, 0x43, 0xf5, 0x6c, 0x67, 0xd3, 0xa8, 0x5f, 0xc3,
	0x9e, 0x63, 0x7b, 0xcf, 0x82, 0xf4, 0x35, 0xca, 0xd6, 0xc1, 0xb5, 0x26, 0xb0, 0xe7, 0xd9, 0xce,
	0xfa, 0x00, 0xe6, 0x63, 0xd8, 0x1d, 0xe7, 0x69, 0x8a, 0x30, 0xf5, 0x49, 0x4e, 0xe7, 0x39, 0x95,
	0x04, 0x77, 0x64, 0xf4, 0x39, 0x0f, 0x5a, 0x2f, 0x61, 0xd7, 0xb1, 0x3d, 0x67, 0x1a, 0xe0, 0x08,
	0x6d, 0x50, 0xff, 0xcf, 0x1a, 0xec, 0x7a, 0xb6, 0xb3, 0x69, 0x5c, 0xf3, 0x01, 0x00, 0x49, 0x42,
	0x5f, 0xa6, 0xda, 0x3c, 0xa5, 0x93, 0x24, 0x74, 0x79, 0xf6, 0xa1, 0xc8, 0x4a, 0xbd, 0x1d, 0x9e,
	0xdd, 0x26, 0x49, 0x28, 0xb5, 0xfe, 0xa1, 0xc1, 0x3d, 0xc7, 0xf6, 0x9e, 0x63, 0xf4, 0x1d, 0x5a,
	0x2a, 0x37, 0x7e, 0x0a, 0x46, 0xc4, 0xf6, 0x8d, 0x09, 0x9e, 0x30, 0x58, 0xc1, 0x0f, 0x58, 0xcc,
	0x21, 0x78, 0x32, 0x0c, 0x4d, 0x0b, 0x76, 0x32, 0x4a, 0x30, 0x2a, 0x4b, 0x04, 0xd7, 0x2e, 0x0f,
	0xca, 0x9a, 0x87, 0x00, 0x12, 0x25, 0xc7, 0x85, 0xd9, 0xdb, 0x02, 0x23, 0xc7, 0xd4, 0x3c, 0x81,
	0x6e, 0x01, 0xc1, 0xf2, 0x2d, 0x71, 0x86, 0x04, 0xc8, 0x31, 0xb5, 0x26, 0x70, 0xcf, 0xb3, 0x9d,
	0x37, 0xc8, 0x1d, 0x29, 0xb6, 0x35, 0x9f, 0xb4, 0x07, 0x8d, 0xfd, 0x3b, 0x85, 0x75, 0x47, 0x8a,
	0x75, 0xb5, 0xd4, 0x15, 0x4b, 0x95, 0xf6, 0x95, 0x29, 0x71, 0x35, 0x36, 0x1c, 0x94, 0x26, 0xd4,
	0xfa, 0xeb, 0x08, 0x74, 0xb6, 0x87, 0x2e, 0xe7, 0x48, 0x5a, 0xb0, 0x95, 0xa2, 0xec, 0x72, 0x39,
	0x47, 0xd6, 0xef, 0x1a, 0x1c, 0x94, 0xe4, 0x6a, 0x9b, 0x3e, 0x85, 0x6e, 0xa4, 0x78, 0x5e, 0x71,
	0xe4, 0x66, 0x08, 0xe3, 0xcd, 0xc7, 0x60, 0x08, 0xed, 0xb2, 0xaa, 0xa2, 0x2b, 0x3c, 0x91, 0x65,
	0x95, 0xd4, 0xe6, 0xdb, 0xa5, 0xb6, 0x56, 0xa4, 0x5a, 0xbf, 0x6a, 0x8a, 0x71, 0x2e, 0xca, 0xd0,
	0x47, 0x19, 0xb7, 0xa2, 0xa7, 0xf9, 0x41, 0x7a, 0x5a, 0xb7, 0xea, 0xb1, 0xbe, 0x81, 0x7d, 0xc7,
	0xf6, 0x7e, 0x88, 0xd1, 0xe2, 0x3c, 0x48, 0x67, 0x82, 0xd5, 0x21, 0x74, 0x68, 0x90, 0x46, 0x88,
	0x72, 0x8b, 0x0d, 0x57, 0xae, 0x98, 0xf9, 0x64, 0x8e, 0xb0, 0xbf, 0x88, 0x31, 0x6f, 0x2e, 0xdd,
	0xdd, 0x62, 0xeb, 0x57, 0x31, 0xb6, 0xfe, 0xd5, 0x60, 0xdf, 0xb3, 0x9d, 0x0f, 0xc3, 0xf9, 0x04,
	0xb6, 0xa7, 0x28, 0x25, 0x3e, 0x1b, 0x9f, 0x1c, 0xc8, 0x70, 0x75, 0x16, 0x60, 0x3b, 0xcd, 0xa7,
	0x70, 0x17, 0xa3, 0x6b, 0xea, 0x27, 0xe8, 0x35, 0x4a, 0x7c, 0xe9, 0xce, 0x56, 0x49, 0x7e, 0x97,
	0x25, 0x2f, 0x58, 0xce, 0xe1, 0x36, 0xdd, 0x52, 0xbe, 0xec, 0xe9, 0x6f, 0x29, 0xbf, 0x32, 0x1f,
	0x81, 0x21, 0x48, 0xf8, 0xa3, 0x20, 0x8b, 0xc7, 0xbd, 0x2e, 0x3f, 0xbd, 0x2b, 0x62, 0x03, 0x16,
	0x62, 0xec, 0xc6, 0x01, 0xf6, 0x33, 0x8a, 0x82, 0xa4, 0x67, 0x70, 0x99, 0xfa, 0x38, 0xc0, 0x1e,
	0x5b, 0x5b, 0x2f, 0xf9, 0x7c, 0xe7, 0x9f, 0xdf, 0xad, 0xb1, 0x9a, 0x24, 0x8d, 0xdb, 0x27, 0x49,
	0x53, 0x9d, 0xa4, 0xd7, 0x7c, 0xc0, 0x6f, 0x1a, 0x96, 0xa9, 0xe5, 0x32, 0xaa, 0x1e, 0x90, 0x13,
	0x01, 0x05, 0x89, 0xbc, 0x7f, 0x0a, 0x87, 0x9e, 0xed, 0xbc, 0x9a, 0x12, 0x7e, 0xf8, 0x79, 0x4a,
	0x66, 0xdf, 0xa3, 0x77, 0x53, 0x38, 0xa9, 0x77, 0xdf, 0x56, 0x35, 0x88, 0x64, 0xe7, 0x3d, 0x5a,
	0xe9, 0x3c, 0x5d, 0x99, 0x43, 0xf2, 0xd4, 0xa7, 0xca, 0x90, 0x7b, 0xbf, 0x6a, 0xeb, 0x3f, 0xf5,
	0xf9, 0x28, 0xf5, 0x27, 0xab, 0x0f, 0xfb, 0x7d, 0x54, 0x1a, 0x6f, 0x50, 0x59, 0xef, 0x41, 0x9b,
	0x9f, 0xc1, 0x3e, 0x4f, 0xa9, 0xc7, 0xb7, 0xab, 0xae, 0x63, 0xb9, 0x6f, 0x2b, 0x1a, 0x67, 0x70,
	0x97, 0x57, 0xd7, 0xb8, 0x74, 0xca, 0xf2, 0x3d, 0x96, 0xf4, 0x14, 0x7b, 0x7e, 0xd1, 0xe0, 0x81,
	0xb8, 0x15, 0x45, 0xb2, 0x7a, 0x37, 0x6b, 0xcf, 0x0d, 0xd1, 0x0e, 0x34, 0x9e, 0xa1, 0x4c, 0x9d,
	0x1b, 0x3c, 0x7c, 0xc9, 0xa2, 0xac, 0xfd, 0xe5, 0x0b, 0x89, 0x43, 0xde, 0x30, 0x86, 0xab, 0x8b,
	0xc0, 0x30, 0xb4, 0xce, 0xe1, 0x7e, 0xd1, 0xfe, 0x17, 0x24, 0xba, 0x88, 0x8b, 0x09, 0x5b, 0x5d,
	0x5c, 0xa3, 0xd6, 0x2b, 0x87, 0xd0, 0xc1, 0x68, 0x81, 0x32, 0xf1, 0x5d, 0xa3, 0xbb, 0x72, 0x65,
	0x0d, 0xe0, 0x7e, 0xd1, 0xef, 0x35, 0x1c, 0x13, 0x5a, 0x09, 0x89, 0x32, 0x79, 0xfd, 0xfc, 0xb3,
	0x82, 0xd1, 0xa8, 0x61, 0x7c, 0xc5, 0x31, 0x1c, 0xf9, 0x32, 0x2b, 0x8c, 0x53, 0x30, 0xca, 0xf7,
	0x5b, 0x7c, 0xb9, 0x18, 0x2e, 0x14, 0x4f, 0x78, 0x18, 0x0e, 0x7a, 0x7f, 0xde, 0x1c, 0x6b, 0x7f,
	0xdd, 0x1c, 0x6b, 0x7f, 0xdf, 0x1c, 0x6b, 0xbf, 0xfd, 0x73, 0x7c, 0xe7, 0x99, 0xf6, 0x53, 0x8b,
	0x0d, 0xa3, 0x51, 0x87, 0xff, 0x8a, 0xfb, 0xe2, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xed, 0xa4,
	0x5c, 0x20, 0x00, 0x0a, 0x00, 0x00,
}
